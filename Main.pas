unit Main;

{This file contains main routines for game editor, including logic and user interfaces}

{$mode objfpc}{$H+,M+,R-,I+,Q-,SMARTLINK+,INLINE+}

interface

uses

  {ZLib,}
  Graphics, Classes, SysUtils, Forms, ComCtrls, GraphType, LResources, Dialogs, FileUtil,
  Math, Menus, StdCtrls, ExtCtrls, Buttons, Controls, Spin, ExtDlgs, ComboEx, MMSystem,
  RichMemo, OpenGLContext, lclvlc, GL, {GLU,}
  {$ifdef Windows}
  Windows, WinInet, ImgList,
  {$endif}
  {$ifdef Linux}
  Linux,Unix,
  {$endif}
  IniFiles, Types, TypInfo, Mouse,
  {Own Units}
  Documentation, Fast_AnimK, Fast_Primitives, Scene_Tree, Performance_Time{, Game};

const

  DEFAULT_MISCELLANEOUS_VALUES_COLOR=$00F0F4EC;
  NAV_SEL_COL_0                     =$009DD7E6;
  NAV_SEL_COL_1                     =$00C8CFA9;

  {Resources Paths}
  SELECTION_TOOLS_MARKER_ICON       ='Pics\Selection_Tools\Selection_Tools_Marker.png';
  DEFAULT_CURSOR_ICON               ='Pics\Cursors\Cursor_0.png';
  DEFAULT_TILE_MAP_ICON             ='Pics\Map_Editor\Default_Tile_Map_Icon.png';
  DEFAULT_TILE_MAP_SPRITE_ICON      ='Pics\Map_Editor\Default_Tile_Map_Sprite_Icon0.png';
  DEFAULT_ACTOR_ICON                ='Pics\Actors\Default_Actor_Icon.png';
  TIMELINE_BUTTON_ICON_PREFIX       ='Pics\TimeLine\Timeline_Button_Icon_';
  TEXT_BUTTON_ICON                  ='Pics\Paint_Tools_Icons_List\Text.png';
  BRUSH_BUTTON_ICON                 ='Pics\Paint_Tools_Icons_List\Brush.png';
  SPRAY_BUTTON_ICON                 ='Pics\Paint_Tools_Icons_List\Spray.png';
  SPLINE_BUTTON_ICON                ='Pics\Paint_Tools_Icons_List\Spline.png';
  SELECT_POINTS_BUTTON_ICON         ='Pics\Paint_Tools_Icons_List\Select_Points.png';
  SELECT_TEXTURE_REGION_BUTTON_ICON ='Pics\Paint_Tools_Icons_List\Select_Texture_Region.png';
  REGULAR_GRID_BUTTON_ICON          ='Pics\Paint_Tools_Icons_List\Grid.png';
  SNAP_GRID_BUTTON_ICON             ='Pics\Paint_Tools_Icons_List\Snap_Grid.png';
  BRUSH_CURSOR_ICON                 ='Pics\Cursors\Cursor_3.png';
  WORLD_AXIS_ICON                   ='Pics\World_Axis\World_Axis.png';
  LOCAL_AXIS_ICON                   ='Pics\Local_Axis\Local_Axis.png';

(***************************** Miscellaneous Types ****************************)
type

  TEventGroupEnum    =set of byte;
  PEventGroupEnum    =^TEventGroupEnum;

  {Points}
  TPtsKind           =(pkAll,pkObj,pkSelected);
  {pkAll      - all points of spline;
   pkObj      - points of single spline object;
   pkSelected - selected points of all splines;}
  PPtsKind           =^TPtsKind;

  {Pivot}
  TPivotMode         =(pmPivotMove,pmPivotScale,pmPivotRotate);
  PPivotMode         =^TPivotMode;

  {Snapping Point}
  TSnapMode          =record {$region -fold}
    snap_event     : boolean;
    first_time_snap: byte;
  end; {$endregion}
  PSnapMode          =^TSnapMode;

  PControl           =^TControl;

  TSavedUpPts        =class;
  TSurface           =class;
  TCamera            =class;
  TTex               =class;
  TRGrid             =class;
  TSGrid             =class;
  TCurve             =class;
  TFText             =class;
  TUV                =class;
  TISGraph           =class;
  TSelIts            =class;
  TPivot             =class;
  TCrcSel            =class;
  TBrsSel            =class;
  TRctSel            =class;
  TTlMap             =class;

  {TF_MainForm--------}
  TF_MainForm        =class(TForm) {$region -fold}
    BB_Bottom_Splitter_To_Left                       : TBitBtn;
    BB_Copy_UV                                       : TBitBtn;
    BB_Delete_All                                    : TBitBtn;
    BB_Add_TileMap_Sprite                            : TBitBtn;
    BB_Text_Generate                                 : TBitBtn;
    BB_Spline_Templates_Left                         : TBitBtn;
    BB_Spline_Templates_Right                        : TBitBtn;
    BB_Load_Bitmap                                   : TBitBtn;
    BB_Delete_Selected                               : TBitBtn;
    BB_Load_Frame                                    : TBitBtn;
    BB_Reset_Angle                                   : TBitBtn;
    BB_Move_To_and_Merge                             : TBitBtn;
    BB_Apply_Bitmap_To_Spline                        : TBitBtn;
    BB_Spline_Generate                               : TBitBtn;
    BB_Reset_Size                                    : TBitBtn;
    BB_Reset_Position                                : TBitBtn;
    BB_Save_UV                                       : TBitBtn;
    BB_Reset_UV                                      : TBitBtn;
    BB_Text_Set_Font                                 : TBitBtn;
    BB_Use_Magic                                     : TBitBtn;
    BB_Triangulate                                   : TBitBtn;
    BB_Mirror_V                                      : TBitBtn;
    BB_Merge_UV                                      : TBitBtn;
    BB_Paste_UV                                      : TBitBtn;
    BB_Mirror_U                                      : TBitBtn;
    BB_Set_Value_U                                   : TBitBtn;
    BB_Reset_Value_A                                 : TBitBtn;
    BB_Reset_Value_U                                 : TBitBtn;
    BB_Set_Value_V                                   : TBitBtn;
    BB_Reset_Value_V                                 : TBitBtn;
    BB_Set_Value_H                                   : TBitBtn;
    BB_Reset_Value_H                                 : TBitBtn;
    BB_Set_Value_W                                   : TBitBtn;
    BB_Reset_Value_W                                 : TBitBtn;
    BB_Set_Value_A                                   : TBitBtn;
    BB_Maximize_UV                                   : TBitBtn;
    BB_Untriangulate                                 : TBitBtn;
    BB_Bottom_Splitter_To_Right                      : TBitBtn;
    BB_Add_TileMap                                   : TBitBtn;
    Button1                                          : TButton;
    CB_Brush_Mode1                                   : TComboBox;
    CB_Brush_Mode2                                   : TComboBox;
    CB_Select_Items_Selection_Background_Style       : TComboBox;
    CB_Select_Items_Inner_Subgraph_Clip_Style        : TComboBox;
    CB_Select_Items_Inner_Subgraph_Line_Style        : TComboBox;
    CB_Select_Items_Inner_Subgraph_Show_Bounds       : TCheckBox;
    CB_Select_Items_Selection_Highlight              : TCheckBox;
    CB_Object_Properties_Recalculate_Position        : TCheckBox;
    CB_Object_Properties_Show_In_Game                : TCheckBox;
    CB_Spline_Better_Quality                         : TCheckBox;
    CB_Spline_Cycloid_Direction_Y                    : TComboBox;
    CB_Physics_Deletion                              : TCheckBox;
    CB_Select_Points_Show_Bounds                     : TCheckBox;
    CB_Select_Items_Outer_Subgraph_Show_Bounds       : TCheckBox;
    CB_Select_Items_Outer_Subgraph_Line_Style        : TComboBox;
    CB_Select_Items_Outer_Subgraph_Clip_Style        : TComboBox;
    CB_Select_Points_Only_Visible                    : TCheckBox;
    CB_Select_Items_Selection_Drawing_Mode           : TComboBox;
    CB_Splines_Deletion                              : TCheckBox;
    CB_Spline_Edges_Anti_Aliasing                    : TCheckBox;
    CB_Spline_Edges_LOD                              : TCheckBox;
    CB_Spline_Dynamics_Style                         : TComboBox;
    CB_Spline_Dynamics_Collider                      : TCheckBox;
    CB_Spline_Best_Precision                         : TCheckBox;
    CB_Object_Properties_Show_In_Editor              : TCheckBox;
    CB_Spline_Rose_Mobius_Grid                       : TCheckBox;
    CB_Spline_Grid_Clipping_Points                   : TCheckBox;
    CB_Spline_Grid_Clipping_Attached_Objects         : TCheckBox;
    CB_Text_Background                               : TCheckBox;
    CB_Spline_Lazy_Repaint                           : TCheckBox;
    CB_Spline_Epicycloid_Hypocycloid                 : TCheckBox;
    CB_Spline_Byte_Mode                              : TCheckBox;
    CB_Spline_Hidden_Line_Elimination                : TCheckBox;
    CB_Spline_Edges_Style                            : TComboBox;
    CB_Spline_Edges_Shape                            : TComboBox;
    CB_Spline_Grid_Clipping_Edges                    : TCheckBox;
    CB_Spline_On_Out_Of_Window                       : TCheckBox;
    CB_Spline_On_Scale_Down                          : TCheckBox;
    CB_Spline_Points_Style                           : TComboBox;
    CB_Spline_Points_Shape                           : TComboBox;
    CB_Spline_Edges_Show_Bounds                      : TCheckBox;
    CB_Spline_Points_Show_Bounds                     : TCheckBox;
    CB_Spline_Cycloid_Direction_X                    : TComboBox;
    CB_Actors_Deletion                               : TCheckBox;
    CB_Tilemaps_Deletion                             : TCheckBox;
    CB_Groups_Deletion                               : TCheckBox;
    CB_Spline_Connect_Ends                           : TCheckBox;
    CB_Spline_Mode                                   : TComboBox;
    CB_Spline_Type                                   : TComboBox;
    CB_Particles_Deletion                            : TCheckBox;
    FontDialog1                                      : TFontDialog;
    FP_UV_Operations                                 : TFlowPanel;
    FP_Image_List                                    : TFlowPanel;
    FSE_Brush_Fall_Off1                              : TFloatSpinEdit;
    FSE_Brush_Fall_Off2                              : TFloatSpinEdit;
    FSE_Spline_Rose_Petals_Count                     : TFloatSpinEdit;
    FSE_Spline_Spiral_Coil_Step                      : TFloatSpinEdit;
    FSE_Spline_Simplification_Angle                  : TFloatSpinEdit;
    FSE_Spline_Cycloid_Curvature                     : TFloatSpinEdit;
    FSE_Spline_Superellipse_Curvature0               : TFloatSpinEdit;
    FSE_Spline_Superellipse_Curvature1               : TFloatSpinEdit;
    FSE_Spline_Superellipse_Curvature2               : TFloatSpinEdit;
    FSE_Spline_Superellipse_Curvature3               : TFloatSpinEdit;
    FSE_Spline_Superellipse_Radius                   : TFloatSpinEdit;
    IL_Default_Tile_Map_Icon                         : TImageList;
    IL_Scene_Tree_Image_List                         : TImageList;
    IL_Local_Axis                                    : TImageList;
    IL_Butons_Icons                                  : TImageList;
    IL_Buttons_Background                            : TImageList;
    IL_Cursors_Icons                                 : TImageList;
    IL_Select_Points                                 : TImageList;
    IL_Spline_Templates                              : TImageList;
    IL_Arrow_Up_Down                                 : TImageList;
    IL_Drawing_Buttons                               : TImageList;
    Image10                                          : TImage;
    Image11                                          : TImage;
    Image12                                          : TImage;
    Image13                                          : TImage;
    Image20                                          : TImage;
    Image21                                          : TImage;
    Image22                                          : TImage;
    Image23                                          : TImage;
    Image24                                          : TImage;
    Image25                                          : TImage;
    Image26                                          : TImage;
    Image27                                          : TImage;
    Image6                                           : TImage;
    Image7                                           : TImage;
    IL_World_Axis                                    : TImageList;
    IL_AnimK                                         : TImageList;
    IL_Default_Tile_Map_Sprite_Icon                  : TImageList;
    Image8                                           : TImage;
    Image9                                           : TImage;
    IL_Fold_Unfold                                   : TImageList;
    I_Frame_List                                     : TImage;
    Image18                                          : TImage;
    Image19                                          : TImage;
    Image4                                           : TImage;
    Image5                                           : TImage;
    IL_Add_Actor_Default_Icon                        : TImageList;
    I_Add_Mask_Template_List                         : TImage;
    I_Add_Sprite_List                                : TImage;
    I_Visibility_Panel                               : TImage;
    Label1                                           : TLabel;
    Label2                                           : TLabel;
    Label3                                           : TLabel;
    Label4                                           : TLabel;
    LCLVLCPlayer_Intro                               : TLCLVLCPlayer;
    L_Edit_Mode                                      : TLabel;
    L_Object_Name                                    : TLabel;
    L_Select_Items_Inner_Subgraph                    : TLabel;
    L_Select_Items_Selection                         : TLabel;
    L_Select_Items_Selection_Background_Style        : TLabel;
    L_Select_Items_Inner_Subgraph_Clip_Style         : TLabel;
    L_Select_Items_Inner_Subgraph_Color              : TLabel;
    L_Select_Items_Selection_Color                   : TLabel;
    L_Select_Items_Inner_Subgraph_Line_Style         : TLabel;
    L_Spline_Cycloid_Direction_Y                     : TLabel;
    L_Spline_Cycloid_Loops_Count                     : TLabel;
    L_Spline_Cycloid_Points_Count                    : TLabel;
    L_Spline_Cycloid_Radius                          : TLabel;
    L_Spline_Cycloid_Curvature                       : TLabel;
    L_Select_Items_Outer_Subgraph                    : TLabel;
    L_Select_Items_Outer_Subgraph_Color              : TLabel;
    L_Spline_Grid_Clipping                           : TLabel;
    L_Spline_Compression                             : TLabel;
    L_Spline_Superellipse_Curvature0                 : TLabel;
    L_Spline_Superellipse_Curvature1                 : TLabel;
    L_Spline_Superellipse_Curvature2                 : TLabel;
    L_Spline_Superellipse_Curvature3                 : TLabel;
    L_Spline_Superellipse_Points_Count               : TLabel;
    L_Spline_Superellipse_Radius                     : TLabel;
    L_Text_Field                                     : TLabel;
    L_Spline_Rose_Angle                              : TLabel;
    L_Spline_Spiral_Angle                            : TLabel;
    L_Spline_Rose_Petals_Count                       : TLabel;
    L_Spline_Spiral_Coil_Step                        : TLabel;
    L_Spline_Rose_Points_Count                       : TLabel;
    L_Spline_Spiral_Points_Count                     : TLabel;
    L_Spline_Rose_Radius                             : TLabel;
    L_Spline_Spiral_Radius                           : TLabel;
    L_Spline_Rose_Rotation                           : TLabel;
    L_Spline_Spiral_Rotation                         : TLabel;
    L_Text_Drawing                                   : TLabel;
    L_Spline_Save                                    : TLabel;
    L_Exec_Time_Info                                 : TLabel;
    L_Speed                                          : TLabel;
    L_Brush_Fall_Off1                                : TLabel;
    L_Brush_Fall_Off2                                : TLabel;
    L_Brush_Hardness1                                : TLabel;
    L_Brush_Hardness2                                : TLabel;
    L_Brush_Mode1                                    : TLabel;
    L_Brush_Mode2                                    : TLabel;
    L_Brush_Size1                                    : TLabel;
    L_Brush_Size2                                    : TLabel;
    L_Count_X                                        : TLabel;
    L_Count_Y                                        : TLabel;
    L_Spline_Epicycloid_Rotation                     : TLabel;
    L_Spline_Epicycloid_Angle                        : TLabel;
    L_Spline_Dynamics                                : TLabel;
    L_Spline_Dynamics_Style                          : TLabel;
    L_RGrid_Color                                    : TLabel;
    L_Spline_Free_Memory                             : TLabel;
    L_Spline_Edges_Dash_Length                       : TLabel;
    L_Spline_Edges_Points_Radius                     : TLabel;
    L_Spline_Spray_Radius                            : TLabel;
    L_Spline_Remove_Brunching                        : TLabel;
    L_Spline_Optimization                            : TLabel;
    L_Spline_Drawing                                 : TLabel;
    L_Spline_Epicycloid_Points_Count                 : TLabel;
    L_Spline_Epicycloid_Petals_Count                 : TLabel;
    L_Spline_Epicycloid_Radius                       : TLabel;
    L_Spline_Freehand_Settings                       : TLabel;
    L_Object_Properties_Parallax_Shift               : TLabel;
    L_Spline_Templates_Name                          : TLabel;
    L_Spline_Points_Shape                            : TLabel;
    L_Spline_Edges_Shape                             : TLabel;
    L_Spline_Points_Rectangle_Inner_Rectangle        : TLabel;
    L_Spline_Edges_Settings                          : TLabel;
    L_Spline_Cycloid_Direction_X                     : TLabel;
    L_Object_Properties                              : TLabel;
    L_Spline_Points_Rectangle_Thikness_Left          : TLabel;
    L_Spline_Points_Count                            : TLabel;
    L_Spline_Points_Rectangle_Thikness_Top           : TLabel;
    L_Spline_Points_Rectangle_Thikness_Right         : TLabel;
    L_Spline_Points_Rectangle_Thikness_Bottom        : TLabel;
    L_Spline_Points_Rectangle_Inner_Rectangle_Height : TLabel;
    L_Spline_Edges                                   : TLabel;
    L_Spline_Points                                  : TLabel;
    L_Spline_Edges_Style                             : TLabel;
    L_Spline_Points_Style                            : TLabel;
    L_Spline_Edges_Width                             : TLabel;
    L_Spline_Points_Rectangle_Thickness              : TLabel;
    L_Spline_Edges_Color                             : TLabel;
    L_Spline_Points_Color                            : TLabel;
    L_Spline_Points_Rectangle_Inner_Rectangle_Width  : TLabel;
    L_Spline_Simplification_Angle                    : TLabel;
    L_Spline_Type                                    : TLabel;
    L_Inner_Subgraph_Color                           : TLabel;
    L_Selected_Points_Color                          : TLabel;
    L_Selective_Deletion                             : TLabel;
    L_Bitmap_Width                                   : TLabel;
    L_Bitmap_Height                                  : TLabel;
    L_Select_Points_Relative_Bucket_Size             : TLabel;
    L_Select_Points_Bucket_Size_Value                : TLabel;
    L_Select_Items_Outer_Subgraph_Line_Style         : TLabel;
    L_Outer_Subgraph_Color                           : TLabel;
    L_Select_Items_Outer_Subgraph_Clip_Style         : TLabel;
    L_Spline_Points_Freq                             : TLabel;
    L_Select_Items_Selection_Drawing_Mode            : TLabel;
    L_Object_Info                                    : TLabel;
    L_Spline_Mode                                    : TLabel;
    L_Tag_Properties                                 : TLabel;
    MI_Save_Asset                                    : TMenuItem;
    OPD_Add_TileMap_Sprite                           : TOpenPictureDialog;
    P_DescriptionHeader                              : TPanel;
    P_Spline_Superellipse                            : TPanel;
    P_Spline_Template_List1                          : TPanel;
    Separator6                                       : TMenuItem;
    MI_Add_Asset                                     : TMenuItem;
    Separator5                                       : TMenuItem;
    MI_On_Hide                                       : TMenuItem;
    MI_On_Show                                       : TMenuItem;
    MI_On_Key_Press                                  : TMenuItem;
    MI_On_Mouse_Down                                 : TMenuItem;
    MI_On_Mouse_Up                                   : TMenuItem;
    MI_On_Mouse_Enter                                : TMenuItem;
    MI_On_Mouse_Leave                                : TMenuItem;
    MI_On_Key_Down                                   : TMenuItem;
    MI_On_Key_Up                                     : TMenuItem;
    MI_On_Double_Click                               : TMenuItem;
    MI_Snap_To                                       : TMenuItem;
    Separator4                                       : TMenuItem;
    MI_Special_Effect                                : TMenuItem;
    MI_Animation                                     : TMenuItem;
    Separator3                                       : TMenuItem;
    MI_Edges_Selection                               : TMenuItem;
    MI_On_Click                                      : TMenuItem;
    MI_Add_Event                                     : TMenuItem;
    Separator2                                       : TMenuItem;
    MI_Points_Selection                              : TMenuItem;
    MI_Add_Tag                                       : TMenuItem;
    Separator1                                       : TMenuItem;
    MenuItem3                                        : TMenuItem;
    MI_Unselect_All                                  : TMenuItem;
    MI_Unfold_All                                    : TMenuItem;
    MI_Fold_All                                      : TMenuItem;
    M_Text_Text_Field                                : TMemo;
    MI_Button_Style_3                                : TMenuItem;
    MI_Align_Image_On_Inner_Window_Resize            : TMenuItem;
    MenuItem5                                        : TMenuItem;
    MI_Button_Styles                                 : TMenuItem;
    MenuItem9                                        : TMenuItem;
    MI_Button_Style_2                                : TMenuItem;
    MenuItem7                                        : TMenuItem;
    MI_Button_Style_1                                : TMenuItem;
    MI_Full_Screen                                   : TMenuItem;
    MI_Trancparency                                  : TMenuItem;
    MI_Antialiasing                                  : TMenuItem;
    MI_Object_Info                                   : TMenuItem;
    MenuItem1                                        : TMenuItem;
    MenuItem2                                        : TMenuItem;
    MenuItem4                                        : TMenuItem;
    MenuItem6                                        : TMenuItem;
    MI_Delete_All_Groups                             : TMenuItem;
    MI_Goto_First_Object                             : TMenuItem;
    MI_Goto_Last_Object                              : TMenuItem;
    MI_Delete_Without_Children                       : TMenuItem;
    OPD_Add_TileMap                                  : TOpenPictureDialog;
    OD_Spline_Load                                   : TOpenDialog;
    OpenGLControl2                                   : TOpenGLControl;
    PageControl1                                     : TPageControl;
    Panel1                                           : TPanel;
    P_AnimK_Custom_Panel                             : TPanel;
    P_Select_Items_Selection_Prop                    : TPanel;
    P_Select_Items_Outer_Subgraph_Prop               : TPanel;
    P_Select_Items_Inner_Subgraph_Prop               : TPanel;
    P_Description                                    : TPanel;
    P_Text_Drawing_Prop                              : TPanel;
    P_Spline_Spiral                                  : TPanel;
    P_SGrid                                          : TPanel;
    P_RGrid                                          : TPanel;
    P_Spline_Dynamics_Prop                           : TPanel;
    P_Spline_Save_Prop                               : TPanel;
    P_Map_Editor                                     : TPanel;
    P_Spline_Cycloid                                 : TPanel;
    P_Spline_Epicycloid                              : TPanel;
    P_Spline_Rose                                    : TPanel;
    P_Play_Anim                                      : TPanel;
    P_Spline_Freehand_Settings                       : TPanel;
    P_Spline_Freehand                                : TPanel;
    P_Text_Settings                                  : TPanel;
    P_Text_Settings_Header                           : TPanel;
    P_Spray                                          : TPanel;
    P_Spline_Template_List                           : TPanel;
    P_Object_Properties                              : TPanel;
    P_Spline_Points                                  : TPanel;
    P_Spline_Edges                                   : TPanel;
    P_Spline_Templates_Properties                    : TPanel;
    P_Spline_Points_Rectangle_Thickness              : TPanel;
    P_Animation_Buttons                              : TPanel;
    P_Add_Actor                                      : TPanel;
    P_Spline_Optimization_Prop                       : TPanel;
    P_Spline_Edges_Prop                              : TPanel;
    P_Spline_Drawing_Prop                            : TPanel;
    P_Spline_Points_Prop                             : TPanel;
    P_Objects_Tags                                   : TPanel;
    P_Scene_Tree                                     : TPanel;
    P_Inner_Subgraph1                                : TPanel;
    P_Outer_Subgraph                                 : TPanel;
    PM_Unfold_And_Align_Image                        : TPopupMenu;
    Panel2                                           : TPanel;
    Panel3                                           : TPanel;
    Panel4                                           : TPanel;
    Panel5                                           : TPanel;
    Panel6                                           : TPanel;
    P_Spline_Points_Rectangle_Inner_Rectangle        : TPanel;
    P_Spline_Edges_Line                              : TPanel;
    P_Spline_Templates                               : TPanel;
    P_Select_Texture_Region                          : TPanel;
    P_Tag_Properties                                 : TPanel;
    P_UV_Packing                                     : TPanel;
    Panel8                                           : TPanel;
    Panel9                                           : TPanel;
    PM_Drawing_Buttons                               : TPopupMenu;
    P_Draw_Custom_Panel                              : TPanel;
    P_Inner_Subgraph                                 : TPanel;
    P_Selective_Deletion                             : TPanel;
    P_Load_Save_Clear                                : TPanel;
    P_Drawing_Buttons                                : TPanel;
    P_Text                                           : TPanel;
    P_Brush                                          : TPanel;
    P_Spline                                         : TPanel;
    P_Select_Items                                   : TPanel;
    P_Transform_Ops                                  : TPanel;
    P_Image_Editor                                   : TPanel;
    P_2D_Operations_Automatic                        : TPanel;
    P_Align_Hot_Keys                                 : TPanel;
    P_UV_Operations                                  : TPanel;
    P_UV_Attributes                                  : TPanel;
    RB_Edges                                         : TRadioButton;
    RB_Points                                        : TRadioButton;
    RB_Polygons                                      : TRadioButton;
    RB_Spline_Constant                               : TRadioButton;
    RB_Spline_None                                   : TRadioButton;
    RG_Edit_Mode                                     : TGroupBox;
    RM_Description                                   : TRichMemo;
    SB_Select_Items_Selection_Color                  : TSpeedButton;
    SB_Select_Items_Outer_Subgraph_Color             : TSpeedButton;
    SB_Select_Items_Inner_Subgraph_Color             : TSpeedButton;
    SB_Select_Items_Outer_Subgraph_Show              : TSpeedButton;
    SB_Select_Items_Inner_Subgraph_Show              : TSpeedButton;
    SB_Text_Background_Color                         : TSpeedButton;
    SB_Text_Background_Color_Random                  : TSpeedButton;
    SB_Spline_Load                                   : TSpeedButton;
    SB_Map_Editor                                    : TSpeedButton;
    SB_RGrid                                         : TSpeedButton;
    SB_SGrid                                         : TSpeedButton;
    SB_RGrid_Color                                   : TSpeedButton;
    SB_Tag_Properties                                : TScrollBox;
    SB_Spline                                        : TSpeedButton;
    SB_Spline_Template_Superellipse                  : TSpeedButton;
    SB_Add_Actor                                     : TSpeedButton;
    SB_Brush                                         : TSpeedButton;
    SB_Brush4                                        : TSpeedButton;
    SB_Brush5                                        : TSpeedButton;
    SB_Image_List                                    : TScrollBox;
    SB_Selected_Points_Select_Color                  : TSpeedButton;
    SB_Load_Image                                    : TSpeedButton;
    SB_Inner_Subgraph_Select_Color                   : TSpeedButton;
    SB_Reset_Pivot2                                  : TSpeedButton;
    SB_Save_Image                                    : TSpeedButton;
    SB_Clear_Scene                                   : TSpeedButton;
    SB_Outer_Subgraph_Select_Color                   : TSpeedButton;
    SB_Select_Texture_Region                         : TSpeedButton;
    SB_Move_Pivot_To_Point                           : TSpeedButton;
    SB_Spline_Edges_Color                            : TSpeedButton;
    SB_Spline_Edges_Show                             : TSpeedButton;
    SB_Spline_Edges_Color_FallOff                    : TSpeedButton;
    SB_Spline_Points_Color                           : TSpeedButton;
    SB_Spline_Points_Show                            : TSpeedButton;
    SB_Spline_Edges_Color_Random                     : TSpeedButton;
    SB_Spline_Points_Color_Random                    : TSpeedButton;
    SB_Spline_Points_Color_FallOff                   : TSpeedButton;
    SB_Spray                                         : TSpeedButton;
    SB_StatusBar1                                    : TStatusBar;
    SB_Text                                          : TSpeedButton;
    SB_Select_Items                                  : TSpeedButton;
    SB_Play_Anim                                     : TSpeedButton;
    SB_Object_Properties                             : TScrollBox;
    SB_Change_Layout                                 : TSpeedButton;
    CB_Brush_Mode                                    : TComboBox;
    CCB_2D_Operations_Automatic                      : TCheckComboBox;
    FSE_Brush_Fall_Off                               : TFloatSpinEdit;
    FSE_Width                                        : TFloatSpinEdit;
    FSE_Height                                       : TFloatSpinEdit;
    FSE_Angle                                        : TFloatSpinEdit;
    GB_Size                                          : TGroupBox;
    GB_Angle                                         : TGroupBox;
    L_Brush_Size                                     : TLabel;
    L_Brush_Hardness                                 : TLabel;
    L_Brush_Fall_Off                                 : TLabel;
    L_Brush_Mode                                     : TLabel;
    L_Label1                                         : TLabel;
    L_Axis_U                                         : TLabel;
    L_Axis_V                                         : TLabel;
    L_Angle                                          : TLabel;
    L_Width                                          : TLabel;
    L_Height                                         : TLabel;
    MI_Add_Group                                     : TMenuItem;
    MI_Remove_Object                                 : TMenuItem;
    MI_Group_Objects                                 : TMenuItem;
    MI_Select_All                                    : TMenuItem;
    MI_Fold_Selected                                 : TMenuItem;
    MI_Unfold_Selected                               : TMenuItem;
    MI_Show_Hints                                    : TMenuItem;
    PC_Image_Editor                                  : TPageControl;
    PC_PageControl3                                  : TPageControl;
    P_Splitter5                                      : TPanel;
    PM_Scene_Tree                                    : TPopupMenu;
    SB_2D_Operations                                 : TScrollBox;
    SB_Centrify_Picture                              : TSpeedButton;
    SB_Drawing                                       : TScrollBox;
    SB_Visibility_Grid                               : TSpeedButton;
    SB_Visibility_Collider                           : TSpeedButton;
    SB_Visibility_Snap_Grid                          : TSpeedButton;
    SB_Visibility_Show_All                           : TSpeedButton;
    SB_Visibility_Spline                             : TSpeedButton;
    SB_Visibility_Texture                            : TSpeedButton;
    SB_Visibility_Actor                              : TSpeedButton;
    SB_TreeView_Object_Tags                          : TScrollBox;
    SB_AnimK                                         : TScrollBox;
    SE_Brush_Hardness1                               : TSpinEdit;
    SE_Brush_Hardness2                               : TSpinEdit;
    SE_Brush_Radius1                                 : TSpinEdit;
    SE_Brush_Radius2                                 : TSpinEdit;
    SE_Count_X                                       : TSpinEdit;
    SE_Count_Y                                       : TSpinEdit;
    SE_Spline_Cycloid_Loops_Count                    : TSpinEdit;
    SE_Spline_Cycloid_Points_Count                   : TSpinEdit;
    FSE_Spline_Cycloid_Radius                        : TFloatSpinEdit;
    FSE_Spline_Epicycloid_Angle                      : TFloatSpinEdit;
    FSE_Spline_Epicycloid_Petals_Count               : TFloatSpinEdit;
    FSE_Spline_Epicycloid_Radius                     : TFloatSpinEdit;
    FSE_Spline_Epicycloid_Rotation                   : TFloatSpinEdit;
    FSE_Spline_Rose_Angle                            : TFloatSpinEdit;
    FSE_Spline_Rose_Radius                           : TFloatSpinEdit;
    FSE_Spline_Rose_Rotation                         : TFloatSpinEdit;
    SE_Spline_Rose_Points_Count                      : TSpinEdit;
    FSE_Spline_Spiral_Angle                          : TFloatSpinEdit;
    SE_Spline_Spiral_Points_Count                    : TSpinEdit;
    FSE_Spline_Spiral_Radius                         : TFloatSpinEdit;
    FSE_Spline_Spiral_Rotation                       : TFloatSpinEdit;
    SE_Spline_Edges_Points_Radius                    : TSpinEdit;
    SE_Spline_Edges_Width                            : TSpinEdit;
    SE_Spline_Epicycloid_Points_Count                : TSpinEdit;
    SE_Spline_Edges_Dash_Length                      : TSpinEdit;
    SE_Spline_Points_Rectangle_Thikness_Left         : TSpinEdit;
    SE_Spline_Points_Rectangle_Inner_Rectangle_Width : TSpinEdit;
    SE_Spline_Points_Count                           : TSpinEdit;
    SE_Spline_Points_Rectangle_Thikness_Top          : TSpinEdit;
    SE_Spline_Points_Rectangle_Thikness_Right        : TSpinEdit;
    SE_Spline_Points_Rectangle_Thikness_Bottom       : TSpinEdit;
    SE_Spline_Points_Rectangle_Inner_Rectangle_Height: TSpinEdit;
    SE_Spline_Pts_Freq                               : TSpinEdit;
    SE_Brush_Radius                                  : TSpinEdit;
    SE_Brush_Hardness                                : TSpinEdit;
    SE_Spline_Bitmap_Width                           : TSpinEdit;
    SE_Spline_Bitmap_Height                          : TSpinEdit;
    SE_Select_Points_Bucket_Size                     : TSpinEdit;
    SB_Spline_Template_Cycloid                       : TSpeedButton;
    SB_Spline_Template_Epicycloid                    : TSpeedButton;
    SB_Spline_Template_Rose                          : TSpeedButton;
    SB_Spline_Template_Spiral                        : TSpeedButton;
    SE_Spline_Superellipse_Points_Count              : TSpinEdit;
    SE_Spline_Spray_Radius                           : TSpinEdit;
    SE_Object_Properties_Parallax_Shift              : TSpinEdit;
    S_Splitter0                                      : TSplitter;
    S_Splitter1                                      : TSplitter;
    S_Splitter2                                      : TSplitter;
    S_Splitter3                                      : TSplitter;
    S_Splitter4                                      : TSplitter;
    S_Splitter6                                      : TSplitter;
    S_Splitter7                                      : TSplitter;
    S_TreeView_Splitter                              : TSplitter;
    S_Splitter8                                      : TSplitter;
    TB_Speed                                         : TTrackBar;
    T_Logo1                                          : TTimer;
    T_Logo2                                          : TTimer;
    T_Logo3                                          : TTimer;
    T_Menu                                           : TTimer;
    T_Game                                           : TTimer;
    TS_AnimK                                         : TTabSheet;
    TS_Outer_Subgraph                                : TTabSheet;
    TS_Inner_Subgraph                                : TTabSheet;
    TS_Selected_Points                               : TTabSheet;
    TS_Greedy2                                       : TTabSheet;
    TS_Hybride                                       : TTabSheet;
    TS_Physical                                      : TTabSheet;
    TS_Greedy1                                       : TTabSheet;
    TS_1_order_Isomorphic                            : TTabSheet;
    TS_p_order_Isomorphic                            : TTabSheet;
    BB_Reset_All_Values                              : TBitBtn;
    BB_Reset_Pivot                                   : TBitBtn;
    TS_File                                          : TTabSheet;
    TS_Draw                                          : TTabSheet;
    MI_Close_All                                     : TMenuItem;
    OpenPictureDialog1                               : TOpenPictureDialog;
    SavePictureDialog1                               : TSavePictureDialog;
    BB_Set_All_Values                                : TBitBtn;
    CD_Select_Color                                  : TColorDialog;
    FSE_Coord_U                                      : TFloatSpinEdit;
    FSE_Coord_V                                      : TFloatSpinEdit;
    GB_Move                                          : TGroupBox;
    MainMenu1                                        : TMainMenu;
    MI_3D_Viewer                                     : TMenuItem;
    MI_Hot_Keys                                      : TMenuItem;
    MI_System_Info                                   : TMenuItem;
    MI_Setings                                       : TMenuItem;
    MI_View                                          : TMenuItem;
    MI_Help                                          : TMenuItem;
    MI_File                                          : TMenuItem;
    MI_Save_As                                       : TMenuItem;
    MI_Open                                          : TMenuItem;
    MI_Exit                                          : TMenuItem;
    OpenDialog1                                      : TOpenDialog;
    PB_ProgressBar1                                  : TProgressBar;
    SaveDialog1                                      : TSaveDialog;
    T_Game_Loop                                      : TTimer;
    TrayIcon1                                        : TTrayIcon;
    TV_Scene_Tree                                    : TTreeView;

    {F_MainForm}
    procedure BB_Add_TileMapClick                                    (      sender           :TObject);
    procedure BB_Add_TileMap_SpriteClick                             (      sender           :TObject);
    procedure BB_Spline_GenerateClick                                (      sender           :TObject);
    procedure BB_Load_FrameClick                                     (      sender           :TObject);
    procedure BB_Spline_Templates_RightClick                         (      sender           :TObject);
    procedure BB_Spline_Templates_LeftClick                          (      sender           :TObject);
    procedure BB_Use_MagicClick                                      (      sender           :TObject);
    procedure Button1Click                                           (      sender           :TObject);
    procedure CB_Object_Properties_Recalculate_PositionChange        (      sender           :TObject);
    procedure CB_Select_Items_Inner_Subgraph_Clip_StyleSelect        (      sender           :TObject);
    procedure CB_Select_Items_Inner_Subgraph_Line_StyleSelect        (      sender           :TObject);
    procedure CB_Select_Items_Inner_Subgraph_Show_BoundsChange       (      sender           :TObject);
    procedure CB_Select_Items_Selection_Background_StyleSelect       (      sender           :TObject);
    procedure CB_Select_Items_Selection_HighlightChange              (      sender           :TObject);
    procedure CB_Object_Properties_Show_In_EditorChange              (      sender           :TObject);
    procedure CB_Spline_Cycloid_Direction_XSelect                    (      sender           :TObject);
    procedure CB_Spline_Cycloid_Direction_YSelect                    (      sender           :TObject);
    procedure CB_Spline_Dynamics_StyleSelect                         (      sender           :TObject);
    procedure CB_Spline_Epicycloid_HypocycloidChange                 (      sender           :TObject);
    procedure CB_Spline_Best_PrecisionChange                         (      sender           :TObject);
    procedure CB_Spline_Byte_ModeChange                              (      sender           :TObject);
    procedure CB_Spline_Edges_ShapeSelect                            (      sender           :TObject);
    procedure CB_Spline_Edges_Show_BoundsChange                      (      sender           :TObject);
    procedure CB_Spline_Better_QualityChange                         (      sender           :TObject);
    procedure CB_Spline_Hidden_Line_EliminationChange                (      sender           :TObject);
    procedure CB_Spline_Lazy_RepaintChange                           (      sender           :TObject);
    procedure CB_Spline_Invert_OrderChange                           (      sender           :TObject);
    procedure CB_Spline_Edges_LODChange                              (      sender           :TObject);
    procedure CB_Spline_Edges_StyleSelect                            (      sender           :TObject);
    procedure CB_Spline_On_Out_Of_WindowChange                       (      sender           :TObject);
    procedure CB_Spline_On_Scale_DownChange                          (      sender           :TObject);
    procedure CB_Spline_Points_ShapeSelect                           (      sender           :TObject);
    procedure CB_Spline_Points_Show_BoundsChange                     (      sender           :TObject);
    procedure CB_Spline_Points_StyleSelect                           (      sender           :TObject);
    procedure CB_Spline_Rose_Mobius_GridChange                       (      sender           :TObject);
    procedure CB_Text_BackgroundChange                               (      sender           :TObject);
    procedure FormMouseMove                                          (      sender           :TObject;
                                                                            shift            :TShiftState;
                                                                            x,y              :integer);
    procedure FormMouseDown                                          (      sender           :TObject;
                                                                            button           :TMouseButton;
                                                                            shift            :TShiftState;
                                                                            x,y              :integer);
    procedure FormMouseUp                                            (      sender           :TObject;
                                                                            button           :TMouseButton;
                                                                            shift            :TShiftState;
                                                                            x,y              :integer);
    procedure FormDblClick                                           (      sender           :TObject);
    procedure FormPaint                                              (      sender           :TObject);
    procedure FormMouseWheelDown                                     (      sender           :TObject;
                                                                            shift            :TShiftState;
                                                                            mousepos         :TPoint;
                                                                      var   handled          :boolean);
    procedure FormMouseWheelUp                                       (      sender           :TObject;
                                                                            shift            :TShiftState;
                                                                            mousepos         :TPoint;
                                                                      var   handled          :boolean);
    procedure FormKeyPress                                           (      sender           :TObject;
                                                                      var   key              :char);
    procedure FormKeyDown                                            (      sender           :TObject;
                                                                      var   key              :word;
                                                                            shift            :TShiftState);
    procedure FormKeyUp                                              (      sender           :TObject;
                                                                      var   key              :word;
                                                                            shift            :TShiftState);
    procedure FormMouseEnter                                         (      sender           :TObject);
    procedure FormMouseLeave                                         (      sender           :TObject);
    procedure FormCreate                                             (      sender           :TObject);
    procedure FormActivate                                           (      sender           :TObject);
    procedure FormDestroy                                            (      sender           :TObject);
    procedure FormDropFiles                                          (      sender           :TObject;
                                                                      const file_names       :array of string);
    procedure FormResize                                             (      sender           :TObject);
    procedure FSE_Spline_Rose_Petals_CountChange                     (      sender           :TObject);
    procedure FSE_Spline_Cycloid_CurvatureChange                     (      sender           :TObject);
    procedure FSE_Spline_Simplification_AngleEditingDone             (      sender           :TObject);
    procedure FSE_Spline_Spiral_Coil_StepChange                      (      sender           :TObject);
    procedure FSE_Spline_Superellipse_Curvature0Change               (      sender           :TObject);
    procedure FSE_Spline_Superellipse_Curvature1Change               (      sender           :TObject);
    procedure FSE_Spline_Superellipse_Curvature2Change               (      sender           :TObject);
    procedure FSE_Spline_Superellipse_Curvature3Change               (      sender           :TObject);
    procedure FSE_Spline_Superellipse_RadiusChange                   (      sender           :TObject);
    procedure I_Frame_ListMouseDown                                  (      sender           :TObject;
                                                                            button           :TMouseButton;
                                                                            shift            :TShiftState;
                                                                            x,y              :integer);
    procedure I_Frame_ListMouseEnter                                 (      sender           :TObject);
    procedure MI_Align_Image_On_Inner_Window_ResizeClick             (      sender           :TObject);

    {Menu Items}
    procedure MI_OpenClick                                           (      sender           :TObject);
    procedure MI_ExitClick                                           (      sender           :TObject);
    procedure MI_3D_ViewerClick                                      (      sender           :TObject);
    procedure MI_Object_InfoClick                                    (      sender           :TObject);
    procedure MI_Full_ScreenClick                                    (      sender           :TObject);
    procedure MI_Save_AsClick                                        (      sender           :TObject);
    procedure MI_TrancparencyClick                                   (      sender           :TObject);
    procedure MI_Hot_KeysClick                                       (      sender           :TObject);
    procedure MI_System_InfoClick                                    (      sender           :TObject);
    procedure MI_Button_Style_1Click                                 (      sender           :TObject);
    procedure MI_Button_Style_2Click                                 (      sender           :TObject);
    procedure MI_Fold_AllClick                                       (      sender           :TObject);
    procedure MI_Unfold_AllClick                                     (      sender           :TObject);
    procedure MI_Unselect_AllClick                                   (      sender           :TObject);
    procedure P_2D_Operations_AutomaticMouseEnter                    (      sender           :TObject);
    procedure P_2D_Operations_AutomaticMouseLeave                    (      sender           :TObject);
    procedure P_Animation_ButtonsMouseMove                           (      sender           :TObject;
                                                                            shift            :TShiftState;
                                                                            x,y              :integer);
    procedure P_Animation_ButtonsPaint                               (      sender           :TObject);
    procedure P_Drawing_ButtonsMouseMove                             (      sender           :TObject;
                                                                            shift            :TShiftState;
                                                                            x,y              :integer);
    procedure P_Select_Items_Inner_Subgraph_PropMouseEnter           (      sender           :TObject);
    procedure P_Select_Items_Inner_Subgraph_PropMouseLeave           (      sender           :TObject);
    procedure P_Select_Items_Outer_Subgraph_PropMouseEnter           (      sender           :TObject);
    procedure P_Select_Items_Outer_Subgraph_PropMouseLeave           (      sender           :TObject);
    procedure P_Select_Items_Selection_PropMouseEnter                (      sender           :TObject);
    procedure P_Select_Items_Selection_PropMouseLeave                (      sender           :TObject);
    procedure P_Spline_Dynamics_PropMouseEnter                       (      sender           :TObject);
    procedure P_Spline_Dynamics_PropMouseLeave                       (      sender           :TObject);
    procedure P_Spline_Optimization_PropMouseEnter                   (      sender           :TObject);
    procedure P_Spline_Optimization_PropMouseLeave                   (      sender           :TObject);
    procedure P_Spline_Edges_PropMouseEnter                          (      sender           :TObject);
    procedure P_Spline_Edges_PropMouseLeave                          (      sender           :TObject);
    procedure P_Spline_Drawing_PropMouseEnter                        (      sender           :TObject);
    procedure P_Spline_Drawing_PropMouseLeave                        (      sender           :TObject);
    procedure P_Spline_Points_PropMouseEnter                         (      sender           :TObject);
    procedure P_Spline_Points_PropMouseLeave                         (      sender           :TObject);
    procedure P_Spline_Save_PropMouseEnter                           (      sender           :TObject);
    procedure P_Spline_Save_PropMouseLeave                           (      sender           :TObject);
    procedure P_Spline_EdgesMouseEnter                               (      sender           :TObject);
    procedure P_Spline_EdgesMouseLeave                               (      sender           :TObject);
    procedure P_Spline_FreehandMouseEnter                            (      sender           :TObject);
    procedure P_Spline_FreehandMouseLeave                            (      sender           :TObject);
    procedure P_Spline_PointsMouseEnter                              (      sender           :TObject);
    procedure P_Spline_PointsMouseLeave                              (      sender           :TObject);
    procedure P_Spline_TemplatesMouseEnter                           (      sender           :TObject);
    procedure P_Spline_TemplatesMouseLeave                           (      sender           :TObject);
    procedure P_Spline_Template_ListMouseEnter                       (      sender           :TObject);
    procedure P_Spline_Template_ListMouseLeave                       (      sender           :TObject);
    procedure P_Spline_Template_ListMouseWheelDown                   (      sender           :TObject;
                                                                            shift            :TShiftState;
                                                                            mousepos         :TPoint;
                                                                      var   handled          :boolean);
    procedure P_Spline_Template_ListMouseWheelUp                     (      sender           :TObject;
                                                                            shift            :TShiftState;
                                                                            mousepos         :TPoint;
                                                                      var   handled          :boolean);
    procedure P_Spline_Template_ListPaint                            (      sender           :TObject);
    procedure P_Text_Drawing_PropMouseEnter                          (      sender           :TObject);
    procedure P_Text_Drawing_PropMouseLeave                          (      sender           :TObject);
    procedure P_Text_SettingsMouseEnter                              (      sender           :TObject);
    procedure P_Text_SettingsMouseLeave                              (      sender           :TObject);
    procedure RB_Spline_AdaptiveChange                               (      sender           :TObject);
    procedure SB_Add_ActorClick                                      (      sender           :TObject);
    procedure SB_Map_EditorClick                                     (      sender           :TObject);
    procedure SB_RGridClick                                          (      sender           :TObject);
    procedure SB_RGrid_ColorClick                                    (      sender           :TObject);
    procedure SB_Select_Items_Inner_Subgraph_ColorClick              (      sender           :TObject);
    procedure SB_Select_Items_Inner_Subgraph_ShowClick               (      sender           :TObject);
    procedure SB_Select_Items_Outer_Subgraph_ColorClick              (      sender           :TObject);
    procedure SB_Select_Items_Outer_Subgraph_ShowClick               (      sender           :TObject);
    procedure SB_Select_Items_Selection_ColorClick                   (      sender           :TObject);
    procedure SB_SGridClick                                          (      sender           :TObject);
    procedure SB_SplineClick                                         (      sender           :TObject);
    procedure SB_Spline_LoadClick                                    (      sender           :TObject);
    procedure SB_Spline_TemplateClick                                (      sender           :TObject);
    procedure SB_Play_AnimClick                                      (      sender           :TObject);
    procedure SB_Select_Texture_RegionClick                          (      sender           :TObject);
    procedure SB_Spline_Edges_ColorClick                             (      sender           :TObject);
    procedure SB_Spline_Edges_Color_FallOffClick                     (      sender           :TObject);
    procedure SB_Spline_Edges_Color_RandomClick                      (      sender           :TObject);
    procedure SB_Spline_Edges_ShowClick                              (      sender           :TObject);
    procedure SB_Spline_Points_ColorClick                            (      sender           :TObject);
    procedure SB_Spline_Points_Color_FallOffClick                    (      sender           :TObject);
    procedure SB_Spline_Points_Color_RandomClick                     (      sender           :TObject);
    procedure SB_Spline_Points_ShowClick                             (      sender           :TObject);
    procedure SB_Object_PropertiesMouseEnter                         (      sender           :TObject);
    procedure SB_Object_PropertiesMouseLeave                         (      sender           :TObject);
    procedure SB_Tag_PropertiesMouseEnter                            (      sender           :TObject);
    procedure SB_Tag_PropertiesMouseLeave                            (      sender           :TObject);
    procedure SB_Text_Select_FontClick                               (      sender           :TObject);
    procedure SB_TreeView_Object_TagsMouseWheelDown                  (      sender           :TObject;
                                                                            shift            :TShiftState;
                                                                            mousepos         :TPoint;
                                                                      var   handled          :boolean);
    procedure SB_TreeView_Object_TagsMouseWheelUp                    (      sender           :TObject;
                                                                            shift            :TShiftState;
                                                                            mousepos         :TPoint;
                                                                      var   handled          :boolean);
    procedure SE_Spline_Cycloid_Loops_CountChange                    (      sender           :TObject);
    procedure SE_Spline_Cycloid_Points_CountChange                   (      sender           :TObject);
    procedure FSE_Spline_Cycloid_RadiusChange                        (      sender           :TObject);
    procedure FSE_Spline_Epicycloid_AngleChange                      (      sender           :TObject);
    procedure FSE_Spline_Epicycloid_Petals_CountChange               (      sender           :TObject);
    procedure SE_Spline_Epicycloid_Points_CountChange                (      sender           :TObject);
    procedure FSE_Spline_Epicycloid_RadiusChange                     (      sender           :TObject);
    procedure FSE_Spline_Epicycloid_RotationChange                   (      sender           :TObject);
    procedure SE_Spline_Pts_FreqEnter                                (      sender           :TObject);
    procedure SE_Spline_Pts_FreqExit                                 (      sender           :TObject);
    procedure SE_Spline_Pts_FreqMouseDown                            (      sender           :TObject;
                                                                            button           :TMouseButton;
                                                                            shift            :TShiftState;
                                                                            x,y              :integer);
    procedure FSE_Spline_Rose_AngleChange                            (      sender           :TObject);
    procedure SE_Spline_Rose_Points_CountChange                      (      sender           :TObject);
    procedure FSE_Spline_Rose_RadiusChange                           (      sender           :TObject);
    procedure FSE_Spline_Rose_RotationChange                         (      sender           :TObject);
    procedure FSE_Spline_Spiral_AngleChange                          (      sender           :TObject);
    procedure SE_Spline_Spiral_Points_CountChange                    (      sender           :TObject);
    procedure FSE_Spline_Spiral_RadiusChange                         (      sender           :TObject);
    procedure FSE_Spline_Spiral_RotationChange                       (      sender           :TObject);
    procedure SE_Spline_Edges_WidthChange                            (      sender           :TObject);
    procedure SE_Spline_Points_CountChange                           (      sender           :TObject);
    procedure SE_Spline_Points_Rectangle_Inner_Rectangle_HeightChange(      sender           :TObject);
    procedure SE_Spline_Points_Rectangle_Inner_Rectangle_WidthChange (      sender           :TObject);
    procedure SE_Spline_Points_Rectangle_Thikness_BottomChange       (      sender           :TObject);
    procedure SE_Spline_Points_Rectangle_Thikness_LeftChange         (      sender           :TObject);
    procedure SE_Spline_Points_Rectangle_Thikness_RightChange        (      sender           :TObject);
    procedure SE_Spline_Points_Rectangle_Thikness_TopChange          (      sender           :TObject);
    procedure SE_Spline_Spray_RadiusChange                           (      sender           :TObject);
    procedure SE_Object_Properties_Parallax_ShiftChange              (      sender           :TObject);
    procedure SE_Spline_Superellipse_Points_CountChange              (      sender           :TObject);

    {Buttons}
    procedure S_Splitter0ChangeBounds                                (      sender           :TObject);
    procedure S_Splitter2ChangeBounds                                (      sender           :TObject);
    procedure S_Splitter3ChangeBounds                                (      sender           :TObject);
    procedure S_Splitter6ChangeBounds                                (      sender           :TObject);
    procedure S_Splitter7ChangeBounds                                (      sender           :TObject);
    procedure S_Splitter1Moved                                       (      sender           :TObject);
    procedure S_Splitter2Moved                                       (      sender           :TObject);
    procedure S_Splitter3Moved                                       (      sender           :TObject);
    procedure BB_Bottom_Splitter_To_LeftClick                        (      sender           :TObject);
    procedure BB_Bottom_Splitter_To_RightClick                       (      sender           :TObject);
    procedure BB_Set_Value_UClick                                    (      sender           :TObject);
    procedure BB_Reset_Value_UClick                                  (      sender           :TObject);
    procedure BB_Set_Value_UMouseLeave                               (      sender           :TObject);
    procedure BB_Set_Value_VClick                                    (      sender           :TObject);
    procedure BB_Reset_Value_VClick                                  (      sender           :TObject);
    procedure BB_Set_All_ValuesClick                                 (      sender           :TObject);
    procedure BB_Reset_All_ValuesClick                               (      sender           :TObject);
    procedure SB_Move_Pivot_To_PointClick                            (      sender           :TObject);
    procedure BB_Reset_PivotClick                                    (      sender           :TObject);
    procedure BB_Save_UVClick                                        (      sender           :TObject);
    procedure BB_Reset_UVClick                                       (      sender           :TObject);
    procedure CCB_2D_Operations_AutomaticItemChange                  (      sender           :TObject;
                                                                            aindex           :integer);
    procedure CCB_2D_Operations_AutomaticGetItems                    (      sender           :TObject);
    procedure CCB_2D_Operations_AutomaticSelect                      (      sender           :TObject);
    procedure SE_Align_2D_Points_Precision_UMouseEnter               (      sender           :TObject);
    procedure SE_Align_2D_Points_Precision_VMouseEnter               (      sender           :TObject);
    procedure SE_Align_2D_Points_Precision_UChange                   (      sender           :TObject);
    procedure SE_Align_2D_Points_Precision_VChange                   (      sender           :TObject);
    procedure SE_Align_2D_Points_Precision_UMouseLeave               (      sender           :TObject);
    procedure SE_Align_2D_Points_Precision_VMouseLeave               (      sender           :TObject);
    procedure CB_Align_2D_Points_Show_Snap_GridChange                (      sender           :TObject);
    procedure CB_Align_2D_Points_Snap_Grid_VisibilityChange          (      sender           :TObject);
    procedure S_Splitter8ChangeBounds                                (      sender           :TObject);
    procedure TB_SpeedChange                                         (      sender           :TObject);
    procedure TB_SpeedClick                                          (      sender           :TObject);
    procedure TextureListItemMouseDown                               (      sender           :TObject;
                                                                            button           :TMouseButton;
                                                                            shift            :TShiftState;
                                                                            x,y              :integer);
    procedure SB_Load_ImageClick                                     (      sender           :TObject);
    procedure SB_Save_ImageClick                                     (      sender           :TObject);
    procedure SB_Clear_SceneClick                                    (      sender           :TObject);
    procedure BB_Delete_SelectedClick                                (      sender           :TObject);
    procedure BB_Delete_AllClick                                     (      sender           :TObject);
    procedure SB_Change_LayoutClick                                  (      sender           :TObject);
    procedure SB_Change_LayoutMouseLeave                             (      sender           :TObject);
    procedure SB_Centrify_PictureClick                               (      sender           :TObject);
    procedure SB_Centrify_PictureMouseLeave                          (      sender           :TObject);
    procedure SB_Background_ColorClick                               (      sender           :TObject);
    procedure SB_Grid_ColorClick                                     (      sender           :TObject);
    procedure SB_Spline_ColorClick                                   (      sender           :TObject);
    procedure SB_IS_Graph_ColorClick                                 (      sender           :TObject);
    procedure SB_UV_Mesh_ColorClick                                  (      sender           :TObject);
    procedure SB_Snap_Grid_ColorClick                                (      sender           :TObject);
    procedure I_Visibility_PanelMouseLeave                           (      sender           :TObject);
    procedure I_Visibility_PanelPaint                                (      sender           :TObject);
    procedure SB_Visibility_TextureMouseEnter                        (      sender           :TObject);
    procedure SB_Visibility_GridMouseEnter                           (      sender           :TObject);
    procedure SB_Visibility_Snap_GridMouseEnter                      (      sender           :TObject);
    procedure SB_Visibility_SplineMouseEnter                         (      sender           :TObject);
    procedure SB_Visibility_ActorMouseEnter                          (      sender           :TObject);
    procedure SB_Visibility_ColliderMouseEnter                       (      sender           :TObject);
    procedure SB_Visibility_TextureClick                             (      sender           :TObject);
    procedure SB_Visibility_GridClick                                (      sender           :TObject);
    procedure SB_Visibility_SplineClick                              (      sender           :TObject);
    procedure SB_Visibility_ColliderClick                            (      sender           :TObject);
    procedure SB_Visibility_ActorClick                               (      sender           :TObject);
    procedure SB_Visibility_Snap_GridClick                           (      sender           :TObject);
    procedure SB_Visibility_Show_AllClick                            (      sender           :TObject);
    procedure TS_DrawMouseWheelDown                                  (      sender           :TObject;
                                                                            shift            :TShiftState;
                                                                            mousepos         :TPoint;
                                                                      var   handled          :boolean);
    procedure TS_DrawMouseWheelUp                                    (      sender           :TObject;
                                                                            shift            :TShiftState;
                                                                            mousepos         :TPoint;
                                                                      var   handled          :boolean);
    procedure P_Load_Save_ClearPaint                                 (      sender           :TObject);
    procedure P_Drawing_ButtonsPaint                                 (      sender           :TObject);
    procedure SB_BrushClick                                          (      sender           :TObject);
    procedure SB_SprayClick                                          (      sender           :TObject);
    procedure SB_TextClick                                           (      sender           :TObject);
    procedure CB_Spline_ModeSelect                                   (      sender           :TObject);
    procedure SE_Spline_Pts_FreqChange                               (      sender           :TObject);
    procedure CB_Spline_TypeSelect                                   (      sender           :TObject);
    procedure CB_Spline_Connect_EndsChange                           (      sender           :TObject);
    procedure FSE_Spline_Simplification_AngleChange                  (      sender           :TObject);
    procedure CB_Spline_Edges_Anti_AliasingChange                    (      sender           :TObject);
    procedure SB_Select_ItemsClick                                   (      sender           :TObject);
    procedure CB_Select_Items_Selection_Drawing_ModeSelect           (      sender           :TObject);
    procedure CB_Select_Items_Outer_Subgraph_Line_StyleSelect        (      sender           :TObject);
    procedure CB_Select_Items_Outer_Subgraph_Clip_StyleSelect        (      sender           :TObject);
    procedure SE_Select_Points_Bucket_SizeChange                     (      sender           :TObject);
    procedure SB_Selected_Points_Select_ColorClick                   (      sender           :TObject);
    procedure CB_Select_Items_Outer_Subgraph_Show_BoundsChange       (      sender           :TObject);
    procedure CB_Select_Points_Show_BoundsChange                     (      sender           :TObject);
    procedure TV_Scene_TreeDblClick                                  (      sender           :TObject);
    procedure TV_Scene_TreeEditing                                   (      sender           :TObject;
                                                                            node             :TTreeNode;
                                                                      var   allowedit        :boolean);
    procedure TV_Scene_TreeEditingEnd                                (      sender           :TObject;
                                                                            node             :TTreeNode;
                                                                            cancel           :boolean);
    procedure TV_Scene_TreeExpanded                                  (      sender           :TObject;
                                                                            node             :TTreeNode);
    procedure TV_Scene_TreeExpanding                                 (      sender           :TObject;
                                                                            node             :TTreeNode;
                                                                      var   allowexpansion   :boolean);
    procedure TV_Scene_TreeKeyDown                                   (      sender           :TObject;
                                                                      var   key              :word;
                                                                            shift            :TShiftState);
    procedure TV_Scene_TreeKeyPress                                  (      sender           :TObject;
                                                                      var   key              :char);
    procedure TV_Scene_TreeMouseEnter                                (      sender           :TObject);
    procedure TV_Scene_TreeMouseLeave                                (      sender           :TObject);
    procedure TV_Scene_TreeMouseMove                                 (      sender           :TObject;
                                                                            shift            :TShiftState;
                                                                            x,y              :integer);
    procedure TV_Scene_TreeMouseWheelDown                            (      sender           :TObject;
                                                                            shift            :TShiftState;
                                                                            mousepos         :TPoint;
                                                                      var   handled          :boolean);
    procedure TV_Scene_TreeMouseWheelUp                              (      sender           :TObject;
                                                                            shift            :TShiftState;
                                                                            mousepos         :TPoint;
                                                                      var   handled          :boolean);
    procedure T_Game_LoopTimer                                       (      sender           :TObject);
    procedure Tic                                                    (      sender           :TObject;
                                                                      var   done             :boolean);
    procedure T_Logo1Timer                                           (      sender           :TObject);
    procedure T_Logo2Timer                                           (      sender           :TObject);
    procedure T_Logo3Timer                                           (      sender           :TObject);
    procedure T_MenuTimer                                            (      sender           :TObject);
    procedure T_GameTimer                                            (      sender           :TObject);

    {Miscellaneous}
    procedure VisibilityChange                                       (      set_visibility   :boolean); inline; {$ifdef Linux}[local];{$endif}
    procedure KeysEnable0;                                                                              inline; {$ifdef Linux}[local];{$endif}
    procedure KeysEnable1;                                                                              inline; {$ifdef Linux}[local];{$endif}
    procedure KeysDisable0;                                                                             inline; {$ifdef Linux}[local];{$endif}
    procedure KeysDisable1;                                                                             inline; {$ifdef Linux}[local];{$endif}

    procedure SplinesTemplatesNamesInit                              (      sln_var_         :TCurve);

    {TrayIcon}
    procedure TrayIcon1Click                                         (      sender           :TObject);

    {Scene Tree}
    constructor Create                                               (      theowner         :TComponent); override;
    procedure MI_Add_GroupClick                                      (      sender           :TObject);
    procedure MI_Remove_ObjectClick                                  (      sender           :TObject);
    procedure MI_Group_ObjectsClick                                  (      sender           :TObject);
    procedure MI_Delete_Without_ChildrenClick                        (      sender           :TObject);
    procedure MI_Delete_All_GroupsClick                              (      sender           :TObject);
    procedure MI_Select_AllClick                                     (      sender           :TObject);
    procedure MI_Fold_SelectedClick                                  (      sender           :TObject);
    procedure MI_Unfold_SelectedClick                                (      sender           :TObject);
    procedure MI_Goto_First_ObjectClick                              (      sender           :TObject);
    procedure MI_Goto_Last_ObjectClick                               (      sender           :TObject);
    procedure TV_Scene_TreeDragOver                                  (      sender,
                                                                            source           :TObject;
                                                                            x,y              :integer;
                                                                            state            :TDragState;
                                                                      var   accept           :boolean);
    procedure TV_Scene_TreeMouseDown                                 (      sender           :TObject;
                                                                            button           :TMouseButton;
                                                                            shift            :TShiftState;
                                                                            x,y              :integer);
    procedure TV_Scene_TreeDragDrop                                  (      sender,
                                                                            source           :TObject;
                                                                            x,y              :integer);
    procedure S_TreeView_SplitterChangeBounds                        (      sender           :TObject);

    private
      procedure OnMove                                               (var   message          :TWMMove); message WM_MOVE; // Обработчик перемещения формы

    strict private

    protected

    strict protected

    public

    published

  end; {$endregion}
  PF_MainForm        =^TF_MainForm;

  {Saved Up Points----}
  TSavedUpPts        =class {$region -fold}
    public
      var
      {TODO}
        saved_up_pts    : TPtPosFArr;
        {TODO}
        saved_up_pts_cnt: TColor;
        {TODO}
      procedure SavePts (const target_pts_arr      :TPtPosFArr;
                         const target_pts_cnt      :TColor;
                         var   saved_up_pts_arr    :TPtPosFArr;
                         var   saved_up_pts_arr_cnt:TColor); {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure ResetPts(var   target_pts_arr      :TPtPosFArr;
                         const saved_up_pts_arr    :TPtPosFArr;
                         const saved_up_pts_arr_cnt:TColor;
                               proc_ptr            :TProc0); {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PSavedUpPts        =^TSavedUpPts;

  {Surface Drawing----}
  TSurface           =class {$region -fold}
    public
      need_repaint           : boolean;
      {Main  Layer------------------} {$region -fold}
        {main bitmap}
        srf_bmp              : Graphics.TBitmap;
        test_bmp             : Graphics.TBitmap;
        {main bitmap handle}
        srf_bmp_ptr          : PInteger;
        test_bmp_ptr         : PInteger;
        {main bitmap bounding rectangle}
        srf_bmp_rct          : TPtRect;
        {background color}
        bg_color             : TColor;
        {background post-process effect}
        bg_style             : TBackgroundStyle; {$endregion}
      {Lower Layer(Before Selection)} {$region -fold}
        {lower layer(before selection) bitmap}
        low_bmp              : Graphics.TBitmap;
        {lower layer(before selection) bitmap handle}
        low_bmp_ptr          : PInteger;
        {drawing of lower layer(before selection)}
        low_bmp_draw         : boolean; {$endregion}
      {Lower Layer(After  Selection)} {$region -fold}
        {lower layer(after selection)}
        low_bmp2             : Graphics.TBitmap;
        {lower layer(after selection) bitmap handle}
        low_bmp2_ptr         : PInteger;
        {drawing of lower layer(after selection)}
        low_bmp2_draw        : boolean; {$endregion}
      {Buffer for Baking Rotatable Sprites}
      rot_arr                : TColorArr;
      rot_arr_ptr            : PInteger;
      rot_arr_width          : TColor;
      rot_arr_height         : TColor;
      {inner window bitmap bounding rectangle}
      inn_wnd_rct            : TPtRect;
      {array of stored drawing styles(blending effects)}
      drawing_style          : array[0..4] of TDrawingStyle;
      {index inside spritesheet array}
      world_axis_bmp_ind     : integer;
      {world axis position}
      world_axis             : TPtPos;
      world_axis_shift       : TPtPos;
      {UI}
      inner_window_ui_visible: boolean;
      {create class instance}
      constructor Create           (         w,h           :TColor);                      {$ifdef Linux}[local];{$endif}
      {destroy class instance}
      destructor  Destroy;                                                      override; {$ifdef Linux}[local];{$endif}
      {World Axis}
      procedure WorldAxisCreate;                                                  inline; {$ifdef Linux}[local];{$endif}
      procedure WorldAxisToBmp     (constref x,y           :integer);             inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure MainBmpRectCalc;                                                  inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure MainBmpSizeCalc;                                                  inline; {$ifdef Linux}[local];{$endif}
      {set new sizes of bitmaps and arrays}
      procedure MainBmpArrsCalc;                                                  inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure InnerWindowDraw    (color                  :TColor);              inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure BmpSettings        (bmp_dst                :Graphics.TBitmap;
                                    pen_color              :TColor;
                                    pen_mode               :TPenMode=pmCopy;
                                    brush_style            :TBrushStyle=bsSolid); inline; {$ifdef Linux}[local];{$endif}

      {TODO}
      procedure MainBmpToLowerBmp;                                                inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure MainBmpToLowerBmp2;                                               inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure LowerBmpToMainBmp;                                                inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure LowerBmp2ToMainBmp;                                               inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure FilBkgndObj        (constref bkgnd_ind     :TColor);              inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure MovBkgndObj        (constref bkgnd_ind     :TColor);              inline; {$ifdef Linux}[local];{$endif}
      {Lower Layer Movement------------------------} {$region -fold}
      procedure ChangeSpeed;                                                      inline; {$ifdef Linux}[local];{$endif}
      procedure MovLeft;                                                          inline; {$ifdef Linux}[local];{$endif}
      procedure FilLeft            (constref bmp_dst_ptr   :PInteger;
                                    constref bmp_dst_width,
                                             bmp_dst_height:integer;
                                    constref rct_dst       :TPtRect);             inline; {$ifdef Linux}[local];{$endif}

      procedure MovRight;                                                         inline; {$ifdef Linux}[local];{$endif}
      procedure FilRight           (constref bmp_dst_ptr   :PInteger;
                                    constref bmp_dst_width,
                                             bmp_dst_height:integer;
                                    constref rct_dst       :TPtRect);             inline; {$ifdef Linux}[local];{$endif}

      procedure MovUp;                                                            inline; {$ifdef Linux}[local];{$endif}
      procedure FilUp              (constref bmp_dst_ptr   :PInteger;
                                    constref bmp_dst_width,
                                             bmp_dst_height:integer;
                                    constref rct_dst       :TPtRect);             inline; {$ifdef Linux}[local];{$endif}

      procedure MovDown;                                                          inline; {$ifdef Linux}[local];{$endif}
      procedure FilDown            (constref bmp_dst_ptr   :PInteger;
                                    constref bmp_dst_width,
                                             bmp_dst_height:integer;
                                    constref rct_dst       :TPtRect);             inline; {$ifdef Linux}[local];{$endif}
      {$endregion}
      {Events Queue}
      {Get Handles---------------------------------}
      procedure GetHandles;                                                               {$ifdef Linux}[local];{$endif}
      {World Axis: Drawing-------------------------}
      procedure WorldAxisDraw;                                                            {$ifdef Linux}[local];{$endif}
      {Align Spline: Calculation-------------------}
      procedure AlnSplineCalc;                                                            {$ifdef Linux}[local];{$endif}
      {Select Pivot: Calculation-------------------}
      procedure SelectPivotCalc;                                                          {$ifdef Linux}[local];{$endif}
      {Select Pivot: Drawing-----------------------}
      procedure SelectPivotDraw;                                                          {$ifdef Linux}[local];{$endif}
      {Unselect Pivot: Drawing---------------------}
      procedure UnselectPivotDraw;                                                        {$ifdef Linux}[local];{$endif}
      {Add Spline: Calculation---------------------}
      procedure AddSplineCalc;                                                            {$ifdef Linux}[local];{$endif}
      {Add Spline: Hidden Lines--------------------}
      procedure AddSplineHdLn;                                                            {$ifdef Linux}[local];{$endif}
      {Add Spline: Has Edge(Lines) Calc.-----------}
      procedure AddSplineHsLn;                                                            {$ifdef Linux}[local];{$endif}
      {Add Spline: Drawing-------------------------}
      procedure AddSplineDraw;                                                            {$ifdef Linux}[local];{$endif}
      {Add Tile Map: Calculation-------------------}
      procedure AddTileMapCalc;                                                           {$ifdef Linux}[local];{$endif}
      {Scale Background: Calculation---------------}
      procedure SclBckgdCalc;                                                             {$ifdef Linux}[local];{$endif}
      {Scale Spline: Calculation-------------------}
      procedure SclSplineCalc;                                                            {$ifdef Linux}[local];{$endif}
      {Repaint Splines with Hidden Lines-----------}
      procedure RepSplineHdLn;                                                            {$ifdef Linux}[local];{$endif}
      {Repaint Spline: Drawing---------------------}
      procedure RepSplineDraw0;                                                           {$ifdef Linux}[local];{$endif}
      procedure RepSplineDraw1;                                                           {$ifdef Linux}[local];{$endif}
      {Duplicated Points: Drawing------------------}
      procedure DupPtsDraw;                                                               {$ifdef Linux}[local];{$endif}
      {SpriteSheet: Reset Background Settings------}
      procedure SpriteSheetSetBckgd;                                                      {$ifdef Linux}[local];{$endif}
      {Actors: Reset Background Settings-----------}
      procedure ActSetBckgd;                                                              {$ifdef Linux}[local];{$endif}
      {Selected Subgraph: Drawing------------------}
      procedure SelectedSubgrtaphDraw;                                                    {$ifdef Linux}[local];{$endif}
      {Background Post-Processing------------------}
      procedure BkgPP;                                                                    {$ifdef Linux}[local];{$endif}
      {Grid Post-Processing------------------------}
      procedure GrdPP;                                                                    {$ifdef Linux}[local];{$endif}
      {Main Render Procedure}
      procedure MainDraw;                                                                 {$ifdef Linux}[local];{$endif}
      procedure EventGroupsCalc    (var      arr           :TBool2Arr;
                                             event_group   :TEventGroupEnum);             {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PSurface           =^TSurface;

  {Main Layer Instance}
  TCamera            =class {$region -fold}
    public
      {Speed Multiplier}
      parallax_shift         : TPtPosF;
      speed_mul              : TPtPosF;
      mov_dir                : TMovingDirection;
      {TODO}
      scl_dif                : integer;
      {scale direction}
      scl_dir                : TSclDir;
      {TODO}
      dir_a                  : boolean;
      dir_d                  : boolean;
      dir_w                  : boolean;
      dir_s                  : boolean;
      {TODO}
      bmp_rect: TPtRect;
      {create class instance}
      constructor Create(w,h:TColor); {$ifdef Linux}[local];{$endif}
      {destroy class instance}
      destructor  Destroy; override;  {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PCamera            =^TCamera;

  {Texture------------}
  TTex               =class {$region -fold}
    public
      srf_var_ptr               : PSurface;
      {list of loaded textures}
      tex_list                  : TPictArr;
      {buffer, which contains loaded texture}
      loaded_picture            : TPicture;
      {texture layer}
      tex_bmp                   : Graphics.TBitmap;
      {texture bmp handle}
      tex_bmp_ptr               : PInteger;
      {texture bmp bounding rectangle}
      tex_bmp_rct_pts           : TPtPosFArr;
      {source bounding box for loaded texture}
      tex_bmp_rct_origin_pts    : TPtPosFArr;
      {size of texture preview in texure list}
      tex_list_item_size        : TColor;
      {checking if texture is enabled}
      is_tex_enabled            : boolean;
      {TODO}
      moving                    : boolean;
      {TODO}
      scaling                   : boolean;
      {TODO}
      rotation                  : boolean;
      {create class instance}
      constructor Create   (         w,h       :TColor);          {$ifdef Linux}[local];{$endif}
      {destroy class instance}
      destructor  Destroy;                              override; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure LoadTexture;                              inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure TexToBmp   (         rect_dst  :TPtRect;
                                     canvas_dst:TCanvas); inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure AlignPictureToCenter;                     inline; {$ifdef Linux}[local];{$endif}
      {fill background texture}
      procedure FilBkTexObj(constref bktex_ind :TColor);  inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PTex               =^TTex;

  {Grid---------------}
  TRGrid             =class {$region -fold}
    public
      srf_var_ptr  : PSurface;
      class var
        {TODO}
        rgrid_color: TColor;
        {grid density}
        rgrid_dnt  : integer;
      {create class instance}
      constructor Create   (         w,h          :TColor);          {$ifdef Linux}[local];{$endif}
      {destroy class instance}
      destructor  Destroy;                                 override; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure RGridToBmp (constref pvt          :TPtPosF;
                            constref bmp_dst_ptr  :PInteger;
                            constref bmp_dst_width:TColor;
                                     rct_clp_ptr  :PPtRect); inline; {$ifdef Linux}[local];{$endif}
      procedure FilRGridObj(constref rgrid_ind    :TColor);  inline; {$ifdef Linux}[local];{$endif}
      procedure MovRGridObj(constref rgrid_ind    :TColor);  inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PRGrid             =^TRGrid;

  {Snap Grid----------}
  TSGrid             =class {$region -fold}
    public
      srf_var_ptr  : PSurface;
      class var
        {snap grid color}
        sgrid_color: TColor;
        {grid density}
        sgrid_dnt  : integer;
        {TODO}
        align_pts  : boolean;
        {create class instance}
      constructor Create   (         w,h             :TColor);          {$ifdef Linux}[local];{$endif}
      {destroy class instance}
      destructor  Destroy;                                    override; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SGridToBmp (constref pvt             :TPtPosF;
                            constref bmp_dst_ptr     :PInteger;
                            constref bmp_dst_width   :TColor;
                                     rct_clp_ptr     :PPtRect); inline; {$ifdef Linux}[local];{$endif}
      procedure FilSGridObj(constref sgrid_ind       :TColor);  inline; {$ifdef Linux}[local];{$endif}
      procedure MovSGridObj(constref sgrid_ind       :TColor);  inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure AlignPts   (var   pts                :TPtPosFArr;
                            const sel_pts_inds       :TColorArr;
                            const pts_cnt,sel_pts_cnt:TColor);          {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PSGrid             =^TSGrid;

  {Spline-------------}
  TCurve             =class {$region -fold}
    public
      srf_var_ptr            : PSurface;
      {spline edges bounding rectangles buffers}
      rct_eds_img_arr        : TFLnArr;
      rct_eds_big_img        : TFastLine;
      rct_eds_useless_fld_arr: TColorArr;
      {spline points bounding rectangles buffers}
      rct_pts_img_arr        : TFLnArr;
      rct_pts_big_img        : TFastLine;
      rct_pts_useless_fld_arr: TColorArr;
      {spline edges buffers}
      eds_img_arr            : TFLnArr;
      eds_big_img            : TFastLine;
      eds_useless_fld_arr    : TColorArr;
      {spline points buffers}
      pts_img_arr            : TFLnArr;
      pts_big_img            : TFastLine;
      pts_useless_fld_arr    : TColorArr;
      {duplicated points}
      dup_pts_arr            : TPtPos3Arr;
      {spline global properties which will be shown on panel of spline properties in editor}
      global_prop            : TCurveProp;
      current_prop           : TCurveProp;
      {Spline Template List} {$region -fold}
        FmlSplineObj         : array[byte] of TProc7;
        sln_tlt_nam_arr1     : array[byte] of string;
        sln_tlt_nam_arr2     : array[byte] of PByteBool;
        // index of minimal parameter(left/top) of "Spline Teamplates"(spline type:formula) buttons:
        sln_tlt_fst_it_ind   : byte;
        // index of current button down:
        cur_tlt_dwn_btn_ind  : smallint; {$endregion}
      {spline saved up points}
      sln_saved_up_pts_var   : TSavedUpPts;
      {TODO}
      btn_glyph_origin       : Graphics.TBitmap;
      {TODO}
      btn_temp_glyph         : Graphics.TBitmap;
      {TODO}
      tex_on_sln_tmp_bmp     : Graphics.TBitmap;
      {TODO}
      tex_on_sln             : TPicture;
      {array of ponts for intermediate calculations(when points areadded)}
      sln_pts_add            : TPtPosFArr;
      {(partial points sums) частичные суммы точек сплайнов}
      partial_pts_sum        : TColorArr;
      {(array of counts of spline objects points) массив числа точек сплайнов}
      sln_obj_pts_cnt        : TColorArr;
      {does spline have selected points:
      0 - no points selected;
      1 - there are selected points in outer subgraph;
      2 - there are selected points in inner subgraph;
      3 - there are selected points in outer and inner subgraphs;
      4 - there is a single selected point}
      has_sel_pts            : T1Byte1Arr;
      {spline_points}
      sln_pts_reserved       : T2PtPosFArr;
      sln_pts                : TPtPosFArr;
      {formula spline points (dummy preview in editor)}
      fml_pts                : TPtPosFArr;
      {(array of spline objects indices) массив индексов сплайнов}
      sln_obj_ind            : TColorArr;
      {(array of spline visible edges indices) массив индексов видимых ребер}
      sln_vis_eds_ind        : TColor2Arr;
      {set value to point:
      0 - inner spline object point;
      1 - first spline object point;
      2 - last  spline object point;
      3 - spline object has single point}
      fst_lst_sln_obj_pts    : TEnum0Arr;
      {does point have an edge:
      -1 - point doesnt have edge;
      0  - point has         edge}
      has_edge               : TShIntArr;
      {TODO}
      rct_bnd_ind_arr        : array of TEnum2Arr;
      {all splines bounding rectangle intersected with inner window}
      sln_obj_all_rct_vis    : TRect;
      {spline objects count}
      sln_obj_cnt            : TColor;
      {spline points count}
      sln_pts_cnt            : TColor;
      {spline points count on addition}
      sln_pts_cnt_add        : TColor;
      {spline edges count}
      sln_eds_cnt            : TColor;
      {points increment used in interjacent calculations}
      pts_inc                : TColor;
      {detect, if spline drawing is happening}
      draw_spline            : boolean;
      {detect, if spline was changed}
      sln_changed            : boolean;
      {detect, if there is at least one spline with property local_prop.hid_ln_elim in True}
      has_hid_ln_elim_sln    : boolean;
      {detect, if there is at least one spline with property local_prop.byte_mode in True}
      has_byte_mode_sln      : boolean;
      {linked list for "Add Point"}
      first_item,p1,p2       : PFList;
      {Init. Part}
      constructor Create                   (constref w,h             :TColor);                  {$ifdef Linux}[local];{$endif}
      destructor  Destroy;                                                            override; {$ifdef Linux}[local];{$endif}
      {compress primitive surface}
      procedure PrimitiveComp              (constref spline_ind      :TColor;
                                            constref pmt_var_ptr,
                                                     pmt_big_var_ptr :PFastLine;
                                                     pmt_bld_stl     :TDrawingStyle); {inline;} {$ifdef Linux}[local];{$endif}
      {add point: drawing}
      procedure AddPoint                   (constref x,y             :integer;
                                            constref bmp_dst_ptr     :PInteger;
                                            constref bmp_dst_width   :TColor;
                                            var      color_info      :TColorInfo;
                                            constref rct_clp         :TPtRect;
                                            var      add_spline_calc_:boolean;
                                                     sleep_          :boolean=False); {inline;} {$ifdef Linux}[local];{$endif}
      {calculation of spline rectangle}
      procedure RctSplineRct0              (constref spline_ind      :TColor;
                                            var      rct_out_,
                                                     rct_ent_        :TRect);         {inline;} {$ifdef Linux}[local];{$endif}
      procedure RctSplineRct1              (constref spline_ind      :TColor;
                                            var      rct_out_,
                                                     rct_ent_        :TRect);         {inline;} {$ifdef Linux}[local];{$endif}
      procedure RctSplineRct2              (constref spline_ind      :TColor;
                                            var      rct_out_,
                                                     rct_ent_        :TRect);         {inline;} {$ifdef Linux}[local];{$endif}
      procedure RctSplineRctEds            (constref spline_ind      :TColor;
                                            constref rct_out_,
                                                     rct_ent_        :TRect);         {inline;} {$ifdef Linux}[local];{$endif}
      procedure RctSplineRctPts            (constref spline_ind      :TColor;
                                            constref rct_out_,
                                                     rct_ent_        :TRect);         {inline;} {$ifdef Linux}[local];{$endif}
      procedure RctSplineEds               (constref spline_ind      :TColor;
                                            constref rct_out_,
                                                     rct_ent_        :TRect);         {inline;} {$ifdef Linux}[local];{$endif}
      procedure RctSplinePts               (constref spline_ind      :TColor;
                                            constref rct_out_,
                                                     rct_ent_        :TRect);         {inline;} {$ifdef Linux}[local];{$endif}
      procedure RctSplineObj0              (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure RctSplineObj1              (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {calculation of all splines rectangles}
      procedure RctSplineAll0              (constref start_ind,
                                                     end_ind         :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure RctSplineAll1              (constref start_ind,
                                                     end_ind         :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure RctSplineAll2              (constref start_ind,
                                                     end_ind         :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure RctSplineAll3              (constref start_ind,
                                                     end_ind         :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {calculation of spline on addition}
      procedure AddSplineObj;                                                         {inline;} {$ifdef Linux}[local];{$endif}
      {add spline bounding rectangle to spline edges buffer into clipped region}
      procedure AddSplineRctEds            (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {add spline bounding rectangle to spline points buffer into clipped region}
      procedure AddSplineRctPts            (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {add spline edges to spline edges buffer into clipped region}
      procedure AddSplineEds00             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds01             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds02             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds03             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds04             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds05             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds06             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds07             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds08             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds09             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds10             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds11             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds12             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds13             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds14             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds15             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds16             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds17             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds18             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds19             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds20             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineEds21             (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {add spline points to spline points buffer into clipped region}
      procedure AddSplinePts0              (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplinePts1              (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplinePts2              (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplinePts3              (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplinePts4              (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplinePts5              (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplinePts6              (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplinePts7              (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {add spline duplicated points on specified buffer(dup_pts_arr)}
      procedure AddSplineDupPts0           (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineDupPts1           (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineDupPts2           (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineDupPts3           (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure AddSplineDupPtsAll         (constref start_ind,
                                                     end_ind         :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {clear spline duplicated points on specified buffer(dup_pts_arr)}
      procedure ClrSplineDupPts0           (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure ClrSplineDupPts1           (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure ClrSplineDupPts2           (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure ClrSplineDupPts3           (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {clear all spline edges on spline edges  bounding rectangles buffer}
      procedure ClrSplineRctEds            (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {clear all spline edges on spline points bounding rectangles buffer}
      procedure ClrSplineRctPts            (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {clear all spline edges on spline edges buffers}
      procedure ClrSplineEds               (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {clear all spline points on spline points buffers}
      procedure ClrSplinePts               (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {clear all splines from start_ind to end_ind}
      procedure ClrSplineAll               (constref start_ind,
                                                     end_ind         :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {create sprite of all spline edges and points bounding rectangles on spline edges  bounding rectangles buffer into clipped region}
      procedure CrtSplineRctEds            (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {create sprite of all spline edges and points bounding rectangles on spline points bounding rectangles buffer into clipped region}
      procedure CrtSplineRctPts            (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {create sprite of all spline edges on spline edges buffer into clipped region}
      procedure CrtSplineEds               (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {create sprite of all spline points on spline points buffer into clipped region}
      procedure CrtSplinePts               (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {create sprite of all spline edges and points from start_ind to end_ind}
      procedure CrtSplineAll0              (constref start_ind,
                                                     end_ind         :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure CrtSplineAll1              (constref start_ind,
                                                     end_ind         :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {fill all spline edges and points bounding rectangles on spline edges  bounding rectangles buffer into clipped region}
      procedure FilSplineRctEds            (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {fill all spline edges and points bounding rectangles on spline points bounding rectangles buffer into clipped region}
      procedure FilSplineRctPts            (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {fill all spline edges on spline edges buffer into clipped region}
      procedure FilSplineEds               (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {fill all spline points on spline points buffer into clipped region}
      procedure FilSplinePts               (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {fill spline object}
      procedure FilSplineObj               (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {fill all spline objects}
      procedure FilSplineAll               (constref start_ind,
                                                     end_ind         :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {generate formula spline into specified area}
      procedure FmlSplineInit;                                                        {inline;} {$ifdef Linux}[local];{$endif}
      procedure FmlSplinePrev              (constref fml_pts_cnt     :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure Cycloid                    (constref x,y             :integer);       {inline;} {$ifdef Linux}[local];{$endif}
      procedure Epicycloid                 (constref x,y             :integer);       {inline;} {$ifdef Linux}[local];{$endif}
      procedure Rose                       (constref x,y             :integer);       {inline;} {$ifdef Linux}[local];{$endif}
      procedure Spiral                     (constref x,y             :integer);       {inline;} {$ifdef Linux}[local];{$endif}
      procedure Superellipse               (constref x,y             :integer);       {inline;} {$ifdef Linux}[local];{$endif}
      {}
      procedure HasSplineEds               (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {move spline edges bounding rectangles}
      procedure MovSplineRctEds            (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {move spline points bounding rectangles}
      procedure MovSplineRctPts            (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {move spline edges}
      procedure MovSplineEds0              (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure MovSplineEds1              (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure MovSplineEds2              (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {move spline points}
      procedure MovSplinePts0              (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      procedure MovSplinePts1              (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {move spline object}
      procedure MovSplineObj               (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {move all spline objects}
      procedure MovSplineAll               (constref start_ind,
                                                     end_ind         :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {repaint spline edges  bounding rectangles on spline edges and points bounding rectangles buffer into clipped region}
      procedure RepSplineRctEds            (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {repaint spline points bounding rectangles on spline edges and points bounding rectangles buffer into clipped region}
      procedure RepSplineRctPts            (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {repaint spline edges}
      procedure RepSplineEds               (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {repaint spline points}
      procedure RepSplinePts               (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {set random color info.}
      procedure RndSplineCol               (var      local_prop      :TCurveProp;
                                            var      col,col_inv     :TColor;
                                            var      col_ptr         :PInteger;
                                            constref btn             :TSpeedButton);  {inline;} {$ifdef Linux}[local];{$endif}
      {generate random spline into specified area}
      procedure RndSplineObj               (constref pt              :TPtPos;
                                            constref w,h             :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
      {drawing simplified spline points on spline points buffer into clipped region}
      procedure SmpSplinePts               (constref spline_ind      :TColor);        {inline;} {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PCurve             =^TCurve;

  {Text---------------}
  TFText             =class {$region -fold}
    public
      srf_var_ptr: PSurface;
      {array of text sprites}
      txt_img_arr: TFTxArr;
      {spline global properties which will be shown on panel of spline properties in editor}
      global_prop: TFTextProp;
      {create class instance}
      constructor Create(w,h:TColor); {$ifdef Linux}[local];{$endif}
      {destroy class instance}
      destructor  Destroy;  override; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PFText             =^TFText;

  {UV-----------------}
  TUV                =class {$region -fold}
    public
      {TODO}
      uv_drawing_style: TDrawingStyle;
      {TODO}
      uv_color        : TColor;
      {array of uv texture points(vertices)}
      uv_pts          : TPtPosFArr;
      {TODO}
      n_gons          : TColor;
      {TODO}
      triangles       : TColor;
      {TODO}
      quads           : TColor;
      {TODO}
      groups          : TColor;
      {create class instance}
      constructor Create(w,h:TColor); {$ifdef Linux}[local];{$endif}
      {destroy class instance}
      destructor  Destroy;  override; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PUV                =^TUV;

  {Intersection Graph-}
  TISGraph           =class {$region -fold}
    public
      {TODO}
      is_graph_drawing_style: TDrawingStyle;
      {TODO}
      is_graph_color        : TColor;
      {array of intersection graph points}
      is_graph_pts          : TPtPosFArr;
      {create class instance}
      constructor Create(w,h:TColor); {$ifdef Linux}[local];{$endif}
      {destroy class instance}
      destructor  Destroy;  override; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure ISGraphCalc;  inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure ISGraphDraw;  inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PISGraph           =^TISGraph;

  {Select Items-------}
  TSelIts            =class {$region -fold}
    public
      srf_var_ptr                : PSurface;
      {outer subgraph edges}
      outer_subgraph_img         : TFastLine;
      {inner subgraph edges}
      inner_subgraph_img         : TFastLine;
      {selection image:circle,rectangle etc.}
      sel_pts_big_img            : TFastLine;
      {selection properties}
      selit_prop                 : TSelItProp;
      sel_bounds_prop            : TCurveProp;
      {subgraph indices arrays} {$region -fold}
        {TODO}
        outer_subgraph1          : TEdgeArr;
        outer_subgraph1_eds_cnt  : TColor;
        {TODO}
        outer_subgraph2          : TEdgeArr;
        outer_subgraph2_eds_cnt  : TColor;
        {TODO}
        outer_subgraph3          : TEdgeArr;
        outer_subgraph3_eds_cnt  : TColor;
        {TODO}
        inner_subgraph_          : TEdgeArr;
        inner_subgraph__eds_cnt  : TColor;
        {TODO}
        sl_pt_subgraph_          : TSlPtArr;
        sl_pt_subgraph__eds_cnt  : TColor; {$endregion}
      {is point of outer or inner subgraph:
      0 - point is not selected;
      1 - point is of outer subgraph;
      2 - point is of inner subgraph}
      out_or_inn_subgraph_pts    : T1Byte1Arr;
      {selected points indices}
      sel_pts_inds               : TColorArr;
      {is point selected}
      is_point_selected          : TBool1Arr;
      {is point duplicated}
      is_point_duplicated        : TBool1Arr;
      {is point in circle}
      is_point_in_circle         : TBool1Arr;
      {is point position calculated}
      is_point_pos_calc          : TBool1Arr;
      {selected points bitmap}
      ///
      {selected points bitmap handle}
      ///
      {selected points bounding rectangle}
      sel_pts_rct                : TPtRectF;
      sel_pts_rct_mrgn           : TColor;
      {TODO}
      not_sel_pts_rct            : TPtRect;
      {TODO}
      bucket_rct                 : TPtRect;
      {TODO}
      bucket_rct_color           : TColor;
      {count of splines with selected points}
      sln_with_sel_pts_cnt       : TColor;
      {count of selected points}
      sel_pts_cnt                : TColor;
      {count of duplicated points}
      dup_pts_cnt                : TColor;
      {minimal index of selected object(spline)}
      sel_obj_min_ind            : TColor;
      {is an abstract object kind after spline which has selected points and minimal index}
      is_not_abst_obj_kind_after : boolean;
      {select points:expression}
      sel_pts                    : boolean;
      {fill bmp only without full repaint}
      fill_bmp_only              : boolean;
      OuterSubgraphProc          : array[0..2] of TProc10;
      InnerSubgraphProc          : array[0..2] of TProc10;
      WholeSubgraphProc          : array[0..2] of TProc11;
      {create class instance}
      constructor Create                        (constref w,h                :TColor);                {$ifdef Linux}[local];{$endif}
      {destroy class instance}
      destructor  Destroy;                                                                  override; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure FillSelBmpAndSelPtsBRectDraw;                                                 inline; {$ifdef linux}[local];{$endif}
      {TODO}
      procedure ChangeSelectionMode             (         item_ind           :TColor);        inline; {$ifdef Linux}[local];{$endif}
      {add circle}
      procedure AddCircleSelection;                                                           inline; {$ifdef Linux}[local];{$endif}
      {compress primitive surface}
      procedure PrimitiveComp                   (constref pmt_img_ptr        :PFastLine;
                                                          pmt_bld_stl        :TDrawingStyle); inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure CrtCircleSelection;                                                           inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure FilSelPtsObj                    (constref x,y                :integer);       inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure MinimizeCircleSelection;                                                      inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SelectAllPts                    (const    pts_cnt,
                                                          eds_cnt            :TColor);        inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SubgraphCalc                    (var      has_sel_pts        :T1Byte1Arr;
                                                 constref pts                :TPtPosFArr;
                                                 constref fst_lst_sln_obj_pts:TEnum0Arr;
                                                 constref obj_ind            :TColorArr;
                                                 constref sln_obj_cnt        :TColor;
                                                 constref sln_pts_cnt        :TColor);        inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure UnselectedPtsCalc0              (constref fst_lst_sln_obj_pts:TEnum0Arr;
                                                 var      pts                :TPtPosFArr;
                                                 constref pvt_pos_curr,
                                                          pvt_pos_prev       :TPtPosF);       inline; {$ifdef Linux}[local];{$endif}
      procedure UnselectedPtsCalc1              (constref fst_lst_sln_obj_pts:TEnum0Arr;
                                                 var      pts                :TPtPosFArr;
                                                 constref pvt_pos_curr,
                                                          pvt_pos_prev       :TPtPosF);       inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SelPtsIndsToFalse1;                                                           inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SelPtsIndsToFalse2;                                                           inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure DuplicatedPtsCalc;                                                            inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure AdvancedClipCalc                (         pts                :TPtPosFArr;
                                                          pts_cnt            :TColor;
                                                          is_pt_marked       :TBool1Arr);     inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure DuplicatedPtsToBmp;                                                           inline; {$ifdef Linux}[local];{$endif}
      {outer subgraph}
      procedure OuterSubgraphCalc0              (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct_clp            :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      procedure OuterSubgraphCalc1              (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct_clp            :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      procedure OuterSubgraphCalc2              (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct_clp            :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      procedure OuterSubgraphDraw               (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct_clp            :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      {inner subgraph}
      procedure InnerSubgraphCalc0              (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct_clp            :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      procedure InnerSubgraphCalc1              (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct_clp            :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      procedure InnerSubgraphCalc2              (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct_clp            :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      procedure InnerSubgraphDraw               (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct_clp            :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      {single point graph}
      procedure SinglePtGraphCalc0              (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct_clp            :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      procedure SinglePtGraphCalc1              (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct_clp            :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      procedure SinglePtGraphCalc2              (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct_clp            :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SelectdPointsCalc               (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct_clp            :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      procedure SelectdPointsDraw               (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct_clp            :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SelectdPointsBnds               (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct_clp            :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure WholeSubgraphDraw0              (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct1,rct2          :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      procedure WholeSubgraphDraw1              (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct1,rct2          :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      procedure WholeSubgraphDraw2              (         x,y                :integer;
                                                 constref pvt                :TPtPosF;
                                                 var      pts                :TPtPosFArr;
                                                 constref bmp_dst_ptr        :PInteger;
                                                 constref rct1,rct2          :TPtRect);       inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SelPvtAndSplineEdsToBmp;                                                      inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SelPtsIndsToBmp                 (var      pts                :TPtPosFArr);    inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PSelIts            =^TSelIts;

  {Pivot--------------}
  TPivot             =class {$region -fold}
    public
      srf_var_ptr          : PSurface;
      {indices inside spritesheet array}
      local_axis_bmp_ind   : integer;
      sel_tls_mrk_ind      : integer;
      {points transform}
      pos_dif              : TPtPosF;
      scl_dif              : TPtPosF;
      rot_dif              : TPtPosF;
      {TODO}
      pvt_pos              : TPtPosF;
      {TODO}
      pvt_scl              : TPtPosF;
      {TODO}
      pvt_origin           : TPtPosF;
      {TODO}
      pvt_draw_sel_eds_on  : TPtPosF;
      {TODO}
      pvt_draw_sel_eds_off : TPtPosF;
      {TODO}
      pvt_mode             : TPivotMode;
      {TODO}
      pvt_marker_arr       : array[0..3] of Graphics.TBitmap;
      {TODO}
      pvt_marker_bmp       : TPortableNetworkGraphic;
      {scale direction}
      scl_dir              : TSclDir;
      prev_mouse_pos       : TPtPosF;
      curr_mouse_pos       : TPtPosF;
      {TODO}
      pvt_marker           : TPtPos;
      {previous pivot}
      pvt_prev             : TPtPosF;
      {mouse motion vector}
      mos_mot_vec          : TLnPos;
      {TODO}
      pvt_axis_rect        : TPtRect;
      {TODO}
      align_pivot          : TPtPos;
      {TODO}
      weighted_pvt_shift   : TPtPos;
      {TODO}
      need_align_pivot_x   : boolean;
      {TODO}
      need_align_pivot_y   : boolean;
      {TODO}
      need_align_pivot_p   : boolean;
      need_align_pivot_p2  : boolean;
      {TODO}
      pvt_marker_draw      : boolean;
      {TODO}
      pvt_marker_left      : boolean;
      {TODO}
      pvt_marker_top       : boolean;
      {TODO}
      pvt_marker_right     : boolean;
      {TODO}
      pvt_marker_bottom    : boolean;
      {TODO}
      pvt_to_pt            : boolean;
      {event of snapping}
      snap_mode            : TSnapMode;
      snap_to_pt           : boolean;
      {TODO}
      pvt_to_pt_draw_pt    : boolean;
      {TODO}
      move_pvt             : boolean;
      {TODO}
      scale_pvt            : boolean;
      {TODO}
      move_pvt_to_pt_button: boolean;
      {TODO}
      SelPtsCalcProc       : array[0..2] of TProc13;
      {TODO}
      SelPtsRctCalcProc    : array[0..2] of TProc12;
      {create class instance}
      constructor Create                  (         w,h:TColor);                            {$ifdef Linux}[local];{$endif}
      {destroy class instance}
      destructor  Destroy;                                                        override; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure LocalAxisCreate;                                                    inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure LocalAxisDraw             (constref x,y:integer);                   inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure LocalAxisHighlight        (constref x,y:integer);                   inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SelectionToolsMarkerCreate;                                         inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SelectionToolsMarkerDraw  (constref x,y:integer);                   inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SetPivotAxisRect          (constref pt_rct           :TPtRect;
                                           constref margin           :TColor=10);   inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure PivotCalc                 (constref pts              :TPtPosFArr;
                                           constref sel_pts_inds     :TColorArr;
                                           constref sel_pts_cnt      :TColor);              {$ifdef Linux}[local];{$endif}
      {align pivot on axis X}
      procedure AlignPivotOnX             (     var x,y              :integer;
                                                    shift            :TShiftState); inline; {$ifdef Linux}[local];{$endif}
      {align pivot on axis Y}
      procedure AlignPivotOnY             (     var x,y              :integer;
                                                    shift            :TShiftState); inline; {$ifdef Linux}[local];{$endif}
      {align pivot on points}
      procedure AlignPivotOnP             (     var x,y              :integer;
                                                    shift            :TShiftState); inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure PivotToPoint              (         x,y              :integer;
                                                    srf_var_         :TSurface;
                                                    sln_var_         :TCurve;
                                                    sel_var_         :TSelIts;
                                                    crc_sel_var_     :TCrcSel);             {$ifdef Linux}[local];{$endif}
      procedure PivotToPoint              (         x,y              :integer;
                                                    b                :boolean;
                                                    srf_var_         :TSurface;
                                                    sln_var_         :TCurve;
                                                    sel_var_         :TSelIts;
                                                    crc_sel_var_     :TCrcSel);             {$ifdef Linux}[local];{$endif}
      procedure PivotToPoint              (         x,y              :integer;
                                                    density          :TColor;
                                                    srf_var_         :TSurface;
                                                    sln_var_         :TCurve;
                                                    sel_var_         :TSelIts;
                                                    crc_sel_var_     :TCrcSel);             {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SclSettings               (         x,y              :integer);     inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SelPtsPosCalc             (         x,y              :integer);     inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SelPtsSclCalc             (         x,y              :integer);     inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SelPtsRotCalc             (         x,y              :integer);     inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SelPtsRctPosCalc          (         x,y              :integer;
                                           var      sel_pts_rect     :TPtRectF);    inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SelPtsRctSclCalc          (         x,y              :integer;
                                           var      sel_pts_rect     :TPtRectF);    inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure SelPtsRctRotCalc          (         x,y              :integer;
                                           var      sel_pts_rect     :TPtRectF);    inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure IsPivotOutOfInnerWindow   (var      custom_rect      :TPtRect;
                                           constref pvt_             :TPtPosF);     inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure PivotToPointDraw          (         cnv_dst          :TCanvas);     inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure PivotAxisDraw0            (         cnv_dst          :TCanvas;
                                           constref custom_rct       :TPtRect;
                                           constref shift            :TPtPos);      inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure PivotAxisDraw1            (         cnv_dst          :TCanvas;
                                           constref custom_rct       :TPtRect;
                                           constref shift            :TPtPos;
                                                    x,y              :integer);     inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure PivotBoundsDraw;                                                    inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure PivotAngleDraw;                                                     inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure PivotModeDraw             (         cnv_dst          :TCanvas);     inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure PivotDraw                 (constref shift            :TPtPos;
                                                    x,y              :integer);     inline; {$ifdef Linux}[local];{$endif}
    end; {$endregion}
  PPivot             =^TPivot;

  {Circle Selection---}
  TCrcSel            =class {$region -fold}
    public
      srf_var_ptr       : PSurface;
      {TODO}
      crc_sel_col       : TColor;
      {TODO}
      crc_sel_rct       : TRect;
      {TODO}
      crc_rad_invalidate: integer;
      {TODO}
      crc_rad           : integer;
      {TODO}
      crc_rad_sqr       : integer;
      {TODO}
      draw_crc_sel      : boolean;
      {TODO}
      resize_crc_sel    : boolean;
      {TODO}
      only_fill         : boolean;
      {create class instance}
      constructor Create;                                                                       {$ifdef Linux}[local];{$endif}
      {destroy class instance}
      destructor  Destroy;                                                            override; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure CircleSelection              (x,y                           :integer;
                                              constref m_c_var              :TSurface;
                                              constref s_c_var              :TSelIts;
                                              constref pts                  :TPtPosFArr;
                                              constref pts_cnt              :TColor;
                                              constref sel_draw             :boolean=True);     {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure CircleSelectionModeDraw      (         x,y                  :integer;
                                              constref m_c_var              :TSurface); inline; {$ifdef Linux}[local];{$endif}
      {TODO}
      procedure ResizeCircleSelectionModeDraw;                                          inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PCrcSel            =^TCrcSel;

  {Brush Selection----}
  TBrsSel            =class {$region -fold}
    public
      srf_var_ptr : PSurface;
      {TODO}
      draw_brs_sel: boolean;
      {create class instance}
      constructor Create;                                        {$ifdef Linux}[local];{$endif}
      {destroy class instance}
      destructor  Destroy;                             override; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PBrsSel            =^TBrsSel;

  {Rectangle Selection}
  TRctSel            =class {$region -fold}
    public
      srf_var_ptr: PSurface;
      {TODO}
      rct_sel    : TRect;
      {TODO}
      rct_width  : integer;
      {create class instance}
      constructor Create;            {$ifdef Linux}[local];{$endif}
      {destroy class instance}
      destructor  Destroy; override; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PRctSel            =^TRctSel;

  {TileMap Editor-----}
  TTlMap             =class {$region -fold}
    public
      {indices inside spritesheet array}
      tilemap_inds_arr       : TIntrArr;
      tilemap_sprite_inds_arr: TIntrArr;
      {create class instance}
      constructor Create;                                                            {$ifdef Linux}[local];{$endif}
      {destroy class instance}
      destructor  Destroy;                                                 override; {$ifdef Linux}[local];{$endif}
      {create default icon for tile map sprite}
      procedure  TileMapSpriteDefaultIconCreate;                             inline; {$ifdef Linux}[local];{$endif}
      {add tile map}
      procedure  AddTileMapObj;                                              inline; {$ifdef Linux}[local];{$endif}
      {add tile map sprite}
      procedure  AddTileMapSpriteObj;                                        inline; {$ifdef Linux}[local];{$endif}
      {add tile map preview}
      procedure  AddTileMapPreview;                                          inline; {$ifdef Linux}[local];{$endif}
      {add tile map sprite preview}
      procedure  AddTileMapSpritePreview;                                    inline; {$ifdef Linux}[local];{$endif}
      {}
      procedure  FilTileMapObj                 (constref tlmap_ind:TColor);  inline; {$ifdef Linux}[local];{$endif}
      {}
      procedure  MovTileMapObj                 (constref tlmap_ind:TColor);  inline; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PTlMap             =^TTlMap;
(******************************************************************************)



(******************************* Global Variables *****************************)
var

  {General}
  F_MainForm                  : TF_MainForm;
  max_sprite_w_h_rct          : TPtRect;
  ini_var                     : TIniFile;
  {inner window margin}
  inn_wnd_mrg                 : integer=01{0}{0};
  splitter_thickness          : integer=04{2}{1};
  status_bar_thickness        : integer=53;
  pp_iters_cnt                : integer=01;
  skip_invalidate             : byte   =00;
  move_with_child_form        : boolean;
  bottom_splitter_to_left     : boolean;
  bottom_splitter_to_right    : boolean;
  bucket_size_change          : boolean;
  align_picture_to_center     : boolean=False;
  full_screen                 : boolean=True;
  game_pause                  : boolean=False;
  splitters_arr               : array[0..7] of PInteger;

  {Show Object---------------------------------} {$region -fold}
  // show objects array
  show_obj_arr                : array[0..9] of boolean;
  // show all objects(visibility list)
  show_all                    : boolean absolute show_obj_arr[00];
  // show texture(visibility list)
  show_tex                    : boolean absolute show_obj_arr[01];
  // show grid(visibility list)
  show_grid                   : boolean absolute show_obj_arr[02];
  // show snap grid(visibility list)
  show_snap_grid              : boolean absolute show_obj_arr[03];
  // show splines(visibility list)
  show_spline                 : boolean absolute show_obj_arr[04];
  // show textures on splines
  show_tex_on_spline          : boolean absolute show_obj_arr[05];
  // show tile maps(visibility list)
  show_tile_map               : boolean absolute show_obj_arr[06];
  // show actors(visibility list)
  show_actor                  : boolean absolute show_obj_arr[07];
  // show colliders(visibility list)
  show_collider               : boolean absolute show_obj_arr[08];
  // show world axis
  show_world_axis             : boolean absolute show_obj_arr[09]; {$endregion}

  {Show Bounding Rectangles--------------------} {$region -fold}
  // show bounding rectangles array
  show_b_rect_arr             : array[0..2] of boolean;
  // show spline points bounding rectangle 1
  show_spline_pts_b_rect_1    : boolean absolute show_b_rect_arr[0]{=True};
  // show spline points bounding rectangle 2
  show_spline_pts_b_rect_2    : boolean absolute show_b_rect_arr[1]{=True};
  // show selected points bounding rectangle
  show_selected_pts_b_rect    : boolean absolute show_b_rect_arr[2]{=True}; {$endregion}

  {Select Tools(checking of speed buttons down)} {$region -fold}
  // down buttons array
  down_arr                       : array[0..10] of boolean;
  // down button "Text"
  down_text_ptr                  : PByteBool;
  // down button "Brush"
  down_brush_ptr                 : PByteBool;
  // down button "Spray"
  down_spray_ptr                 : PByteBool;
  // down button "Spline"
  down_spline_ptr                : PByteBool;
  // down button "Select Items"
  down_select_items_ptr          : PByteBool;
  // down button "Select Texture Region"
  down_select_texture_region_ptr : PByteBool;
  // down button "Regular Grid"
  down_rgrid_ptr                 : PByteBool;
  // down button "Snap Grid"
  down_sgrid_ptr                 : PByteBool;
  // down button "Play"
  down_play_anim_ptr             : PByteBool;
  // down button "Map Editor"
  down_map_editor_ptr            : PByteBool;
  // down button "Add Actor"
  down_add_actor_ptr             : PByteBool;
  {// down button "Text Event"
  down_add_text_event_ptr        : PByteBool;} {$endregion}

  {Calculation Flags---------------------------} {$region -fold}
  // calculation flags array
  calc_arr                    : array[0..100] of boolean;
  // do all layers bounding rectangles need to be calculated:
  main_bmp_rect_calc          : boolean absolute calc_arr[00];
  // do all layers bitmaps sizes need to be calculated?:
  main_bmp_size_calc          : boolean absolute calc_arr[01];
  // do specified arrays sizes need to be calculated(probably with calculation of appropriate bitmaps sizes):
  main_bmp_arrs_calc          : boolean absolute calc_arr[02];
  // get handles of all main buffers:
  main_bmp_hndl_calc          : boolean absolute calc_arr[03];
  // resize form:
  form_resize_calc            : boolean absolute calc_arr[04];
  // is canvas changed:
  change_canvas_calc          : boolean absolute calc_arr[05];
  // background post-processing:
  bkg_pp_calc                 : boolean absolute calc_arr[06];
  // is cursor in inner window:
  drawing_area_enter_calc     : boolean absolute calc_arr[07];
  // does grid need to be calculated:
  grid_calc                   : boolean absolute calc_arr[08];
  // does snap grid need to be calculated:
  snap_grid_calc              : boolean absolute calc_arr[09];
  // calculate snap grid precision:
  snap_grid_pr_calc           : boolean absolute calc_arr[10];
  // is snap grid precision changed:
  snap_grid_precision_calc    : boolean absolute calc_arr[11];
  // add spline:
  add_spline_calc             : boolean absolute calc_arr[12];
  // is spline simplification angle changed:
  spline_smpl_angle_calc      : boolean absolute calc_arr[13];
  // connect ends of spline:
  connect_ends_calc           : boolean absolute calc_arr[14];
  // anti-aliasing:
  spline_aa_calc              : boolean absolute calc_arr[15];
  // ...:
  //sel_tls_mrk_set_bckgd       : boolean absolute calc_arr[16];
  // reset background settings for actors:
  actor_set_bckgd             : boolean absolute calc_arr[17];
  // repaint all splines:
  repaint_spline_calc         : boolean absolute calc_arr[18];
  // scale all splines:
  spline_scale_calc           : boolean absolute calc_arr[19];
  // draw selected edges:
  sel_eds_draw_calc           : boolean absolute calc_arr[20];
  // reset background settings for timeline buttons:
  //timeline_set_bkgnd          : boolean absolute calc_arr[21];
  // reset background settings for timeline buttons:
  //cursors_set_bkgnd           : boolean absolute calc_arr[22];
  // timeline drawing:
  timeline_draw               : boolean absolute calc_arr[23];
  // cursor drawing:
  cursor_draw                 : boolean absolute calc_arr[24];
  // does pivot need to be unselected:
  unselect_pivot_calc         : boolean absolute calc_arr[27];
  // is spliter position changed:
  splitter_pos_moved_calc     : boolean absolute calc_arr[28];
  // scale background:
  bckgd_scale_calc            : boolean absolute calc_arr[29];
  // scene drawing:
  fill_scene_calc             : boolean absolute calc_arr[30];
  // align points:
  align_pts_calc              : boolean absolute calc_arr[31];
  // calculate bounding rectangles:
  rectangles_calc             : boolean absolute calc_arr[32];
  // add spline               : hidden lines:
  add_hid_ln_calc             : boolean absolute calc_arr[33];
  // repaint all splines: hidden lines:
  repaint_spline_hid_ln_calc0 : boolean absolute calc_arr[34];
  repaint_spline_hid_ln_calc1 : boolean absolute calc_arr[35];
  repaint_spline_hid_ln_calc2 : boolean absolute calc_arr[36];
  // reset background settings for world axis:
  sprite_sheet_set_bckgd      : boolean absolute calc_arr[37];
  // lazy repaint:
  lazy_repaint_calc           : boolean absolute calc_arr[38];
  // add tile map:
  add_tlmap_calc              : boolean absolute calc_arr[39];
  // ...:
  has_edge_calc               : boolean absolute calc_arr[40];
  // ...:
  copy1_calc                  : boolean absolute calc_arr[41];
  // ...:
  copy2_calc                  : boolean absolute calc_arr[42];
  // ...:
  copy3_calc                  : boolean absolute calc_arr[43];
  // ...:
  copy4_calc                  : boolean absolute calc_arr[44];
  // ...:
  copy5_calc                  : boolean absolute calc_arr[45];
  // ...:
  copy6_calc                  : boolean absolute calc_arr[46];
  // ...:
  copy7_calc                  : boolean absolute calc_arr[47];
  // ...:
  copy8_calc                  : boolean absolute calc_arr[48];
  // reset background settings for local axis:
  //local_axis_set_bckgd        : boolean absolute calc_arr[49];
  // reset background settings for tile map sprite:
  //tlm_sprite_set_bckgd        : boolean absolute calc_arr[50];
  {$endregion}

  {Miscellaneous Expressions-------------------} {$region -fold}
  // expressions array
  exp_arr                     : array[0..2] of boolean;
  // selected_pts_count>0
  exp0                        : boolean absolute exp_arr[0];
  // selected_pts_count<>spline_pts_count
  exp1                        : boolean absolute exp_arr[1];
  // spline_pts_count>0
  exp2                        : boolean absolute exp_arr[2]; {$endregion}

  {Visibility Panel}
  visibility_panel_picture    : Graphics.TBitmap;
  show_visibility_panel       : boolean=True;
  show_obj_info               : boolean=True;

  {Buttons:Draw-} {$region -fold}
  P_Drawing_Buttons_ClickArr  : array of TNotifyEvent;
  P_Animation_Buttons_ClickArr: array of TNotifyEvent;
  prev_panel_draw             : TPanel;
  curr_panel_draw             : TPanel; {$endregion}

  {Buttons:AnimK} {$region -fold}
  prev_panel_animk            : TPanel;
  curr_panel_animk            : TPanel; {$endregion}

  {Camera}
  cmr_var                     : TCamera;

  {Sprite Sheet}
  sprite_sheet_arr            : TFastImageItemArr;

  {Main Layer}
  srf_var                     : TSurface;

  {Background Texture(single instance, not tiled)}
  tex_var                     : TTex;

  {Regular Grid}
  rgr_var                     : TRGrid;

  {Snap Grid}
  sgr_var                     : TSGrid;

  {Spline}
  sln_var                     : TCurve;

  {Text}
  txt_var                     : TFText;

  {UV}
  uv_var                      : TUV;

  {Intersection Graph}
  isg_var                     : TISGraph;

  {Selected Points}
  sel_var                     : TSelIts;

  {Pivot}
  pvt_var                     : TPivot;

  {Circle Selection}
  crc_sel_var                 : TCrcSel;

  {Brush Selection}
  brs_sel_var                 : TBrsSel;

  {Rectangle Selection}
  rct_sel_var                 : TRctSel;

  {Map Editor}
  tlm_var                     : TTlMap;

  {Actors}
  fast_actor_set_var          : TFastActorSet;
  img_lst_bmp                 : Graphics.TBitmap;
  img_lst_bmp_ptr             : PInteger;

  {Physics}
  fast_physics_var            : TCollider;

  {Fluid}
  fast_fluid_var              : TFluid;

  {Scene Tree}
  obj_var                     : TSceneTree;
  single_selected_node_ind    : integer;
  source_node_x,source_node_y : integer;
  is_mouse_in_scene_tree      : boolean;
  scene_tree_mouse_down       : boolean;
  is_scene_tree_editing       : boolean;
  prev_key                    : char='_';

  {Color Picker}
  pixel_color                 : TColor;

  {Brush}
  custom_icon                 : TPortableNetworkGraphic;
  PrevX,PrevY                 : integer;
  draw_brush                  : boolean;

  {Spray}
  draw_spray                  : boolean;

  sc0,sc1                     : TPtPos;

  ncs_adv_clip_rect           : TPtRectF;

  mouse_pos_x,mouse_pos_y     : integer;
  treeview_splitter_shift     : integer;

  P_TreeView_Attributes_Cells : TPanel;

  {Execution Time}
  exec_timer                  : TPerformanceTime;

  test_picture_color          : Graphics.TPicture;
  test_picture_alpha          : Graphics.TPicture;

  vec_x,vec_y                 : integer;

  sln_sprite_counter_pos_arr  : TColorArr;
  sln_sprite_counter_rad_arr  : TColorArr;
  sln_sprite_counter_pow_arr  : TColorArr;

  sprite_rect_arr             : TPtPosArr;
  useless_arr_                : T1Byte1Arr;
  useless_fld_arr_            : TColorArr;

  anim_play2                  : boolean;

  is_active                   : boolean=True;

  downtime_counter            : integer;
  downtime                    : integer=320;

  {TimeLine}
  // cursors:
  cursors_inds_arr            : TIntrArr;
  // buttons_background:
  bckgd_btn_inds_arr          : TIntrArr;
  // buttons icons:
  tmln_btn_inds_arr           : TIntrArr;
  // buttons positions:
  btn_pos_arr                 : TPtPosArr;

  {Cursors}
  cur_pos                     : TPoint;

  {OpenGL Context}
  texture_id                  : TColor;
  buffer                      : Windows.BITMAP;

  {Physics Test}
  coll_arr                    : TColorArr;
  projectile_var              : TProjectile;
  projectile_arr              : array of TProjectile;

  {Test}
  arr_test_byte               : T1Byte1Arr;
  angle                       : double=0;
  flood_fill_inc              : boolean;
  drs                         : byte;

  loop_cnt,angle_cnt          : TColor;
  rot_img_arr                 : TFastImageItemArr;
  bounding_rct                : TPtRect;
  arr_test                    : TColorArr;

  frame_skip                  : byte;
  frame_step                  : byte=1;

  cmr_var_parallax_shift      : TPtPosF=(x:16; y:16);

  {
    Nearest TODO:
      - Optimization:
        1. get rid of double, triple or quadruple addressing; (priority: medium; complexity: easy);
        2. ...;
      - UI:
        1. implementation of object tags; (priority: high; complexity: middling);
        2. ...;
      - Splines:
        1. static contour anti-aliasing for sparse sprites in compressed sparse row format; (priority: low; complexity: hard);
        2. implementation of drawing for lines of any width greater than 3; (priority: low; complexity: very hard);
        3. Bezier splines; (priority: high; complexity: middling);
  }

(******************************************************************************)



{Forward Declarations}(********************************************************)

{Miscellaneous Routines} {$region -fold}
procedure SpeedButtonRepaint; inline; {$ifdef Linux}[local];{$endif}
procedure BtnColAndDown(constref spd_btn:TSpeedButton; var down_flag:boolean; color_down:TColor=NAV_SEL_COL_0; color_up:TColor=$00CBDAB1); inline; {$ifdef Linux}[local];{$endif}
procedure SelectionBounds(custom_bitmap:Graphics.TBitmap; custom_rect:TPtRect; custom_color:TColor; custom_width:integer);
procedure SelectionBoundsRepaint; inline; {$ifdef Linux}[local];{$endif}
procedure IsObjColorAMaskColor; inline; {$ifdef Linux}[local];{$endif}
function  DwmIsCompositionEnabled(out pfEnabled:longbool): HRESULT; external 'Dwmapi.dll';
function  EnumDisplaySettingsA(lpszDeviceName:LPCSTR; iModeNum:DWORD; var lpDevMode:TDeviceModeA): BOOL; external 'user32';
procedure InvalidateInnerWindow; inline; {$ifdef Linux}[local];{$endif}
procedure InvalidateRegion(rct_dst:TRect); inline; {$ifdef Linux}[local];{$endif}
procedure MoveBorders; inline; {$ifdef Linux}[local];{$endif}
procedure Align3DViewer; inline; {$ifdef Linux}[local];{$endif}
function  ObjectInfo0: string; inline; {$ifdef Linux}[local];{$endif}
procedure CheckDIB; inline; {$ifdef Linux}[local];{$endif}
{$endregion}

{Scene Tree------------} {$region -fold}
// calculate objects indices in object array:
procedure ObjIndsCalc;                                                inline; {$ifdef Linux}[local];{$endif}
// calculate objects indices in scene tree:
procedure ScTIndsCalc;                                                inline; {$ifdef Linux}[local];{$endif}
// change panels visibility after folding/unfolding or draging items in scene tree :
procedure CngPnVsCalc;                                                inline; {$ifdef Linux}[local];{$endif}
// select panels after selection in scene tree :
procedure SelPnlsCalc;                                                inline; {$ifdef Linux}[local];{$endif}
// unselect panels after clearing selection in scene tree :
procedure UnsPnlsCalc;                                                inline; {$ifdef Linux}[local];{$endif}
// calculate selected objects indices in scene tree:
procedure SelIndsCalc;                                                inline; {$ifdef Linux}[local];{$endif}
// recalculate positions of selected objects:
procedure SelObjsPosRecalc0;                                          inline; {$ifdef Linux}[local];{$endif}
procedure SelObjsPosRecalc1;                                          inline; {$ifdef Linux}[local];{$endif}
// (Check Equality Of All Objects By Kind                ) Проверка на равенство всех обьектов по виду:
function  AreAllObjKindEqual: TKindOfObject;                          inline; {$ifdef Linux}[local];{$endif}
// (Check Equality Of All Objects By Parallax Shift      ) Проверка на равенство всех обьектов по параллаксу:
function  AreAllObjPrlxEqual: TPtPosF;                                inline; {$ifdef Linux}[local];{$endif}
// (Check Equality Of All Objects By Visibility          ) Проверка на равенство всех обьектов по видимости:
function  AreAllObjShowEqual: byte;                                   inline; {$ifdef Linux}[local];{$endif}
// (Check Equality Of All Objects By Recalculate Position) Проверка на равенство всех обьектов по пересчету позиций:
function  AreAllObjRPosEqual: boolean;                                inline; {$ifdef Linux}[local];{$endif}
// (Check Equality Of All Objects By Properties          ) Проверка на равенство всех обьектов по свойствам:
procedure AreAllObjPropEqual;                                         inline; {$ifdef Linux}[local];{$endif}
//
procedure ParallaxShiftChange;                                        inline; {$ifdef Linux}[local];{$endif}
//
procedure RecalcPosChange;                                            inline; {$ifdef Linux}[local];{$endif}
//
procedure ObjectShowChange;                                           inline; {$ifdef Linux}[local];{$endif}
//
procedure CrtNodeData        (         node_with_data:TTreeNode;
                                       g_ind         :TColor);        inline; {$ifdef Linux}[local];{$endif}
//
procedure WrtNodeData        (         data_start_ptr:PPtPosF;
                                       data_write    :TPtPosF;
                                       size_of_data  :integer);       inline; {$ifdef Linux}[local];{$endif}
//
procedure WrtNodeData        (         data_start_ptr:PByte;
                                       data_write    :byte;
                                       size_of_data  :integer);       inline; {$ifdef Linux}[local];{$endif}
//
procedure WrtNodeData        (         data_start_ptr:PBoolean;
                                       data_write    :boolean;
                                       size_of_data  :integer);       inline; {$ifdef Linux}[local];{$endif}
//
procedure ClrNodeData        (         node_with_data:TTreeNode);     inline; {$ifdef Linux}[local];{$endif}
//
procedure DeleteSelectedNodes(         TV            :TTreeView);     inline; {$ifdef Linux}[local];{$endif}
//
procedure AddTagPanel        (constref ind           :integer);       inline; {$ifdef Linux}[local];{$endif}
//
procedure CreateNode         (         item_text1,
                                       item_text2    :ansistring;
                                       is_first_node :boolean=False); inline; {$ifdef Linux}[local];{$endif}
{$endregion}

{Brush-----------------} {$region -fold}
procedure BrushDraw(X,Y:integer); inline; {$ifdef Linux}[local];{$endif}
{$endregion}

{Spray-----------------} {$region -fold}
procedure SprayDraw(X,Y,r:integer; custom_color:TColor); inline; {$ifdef Linux}[local];{$endif}
{$endregion}

{TimeLine--------------} {$region -fold}
procedure TimeLineButtonsCreate;                     inline; {$ifdef Linux}[local];{$endif}
procedure TimeLineButtonsDraw(constref x,y:integer); inline; {$ifdef Linux}[local];{$endif}
{$endregion}

{Cursors---------------} {$region -fold}
procedure CursorsCreate;                                                inline; {$ifdef Linux}[local];{$endif}
procedure CursorDraw(constref x,y:integer; constref cur_ind:integer=0); inline; {$ifdef Linux}[local];{$endif}
procedure CursorDraw;                                                   inline; {$ifdef Linux}[local];{$endif}
{$endregion}

(******************************************************************************)



implementation

uses
  {model_viewer,}Hot_Keys;

{$R *.lfm}

{LI = Logic Interface;
 UI = User  Interface.}

// (Miscellaneous Routines) Разные процедуры:
{LI} {$region -fold}
{$endregion}

// (Object Info) Информация об обьекте:
{LI} {$region -fold}
function  ObjectInfo0: string;                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  info_arr  : array[0..19] of string;
  i         : integer;
  hid_ln_cnt: integer;
begin

  Result    :='';
  hid_ln_cnt:=0;
  if (sln_var<>Nil) then
    for i:=0 to sln_var.sln_obj_cnt-1 do
      Inc(hid_ln_cnt,sln_var.eds_img_arr[i].hid_ln_cnt);

  if (obj_var<>Nil) then
    info_arr[00]:='Objects: '                                                             +InttoStr(obj_var.obj_cnt-1             )+';';
  info_arr[01]:=#13+'Objects of lower layer: '                                            +IntToStr(obj_var.low_lr_obj_cnt-1      )+';';
  info_arr[02]:=#13+'Objects of upper layer: '                                            +IntToStr(obj_var.upp_lr_obj_cnt        )+';';
  info_arr[03]:=#13+'Groups: '                                                            +IntToStr(obj_var.group_cnt             )+';';
  info_arr[04]:=#13+'Actors: '                                                            +IntToStr(obj_var.actor_cnt             )+';';
  info_arr[05]:=#13+'  • Static: 0'                                                                                                +';';
  info_arr[06]:=#13+'  • Dynamic: 0'                                                                                               +';';
  info_arr[07]:=#13+'  • Physical: 0'                                                                                              +';';
  info_arr[08]:=#13+'Particles: '                                                         +IntToStr(obj_var.prtcl_cnt             )+';';
  info_arr[09]:=#13+'Splines: '                                                           +IntToStr(obj_var.curve_cnt             )+';';
  if (sln_var<>Nil) then
    info_arr[10]:=#13+'  • Points: '                                                      +InttoStr(sln_var.sln_pts_cnt           )+';';
  if (sel_var<>Nil) then
    begin
      info_arr[11]:=#13+'    • Count of splines'+#13+'      with selected points: '       +InttoStr(sel_var.sln_with_sel_pts_cnt  )+';';
      info_arr[12]:=#13+'    • Minimal index of curve'+#13+'      with selected points: ' +InttoStr(sel_var.sel_obj_min_ind       )+';';
      info_arr[13]:=#13+'    • Selected: '                                                +InttoStr(sel_var.sel_pts_cnt           )+';';
      if (sel_var.sel_pts_cnt=0) then
        info_arr[14]:=#13+'      • Is not abstract object'+#13+'        kind after: No;'
      else
        begin
          if sel_var.is_not_abst_obj_kind_after then
            info_arr[14]:=#13+'      • Is not abstract object'+#13+'        kind after: '    +'Yes;'
          else
            info_arr[14]:=#13+'      • Is not abstract object'+#13+'        kind after: '    +'No;'
        end;
      info_arr[15]:=#13+'    • Duplicated: '                                              +InttoStr(sel_var.dup_pts_cnt           )+';';
    end;
  if (sln_var<>Nil) then
    begin
      info_arr[16]:=#13+'  • Lines: '                                                     +InttoStr(sln_var.sln_eds_cnt           )+';';
      info_arr[17]:=#13+'    • Visible: '                                                 +InttoStr(sln_var.sln_eds_cnt-hid_ln_cnt)+';';
      info_arr[18]:=#13+'    • Hidden: '                                                  +InttoStr(hid_ln_cnt                    )+';';
    end;
  info_arr[19]:=#13+'Tile maps: '                                                         +IntToStr(obj_var.tlmap_cnt             )+';';

  for i:=0 to 19 do
    Result+=info_arr[i];

end; {$endregion}
procedure DrawObjectInfo0;                                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  F_MainForm.L_Object_Info.Caption:=ObjectInfo0;
end; {$endregion}
procedure DrawObjectInfo1(constref x,y:integer; bmp_dst:Graphics.TBitmap; constref text_:string); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  F_MainForm.L_Exec_Time_Info.Caption:=text_;
end; {$endregion}
procedure CheckDIB;                                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  h_d_c: HDC;}
begin
  {h_d_c:=F_MainForm.Canvas.Handle;}
  {F_MainForm.L_Log.Caption:=IntToStr(GetDeviceCaps(h_d_c,RC_STRETCHBLT));}
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.MI_Object_InfoClick(sender:TObject); {$region -fold}
begin
  L_Object_Info.Visible:=MI_Object_Info.Checked;
  show_obj_info        :=MI_Object_Info.Checked;
end; {$endregion}
{$endregion}

// (Documentation) Документация:
{LI} {$region -fold}
procedure AddDocContent(var rich_memo:TRichMemo; str_arr:TStringArr; font_arr:TFontArr; char_pos_start:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i  : integer;
  str: string;
begin
  with rich_memo do
    begin
      if (Length(str_arr)=1) then
        begin
          Lines.Add(str_arr[0]);
          SetTextAttributes(char_pos_start,Length(str_arr[0])+char_pos_start,font_arr[0]);
        end
      else
        begin
          str:='';
          for i:=0 to Length(str_arr)-1 do
            str+=str_arr[i];
          Lines.Add(str);
          SetTextAttributes(char_pos_start,Length(str_arr[0])+char_pos_start,font_arr[0]);
          for i:=1 to Length(str_arr)-1 do
            SetTextAttributes(Length(str_arr[i-1]){+1}+char_pos_start,Length(str_arr[i])+char_pos_start,font_arr[i]);
        end;
    end;
end; {$endregion}
{$endregion}

// (Tray Icon) Системный трей:
{UI} {$region -fold}
procedure TF_MainForm.TrayIcon1Click(sender:TObject); {$region -fold}
begin
  ShowOnTop;
end; {$endregion}
{$endregion}

// (Open) Импорт файла:
{UI} {$region -fold}
procedure TF_MainForm.MI_OpenClick(sender:TObject); {$region -fold}
{var
  node_first: TTreeNode;
  execution_time: double;
  fcs_cnt,    {количество UV-островов, символов 'f' в импортируемом файле}
  eds_cnt,    {количество ребер, символов '/' в импортируемом файле}
  vts_cnt,    {количество вершин, символов 'v' в импортируемом файле}
  tex_vts_cnt,{количество текстурных вершин, строк 'vt' в импортируемом файле}
  i,j,k,m1,m2,m3,m4: integer;
  file_import: text;
  file_path,file_line,s: string;}
begin
  {begin
    k                       :=-1;
    fcs_cnt                 :=0;
    vts_cnt                 :=0;
    tex_vts_cnt             :=0;
    PB_ProgressBar1.Position:=0;
    SetLength(uv_var.uv_pts,1000000);
  end;
  OpenDialog1.Options:=OpenDialog1.Options+[ofFileMustExist];
  if (not OpenDialog1.Execute) then
    Exit;
  file_path:=OpenDialog1.Filename;
  Text:='MorphoEngine'+'('+file_path+')';
  exec_timer:=TPerformanceTime.Create;
  exec_timer.Start;
  AssignFile(file_import,file_path);
  Reset(file_import);

  while (not EOF(file_import)) do
    begin
      readln(file_import,file_line);
      for i:=0 to length(file_line)-1 do
        case file_line[i+1] of
          #32:
            case file_line[i] of
              'v': Inc(vts_cnt);
              'f': Inc(fcs_cnt);
            end;
          't':
            begin
              Inc(k);
              Inc(tex_vts_cnt);
              if file_line[i]='v' then
                begin
                  j:=i+2;
                  s:='';
                  while (not (file_line[j+1]=#32)) do
                    begin
                      Inc(j);
                      if file_line[j]='-' then
                        file_line[j]:='0';
                      if file_line[j]='.' then
                        file_line[j]:=',';
                      s:=s+file_line[j];
                      uv_var.uv_pts[k].x:=StrToFloat(s);
                    end;
                  Inc(j);
                  s:='';
                  while (not (file_line[j+1]=#32)) do
                    begin
                      Inc(j);
                      if file_line[j]='-' then
                        file_line[j]:='0';
                      if file_line[j]='.' then
                        file_line[j]:=',';
                      s:=s+file_line[j];
                      uv_var.uv_pts[k].y:=StrToFloat(s);
                    end;
                end;
            end;
        end;
    end;

  Repaint;
  with srf_var.srf_bmp.Canvas,srf_var,tex_var,uv_var do
    begin
      m1:=Trunc(tex_bmp_rct_pts[0].x)-2;
      m2:=Trunc(tex_bmp_rct_pts[0].y)-2;
      m3:=Trunc(tex_bmp_rct_pts[0].x)+3;
      m4:=Trunc(tex_bmp_rct_pts[0].y)+3;
      Pen.Color:=clBlack;
      Brush.Style:=bsClear;
      for i:=2 to tex_vts_cnt-1 do
        Rectangle(Trunc((tex_bmp_rct_pts[1].x-tex_bmp_rct_pts[0].x)*   uv_pts[i].x) +m1,
                  Trunc((tex_bmp_rct_pts[1].y-tex_bmp_rct_pts[0].y)*(1-uv_pts[i].y))+m2,
                  Trunc((tex_bmp_rct_pts[1].x-tex_bmp_rct_pts[0].x)*   uv_pts[i].x) +m3,
                  Trunc((tex_bmp_rct_pts[1].y-tex_bmp_rct_pts[0].y)*(1-uv_pts[i].y))+m4);
      Brush.Style:=bsSolid;
    end;
  InvalidateInnerWindow;

  eds_cnt:=vts_cnt; // TODO
  exec_timer.Stop;
  execution_time:=Trunc(exec_timer.Delay*1000)/1000;
  PB_ProgressBar1.Position:=100;
  L_Object_Info.Caption:=ObjectInfo0;
  node_first:=TV_Scene_Tree.Items.GetFirstVisibleNode;
  TV_Scene_Tree.Items.AddChild(node_first,ExtractFileName(OpenDialog1.Filename));
  node_first.Expanded:=true;
  {M_Loaded_File.Lines.LoadfromFile(OpenDialog1.Filename);}
  CloseFile(file_import);}
end; {$endregion}
{$endregion}

// (Save as) Сохранение файла:
{UI} {$region -fold}
procedure TF_MainForm.MI_Save_AsClick(sender:TObject); {$region -fold}
begin
  {TODO}
  {SaveDialog1.Filter:='Wavefront Obj|*.obj|Text|*.txt|All files|*.*';
  if (not SaveDialog1.Execute) then
    Exit;}
end; {$endregion}
{$endregion}

// (Exit) Выход из программы:
{UI} {$region -fold}
procedure TF_MainForm.MI_ExitClick(sender:TObject); {$region -fold}
begin
  Close;
end; {$endregion}
{$endregion}

// (3D Viewer) Трехмерный просмотр:
{UI} {$region -fold}
procedure TF_MainForm.MI_3D_ViewerClick(sender:TObject); {$region -fold}
begin
  {if MI_3D_Viewer.Checked then
    begin
      F_3D_Viewer.OpenGLControl1.Enabled  :=True;
      F_3D_Viewer.T_3DViewer_Timer.Enabled:=True;
      F_3D_Viewer.Show;
      F_3D_Viewer.BorderStyle:=TFormBorderStyle.bsNone;
      Align3DViewer;
    end
  else
    begin
      F_3D_Viewer.OpenGLControl1.Enabled  :=False;
      F_3D_Viewer.T_3DViewer_Timer.Enabled:=False;
      F_3D_Viewer.Hide;
    end;}
end; {$endregion}
{$endregion}

// (Full Screen) Полный экран:
{UI} {$region -fold}
procedure TF_MainForm.MI_Full_ScreenClick(sender:TObject); {$region -fold}
begin
  //S_Splitter1.Left:=269;
  S_Splitter4.Top :=176;
  case MI_Full_Screen.Checked of
    True :
      begin
        full_screen   :=True;
        BorderStyle   :=TFormBorderStyle.bsNone;
        S_Splitter0.Top :={491}P_UV_Operations.Top   +
                             P_UV_Operations.Height+20;
        S_Splitter2.Top :=558;
        S_Splitter3.Left:=835;
      end;
    False:
      begin
        full_screen   :=False;
        BorderStyle   :=bsSizeable;
        WindowState   :=wsFullScreen;
        CCB_2D_Operations_Automatic.Top:=250;
        S_Splitter0.Top :={491}P_UV_Operations.Top   +
                             P_UV_Operations.Height+20;
        S_Splitter2.Top :=536;
        S_Splitter3.Left:=835;
      end;
  end;
  srf_var.EventGroupsCalc(calc_arr,[0,1,2,3,4,6,8,9,17,18,20,28,30,31,32]);
end; {$endregion}
{$endregion}

// (Trancparency) Прозрачность:
{UI} {$region -fold}
procedure TF_MainForm.MI_TrancparencyClick(sender:TObject); {$region -fold}
begin
end; {$endregion}
{$endregion}

// (Hot Keys) Клавиатурная раскладка:
{UI} {$region -fold}
procedure TF_MainForm.MI_Hot_KeysClick(sender:TObject); {$region -fold}
begin
  if MI_Hot_Keys.Checked then
    F_Hot_Keys.Show
  else
    F_Hot_Keys.Hide;
end; {$endregion}
{$endregion}

// (SystemInfo) Системная информация:
{UI} {$region -fold}
procedure TF_MainForm.MI_System_InfoClick(sender:TObject); {$region -fold}
var
  size: longword;
  buffer: array[0..255] of char='';
  user_name,computer_name,info: string;
  {$ifdef Windows}
  flags: Windows.DWORD; // flags to pass to API function
  {$endif}
begin
  size:=256;
  {$ifdef Windows}
  flags:=0;
  GetUserName(buffer,size);
  user_name:=buffer;
  size:=MAX_COMPUTERNAME_LENGTH+1;
  GetComputerName(buffer,size);
  computer_name:=buffer;
  {$endif}
  info:='Date..................................' +{$i %DATE%}
   +#13+'System Bit........................'     +{$i %FPCTARGET%}
   +#13+'CPU...................................' +{$i %FPCTARGETCPU%}
   +#13+'CPU Count.......................'       +IntToStr(CPUCount)
   +#13+'OS.....................................'+{$i %FPCTARGETOS%}
   +#13+'FPC Version.....................'       +{$i %FPCVERSION%}
   {$ifdef Windows}
   +#13+'User Name......................'        +user_name
   +#13+'Computer Name............'              +computer_name
   {$endif}
   +#13+'Internet............................';
  {$ifdef Windows}
  if (WinInet.InternetGetConnectedState(@flags,0)) then
  {$else}
  if GetSystemMetrics(SM_NETWORK) and ($01=$01) then
  {$endif}
    info:=info+'Available'
  else
    info:=info+'Unavailable';
  MessageDlg(info,mtInformation,[mbOK],0);
end; {$endregion}
{$endregion}

// (Set Value, U)(Move) Установить значение по U:
{UI} {$region -fold}
procedure TF_MainForm.BB_Set_Value_UClick     (sender:TObject); {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.BB_Set_Value_UMouseLeave(sender:TObject); {$region -fold}

  procedure UnselectedPtsCalc2(var pts:array of TPtPosF); {$region -fold}
  var
    i: integer;
  begin
    with sel_var do
      for i:=0 to sel_pts_cnt-1 do
        pts[sel_pts_inds[i]].x:=pts[sel_pts_inds[i]].x+(pvt_var.pvt_pos.x-pvt_var.pvt_origin.x)*FSE_Coord_U.Value*10;
  end; {$endregion}

begin
  if (sel_var.sel_pts_cnt>0) then
    UnselectedPtsCalc2(sln_var.sln_pts);
  {main_canvas_var.MainBmpPrepareDraw;}
end; {$endregion}
{$endregion}

// (Reset Value, U)(Move) Восстановить значение по U:
{UI} {$region -fold}
procedure TF_MainForm.BB_Reset_Value_UClick(sender:TObject); {$region -fold}
begin
  FSE_Coord_U.Value:=0;
end; {$endregion}
{$endregion}

// (Set Value, V)(Move) Установить значение по V:
{UI} {$region -fold}
procedure TF_MainForm.BB_Set_Value_VClick(sender:TObject); {$region -fold}
var
  check_border_v,i: integer;
begin
  with sln_var,sel_var do
    for i:=0 to sel_pts_cnt-1 do
      begin
        check_border_v:=Trunc(sln_pts[sel_pts_inds[i]].y-F_MainForm.Height*FSE_Coord_V.Value);
        if ((check_border_v>0) and (check_border_v<F_MainForm.Height)) then
          sln_pts[sel_pts_inds[i]].y:=check_border_v
        else
        if (check_border_v<0) then
          sln_pts[sel_pts_inds[i]].x:=0
        else
        if (check_border_v>F_MainForm.Width) then
          sln_pts[sel_pts_inds[i]].x:=F_MainForm.Width-1;
      end;
  InvalidateInnerWindow;
end; {$endregion}
{$endregion}

// (Reset Value, V)(Move) Восстановить значение по V:
{UI} {$region -fold}
procedure TF_MainForm.BB_Reset_Value_VClick(sender:TObject); {$region -fold}
begin
  FSE_Coord_V.value:=0;
end; {$endregion}
{$endregion}

// (Set All Values) Установить все значения:
{UI} {$region -fold}
procedure TF_MainForm.BB_Set_All_ValuesClick(sender:TObject); {$region -fold}
begin
  BB_Set_Value_UClick(FSE_Coord_U);
  BB_Set_Value_VClick(FSE_Coord_V);
end; {$endregion}
{$endregion}

// (Reset All Values) Восстановить все значения:
{UI} {$region -fold}
procedure TF_MainForm.BB_Reset_All_ValuesClick(sender:TObject); {$region -fold}
var
  i: integer;
begin
  for i:=0 to ComponentCount-1 do
    if (Components[i] is TFloatSpinEdit) then
      if byte(Components[i].tag) in [4,9,16,25,36] then
        TFloatSpinEdit(Components[i]).value:=0;
  FSE_Width.value :=1;
  FSE_Height.value:=1;
end; {$endregion}
{$endregion}

// (Move Pivot To Point) Переместить локальную ось в точку:
{UI} {$region -fold}
procedure TF_MainForm.SB_Move_Pivot_To_PointClick(sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Move_Pivot_To_Point,pvt_var.move_pvt_to_pt_button);
end; {$endregion}
{$endregion}

// (Reset Pivot) Восстановить локальную ось:
{UI} {$region -fold}
procedure TF_MainForm.BB_Reset_PivotClick(sender:TObject); {$region -fold}
begin
  with sln_var,sel_var do
    if (sel_pts_cnt>0) then
      begin
        pvt_var.PivotCalc(sln_pts,sel_pts_inds,sel_pts_cnt);
        InvalidateInnerWindow;
      end;
end; {$endregion}
{$endregion}

// (Save UV) Сохранить актуальную развертку:
{LI} {$region -fold}
procedure TSavedUpPts.SavePts(const target_pts_arr:TPtPosFArr; const target_pts_cnt:TColor; var saved_up_pts_arr:TPtPosFArr; var saved_up_pts_arr_cnt:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  saved_up_pts_arr_ptr:^TPtPosF;
  target_pts_arr_ptr  :^TPtPosF;
  i                   : integer;
begin
  saved_up_pts_arr:=Nil;
  SetLength(saved_up_pts_arr,target_pts_cnt);
  saved_up_pts_arr_ptr:=@saved_up_pts_arr[0];
  target_pts_arr_ptr  :=@target_pts_arr  [0];
  for i:=0 to target_pts_cnt-1 do
    begin
      saved_up_pts_arr_ptr^:=target_pts_arr_ptr^;
      Inc(saved_up_pts_arr_ptr);
      Inc(target_pts_arr_ptr);
    end;
  saved_up_pts_arr_cnt:=target_pts_cnt;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.BB_Save_UVClick(sender:TObject);                                                                                                                                                {$region -fold}
begin
  with sln_var do
    sln_saved_up_pts_var.SavePts(sln_pts,
                                 sln_pts_cnt,
                                 sln_saved_up_pts_var.saved_up_pts,
                                 sln_saved_up_pts_var.saved_up_pts_cnt);
end; {$endregion}
{$endregion}

// (Reset UV) Вернуть сохраненную развертку:
{LI} {$region -fold}
procedure TSavedUpPts.ResetPts(var target_pts_arr:TPtPosFArr; const saved_up_pts_arr:TPtPosFArr; const saved_up_pts_arr_cnt:TColor; proc_ptr:TProc0); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  saved_up_pts_arr_ptr:^TPtPosF;
  target_pts_arr_ptr  :^TPtPosF;
  i                   : integer;
begin
  saved_up_pts_arr_ptr:=@saved_up_pts_arr[0];
  target_pts_arr_ptr  :=@target_pts_arr  [0];
  for i:=0 to saved_up_pts_arr_cnt-1 do
    begin
      if (saved_up_pts_arr_ptr^.x<>0) and
         (saved_up_pts_arr_ptr^.y<>0) then
        target_pts_arr_ptr^:=saved_up_pts_arr_ptr^;
      Inc(saved_up_pts_arr_ptr);
      Inc(target_pts_arr_ptr);
    end;
  proc_ptr;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.BB_Reset_UVClick(Sender:TObject);                                                                                                                                   {$region -fold}
begin
  with sln_var do
    sln_saved_up_pts_var.ResetPts(sln_pts,
                                  sln_saved_up_pts_var.saved_up_pts,
                                  sln_saved_up_pts_var.saved_up_pts_cnt,
                                  @srf_var.MainDraw);
end; {$endregion}
{$endregion}

// (2D Operations Attributes) Атрибуты 2D операций:
{UI} {$region -fold}
procedure TF_MainForm.CCB_2D_Operations_AutomaticItemChange(sender:TObject; AIndex:integer); {$region -fold}
begin
  sgr_var.align_pts:=F_MainForm.CCB_2D_Operations_Automatic.State[0]=cbChecked;
  srf_var.EventGroupsCalc(calc_arr,[18,30,31,32]);
end; {$endregion}
procedure TF_MainForm.CCB_2D_Operations_AutomaticGetItems  (sender:TObject);                 {$region -fold}
begin
  if CCB_2D_Operations_Automatic.ItemIndex=CCB_2D_Operations_Automatic.Items.Count-1 then
    case CCB_2D_Operations_Automatic.State[CCB_2D_Operations_Automatic.Items.Count-1] of
      cbChecked:
        CCB_2D_Operations_Automatic.CheckAll(cbChecked);
      cbUnchecked:
        CCB_2D_Operations_Automatic.CheckAll(cbUnchecked);
    end;
  InvalidateInnerWindow;
end; {$endregion}
procedure TF_MainForm.CCB_2D_Operations_AutomaticSelect    (sender:TObject);                 {$region -fold}
begin
end; {$endregion}
{$endregion}

// (Unfold Image Window) Развернуть окно:
{LI} {$region -fold}
procedure SplittersPosCalc;                                                                inline; {$ifdef Linux}[local]{$endif} {$region -fold}
begin
  {if (F_MainForm.width<678) then
    F_MainForm.width :=678;}
  if (F_MainForm.S_Splitter1.left<5{0}) then
    F_MainForm.S_Splitter1.left :=0;
  if (F_MainForm.S_Splitter3.left>F_MainForm.width -splitter_thickness-3) then
    F_MainForm.S_Splitter3.left :=F_MainForm.width -splitter_thickness;
  if (F_MainForm.S_Splitter2.top >F_MainForm.height-splitter_thickness-F_MainForm.SB_StatusBar1.height-0{20}) then
    F_MainForm.S_Splitter2.top  :=F_MainForm.height-splitter_thickness-F_MainForm.SB_StatusBar1.height-0{20};
  splitters_arr[0]^:=F_MainForm.S_Splitter0.top;
  splitters_arr[1]^:=F_MainForm.S_Splitter1.left;
  splitters_arr[2]^:=F_MainForm.S_Splitter2.top;
  splitters_arr[3]^:=F_MainForm.S_Splitter3.left;
  splitters_arr[4]^:=F_MainForm.S_Splitter4.top;
  splitters_arr[5]^:=F_MainForm.P_Splitter5.top;
  splitters_arr[6]^:=F_MainForm.S_Splitter6.top;
  splitters_arr[7]^:=F_MainForm.S_Splitter7.top;
end; {$endregion}
procedure IsControlEnbVis(control:TControl; _enabled:boolean=True; _visible:boolean=True); inline; {$ifdef Linux}[local]{$endif} {$region -fold}
begin
  control.Enabled:=_enabled;
  control.Visible:=_visible;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_Change_LayoutClick     (sender:TObject); {$region -fold}

  procedure UnfoldWindow; {$ifdef Linux}[local]{$endif} {$region -fold}

    procedure SetSplittersAnchors(space:TSpacingSize; control:TControl); {$ifdef Linux}[local]{$endif} {$region -fold}
    begin
      S_Splitter1         .AnchorParallel(akBottom,space,F_MainForm);
      S_Splitter3         .AnchorParallel(akBottom,space,F_MainForm);
      P_Image_Editor      .AnchorParallel(akBottom,space,F_MainForm);
      P_UV_Packing        .AnchorParallel(akBottom,space,F_MainForm);
      //S_TreeView_Splitter .AnchorParallel(akBottom,space,F_MainForm);
      //TV_Scene_Tree       .AnchorParallel(akBottom,space,F_MainForm);
      //SB_TreeView_Object_Tags.AnchorParallel(akBottom,space,F_MainForm);
    end; {$endregion}

  begin
    with F_MainForm do
      begin
        case tag of
          0:
            begin
              SetSplittersAnchors(0,F_MainForm);
              IsControlEnbVis(BB_Bottom_Splitter_To_Left ,False,False);
              IsControlEnbVis(BB_Bottom_Splitter_To_Right,False,False);
              IsControlEnbVis(PB_ProgressBar1            ,False,False);
              IsControlEnbVis(SB_StatusBar1              ,False,False);
              SB_StatusBar1.height    :=0;
              S_Splitter1  .left      :=0;
              S_Splitter2  .top       :=F_MainForm.height-splitter_thickness;
              S_Splitter3  .left      :=F_MainForm.width -splitter_thickness;
              S_TreeView_Splitter.left:=F_MainForm.width;
              tag                     :=1{1};
            end;
          {1:
            begin
              BorderStyle:=TFormBorderStyle.bsNone;
              tag        :=2;
            end;
          2:
            begin
              BorderStyle:=TFormBorderStyle.bsSizeable;
              tag        :=3;
            end;}
          1{3}:
            begin
              SetSplittersAnchors(0,F_MainForm);
              if (PC_Image_Editor.TabPosition=tpBottom) or (PC_Image_Editor.TabPosition=tpTop) then
                S_Splitter2.top       :=F_MainForm.height-067
              else
              if (PC_Image_Editor.TabPosition=tpLeft) or (PC_Image_Editor.TabPosition=tpRight) then
                S_Splitter2.top       :=F_MainForm.height-045;
              S_Splitter3.left        :=F_MainForm.width -210;
              S_TreeView_Splitter.left:=F_MainForm.width -050;
              tag                     :=0{4};
            end;
          {4:
            begin
              BorderStyle:=TFormBorderStyle.bsNone;
              tag        :=5;
            end;
          5:
            begin
              BorderStyle:=TFormBorderStyle.bsSizeable;
              tag        :=0;
            end;}
        end;
        SplittersPosCalc;
        SB_Change_Layout.down:=False;
      end;
  end; {$endregion}

begin
  UnfoldWindow;
  MoveBorders;
end; {$endregion}
procedure TF_MainForm.SB_Change_LayoutMouseLeave(sender:TObject); {$region -fold}
begin
  SB_Change_Layout.Repaint;
end; {$endregion}
{$endregion}

// (Original Image Size and Image Position) Исходный размер  и позиция изображения:
{UI} {$region -fold}
procedure TF_MainForm.MI_Align_Image_On_Inner_Window_ResizeClick(sender:TObject); {$region -fold}
begin
  align_picture_to_center:=MI_Align_Image_On_Inner_Window_Resize.Checked;
end; {$endregion}
procedure TF_MainForm.SB_Centrify_PictureClick                  (sender:TObject); {$region -fold}
begin
  tex_var.AlignPictureToCenter;
  with srf_var,inn_wnd_rct do
    begin
      world_axis_shift:=PtPos((left+right )>>1-world_axis.x,
                              (top +bottom)>>1-world_axis.y);
      obj_var.SetWorldAxisShift(world_axis_shift);
      obj_var.SetWorldAxisShiftC;
      EventGroupsCalc(calc_arr,[8,9,18,30,31,32,41,48]);
      SpeedButtonRepaint;
      SB_Centrify_Picture.down:=False;
    end;
end; {$endregion}
procedure TF_MainForm.SB_Centrify_PictureMouseLeave             (sender:TObject); {$region -fold}
begin
  SB_Centrify_Picture.Repaint;
end; {$endregion}
{$endregion}

// (Align Image and 3D Viewer) Выравнивание изображения и 3D просмотра:
{LI} {$region -fold}
procedure Align3DViewer;         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  monitor_width : TScreen;
  monitor_height: TScreen;}
begin
  {if F_3D_Viewer.BorderStyle=TFormBorderStyle.bsNone then
    begin
      F_3D_Viewer.SetBounds(splitters_arr[3]^+splitter_thickness+1,43,
                            F_MainForm.S_Splitter4.width,
                     Trunc((F_MainForm.S_Splitter4.width*196)/186));
      F_3D_Viewer.Constraints.MaxHeight:=splitters_arr[4]^-2;
    end
  else if F_3D_Viewer.BorderStyle=bsSizeable then
    begin
      monitor_width :=TScreen.Create(F_MainForm);
      monitor_height:=TScreen.Create(F_MainForm);
      F_3D_Viewer.Constraints.MaxWidth :=monitor_width .DesktopWidth ;
      F_3D_Viewer.Constraints.MaxHeight:=monitor_height.DesktopHeight;
    end;}
end; {$endregion}
procedure MoveBorders;           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  //F_MainForm.KeysEnable;
  SplittersPosCalc;
  {TODO}
  F_MainForm.S_Splitter1.Left:=0;

  with srf_var,sel_var,crc_sel_var do
    begin
      EventGroupsCalc(calc_arr,[0,1,2,3,4,6,8,9,17,18,20,28,30,31,32,37,44,48]);
      if down_select_items_ptr^ then
        begin
          ResizeCircleSelectionModeDraw;
          AddCircleSelection;
          CrtCircleSelection;
          with crc_sel_rct do
           {CircleSelectionModeDraw(left+width >>1,
                                    top +height>>1,
                                    srf_var);}
            FilSelPtsObj(left,top);
        end;
    end;
  SpeedButtonRepaint;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.S_Splitter0ChangeBounds         (sender:TObject); {$region -fold}
begin
  //KeysDisable;
  {$ifdef Windows}
  Application.ProcessMessages;
  {$else}
  SB_2D_Operations.Update;
  {$endif}
end; {$endregion}
procedure TF_MainForm.S_Splitter2ChangeBounds         (sender:TObject); {$region -fold}
var
  n,k: integer;

  procedure CheckBounds(exp1_,exp2_:boolean; k,m:integer); {$region -fold}
  begin
    if exp1_ and exp2_ then
      begin
        CCB_2D_Operations_Automatic.top:=k;
        S_Splitter0                .top:=n-22*m;
      end;
  end; {$endregion}

begin
  //KeysDisable;
  n:=P_UV_Operations.top
    +P_UV_Operations.height
    +CCB_2D_Operations_Automatic.height
    +P_UV_Attributes.height
    {+3*Trunc(CB_Align_2D_Points_Snap_Grid_Visibility.height/3)};
  case F_MainForm.Tag of
    {0:
      if (S_Splitter2.top+splitter_thickness>SB_StatusBar1.top) then
          S_Splitter2.top:=SB_StatusBar1.top-splitter_thickness;}
    1:
      if (S_Splitter2.top+splitter_thickness>F_MainForm.height) then
        S_Splitter2.top:=F_MainForm.height-splitter_thickness;
  end;
  {if (S_Splitter2.top< TV_Scene_Tree.top+P_Scene_Tree.height+7) then
       S_Splitter2.top:=TV_Scene_Tree.top+P_Scene_Tree.height+7;}
  CheckBounds((splitters_arr[1]^>=270),(splitters_arr[1]^<352),228,0);
  CheckBounds((splitters_arr[1]^>=352),(splitters_arr[1]^<466),206,1);
  CheckBounds((splitters_arr[1]^>=466),(splitters_arr[1]^<663),184,2);
  CheckBounds((splitters_arr[1]^>=663),True                   ,162,3);
  k:=2*18-Trunc(520/Trunc(S_Splitter2.Top/18));
  if (S_Splitter2.Top<520) and (k>8) then
    begin
      L_Object_Info   .Font.Height:=k;
      L_Exec_Time_Info.Font.Height:=k;
    end;
  if (S_Splitter2.Top<290) then
    begin
      L_Exec_Time_Info.AnchorParallel(akLeft  ,0,Nil);
      L_Exec_Time_Info.AnchorParallel(akBottom,0,Nil);
      L_Exec_Time_Info.Left:=250;
      L_Exec_Time_Info.Top :=015;
    end
  else
    begin
      L_Exec_Time_Info.AnchorParallel(akLeft  ,20,S_Splitter1);
      L_Exec_Time_Info.AnchorParallel(akBottom,20,S_Splitter2);
    end;
  {$ifdef Windows}
  Application.ProcessMessages;
  {$else}
  Update;
  {$endif}
end; {$endregion}
procedure TF_MainForm.S_Splitter3ChangeBounds         (sender:TObject); {$region -fold}
begin
  //KeysDisable;
  //Align3DViewer;
  {$ifdef Windows}
  Application.ProcessMessages;
  {$else}
  SB_2D_Operations.Update;
  {$endif}
  S_TreeView_Splitter.left:=S_Splitter3.left+treeview_splitter_shift;
  if (S_TreeView_Splitter.left>F_MainForm.width-splitter_thickness) then
    S_TreeView_Splitter.left :=F_MainForm.width-splitter_thickness;
end; {$endregion}
procedure TF_MainForm.S_Splitter6ChangeBounds         (sender:TObject); {$region -fold}
begin
  //KeysDisable;
  TV_Scene_Tree.Update;
  SB_TreeView_Object_Tags.Update;
  SB_Object_Properties.Update;
end; {$endregion}
procedure TF_MainForm.S_Splitter7ChangeBounds         (sender:TObject); {$region -fold}
begin
  //KeysDisable;
  SB_Object_Properties.Update;
  SB_Tag_Properties.Update;
end; {$endregion}
procedure TF_MainForm.S_Splitter8ChangeBounds         (sender:TObject); {$region -fold}
begin
  //KeysDisable;
  //Align3DViewer;
  {$ifdef Windows}
  Application.ProcessMessages;
  {$else}
  SB_2D_Operations.Update;
  {$endif}
end; {$endregion}
procedure TF_MainForm.S_Splitter1Moved                (sender:TObject); {$region -fold}
begin
  MoveBorders;
end; {$endregion}
procedure TF_MainForm.S_Splitter2Moved                (sender:TObject); {$region -fold}
begin
  MoveBorders;
end; {$endregion}
procedure TF_MainForm.S_Splitter3Moved                (sender:TObject); {$region -fold}
begin
  MoveBorders;
  treeview_splitter_shift:=S_TreeView_Splitter.left-S_Splitter3.left;
end; {$endregion}
procedure TF_MainForm.BB_Bottom_Splitter_To_LeftClick (sender:TObject); {$region -fold}
begin
  if (S_Splitter0.Top<=S_Splitter2.Top) then
    begin
      bottom_splitter_to_left:=not bottom_splitter_to_left;
      if bottom_splitter_to_left then
        begin
          BB_Bottom_Splitter_To_Left.Caption:='>';
          S_Splitter2   .AnchorParallel(akLeft  ,0 ,F_MainForm );
          S_Splitter1   .AnchorParallel(akBottom,0 ,S_Splitter2);
          P_Image_Editor.AnchorParallel(akLeft  ,0 ,F_MainForm );
          P_UV_Packing  .AnchorParallel(akBottom,0{10},S_Splitter2);
        end
      else
        begin
          BB_Bottom_Splitter_To_Left.Caption:='<';
          S_Splitter2   .AnchorParallel(akLeft  ,0 ,S_Splitter1  );
          S_Splitter1   .AnchorParallel(akBottom,0{23},SB_StatusBar1);
          P_Image_Editor.AnchorParallel(akLeft  ,0{10},S_Splitter1  );
          P_UV_Packing  .AnchorParallel(akBottom,0{23},SB_StatusBar1);
        end;
    end;
  BB_Bottom_Splitter_To_Left.Repaint;
end; {$endregion}
procedure TF_MainForm.BB_Bottom_Splitter_To_RightClick(sender:TObject); {$region -fold}
begin
  if (S_Splitter4.Top<=S_Splitter2.top) then
    begin
      bottom_splitter_to_right:=not bottom_splitter_to_right;
      if bottom_splitter_to_right then
        begin
          BB_Bottom_Splitter_To_Right.Caption:='<';
          S_Splitter2   .AnchorParallel(akRight ,0 ,F_MainForm );
          S_Splitter3   .AnchorParallel(akBottom,0 ,S_Splitter2);
          P_Image_Editor.AnchorParallel(akRight ,0 ,F_MainForm );
          TV_Scene_Tree .AnchorParallel(akBottom,0{10},S_Splitter2);
        end
      else
        begin
          BB_Bottom_Splitter_To_Right.Caption:='>';
          S_Splitter2   .AnchorParallel(akRight ,0 ,S_Splitter3  );
          S_Splitter3   .AnchorParallel(akBottom,0{23},SB_StatusBar1);
          P_Image_Editor.AnchorParallel(akRight ,0{10},S_Splitter3  );
          TV_Scene_Tree .AnchorParallel(akBottom,0{23},SB_StatusBar1);
        end;
    end;
  BB_Bottom_Splitter_To_Right.Repaint;
end; {$endregion}
{$endregion}

// (Selection Bounds) Ограничивающий прямоугольник при выделении кнопок:
{LI} {$region -fold}
procedure SelectionBounds(custom_bitmap:Graphics.TBitmap; custom_rect:TPtRect; custom_color:TColor; custom_width:integer); {$region -fold}
begin
  with custom_bitmap.Canvas do
    begin
      Pen.Mode :=pmNotCopy{pmMergeNotPen}{pmNotMask};
      Pen.Width:=custom_width;
      Pen.Color:=$FFFFFF-custom_color;
      Brush.Style:=bsClear;
      {$ifdef Windows}
      Windows.Rectangle(custom_bitmap.Canvas.Handle,
                        custom_rect.Left,
                        custom_rect.Top,
                        custom_rect.Right,
                        custom_rect.Bottom);
      {$else}
      Rectangle(custom_rect.Left,
                custom_rect.Top,
                custom_rect.Right,
                custom_rect.Bottom);
      {$endif}
    end;
end; {$endregion}
procedure SelectionBoundsRepaint; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k: integer;
begin
  with F_MainForm do
    begin
      visibility_panel_picture.PixelFormat:=pf32bit;
      SelectionBounds(visibility_panel_picture,PtRct(2,2,I_Visibility_Panel.Width-1,I_Visibility_Panel.Height-1),$00CBDAB1,4);
      for k:=0 to 4{5} do
        SelectionBounds(visibility_panel_picture,PtRct(2,28+36*k,I_Visibility_Panel.Width-1,65+36*k),$00CBDAB1,2);
    end;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.I_Visibility_PanelPaint          (sender:TObject); {$region -fold}
begin
  I_Visibility_Panel.Canvas.Draw(0,0,visibility_panel_picture);
end; {$endregion}
procedure TF_MainForm.I_Visibility_PanelMouseLeave     (sender:TObject); {$region -fold}
begin
  SelectionBoundsRepaint;
  I_Visibility_Panel.Repaint;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_TextureMouseEnter  (sender:TObject); {$region -fold}
begin
  SelectionBoundsRepaint;
  SelectionBounds(visibility_panel_picture,PtRct(2,28,I_Visibility_Panel.Width-1,65),clBlue,2);
  I_Visibility_Panel.Invalidate;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_GridMouseEnter     (sender:TObject); {$region -fold}
begin
  SelectionBoundsRepaint;
  SelectionBounds(visibility_panel_picture,PtRct(2,64,I_Visibility_Panel.Width-1,101),clBlue,2);
  I_Visibility_Panel.Invalidate;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_Snap_GridMouseEnter(sender:TObject); {$region -fold}
begin
  SelectionBoundsRepaint;
  SelectionBounds(visibility_panel_picture,PtRct(2,100,I_Visibility_Panel.Width-1,137),clBlue,2);
  I_Visibility_Panel.Invalidate;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_SplineMouseEnter   (sender:TObject); {$region -fold}
begin
  SelectionBoundsRepaint;
  SelectionBounds(visibility_panel_picture,PtRct(2,136,I_Visibility_Panel.Width-1,173),clBlue,2);
  I_Visibility_Panel.Invalidate;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_ActorMouseEnter  (sender:TObject); {$region -fold}
begin
  SelectionBoundsRepaint;
  SelectionBounds(visibility_panel_picture,PtRct(2,172,I_Visibility_Panel.Width-1,209),clBlue,2);
  I_Visibility_Panel.Invalidate;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_ColliderMouseEnter (sender:TObject); {$region -fold}
begin
  SelectionBoundsRepaint;
  SelectionBounds(visibility_panel_picture,PtRct(2,208,I_Visibility_Panel.Width-1,245),clBlue,2);
  I_Visibility_Panel.Invalidate;
end; {$endregion}
{$endregion}

// (Visibility Panel) Панель видимости:
{LI} {$region -fold}
procedure TF_MainForm.VisibilityChange(set_visibility:boolean); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  I_Visibility_Panel      .Visible:=set_visibility;
  SB_Change_Layout  .Visible:=set_visibility;
  SB_Centrify_Picture.Visible:=set_visibility;
  SB_Visibility_Texture   .Visible:=set_visibility;
  SB_Visibility_Grid      .Visible:=set_visibility;
  SB_Visibility_Spline    .Visible:=set_visibility;
  SB_Visibility_Collider  .Visible:=set_visibility;
  SB_Visibility_Actor     .Visible:=set_visibility;
  SB_Visibility_Snap_Grid .Visible:=set_visibility;
  SB_Visibility_Show_All  .Visible:=set_visibility;
  L_Object_Info           .Visible:=set_visibility;
  L_Exec_Time_Info        .Visible:=set_visibility;
  L_Speed                 .Visible:=set_visibility;
  TB_Speed                .Visible:=set_visibility;
  MI_Object_Info          .Checked:=set_visibility;
  show_obj_info                   :=set_visibility;
end; {$endregion}
procedure SetVisibility(btn:TSpeedButton; var &exp:boolean);    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  btn.Transparent:=&exp;
  &exp       :=not &exp;
  btn.Down:=False;
  srf_var.EventGroupsCalc(calc_arr,[30,41]);
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_Visibility_TextureClick  (sender:TObject);                                    {$region -fold}
begin
  SetVisibility(SB_Visibility_Texture,show_tex);
  SpeedButtonRepaint;
  srf_var.low_bmp_draw:=show_grid or show_snap_grid or (show_spline and (sln_var.sln_pts_cnt<>0));
end; {$endregion}
procedure TF_MainForm.SB_Visibility_GridClick     (sender:TObject);                                    {$region -fold}
begin
  SetVisibility(SB_Visibility_Grid,show_grid);
  SpeedButtonRepaint;
  srf_var.low_bmp_draw:=show_grid or show_snap_grid or (show_spline and (sln_var.sln_pts_cnt<>0));
end; {$endregion}
procedure TF_MainForm.SB_Visibility_Snap_GridClick(sender:TObject);                                    {$region -fold}
begin
  SetVisibility(SB_Visibility_Snap_Grid,show_snap_grid);
  SpeedButtonRepaint;
  srf_var.low_bmp_draw:=show_grid or show_snap_grid or (show_spline and (sln_var.sln_pts_cnt<>0));
end; {$endregion}
procedure TF_MainForm.SB_Visibility_SplineClick   (sender:TObject);                                    {$region -fold}
begin
  repaint_spline_calc:=True;
  rectangles_calc    :=True;
  spline_scale_calc  :=True;
  cmr_var.scl_dir    :=sdNone;
  SetVisibility(SB_Visibility_Spline,show_spline);
  repaint_spline_calc:=False;
  rectangles_calc    :=False;
  spline_scale_calc  :=False;
  SpeedButtonRepaint;
  srf_var.low_bmp_draw:=show_grid or show_snap_grid or (show_spline and (sln_var.sln_pts_cnt<>0));
end; {$endregion}
procedure TF_MainForm.SB_Visibility_ActorClick    (sender:TObject);                                    {$region -fold}
begin
  SetVisibility(SB_Visibility_Actor,show_actor);
  SpeedButtonRepaint;
  srf_var.low_bmp_draw:=show_grid or show_snap_grid or (show_spline and (sln_var.sln_pts_cnt<>0));
end; {$endregion}
procedure TF_MainForm.SB_Visibility_ColliderClick (sender:TObject);                                    {$region -fold}
begin
  SetVisibility(SB_Visibility_Collider,show_collider);
  SpeedButtonRepaint;
  srf_var.low_bmp_draw:=show_grid or show_snap_grid or (show_spline and (sln_var.sln_pts_cnt<>0));
end; {$endregion}
procedure TF_MainForm.SB_Visibility_Show_AllClick (sender:TObject);                                    {$region -fold}
var
  i: integer;
begin
  show_all                           :=not show_all;
  SB_Visibility_Texture  .Transparent:=not show_all;
  SB_Visibility_Grid     .Transparent:=not show_all;
  SB_Visibility_Snap_Grid.Transparent:=not show_all;
  SB_Visibility_Spline   .Transparent:=not show_all;
  SB_Visibility_Actor    .Transparent:=not show_all;
  SB_Visibility_Collider .Transparent:=not show_all;
  SB_Visibility_Show_All .Transparent:=not show_all;
  for i:=0 to High(show_obj_arr) do
    show_obj_arr[i]:=show_all;
  SB_Visibility_Show_All.Down:=False;
  cmr_var.scl_dir            :=sdNone;
  srf_var.EventGroupsCalc(calc_arr,[18,19,30,31,32]);
  SpeedButtonRepaint;
  srf_var.low_bmp_draw:=show_grid or show_snap_grid {or (show_spline and (sln_var.sln_pts_cnt<>0))};
end; {$endregion}
{$endregion}

// (Color Scheme) Выбор цвета обьектов "Grid","Spline",...:
{UI} {$region -fold}
procedure SetObjectColor(speed_button:TSpeedButton; var custom_color:TColor); {$region -fold}
begin
  F_MainForm.CD_Select_Color.Color:=speed_button.Color;
  F_MainForm.CD_Select_Color.Execute;
  speed_button.Color:=F_MainForm.CD_Select_Color.Color;
  custom_color      :=F_MainForm.CD_Select_Color.Color;
  srf_var.MainDraw;
  speed_button.Down:=False;
end; {$endregion}
procedure TF_MainForm.SB_Background_ColorClick(sender:TObject);               {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.SB_Grid_ColorClick      (sender:TObject);               {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.SB_Snap_Grid_ColorClick (sender:TObject);               {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.SB_Spline_ColorClick    (sender:TObject);               {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.SB_UV_Mesh_ColorClick   (sender:TObject);               {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.SB_IS_Graph_ColorClick  (sender:TObject);               {$region -fold}
begin
end; {$endregion}
{$endregion}

// (Buttons PopUp Menu) Всплывающее меню панели инструментов:
{UI} {$region -fold}
procedure ButtonsPopUpMenu(panel:TPanel; menu_item:TMenuItem; col1,col2,col3:TColor; &transparent:boolean); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  if menu_item.Checked then
    begin
      panel.BevelColor:=col1;
      panel.Color     :=col2;
    end;
  for i:=0 to panel.ControlCount-1 do
    begin
      (panel.Controls[i] as TSpeedButton).Transparent:=&transparent;
      (panel.Controls[i] as TSpeedButton).Flat       :=&transparent;
       panel.Controls[i].Color:=col3;
    end;
end; {$endregion}
procedure TF_MainForm.MI_Button_Style_1Click(Sender:TObject); {$region -fold}
begin
  ButtonsPopUpMenu(P_Drawing_Buttons,MI_Button_Style_1,$00D2CE9D,$00F2F1E3,$009DD7E6,MI_Button_Style_1.Checked);
end; {$endregion}
procedure TF_MainForm.MI_Button_Style_2Click(Sender:TObject); {$region -fold}
begin
  ButtonsPopUpMenu(P_Drawing_Buttons,MI_Button_Style_2,$00ABAFA3,$00ABAFA3,$009DD7E6,not MI_Button_Style_2.Checked);
end; {$endregion}
{$endregion}

// (Buttons Colorize) Окраска кнопок при нажатии:
{LI} {$region -fold}
procedure BtnColAndDown    (constref spd_btn:TSpeedButton; var down_flag:boolean; color_down:TColor=NAV_SEL_COL_0; color_up:TColor=$00CBDAB1); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with spd_btn do
    begin
      Flat:=Down;
      if Down then
        Color:=color_down
      else
        Color:=color_up;
    end;
  down_flag:=not down_flag;
end; {$endregion}
procedure MouseMoveProcInit(pnl:TPanel; pnl_proc:TMouseMoveEvent);                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to pnl.ControlCount-1 do
    (pnl.Controls[i] as TSpeedButton).OnMouseMove:=pnl_proc;
end; {$endregion}
procedure ButtonColorize   (prnt_pnl:TPanel; btn_col:TColor=NAV_SEL_COL_0);                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to prnt_pnl.ControlCount-1 do
    begin
     (prnt_pnl.Controls[i] as TSpeedButton).Transparent:=not (prnt_pnl.Controls[i] as TSpeedButton).Down;
      prnt_pnl.Controls[i].Color:=btn_col;
    end;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.P_Load_Save_ClearPaint      (sender:TObject);                                 {$region -fold}
begin
  ButtonColorize(P_Load_Save_Clear);
end; {$endregion}
procedure TF_MainForm.P_Drawing_ButtonsPaint      (sender:TObject);                                 {$region -fold}
begin
  ButtonColorize(P_Drawing_Buttons);
end; {$endregion}
procedure TF_MainForm.P_Animation_ButtonsPaint    (sender:TObject);                                 {$region -fold}
begin
  ButtonColorize(P_Animation_Buttons);
end; {$endregion}
procedure TF_MainForm.P_Drawing_ButtonsMouseMove  (sender:TObject; shift:TShiftState; x,y:integer); {$region -fold}
begin
  P_Drawing_Buttons.Repaint;
end; {$endregion}
procedure TF_MainForm.P_Animation_ButtonsMouseMove(sender:TObject; shift:TShiftState; x,y:integer); {$region -fold}
begin
  P_Animation_Buttons.Repaint;
end; {$endregion}
{$endregion}

// (Buttons Scroll) Прокрутка панели кнопок:
{LI} {$region -fold}
procedure ButtonMoveToPrevPos(prnt_pnl:TPanel; constref btn:TControl; constref min_param,btn_width,margin:integer; constref left_or_top:TParamType); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  case left_or_top of
    ptLeft:
      begin
        if (btn.left=min_param) then
          Exit;
        for i in [0..prnt_pnl.ControlCount-1] do
          prnt_pnl.Controls[i].left:=prnt_pnl.Controls[i].left-(btn_width+margin);
      end;
    ptTop:
      begin
        if (btn.top=min_param) then
          Exit;
        for i in [0..prnt_pnl.ControlCount-1] do
          prnt_pnl.Controls[i].top:=prnt_pnl.Controls[i].top-(btn_width+margin);
      end;
  end;
end; {$endregion}
procedure ButtonMoveToSuccPos(prnt_pnl:TPanel; constref btn:TControl; constref max_param,btn_width,margin:integer; constref left_or_top:TParamType); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  case left_or_top of
    ptLeft:
      begin
        if (btn.left=max_param) then
          Exit;
        for i in [0..prnt_pnl.ControlCount-1] do
          prnt_pnl.Controls[i].left:=prnt_pnl.Controls[i].left+(btn_width+margin);
      end;
    ptTop:
      begin
        if (btn.top=max_param) then
          Exit;
        for i in [0..prnt_pnl.ControlCount-1] do
          prnt_pnl.Controls[i].top:=prnt_pnl.Controls[i].top+(btn_width+margin);
      end;
  end;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.TS_DrawMouseWheelDown(sender:TObject; shift:TShiftState; mousepos:TPoint; var handled:boolean); {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.TS_DrawMouseWheelUp  (sender:TObject; shift:TShiftState; mousepos:TPoint; var handled:boolean); {$region -fold}
begin
end; {$endregion}
{$endregion}

// (Buttons Panels Visibility) Видимость панелей для инструментов рисования:
{LI} {$region -fold}
procedure DrawingPanelsSetVisibility1(var down_button_ptr:PByteBool; active_panel,empty_panel:TPanel; var prev_panel,curr_panel:TPanel); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  curr_panel:=active_panel;
  if (not down_button_ptr^) then
    begin
      prev_panel .visible:=False;
      empty_panel.visible:=True;
      curr_panel .visible:=False;
    end
  else
    begin
      prev_panel .visible:=False;
      empty_panel.visible:=False;
      curr_panel .visible:=True;
    end;
  prev_panel:=curr_panel;
end; {$endregion}
procedure DrawingPanelsSetVisibility2;                                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if down_select_items_ptr^ then
    begin
      crc_sel_var.only_fill:=False;
      {with obj_var do
        FilScene1(0,obj_cnt-1);
      if show_world_axis then
        with srf_var do
          WorldAxisBmp(world_axis.x-world_axis_bmp.bmp_ftimg_width_origin >>1,
                       world_axis.y-world_axis_bmp.bmp_ftimg_height_origin>>1);}
    end;
  if sln_var.has_hid_ln_elim_sln or sln_var.has_byte_mode_sln then
    begin
      if (not down_select_items_ptr^) then
        begin
          if (not repaint_spline_hid_ln_calc1) {and (down_spline_ptr^)} then
            begin
              srf_var.EventGroupsCalc(calc_arr,[18,23,24,{27,}30,31,32,34,41,48]);
              repaint_spline_hid_ln_calc1:=True;
              repaint_spline_hid_ln_calc2:=False;
            end;
        end
      else
        begin
          //if (not repaint_spline_hid_ln_calc2) then
          srf_var.EventGroupsCalc(calc_arr,[18,23,24,30,31,32{,34},41,48]);
          repaint_spline_hid_ln_calc1:=False;
          repaint_spline_hid_ln_calc2:=True;
        end;
    end
  else
  //if (not down_select_points_ptr^) {and (sel_var.sel_pts_cnt<>0)} then
    srf_var.EventGroupsCalc(calc_arr,[18,23,24,{27,}30,31,32,41,48]);
end; {$endregion}
{$endregion}

// (Main Layer) Основной слой:
{LI} {$region -fold}
constructor TSurface.Create(w,h:TColor);                                                                                                       {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  obj_var.Add(kooBkgnd,world_axis_shift);
  CreateNode('Background','');
  ObjIndsCalc;
  ScTIndsCalc;

  srf_bmp:=Graphics.TBitmap.Create;
  {$ifopt D+}
  srf_bmp.PixelFormat:=pfDevice;
  {$endif}

  test_bmp:=Graphics.TBitmap.Create;
  {$ifopt D+}
  test_bmp.PixelFormat:=pfDevice;
  {$endif}

  low_bmp:=Graphics.TBitmap.Create;
  {$ifopt D+}
  low_bmp.PixelFormat:=pfDevice;
  {$endif}
  low_bmp_draw:=True;

  low_bmp2:=Graphics.TBitmap.Create;
  {$ifopt D+}
  low_bmp2.PixelFormat:=pfDevice;
  {$endif}
  low_bmp2_draw:=False;

  cmr_var.parallax_shift    :=obj_default_prop.parallax_shift;
  show_all                  :=True;
  inner_window_ui_visible   :=True;
  bg_color                  :=$00666688{clBlack}{clDkGray}{clLtGray};
  bg_style                  :=bsGrayscale;
  srf_bmp.Canvas.Brush.Color:=bg_color;

  SetTextInfo(srf_bmp.Canvas,32,$00E6F9EB,'AR DESTINE');

  WorldAxisCreate;

end; {$endregion}
destructor  TSurface.Destroy;                                                                                                                  {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure TSurface.WorldAxisCreate;                                                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // Create World Axis Icon:
  SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
  sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
  (
    srf_bmp_ptr,
    srf_bmp.width,
    srf_bmp.height,
    inn_wnd_rct,
    max_sprite_w_h_rct,
    Application.Location+WORLD_AXIS_ICON,
    @F_MainForm.IL_World_Axis.GetBitmap,
    0
  );
  world_axis_bmp_ind:=Length(sprite_sheet_arr)-1;
  with sprite_sheet_arr[world_axis_bmp_ind],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;

      SetPPInfo(clRed);
      SetGrad  (0,bmp_ftimg_height,0,255);

      col_trans_arr[01]:=132;
      col_trans_arr[02]:=032;
      col_trans_arr[03]:=132;
      col_trans_arr[04]:=132;
      col_trans_arr[05]:=132;
      col_trans_arr[06]:=132;
      col_trans_arr[07]:=132;
      col_trans_arr[08]:=132;
      col_trans_arr[09]:=132;
      col_trans_arr[10]:=0;
      col_trans_arr[11]:=255;
      col_trans_arr[12]:=0;
      col_trans_arr[13]:=255;
      col_trans_arr[14]:=0;
      col_trans_arr[15]:=255;
      col_trans_arr[16]:=0;

      pix_drw_type             :=00{01}; //must be in range of [0..002]
      nt_pix_cfx_type          :=02{00};
      pt_pix_cfx_type          :=02{00};
      fx_cnt                   :=00{01}; //must be in range of [0..255]

      fx_arr[0].rep_cnt        :=01{02}; //must be in range of [0..255]

      fx_arr[0].nt_pix_srf_type:=01    ; //must be in range of [0..001]
      fx_arr[0].nt_pix_cfx_type:=17    ; //must be in range of [0..255]
      fx_arr[0].nt_pix_cng_type:=00    ; //must be in range of [0..001]

      fx_arr[0].pt_pix_srf_type:=01    ; //must be in range of [0..001]
      fx_arr[0].pt_pix_cfx_type:=17    ; //must be in range of [0..255]
      fx_arr[0].pt_pix_cng_type:=00    ; //must be in range of [0..001]
    end;
end; {$endregion}
procedure TSurface.WorldAxisToBmp(constref x,y:integer);                                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  world_axis_x,world_axis_y: integer;}
begin
  {srf_bmp.BeginUpdate(True);
  with srf_bmp.Canvas,world_axis_shift do
    begin
      Pen.Mode    :=pmNotMask{pmNotXor}{pmCopy};
      Pen.Color   :=clGreen;
      world_axis_x:=world_axis.x+world_axis_shift.x;
      world_axis_y:=world_axis.y+world_axis_shift.y;
      Line  ( 00+world_axis_x,
              00+world_axis_y,
              60+world_axis_x,
              00+world_axis_y);
      LineTo( 50+world_axis_x,
             -02+world_axis_y);
      LineTo( 50+world_axis_x,
              02+world_axis_y);
      LineTo( 60+world_axis_x,
              00+world_axis_y);
      Line  ( 00+world_axis_x,
              00+world_axis_y,
              00+world_axis_x,
             -60+world_axis_y);
      LineTo(-02+world_axis_x,
             -50+world_axis_y);
      LineTo( 02+world_axis_x,
             -50+world_axis_y);
      LineTo( 00+world_axis_x,
             -60+world_axis_y);
      Pen.Color:=clBlue;
      Pen.Style:=psDot;
      Line  ( 00+world_axis_x,
              00+world_axis_y,
             -60+world_axis_x,
              00+world_axis_y);
      Pen.Style:=psSolid;
      LineTo(-50+world_axis_x,
             -02+world_axis_y);
      LineTo(-50+world_axis_x,
              02+world_axis_y);
      LineTo(-60+world_axis_x,
              00+world_axis_y);
      Pen.Style:=psDot;
      Line  ( 00+world_axis_x,
              00+world_axis_y,
              00+world_axis_x,
              60+world_axis_y);
      Pen.Style:=psSolid;
      LineTo(-02+world_axis_x,
              50+world_axis_y);
      LineTo( 02+world_axis_x,
              50+world_axis_y);
      LineTo( 00+world_axis_x,
              60+world_axis_y);
    end;
  srf_bmp.EndUpdate(False);}

  with {pvt_var.sel_tls_mrk}{tlm_var.tilemap_sprite_icon}{pvt_var.local_axis_bmp}sprite_sheet_arr[world_axis_bmp_ind],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      SetRctPos(x+world_axis_shift.x,
                y+world_axis_shift.y);
      SdrProc[3];
    end;

end; {$endregion}
procedure InvalidateInnerWindow;                                                                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {$ifdef Windows}
  InvalidateRect(F_MainForm.Handle,
                 Rect(splitters_arr[1]^+splitter_thickness,
                      splitters_arr[5]^+splitter_thickness,
                      splitters_arr[3]^,
                      splitters_arr[2]^),
                 True);
  {$else}
  Invalidate;
  {$endif}
end; {$endregion}
procedure InvalidateRegion(rct_dst:TRect);                                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {$ifdef Windows}
  InvalidateRect(F_MainForm.Handle,
                 Rect(rct_dst.Left,
                      rct_dst.Top,
                      rct_dst.Right,
                      rct_dst.Bottom),
                 True);
  {$else}
  Invalidate;
  {$endif}
end; {$endregion}
procedure TSurface.MainBmpRectCalc;                                                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  srf_bmp_rct:=PtBounds(0,0,{1024}F_MainForm.Width,{640}F_MainForm.Height);
  inn_wnd_rct:=PtRct({0000}splitters_arr[1]^+splitter_thickness+inn_wnd_mrg,
                     {0000}splitters_arr[5]^+splitter_thickness+inn_wnd_mrg,
                     {1022}splitters_arr[3]^                   -inn_wnd_mrg,
                     {0638}splitters_arr[2]^                   -inn_wnd_mrg);
  pvt_var.SetPivotAxisRect(inn_wnd_rct);
end; {$endregion}
procedure TSurface.MainBmpSizeCalc;                                                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  srf_bmp .width :=srf_bmp_rct.width ;
  srf_bmp .height:=srf_bmp_rct.height;
  test_bmp.width :=srf_bmp_rct.width ;
  test_bmp.height:=srf_bmp_rct.height;
  low_bmp .width :=srf_bmp_rct.width ;
  low_bmp .height:=srf_bmp_rct.height;
  low_bmp2.width :=srf_bmp_rct.width ;
  low_bmp2.height:=srf_bmp_rct.height;
  rot_arr_width  :=srf_bmp_rct.width ;
  rot_arr_height :=srf_bmp_rct.height;
  if show_tex then
    with tex_var do
      begin
        tex_bmp.width :=Trunc(tex_bmp_rct_pts[1].x-tex_bmp_rct_pts[0].x);
        tex_bmp.height:=Trunc(tex_bmp_rct_pts[1].y-tex_bmp_rct_pts[0].y);
      end;
end; {$endregion}
procedure TSurface.MainBmpArrsCalc;                                                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Spline--------} {$region -fold}
  with sln_var do
    begin
      with rct_eds_big_img do
        begin
          SetBkgnd   (srf_bmp_ptr           ,srf_bmp.width,srf_bmp.height,@inn_wnd_rct);
          BuffersInit(                       srf_bmp.width,srf_bmp.height,False,True,False,False);
        end;
      with rct_pts_big_img do
        begin
          SetBkgnd   (srf_bmp_ptr           ,srf_bmp.width,srf_bmp.height,@inn_wnd_rct);
          BuffersInit(                       srf_bmp.width,srf_bmp.height,False,True,False,False);
        end;
      with eds_big_img do
        begin
          SetBkgnd   (srf_bmp_ptr           ,srf_bmp.width,srf_bmp.height,@inn_wnd_rct);
          BuffersInit(                       srf_bmp.width,srf_bmp.height,True,True,False,True);
        end;
      with pts_big_img do
        begin
          SetBkgnd   (srf_bmp_ptr           ,srf_bmp.width,srf_bmp.height,@inn_wnd_rct);
          BuffersInit(                       srf_bmp.width,srf_bmp.height,True,True,False,True);
        end;

      //dup_pts_arr            :=Nil;
      SetLength     (dup_pts_arr            ,srf_bmp.width*srf_bmp.height);
      ArrClear      (dup_pts_arr            ,inn_wnd_rct,  srf_bmp.width );

      {
      //rct_eds_useless_fld_arr:=Nil;
      SetLength     (rct_eds_useless_fld_arr,srf_bmp.width*srf_bmp.height);
      ArrClear      (rct_eds_useless_fld_arr,inn_wnd_rct,  srf_bmp.width );

      //rct_pts_useless_fld_arr:=Nil;
      SetLength     (rct_pts_useless_fld_arr,srf_bmp.width*srf_bmp.height);
      ArrClear      (rct_pts_useless_fld_arr,inn_wnd_rct,  srf_bmp.width );
      }

      //    eds_useless_fld_arr:=Nil;
      SetLength     (    eds_useless_fld_arr,srf_bmp.width*srf_bmp.height);
      ArrClear      (    eds_useless_fld_arr,inn_wnd_rct,  srf_bmp.width );

      {
      //    pts_useless_fld_arr:=Nil;
      SetLength     (    pts_useless_fld_arr,srf_bmp.width*srf_bmp.height);
      ArrClear      (    pts_useless_fld_arr,inn_wnd_rct,  srf_bmp.width );
      }

    end; {$endregion}

  {Selected Edges} {$region -fold}
  with sel_var do
    begin
      with outer_subgraph_img do
        begin
          SetBkgnd   (srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct);
          BuffersInit(            srf_bmp.width,srf_bmp.height,True,True,True,True);
          GCCArrInit;
        end;
      with inner_subgraph_img do
        begin
          SetBkgnd   (srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct);
          BuffersInit(            srf_bmp.width,srf_bmp.height,True,True,True,True);
        end;
      with sel_pts_big_img do
        begin
          SetBkgnd   (srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct);
          BuffersInit(            srf_bmp.width,srf_bmp.height,True,True,True,True);
        end;
    end; {$endregion}

  {Physics-------} {$region -fold}
  SetLength(fast_physics_var.coll_box_arr,srf_bmp.width*srf_bmp.height);
  SetLength(coll_arr                     ,srf_bmp.width*srf_bmp.height);
  SetLength(projectile_arr,10000); {$endregion}

  {Baking Sprites} {$region -fold}
  SetLength(rot_arr            ,srf_bmp.width*srf_bmp.height);
  ArrClear (rot_arr,inn_wnd_rct,srf_bmp.width);
  rot_arr_ptr:=Unaligned(@rot_arr[0]); {$endregion}

end; {$endregion}
procedure TSurface.InnerWindowDraw(color:TColor);                                                                                      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_prop: TCurveProp;
  //a,b     : integer;
begin
  {with dst_canvas do
    begin
     a:=Trunc((inn_wnd_mrg+1)/2);
      b:=inn_wnd_mrg;
      if Odd(b) then
        b:=a
      else
        b:=a+1;
      Brush.Style:=bsClear;
      Pen.Mode   :=pmCopy;
      Pen.Color  :=color;
      Pen.Width  :=inn_wnd_mrg;
      Rectangle(inn_wnd_rct.left  -a,
                inn_wnd_rct.top   -a,
                inn_wnd_rct.right +b,
                inn_wnd_rct.bottom+b);
      Pen.Width:=1;
    end;}
  with rct_prop do
    begin
      pts_col           :=color;
      pts_col_inv       :=SetColorInv(color);
      pts_rct_tns_left  :=inn_wnd_mrg;
      pts_rct_tns_top   :=inn_wnd_mrg;
      pts_rct_tns_right :=inn_wnd_mrg;
      pts_rct_tns_bottom:=inn_wnd_mrg;
      pts_rct_inn_width :=inn_wnd_rct.width ;
      pts_rct_inn_height:=inn_wnd_rct.height;
      SetRctWidth (rct_prop);
      SetRctHeight(rct_prop);
      SetRctValues(rct_prop);
      Fast_Primitives.Rectangle
      (
        inn_wnd_rct.left+inn_wnd_rct.width >>1-pts_rct_width__odd,
        inn_wnd_rct.top +inn_wnd_rct.height>>1-pts_rct_height_odd,
        srf_bmp_ptr,
        srf_bmp.width,
        srf_bmp.height,
        PtBounds
        (
          inn_wnd_rct.left  -inn_wnd_mrg,
          inn_wnd_rct.top   -inn_wnd_mrg,
          inn_wnd_rct.right +inn_wnd_mrg,
          inn_wnd_rct.bottom+inn_wnd_mrg
        ),
        rct_prop
      );
    end;
end; {$endregion}
procedure TSurface.BmpSettings(bmp_dst:Graphics.TBitmap; pen_color:TColor; pen_mode:TPenMode=pmCopy; brush_style:TBrushStyle=bsSolid); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with bmp_dst.Canvas do
    begin
      Pen.Mode   :=pen_mode{pmNotCopy}{pmMergeNotPen}{pmNotMask};
      Pen.Color  :=(*//$FFFFFF-*)pen_color;
      Brush.Style:=brush_style;
    end;
end; {$endregion}
procedure TSurface.MainBmpToLowerBmp;                                                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  BmpToBmp2(srf_bmp_ptr,low_bmp_ptr,srf_bmp.width,low_bmp.width,inn_wnd_rct,inn_wnd_mrg);
end; {$endregion}
procedure TSurface.MainBmpToLowerBmp2;                                                                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  BmpToBmp2(srf_bmp_ptr,low_bmp2_ptr,srf_bmp.width,low_bmp2.width,inn_wnd_rct,inn_wnd_mrg);
end; {$endregion}
procedure TSurface.LowerBmpToMainBmp;                                                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  BmpToBmp2(low_bmp_ptr,srf_bmp_ptr,low_bmp.width,srf_bmp.width,inn_wnd_rct,inn_wnd_mrg);
end; {$endregion}
procedure TSurface.LowerBmp2ToMainBmp;                                                                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  BmpToBmp2(low_bmp2_ptr,srf_bmp_ptr,low_bmp2.width,srf_bmp.width,inn_wnd_rct,inn_wnd_mrg);
end; {$endregion}
procedure TSurface.FilBkgndObj(constref bkgnd_ind:TColor);                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with obj_var.obj_arr[obj_var.bkgnd_inds_obj_arr[bkgnd_ind]] do
    PPFloodFill(bkgnd_ptr,rct_clp_ptr^,bkgnd_width,bg_color);
end; {$endregion}
procedure TSurface.MovBkgndObj(constref bkgnd_ind:TColor);                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with obj_var.obj_arr[obj_var.bkgnd_inds_obj_arr[bkgnd_ind]] do
    PPFloodFill(bkgnd_ptr,rct_dst_ptr^,bkgnd_width,bg_color);
end; {$endregion}
procedure TSurface.ChangeSpeed;                                                                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (cmr_var.parallax_shift.x<0) then
    Exit;
  cmr_var.parallax_shift.x:=cmr_var.parallax_shift.x-0.05;
  cmr_var.parallax_shift.y:=cmr_var.parallax_shift.y-0.05;
  obj_var.SetParallaxShift(PtPosF(-0.05,-0.05));
end; {$endregion}
procedure TSurface.MovRight;                                                                                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (cmr_var.parallax_shift.x<0) then
    Exit;
  cmr_var.mov_dir   :=mdRight;
  world_axis_shift.x-=Trunc(cmr_var.parallax_shift.x);
  obj_var.MovWorldAxisShiftRight;
end; {$endregion}
procedure TSurface.FilRight(constref bmp_dst_ptr:PInteger; constref bmp_dst_width,bmp_dst_height:integer; constref rct_dst:TPtRect);   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct: TPtRect;
begin
  with obj_var do
    begin
      rct:=PtRct
      (
        rct_dst.right-Trunc(cmr_var.parallax_shift.x),
        rct_dst.top,
        rct_dst.right,
        rct_dst.bottom
      );
      BitBlt1
      (
        bmp_dst_ptr,
        bmp_dst_ptr,
        rct_dst.left +Trunc(cmr_var.parallax_shift.x),
        rct_dst.top,
        rct_dst.width-Trunc(cmr_var.parallax_shift.x),
        rct_dst.height,
        rct_dst.left,
        rct_dst.top,
        bmp_dst_width,
        bmp_dst_width
      );
      SetRctDstPtr(@rct,0,low_lr_obj_cnt-1);
    end;
end; {$endregion}
procedure TSurface.MovLeft;                                                                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (cmr_var.parallax_shift.x<0) then
    Exit;
  cmr_var.mov_dir:=mdLeft;
  world_axis_shift.x+=Trunc(cmr_var.parallax_shift.x);
  obj_var.MovWorldAxisShiftLeft;
end; {$endregion}
procedure TSurface.FilLeft (constref bmp_dst_ptr:PInteger; constref bmp_dst_width,bmp_dst_height:integer; constref rct_dst:TPtRect);   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct: TPtRect;
begin
  with obj_var do
    begin
      rct:=PtRct
      (
        rct_dst.left,
        rct_dst.top,
        rct_dst.left+Trunc(cmr_var.parallax_shift.x),
        rct_dst.bottom
      );
      BitBlt2
      (
        bmp_dst_ptr,
        bmp_dst_ptr,
        rct_dst.left,
        rct_dst.top,
        rct_dst.width-Trunc(cmr_var.parallax_shift.x),
        rct_dst.height,
        rct_dst.left +Trunc(cmr_var.parallax_shift.x),
        rct_dst.top,
        bmp_dst_width,
        bmp_dst_width
      );
      SetRctDstPtr(@rct,0,low_lr_obj_cnt-1);
    end;
end; {$endregion}
procedure TSurface.MovDown;                                                                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (cmr_var.parallax_shift.x<0) then
    Exit;
  cmr_var.mov_dir   :=mdDown;
  world_axis_shift.y-=Trunc(cmr_var.parallax_shift.y);
  obj_var.MovWorldAxisShiftDown;
end; {$endregion}
procedure TSurface.FilDown (constref bmp_dst_ptr:PInteger; constref bmp_dst_width,bmp_dst_height:integer; constref rct_dst:TPtRect);   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct: TPtRect;
begin
  with obj_var do
    begin
      rct:=PtRct
      (
        rct_dst.left,
        rct_dst.bottom-Trunc(cmr_var.parallax_shift.y),
        rct_dst.right,
        rct_dst.bottom
      );
      BitBlt1
      (
        bmp_dst_ptr,
        bmp_dst_ptr,
        rct_dst.left,
        rct_dst.top   +Trunc(cmr_var.parallax_shift.y),
        rct_dst.width,
        rct_dst.height-Trunc(cmr_var.parallax_shift.y),
        rct_dst.left,
        rct_dst.top,
        bmp_dst_width,
        bmp_dst_width
      );
      SetRctDstPtr(@rct,0,low_lr_obj_cnt-1);
    end;
end; {$endregion}
procedure TSurface.MovUp;                                                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (cmr_var.parallax_shift.x<0) then
    Exit;
  cmr_var.mov_dir   :=mdUp;
  world_axis_shift.y+=Trunc(cmr_var.parallax_shift.y);
  obj_var.MovWorldAxisShiftUp;
end; {$endregion}
procedure TSurface.FilUp   (constref bmp_dst_ptr:PInteger; constref bmp_dst_width,bmp_dst_height:integer; constref rct_dst:TPtRect);   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct: TPtRect;
begin
  with obj_var do
    begin
      rct:=PtRct
      (
        rct_dst.left,
        rct_dst.top,
        rct_dst.right,
        rct_dst.top+Trunc(cmr_var.parallax_shift.y)
      );
      BitBlt2
      (
        bmp_dst_ptr,
        bmp_dst_ptr,
        rct_dst.left,
        rct_dst.top,
        rct_dst.width,
        rct_dst.height-Trunc(cmr_var.parallax_shift.y),
        rct_dst.left,
        rct_dst.top   +Trunc(cmr_var.parallax_shift.y),
        bmp_dst_width,
        bmp_dst_width
      );
      SetRctDstPtr(@rct,0,low_lr_obj_cnt-1);
    end;
end; {$endregion}

{Events Queue}
{Get Handles-------------------------------------}
procedure TSurface.GetHandles;                                                                                                                 {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with obj_var,rgr_var,sgr_var,sln_var,tex_var do
    begin
      srf_bmp_ptr :=GetBmpHandle(srf_bmp );
      test_bmp_ptr:=GetBmpHandle(test_bmp);
      low_bmp_ptr :=GetBmpHandle(low_bmp );
      low_bmp2_ptr:=GetBmpHandle(low_bmp2);
      if show_tex then
        begin
          tex_bmp_ptr:=GetBmpHandle(tex_bmp);
          tex_bmp.Canvas.Draw(0,0,loaded_picture.Bitmap);
        end;
      with obj_var do
        SetObjBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct,0,obj_cnt-1);
    end;
  // Get Target Render For OpenGL Output:
  GLBitmapInit(texture_id,srf_bmp,down_play_anim_ptr^);
  //if down_play_anim_ptr^ then
  GetObject(srf_bmp.Handle,SizeOf(buffer),@buffer);
end; {$endregion}
{World Axis: Drawing-----------------------------}
procedure TSurface.WorldAxisDraw;                                                                                                              {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  WorldAxisToBmp(world_axis.x-sprite_sheet_arr[world_axis_bmp_ind].fast_image_data.bmp_ftimg_width_origin >>1,
                 world_axis.y-sprite_sheet_arr[world_axis_bmp_ind].fast_image_data.bmp_ftimg_height_origin>>1);
end; {$endregion}
{Align Spline: Calculation-----------------------}
procedure TSurface.AlnSplineCalc;                                                                                                              {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_var,sel_var,sgr_var do
    AlignPts
    (
      sln_pts,
      sel_pts_inds,
      sln_pts_cnt,
      sel_pts_cnt
    );
end; {$endregion}
{Select Pivot: Calculation-----------------------}
procedure TSurface.SelectPivotCalc;                                                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (not show_spline) then
    Exit;
  with obj_var,sln_var,sel_var,pvt_var do
    begin
      SubgraphCalc
      (
        has_sel_pts,
        sln_pts,
        fst_lst_sln_obj_pts,
        sln_obj_ind,
        sln_obj_cnt,
        sln_pts_cnt
      );
      is_not_abst_obj_kind_after:=IsAnotherObjKindAfter4
      (
        kooCurve,
        sel_obj_min_ind
      );
      PivotCalc
      (
        sln_pts,
        sel_pts_inds,
        sel_pts_cnt
      );
      {if (clip_style=csAdvancedClip) then
        begin
          //ncs_adv_clip_rect:=NCSRectCalc(selected_pts_rect,bucket_rect.Width,bucket_rct.Height);
          //AdvancedClipCalc(pts:array of TPointPosF; pts_count:integer; is_pt_marked:aray of boolean);
        end;}
    end;
end; {$endregion}
{Select Pivot: Drawing---------------------------}
procedure TSurface.SelectPivotDraw;                                                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
  editor_or_game: set of byte;
begin
  if (not show_spline) then
    Exit;
  with fast_image_proc_var,obj_var,sln_var,sel_var do
    begin
      editor_or_game:=[0,1+Byte(res_var_ptr^)];
      if (not is_not_abst_obj_kind_after) then
        ClrSplineAll(sel_obj_min_ind,obj_cnt-1);
      for i:=0 to sln_obj_cnt-1 do
        begin
          j:=obj_arr[curve_inds_obj_arr[i]].t_ind;
          if (j>=sel_obj_min_ind) and (j<=obj_cnt-1) and (obj_arr[curve_inds_obj_arr[i]].obj_show in editor_or_game) then
            begin
              if (has_sel_pts[i]<>0) then
                begin
                  {Edges}
                  with eds_img_arr[i],local_prop do
                    if (eds_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) then
                      begin
                        if ChkNTValueArr then
                          begin
                            AddSplineEds00(i);
                            CrtSplineEds  (i);
                          end;
                        RepSplineEds  (i);
                        AddSplineEds04(i);
                        CrtSplineEds  (i);
                      end;
                  {Points}
                  with pts_img_arr[i],local_prop do
                    if (pts_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) then
                      begin
                        AddSplineDupPts3(i);
                        RepSplinePts    (i);
                        AddSplinePts3   (i);
                        CrtSplinePts    (i);
                        ClrSplineDupPts3(i);
                      end;
                end;
            end;
        end;
      if (not is_not_abst_obj_kind_after) then
        FilScene(sel_obj_min_ind,obj_var.obj_cnt-1);
      SelPvtAndSplineEdsToBmp;
    end;
end; {$endregion}
{Unselect Pivot: Drawing-------------------------}
procedure TSurface.UnselectPivotDraw;                                                                                                          {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j           : integer;
  editor_or_game: set of byte;
begin
  if (not show_spline) then
    Exit;
  with obj_var,sln_var,sel_var,crc_sel_var,pvt_var do
    begin
      editor_or_game:=[0,1+Byte(res_var_ptr^)];
      if rectangles_calc then
        RctSplineAll1(sel_obj_min_ind,obj_cnt-1);
      for i:=0 to sln_obj_cnt-1 do
        begin
          j:=obj_arr[curve_inds_obj_arr[i]].t_ind;
          if (j>=sel_obj_min_ind) and (j<=obj_cnt-1) and (obj_arr[curve_inds_obj_arr[i]].obj_show in editor_or_game) then
            begin
              if (has_sel_pts[i]<>0) then
                begin
                  {Bounding Rectangles: Edges}
                  with rct_eds_img_arr[i],local_prop do
                    if (rct_eds_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) then
                      begin
                        lazy_repaint_prev:=IsRct1InRct2(rct_ent,rct_clp_ptr^);
                        AddSplineRctEds (i);
                        CrtSplineRctEds (i);
                      end;
                  {Bounding Rectangles: Points}
                  with rct_pts_img_arr[i],local_prop do
                    if (rct_pts_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) then
                      begin
                        lazy_repaint_prev:=IsRct1InRct2(rct_ent,rct_clp_ptr^);
                        AddSplineRctPts (i);
                        CrtSplineRctPts (i);
                      end;
                  {Edges}
                  with eds_img_arr[i],local_prop do
                    if (eds_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) then
                      begin
                        lazy_repaint_prev:=IsRct1InRct2(rct_ent,rct_clp_ptr^);
                        RepSplineEds    (i);
                        AddSplineEds03  (i);
                        CrtSplineEds    (i);
                      end;
                  {Points}
                  with pts_img_arr[i],local_prop do
                    if (pts_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) then
                      begin
                        lazy_repaint_prev:=IsRct1InRct2(rct_ent,rct_clp_ptr^);
                        AddSplineDupPts2(i);
                        RepSplinePts    (i);
                        AddSplinePts2   (i);
                        CrtSplinePts    (i);
                        ClrSplineDupPts2(i);
                      end;
                end;
            end;
        end;
      if (not is_not_abst_obj_kind_after) then
        FilScene(sel_obj_min_ind,obj_var.obj_cnt-1);
      SelPvtAndSplineEdsToBmp;
      SelPtsIndsToFalse1;
      FillByte((@has_sel_pts[0])^,Length(has_sel_pts),0);
      crc_sel_rct               :=Default(TRect  );
      pvt_pos                   :=Default(TPtPosF);
      move_pvt                  :=False;
      pvt_to_pt                 :=False;
      pvt_marker_draw           :=False;
      need_align_pivot_x        :=False;
      need_align_pivot_y        :=False;
      need_align_pivot_p        :=False;
      need_align_pivot_p2       :=False;
      is_not_abst_obj_kind_after:=True;
      sel_pts_cnt               :=0;
      outer_subgraph1_eds_cnt   :=0;
      outer_subgraph2_eds_cnt   :=0;
      outer_subgraph3_eds_cnt   :=0;
      inner_subgraph__eds_cnt   :=0;
      exp0                      :=(sel_pts_cnt >0);
      exp1                      :=(sel_pts_cnt<>sln_pts_cnt);
      exp2                      :=(sln_pts_cnt >0);
    end;
end; {$endregion}
{Add Spline: Calculation-------------------------}
procedure TSurface.AddSplineCalc;                                                                                                              {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (not show_spline) then
    Exit;
  with obj_var,sln_var do
    begin
      Add(kooCurve,world_axis_shift);
      SetObjBkgnd
      (
        @obj_arr[obj_cnt-1],
        srf_bmp_ptr,
        srf_bmp.width,
        srf_bmp.height,
        @inn_wnd_rct
      );
      AddSplineObj;
      CreateNode('Spline',IntToStr(obj_var.curve_cnt));
      ObjIndsCalc;
      ScTIndsCalc;
      CngPnVsCalc;
    end;
end; {$endregion}
{Add Spline: Hidden Lines Calc.------------------}
procedure TSurface.AddSplineHdLn;                                                                                                              {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (not show_spline) then
    Exit;
  with sln_var do
    begin
      {Edges}
      with eds_img_arr[sln_obj_cnt-1],local_prop do
        if hid_ln_elim then
          begin
            ArrClear      (eds_useless_fld_arr,
                           rct_clp_ptr^,
                           srf_bmp.width,
                           0);
            AddSplineEds07(sln_obj_cnt-1);
            ArrFill       (useless_arr,
                           @eds_useless_fld_arr[0],
                           srf_bmp.width,
                           srf_bmp.height,
                           rct_clp_ptr^);
            hid_ln_cnt   :=sln_obj_pts_cnt[sln_obj_cnt-1]-ArrNzItCnt(@has_edge[partial_pts_sum[sln_obj_cnt-1]],
                                                                     @useless_arr[0],
                                                                     sln_obj_pts_cnt[sln_obj_cnt-1]-1)-1;
            vis_ln_cnt   :=sln_obj_pts_cnt[sln_obj_cnt-1]-hid_ln_cnt-1;
            if (hid_ln_cnt=0) then
              Exit;
            SetLength     (sln_vis_eds_ind[sln_obj_cnt-1],
                           vis_ln_cnt);
            ArrNzItCrt    (@has_edge[partial_pts_sum[sln_obj_cnt-1]],
                           @useless_arr[0],
                           @sln_vis_eds_ind[sln_obj_cnt-1,0],
                           sln_obj_pts_cnt [sln_obj_cnt-1]-1,
                           vis_ln_cnt);
          end;
    end;
end; {$endregion}
{Add Spline: Has Edge(Lines) Calc.---------------}
procedure TSurface.AddSplineHsLn;                                                                                                              {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  sln_var.HasSplineEds(sln_var.sln_obj_cnt-1);
end; {$endregion}
{Add Spline: Drawing-----------------------------}
procedure TSurface.AddSplineDraw;                                                                                                              {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (not show_spline) then
    Exit;
  with fast_image_proc_var,sln_var do
    begin

      {Bounding Rectangles: Edges}
      with rct_eds_img_arr[sln_obj_cnt-1],local_prop do
        begin
          if rct_eds_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^)) then
            begin
              lazy_repaint_prev  :=IsRct1InRct2(rct_ent,rct_clp_ptr^);
              AddSplineRctEds(sln_obj_cnt-1);
              CrtSplineRctEds(sln_obj_cnt-1);
            end
          else
            lazy_repaint_prev:=False;
        end;

      {Bounding Rectangles: Points}
      with rct_pts_img_arr[sln_obj_cnt-1],local_prop do
        begin
          if rct_pts_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^)) then
            begin
              lazy_repaint_prev  :=IsRct1InRct2(rct_ent,rct_clp_ptr^);
              AddSplineRctPts(sln_obj_cnt-1);
              CrtSplineRctPts(sln_obj_cnt-1);
            end
          else
            lazy_repaint_prev:=False;
        end;

      {Edges}
      with eds_img_arr[sln_obj_cnt-1],local_prop do
        begin
          if eds_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^)) then
            begin
              lazy_repaint_prev  :=IsRct1InRct2(rct_ent,rct_clp_ptr^);
              if lazy_repaint_prev then
                begin
                  if byte_mode then
                    begin
                      if (not better_quality) then
                        begin
                          if hid_ln_elim then
                            begin
                              if (hid_ln_cnt=0) then
                                AddSplineEds15(sln_obj_cnt-1)
                              else
                                AddSplineEds11(sln_obj_cnt-1);
                            end
                          else
                            AddSplineEds09(sln_obj_cnt-1);
                        end
                      else
                        begin
                          if hid_ln_elim then
                            begin
                              if (hid_ln_cnt=0) then
                                AddSplineEds21(sln_obj_cnt-1)
                              else
                                AddSplineEds19(sln_obj_cnt-1);
                            end
                          else
                            AddSplineEds17(sln_obj_cnt-1);
                        end;
                    end
                  else
                    begin
                      if hid_ln_elim then
                        begin
                          if (hid_ln_cnt=0) then
                            AddSplineEds13(sln_obj_cnt-1)
                          else
                            AddSplineEds06(sln_obj_cnt-1);
                        end
                      else
                        AddSplineEds01(sln_obj_cnt-1);
                    end;
                end
              else
                begin
                  if byte_mode then
                    begin
                      if (not better_quality) then
                        begin
                          if hid_ln_elim then
                            begin
                              if (hid_ln_cnt=0) then
                                AddSplineEds14(sln_obj_cnt-1)
                              else
                                AddSplineEds10(sln_obj_cnt-1);
                            end
                          else
                            AddSplineEds08(sln_obj_cnt-1);
                        end
                      else
                        begin
                          if hid_ln_elim then
                            begin
                              if (hid_ln_cnt=0) then
                                AddSplineEds20(sln_obj_cnt-1)
                              else
                                AddSplineEds18(sln_obj_cnt-1);
                            end
                          else
                            AddSplineEds16(sln_obj_cnt-1);
                        end;
                    end
                  else
                    begin
                      if hid_ln_elim then
                        begin
                          if (hid_ln_cnt=0) then
                            AddSplineEds12(sln_obj_cnt-1)
                          else
                            AddSplineEds05(sln_obj_cnt-1);
                        end
                      else
                        AddSplineEds00(sln_obj_cnt-1);
                    end;
                end;
              CrtSplineEds   (sln_obj_cnt-1);
            end
          else
            lazy_repaint_prev:=False;
        end;

      {Points}
      with pts_img_arr[sln_obj_cnt-1],local_prop do
        begin
          if pts_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^)) then
            begin
              lazy_repaint_prev  :=IsRct1InRct2(rct_ent,rct_clp_ptr^);
              AddSplineDupPts0(sln_obj_cnt-1);
              if byte_mode then
                AddSplinePts4 (sln_obj_cnt-1)
              else
                AddSplinePts0 (sln_obj_cnt-1);
              CrtSplinePts    (sln_obj_cnt-1);
              ClrSplineDupPts0(sln_obj_cnt-1);
            end
          else
            lazy_repaint_prev:=False;
        end;

    end;
end; {$endregion}
{Add Tile Map: Calculation-----------------------}
procedure TSurface.AddTileMapCalc;                                                                                                             {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (not show_tile_map) then
    Exit;
  with obj_var,tlm_var do
    begin
      Add(kooTlMap,world_axis_shift);
      SetObjBkgnd
      (
        @obj_arr[obj_cnt-1],
        srf_bmp_ptr,
        srf_bmp.width,
        srf_bmp.height,
        @inn_wnd_rct
      );
      AddTileMapObj;

      CreateNode('Tile Map',IntToStr(obj_var.tlmap_cnt));
      ObjIndsCalc;
      ScTIndsCalc;
      CngPnVsCalc;
    end;
end; {$endregion}
{Scale Background: Calculation-------------------}
procedure TSurface.SclBckgdCalc;                                                                                                               {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PtsScl
  (
    PtPosF(world_axis.x,
           world_axis.y),
    tex_var.tex_bmp_rct_pts,
    PtPosF(DEFAULT_SCL_MUL,
           DEFAULT_SCL_MUL),
    cmr_var.scl_dir,
    0,
    1
  );
end; {$endregion}
{Scale Spline: Calculation-----------------------}
procedure TSurface.SclSplineCalc;                                                                                                              {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_var do
    PtsScl
    (
      PtPosF(world_axis.x,
             world_axis.y),
      sln_pts,
      PtPosF(DEFAULT_SCL_MUL,
             DEFAULT_SCL_MUL),
      cmr_var.scl_dir,
      0,
      sln_pts_cnt-1
    );
end; {$endregion}
{Repaint Splines with Hidden Lines---------------}
procedure TSurface.RepSplineHdLn;                                                                                                              {$ifdef Linux}[local];{$endif} {$region -fold}
var
  eds_img_arr_ptr        : PFastLine;
  eds_useless_fld_arr_ptr: PInteger;
  i                      : integer;
begin
  if (not show_spline) then
    Exit;
  with sln_var do
    begin
      eds_img_arr_ptr        :=Unaligned(@eds_img_arr        [0]);
      eds_useless_fld_arr_ptr:=Unaligned(@eds_useless_fld_arr[0]);
      for i:=0 to sln_obj_cnt-1 do
        with (eds_img_arr_ptr+i)^,local_prop do
          if hid_ln_elim then
            begin
              ArrClear     (eds_useless_fld_arr,
                            rct_clp_ptr^,
                            srf_bmp.width,
                            0);
              AddSplineEds07(i);
              ArrFill      (useless_arr,
                            eds_useless_fld_arr_ptr,
                            srf_bmp.width,
                            srf_bmp.height,
                            rct_clp_ptr^);
              hid_ln_cnt  :=sln_obj_pts_cnt[i]-ArrNzItCnt(@has_edge[partial_pts_sum[i]],
                                                          @useless_arr[0],
                                                          sln_obj_pts_cnt[i]-1)-1;
              vis_ln_cnt  :=sln_obj_pts_cnt[i]-hid_ln_cnt-1;
              if (hid_ln_cnt=0) then
                Exit;
              SetLength    (sln_vis_eds_ind[i],
                            vis_ln_cnt);
              ArrNzItCrt   (@has_edge[partial_pts_sum[i]],
                            @useless_arr[0],
                            @sln_vis_eds_ind[i,0],
                            sln_obj_pts_cnt [i]-1,
                            vis_ln_cnt);
            end;
    end;
end; {$endregion}
{Repaint Spline: Drawing-------------------------}
procedure TSurface.RepSplineDraw0;                                                                                                             {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_eds_var_ptr: PFastLine;
  rct_pts_var_ptr: PFastLine;
      eds_var_ptr: PFastLine;
      pts_var_ptr: PFastLine;
  //has_sel_pts_ptr: PByte;
  i              : integer;
  b              : boolean;
  b0 ,b1 ,b2 ,b3 : boolean;
  b0_,b1_,b2_,b3_: boolean;
  editor_or_game : set of byte;
begin
  if (not show_spline) then
    Exit;
  with obj_var,sln_var,fast_image_proc_var do
    begin
      editor_or_game :=[0,1+Byte(res_var_ptr^)];
      if rectangles_calc then
        RctSplineAll2(0,obj_var.obj_cnt-1){RctSplineAll0(0,sln_obj_cnt-1)};
      rct_eds_var_ptr:=Unaligned(@rct_eds_img_arr[0]);
      rct_pts_var_ptr:=Unaligned(@rct_pts_img_arr[0]);
          eds_var_ptr:=Unaligned(@    eds_img_arr[0]);
          pts_var_ptr:=Unaligned(@    pts_img_arr[0]);
      //has_sel_pts_ptr:=Unaligned(@has_sel_pts    [0]);
      b              :=spline_scale_calc or form_resize_calc or ((not repaint_spline_hid_ln_calc1) and repaint_spline_hid_ln_calc2);
      for i:=0 to sln_obj_cnt-1 do
        if (obj_arr[curve_inds_obj_arr[i]].obj_show in editor_or_game) then
          begin

            b:=b or obj_arr[curve_inds_obj_arr[i]].forced_repaint;

            {Bounding Rectangles: Edges}
            with (rct_eds_var_ptr+i)^,local_prop,fst_img do
              begin
                if (rct_eds_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) then
                  begin
                    b0 :=IsRct1InRct2(rct_ent,rct_clp_ptr^);
                    b0_:=(not b0){clipped} or (b0 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                    if b0_ then
                      begin
                        if free_mem_on_scale_down and (fst_img<>Nil) then
                          begin
                            fast_image_data_ptr0:=@fast_image_data;
                            ClrArr;
                          end;
                        AddSplineRctEds(i);
                        CrtSplineRctEds(i);
                      end;
                    lazy_repaint_prev:=b0;
                  end
                else
                  begin
                    if free_mem_on_out_of_wnd and (fst_img<>Nil) then
                      begin
                        fast_image_data_ptr0:=@fast_image_data;
                        ClrArr;
                      end;
                    lazy_repaint_prev:=False;
                  end;
              end;

            {Bounding Rectangles: Points}
            with (rct_pts_var_ptr+i)^,local_prop,fst_img do
              begin
                if (rct_pts_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) then
                  begin
                    b1 :=IsRct1InRct2(rct_ent,rct_clp_ptr^);
                    b1_:=(not b1){clipped} or (b1 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                    if b1_ then
                      begin
                        if free_mem_on_scale_down and (fst_img<>Nil) then
                          begin
                            fast_image_data_ptr0:=@fast_image_data;
                            ClrArr;
                          end;
                        AddSplineRctPts(i);
                        CrtSplineRctPts(i);
                      end;
                    lazy_repaint_prev:=b1;
                  end
                else
                  begin
                    if free_mem_on_out_of_wnd and (fst_img<>Nil) then
                      begin
                        fast_image_data_ptr0:=@fast_image_data;
                        ClrArr;
                      end;
                    lazy_repaint_prev:=False;
                  end;
              end;

            {Edges}
            with (eds_var_ptr+i)^,local_prop,fst_img do
              begin
                if (eds_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) then
                  begin
                    b2 :=IsRct1InRct2(rct_ent,rct_clp_ptr^);
                    b2_:=(not b2){clipped} or (b2 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                    if b2_ then
                      begin
                        if free_mem_on_scale_down and (fst_img<>Nil) then
                          begin
                            fast_image_data_ptr0:=@fast_image_data;
                            ClrArr;
                          end;
                        //if ((has_sel_pts_ptr+i)^=0) then
                          begin
                            if b2 then
                              begin
                                if byte_mode then
                                  begin
                                    if (not better_quality) then
                                      begin
                                        if hid_ln_elim then
                                          begin
                                            if (hid_ln_cnt=0) then
                                              AddSplineEds15(i)
                                            else
                                              AddSplineEds11(i);
                                          end
                                        else
                                          AddSplineEds09(i);
                                      end
                                    else
                                      begin
                                        if hid_ln_elim then
                                          begin
                                            if (hid_ln_cnt=0) then
                                              AddSplineEds21(i)
                                            else
                                              AddSplineEds19(i);
                                          end
                                        else
                                          AddSplineEds17(i);
                                      end;
                                  end
                                else
                                  begin
                                    if hid_ln_elim then
                                      begin
                                        if (hid_ln_cnt=0) then
                                          AddSplineEds13(i)
                                        else
                                          AddSplineEds06(i);
                                      end
                                    else
                                      AddSplineEds01(i);
                                  end;
                              end
                            else
                              begin
                                if byte_mode then
                                  begin
                                    if (not better_quality) then
                                      begin
                                        if hid_ln_elim then
                                          begin
                                            if (hid_ln_cnt=0) then
                                              AddSplineEds14(i)
                                            else
                                              AddSplineEds10(i);
                                          end
                                        else
                                          AddSplineEds08(i);
                                      end
                                    else
                                      begin
                                        if hid_ln_elim then
                                          begin
                                            if (hid_ln_cnt=0) then
                                              AddSplineEds20(i)
                                            else
                                              AddSplineEds18(i);
                                          end
                                        else
                                          AddSplineEds16(i);
                                      end;
                                  end
                                else
                                  begin
                                    if hid_ln_elim then
                                      begin
                                        if (hid_ln_cnt=0) then
                                          AddSplineEds12(i)
                                        else
                                          AddSplineEds05(i);
                                      end
                                    else
                                      AddSplineEds00(i);
                                  end;
                              end;
                          end
                        {else
                          AddSplineEds1(i)};
                        CrtSplineEds(i);
                      end;
                    lazy_repaint_prev:=b2;
                  end
                else
                  begin
                    if free_mem_on_out_of_wnd and (fst_img<>Nil) then
                      begin
                        fast_image_data_ptr0:=@fast_image_data;
                        ClrArr;
                      end;
                    lazy_repaint_prev:=False;
                  end;
              end;

            {Points}
            with (pts_var_ptr+i)^,local_prop,fst_img do
              begin
                if (pts_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) then
                  begin
                    b3 :=IsRct1InRct2(rct_ent,rct_clp_ptr^);
                    b3_:=(not b3){clipped} or (b3 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                    if b3_ then
                      begin
                        if free_mem_on_scale_down and (fst_img<>Nil) then
                          begin
                            fast_image_data_ptr0:=@fast_image_data;
                            ClrArr;
                          end;
                        //if ((has_sel_pts_ptr+i)^=0) then
                          begin
                            AddSplineDupPts0(i);
                            if byte_mode then
                              AddSplinePts4 (i)
                            else
                              AddSplinePts0 (i);
                            ClrSplineDupPts0(i);
                          end
                        {else
                          begin
                            AddSplineDupPts1(i);
                            if byte_mode then
                              AddSplinePts5 (i)
                            else
                              AddSplinePts1 (i);
                            ClrSplineDupPts1(i);
                          end};
                        CrtSplinePts(i);
                      end;
                    lazy_repaint_prev:=b3;
                  end
                else
                  begin
                    if free_mem_on_out_of_wnd and (fst_img<>Nil) then
                      begin
                        fast_image_data_ptr0:=@fast_image_data;
                        ClrArr;
                      end;
                    lazy_repaint_prev:=False;
                  end;
              end;

        end;
    end;

end; {$endregion}
procedure TSurface.RepSplineDraw1;                                                                                                             {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_eds_var_ptr: PFastLine;
  rct_pts_var_ptr: PFastLine;
      eds_var_ptr: PFastLine;
      pts_var_ptr: PFastLine;
  has_sel_pts_ptr: PByte;
  i              : integer;
  b              : boolean;
  b0 ,b1 ,b2 ,b3 : boolean;
  b0_,b1_,b2_,b3_: boolean;
  editor_or_game : set of byte;
begin
  if (not show_spline) then
    Exit;
  with fast_image_proc_var,obj_var,sln_var do
    begin
      editor_or_game :=[0,1+Byte(res_var_ptr^)];
      if rectangles_calc then
        RctSplineAll2(0,obj_var.obj_cnt-1){RctSplineAll0(0,sln_obj_cnt-1)};
      rct_eds_var_ptr:=Unaligned(@rct_eds_img_arr[0]);
      rct_pts_var_ptr:=Unaligned(@rct_pts_img_arr[0]);
          eds_var_ptr:=Unaligned(@    eds_img_arr[0]);
          pts_var_ptr:=Unaligned(@    pts_img_arr[0]);
      has_sel_pts_ptr:=Unaligned(@has_sel_pts    [0]);
      b              :=spline_scale_calc or form_resize_calc or (not repaint_spline_hid_ln_calc2);
      for i:=0 to sln_obj_cnt-1 do
        if (obj_arr[curve_inds_obj_arr[i]].obj_show in editor_or_game) then
          begin

            b:=b or obj_arr[curve_inds_obj_arr[i]].forced_repaint;

            {Bounding Rectangles: Edges}
            with (rct_eds_var_ptr+i)^,local_prop,fst_img do
              begin
                if (rct_eds_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) then
                  begin
                    b0 :=IsRct1InRct2(rct_ent,rct_clp_ptr^);
                    b0_:=(not b0){clipped} or (b0 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                    if b0_ then
                      begin
                        if free_mem_on_scale_down and (fst_img<>Nil) then
                          begin
                            fast_image_data_ptr0:=@fast_image_data;
                            ClrArr;
                          end;
                        AddSplineRctEds(i);
                        CrtSplineRctEds(i);
                      end;
                    lazy_repaint_prev:=b0;
                  end
                else
                  begin
                    if free_mem_on_out_of_wnd and (fst_img<>Nil) then
                      begin
                        fast_image_data_ptr0:=@fast_image_data;
                        ClrArr;
                      end;
                    lazy_repaint_prev:=False;
                  end;
              end;

            {Bounding Rectangles: Points}
            with (rct_pts_var_ptr+i)^,local_prop,fst_img do
              begin
                if (rct_pts_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) then
                  begin
                    b1 :=IsRct1InRct2(rct_ent,rct_clp_ptr^);
                    b1_:=(not b1){clipped} or (b1 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                    if b1_ then
                      begin
                        if free_mem_on_scale_down and (fst_img<>Nil) then
                          begin
                            fast_image_data_ptr0:=@fast_image_data;
                            ClrArr;
                          end;
                        AddSplineRctPts(i);
                        CrtSplineRctPts(i);
                      end;
                    lazy_repaint_prev:=b1;
                  end
                else
                  begin
                    if free_mem_on_out_of_wnd and (fst_img<>Nil) then
                      begin
                        fast_image_data_ptr0:=@fast_image_data;
                        ClrArr;
                      end;
                    lazy_repaint_prev:=False;
                  end;
              end;

            {Edges}
            with (eds_var_ptr+i)^,local_prop,fst_img do
              begin
                if (eds_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) then
                  begin
                    b2 :=IsRct1InRct2(rct_ent,rct_clp_ptr^);
                    b2_:=(not b2){clipped} or (b2 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                    if b2_ then
                      begin
                        if free_mem_on_scale_down and (fst_img<>Nil) then
                          begin
                            fast_image_data_ptr0:=@fast_image_data;
                            ClrArr;
                          end;
                        if ((has_sel_pts_ptr+i)^=0) then
                          AddSplineEds00(i)
                        else
                          AddSplineEds02(i);
                        CrtSplineEds    (i);
                      end;
                    lazy_repaint_prev:=b2;
                  end
                else
                  begin
                    if free_mem_on_out_of_wnd and (fst_img<>Nil) then
                      begin
                        fast_image_data_ptr0:=@fast_image_data;
                        ClrArr;
                      end;
                    lazy_repaint_prev:=False;
                  end;
              end;

            {Points}
            with (pts_var_ptr+i)^,local_prop,fst_img do
              begin
                if (pts_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) then
                  begin
                    b3 :=IsRct1InRct2(rct_ent,rct_clp_ptr^);
                    b3_:=(not b3){clipped} or (b3 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                    if b3_ then
                      begin
                        if free_mem_on_scale_down and (fst_img<>Nil) then
                          begin
                            fast_image_data_ptr0:=@fast_image_data;
                            ClrArr;
                          end;
                        if ((has_sel_pts_ptr+i)^=0) then
                          begin
                            AddSplineDupPts0(i);
                            AddSplinePts0   (i);
                            ClrSplineDupPts0(i);
                          end
                        else
                          begin
                            AddSplineDupPts1(i);
                            AddSplinePts1   (i);
                            ClrSplineDupPts1(i);
                          end;
                        CrtSplinePts(i);
                      end;
                    lazy_repaint_prev:=b3;
                  end
                else
                  begin
                    if free_mem_on_out_of_wnd and (fst_img<>Nil) then
                      begin
                        fast_image_data_ptr0:=@fast_image_data;
                        ClrArr;
                      end;
                    lazy_repaint_prev:=False;
                  end;
              end;

        end;
    end;

end; {$endregion}
{Duplicated Points: Drawing----------------------}
procedure TSurface.DupPtsDraw;                                                                                                                 {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_var do
    ArrFill(dup_pts_arr,srf_bmp_ptr,srf_bmp.width,srf_bmp.height,inn_wnd_rct,clGreen);
end; {$endregion}
{Sprite Sheet: Reset Background Settings---------}
procedure TSurface.SpriteSheetSetBckgd;                                                                                                        {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to Length(sprite_sheet_arr)-1 do
    with sprite_sheet_arr[i],fast_image_proc_var do
      begin
        fast_image_data_ptr0:=@fast_image_data;
        SetBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,inn_wnd_rct);
      end;
end; {$endregion}
{Actors      : Reset Background Settings---------}
procedure TSurface.ActSetBckgd;                                                                                                                {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_actor_set_var.d_icon,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      SetBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,inn_wnd_rct);
    end;
end; {$endregion}
{Selected Subgraph: Drawing----------------------}
procedure TSurface.SelectedSubgrtaphDraw;                                                                                                      {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_var,sel_var,pvt_var do
    begin
      //SelPtsPosCalc     (Trunc(pvt_pos.x),Trunc(pvt_pos.y));
      //WholeSubgraphDraw0(Trunc(pvt_pos.x),Trunc(pvt_pos.y),pvt_pos,sln_pts,srf_bmp_ptr,inn_wnd_rct,ClippedRct(inn_wnd_rct,sel_pts_rct));
      FillSelBmpAndSelPtsBRectDraw;
    end;
end; {$endregion}
{Background Post-Processing----------------------}
procedure TSurface.BkgPP;                                                                                                                      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i:integer;
begin
  if (bg_style=bsGrayscale) or (bg_style=bsBoth) then
    PPGrayscaleG(srf_bmp_ptr,inn_wnd_rct,srf_bmp.width);
  if (bg_style=bsBlur) or (bg_style=bsBoth) then
    for i:=0 to pp_iters_cnt-1 do
      PPBlur(srf_bmp_ptr,inn_wnd_rct,srf_bmp.width);
end; {$endregion}
{Grid Post-Processing----------------------------}
procedure TSurface.GrdPP;                                                                                                                      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to 1 do
    PPBlur(srf_bmp_ptr,
           inn_wnd_rct,
           srf_bmp.width,
           11);
end; {$endregion}
{Main Render Procedure}
procedure TSurface.MainDraw;                                                                                                                   {$ifdef Linux}[local];{$endif} {$region -fold}
var
  execution_time: double;
begin

  //exec_timer:=TPerformanceTime.Create;
  exec_timer.Start;

  {Calculation of Some Expressions}
  if (sel_var<>Nil) then
    begin
      exp0               :=(sel_var.sel_pts_cnt>0);
      sel_var.sel_pts    :=sel_var.sel_pts   and exp0;
      sel_eds_draw_calc  :=sel_eds_draw_calc and exp0;
      bkg_pp_calc        :=bkg_pp_calc       and exp0;
    end;
  if (sln_var<>Nil) then
    begin
      exp2               :=(sln_var.sln_pts_cnt>0);
      repaint_spline_calc:=repaint_spline_calc and exp2;
    end;
  if (down_play_anim_ptr<>Nil) then
    begin
      timeline_draw      :=(down_play_anim_ptr^);
      cursor_draw        :=(down_play_anim_ptr^);
    end;

  {Rectangles----------------------------} {$region -fold}
  if main_bmp_rect_calc then
    MainBmpRectCalc; {$endregion}

  {Sizes---------------------------------} {$region -fold}
  if main_bmp_size_calc then
    MainBmpSizeCalc; {$endregion}

  {Handles ------------------------------} {$region -fold}
  if form_resize_calc then
    GetHandles; {$endregion}

  {Arrays--------------------------------} {$region -fold}
  if main_bmp_arrs_calc then
    MainBmpArrsCalc; {$endregion}

  {Background Settings: Sprite Sheet-----} {$region -fold}
  if sprite_sheet_set_bckgd then
    SpriteSheetSetBckgd; {$endregion}

  {Background Settings: Actors-----------} {$region -fold}
  if actor_set_bckgd then
    ActSetBckgd; {$endregion}

  {Scale Background----------------------} {$region -fold}
    if bckgd_scale_calc then
      SclBckgdCalc; {$endregion}

  {Add Spline----------------------------} {$region -fold}
  if add_spline_calc then
    AddSplineCalc; {$endregion}

  {Scale Splines-------------------------} {$region -fold}
  if spline_scale_calc then
    SclSplineCalc; {$endregion}

  {Align Splines-------------------------} {$region -fold}
  if sgr_var.align_pts and align_pts_calc then
    AlnSplineCalc; {$endregion}

  {Add Tile Map--------------------------} {$region -fold}
  if add_tlmap_calc then
    AddTileMapCalc; {$endregion}

  {Select Pivot--------------------------} {$region -fold}
  if sel_var.sel_pts then
    SelectPivotCalc; {$endregion}

  need_repaint:=True;

  {Select Pivot-------------------------------------} {$region -fold}
  if sel_var.sel_pts then
    SelectPivotDraw; {$endregion}

  {Unselect Pivot-----------------------------------} {$region -fold}
  if unselect_pivot_calc then
    UnselectPivotDraw; {$endregion}

  {Add Spline: Hidden Lines Calc.-------------------} {$region -fold}
  if add_hid_ln_calc then
    AddSplineHdLn; {$endregion}

  {Add Spline: Has Edge Calc.-----------------------} {$region -fold}
  if has_edge_calc then
    AddSplineHsLn; {$endregion}

  {Add Spline---------------------------------------} {$region -fold}
  if add_spline_calc then
    AddSplineDraw; {$endregion}

  {Repaint Splines: Hidden Lines--------------------} {$region -fold}
  if repaint_spline_hid_ln_calc0 then
    RepSplineHdLn; {$endregion}

  {Repaint Splines----------------------------------} {$region -fold}
  if repaint_spline_calc then
    begin
      if down_select_items_ptr^ and (not sel_var.sel_pts) then
        RepSplineDraw1
      else
        RepSplineDraw0;
    end; {$endregion}

  {Scene Drawing(Lower Layer)-----------------------} {$region -fold}
  if ((fill_scene_calc and sel_var.is_not_abst_obj_kind_after and (not unselect_pivot_calc)) or form_resize_calc or bckgd_scale_calc) then
    with obj_var do
      FilScene(0,low_lr_obj_cnt-1); {$endregion}

  {Copy Main Buffer To Lower Buffer-----------------} {$region -fold}
  if copy1_calc then
    MainBmpToLowerBmp; {$endregion}

  {Scene Drawing(Upper Layer)-----------------------} {$region -fold}
  if ((fill_scene_calc and sel_var.is_not_abst_obj_kind_after and (not unselect_pivot_calc)) or form_resize_calc or bckgd_scale_calc) and (not down_play_anim_ptr^) then
    with obj_var do
      FilScene(low_lr_obj_cnt,obj_cnt-1); {$endregion}

  {Background Post-Processing After Points Selection} {$region -fold}
  if bkg_pp_calc then
    BkgPP; {$endregion}

  {Copy Main Buffer To Lower Buffer-----------------} {$region -fold}
  if copy2_calc then
    MainBmpToLowerBmp; {$endregion}

  {World Axis---------------------------------------} {$region -fold}
  if show_world_axis and (not exp0) then
    WorldAxisDraw; {$endregion}

  {Copy Main Buffer To Lower Buffer-----------------} {$region -fold}
  if copy4_calc then
    MainBmpToLowerBmp; {$endregion}

  {Inner Window Rectangle---------------------------} {$region -fold}
  if (inn_wnd_mrg>0) then
    InnerWindowDraw($00FF9F66); {$endregion}

  {Copy Main Buffer To Lower Buffer-----------------} {$region -fold}
  if copy5_calc then
    MainBmpToLowerBmp; {$endregion}

  {Selected Subgrtaph-------------------------------} {$region -fold}
  if sel_eds_draw_calc then
    SelectedSubgrtaphDraw; {$endregion}

  {Copy Main Buffer To Lower Buffer-----------------} {$region -fold}
  if copy6_calc then
    MainBmpToLowerBmp; {$endregion}

  {Pivot--------------------------------------------} {$region -fold}
  if exp0 then
    pvt_var.PivotDraw(PtPos(0,0),Trunc(pvt_var.pvt_pos.x),Trunc(pvt_var.pvt_pos.y)); {$endregion}

  {Copy Main Buffer To Lower Buffer ----------------} {$region -fold}
  if copy7_calc then
    MainBmpToLowerBmp; {$endregion}

  {Copy Main Buffer To Lower Buffer 2---------------} {$region -fold}
  if copy8_calc then
    MainBmpToLowerBmp2; {$endregion}

  {Invalidate Drawing Area(Editor Inner Window)-----} {$region -fold}
  if (not down_play_anim_ptr^) then
    InvalidateInnerWindow; {$endregion}

  need_repaint:=False;

(******************************************************************************)

  exec_timer.Stop;
  execution_time:=Trunc(exec_timer.Delay*1000);

  {Log.}
  DrawObjectInfo0;
  DrawObjectInfo1
  (
    inn_wnd_rct.right -170,
    inn_wnd_rct.bottom-030,
    srf_bmp,
    'Execution time: '+FloatToStr(execution_time)+' ms.'
  );

end; {$endregion}
procedure TSurface.EventGroupsCalc(var arr:TBool2Arr; event_group:TEventGroupEnum);                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  for b in event_group do
    arr[b]:=True;
  MainDraw;
  for b in event_group do
    arr[b]:=False;
end; {$endregion}
{$endregion}

// (Camera) Камера:
{LI} {$region -fold}
constructor TCamera.Create(w,h:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  bmp_rect :=PtBounds(0,0,w,h);
  speed_mul:=PtPosF  (1.0,1.0);
end; {$endregion}
destructor  TCamera.Destroy;            {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
{$endregion}

// (Texture) Текстура:
{LI} {$region -fold}
constructor TTex.Create(w,h:TColor);                                   {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  srf_var_ptr:=@srf_var;
  obj_var.Add(kooBkTex,srf_var_ptr^.world_axis_shift);
  CreateNode('Background Texture','');
  ObjIndsCalc;
  ScTIndsCalc;
  CngPnVsCalc;
  SetLength(tex_bmp_rct_pts       ,2);
  SetLength(tex_bmp_rct_origin_pts,2);
  SetLength(tex_list              ,8); // Выделение памяти для массива текстур
  with srf_var_ptr^ do
    begin
      tex_bmp_rct_origin_pts[0].x:=296{Trunc(inn_wnd_rct.left+inn_wnd_rct.right -w)>>1};
      tex_bmp_rct_origin_pts[0].y:=034{Trunc(inn_wnd_rct.top +inn_wnd_rct.bottom-h)>>1};
      tex_bmp_rct_origin_pts[1].x:=tex_bmp_rct_origin_pts[0].x+w;
      tex_bmp_rct_origin_pts[1].y:=tex_bmp_rct_origin_pts[0].y+h;
      tex_bmp_rct_pts            :=tex_bmp_rct_origin_pts;
    end;
  loaded_picture    :=TPicture.Create;
  tex_bmp           :=Graphics.TBitmap.Create;
  tex_bmp.Width     :=w;
  tex_bmp.Height    :=h;
  tex_list_item_size:=256;
  show_tex          :=True;
end; {$endregion}
destructor TTex.Destroy;                                               {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure CreateTextureList;                                           {$ifdef Linux}[local];{$endif} {$region -fold}
var
  texture_list_item        : TSpeedButton;
  texture_list_item_picture: Graphics.TBitmap;
begin
  F_MainForm.FP_Image_List.Caption:='';
  texture_list_item        :=TSpeedButton.Create(Nil);
  texture_list_item_picture:=Graphics.TBitmap.Create;
  with texture_list_item,tex_var,srf_var_ptr^ do
    begin
      texture_list_item.OnMouseDown:=@F_MainForm.TextureListItemMouseDown;
      BorderSpacing.Around:=2;
      Color               :=$00A6A6A6;
      AllowAllUp          :=True;
      Flat                :=True;
      Transparent         :=False;
      Width               :=tex_list_item_size;
      Height              :=tex_list_item_size;
      Parent              :=F_MainForm.FP_Image_List;
      if (loaded_picture.Width=loaded_picture.height) then
        with texture_list_item_picture do
          begin
            width :=tex_list_item_size-6;
            height:=width;
          end;
      if (loaded_picture.width>loaded_picture.height) then
        with texture_list_item_picture do
          begin
            width :=tex_list_item_size-6;
            height:=Trunc((loaded_picture.height*width)/loaded_picture.width);
          end;
      if (loaded_picture.width<loaded_picture.height) then
        with texture_list_item_picture do
          begin
            height:=tex_list_item_size-6;
            width :=Trunc((loaded_picture.width*height)/loaded_picture.height);
          end;
      texture_list_item_picture.Canvas.StretchDraw(Rect(0,0,
                                                        texture_list_item_picture.width,
                                                        texture_list_item_picture.height),
                                                   loaded_picture.Graphic);
      Glyph.width :=tex_list_item_size-6;
      Glyph.height:=tex_list_item_size-6;
      Glyph       :=texture_list_item_picture;
    end;
end; {$endregion}
procedure TTex.LoadTexture;                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with srf_var_ptr^ do
    begin
      F_MainForm.SB_StatusBar1.Panels.Items[2].Text:='  '+F_MainForm.OpenPictureDialog1.Filename;
      CreateTextureList;
      is_tex_enabled:=True;
      AlignPictureToCenter;
      if down_select_items_ptr^ then
        begin
          crc_sel_var.crc_sel_rct:=Default(TRect);
          rct_sel_var.rct_sel    :=Default(TRect);
        end;
      tex_bmp_ptr   :=GetBmpHandle(tex_bmp);
      tex_bmp.width :=Trunc(tex_bmp_rct_pts[1].x-tex_bmp_rct_pts[0].x);
      tex_bmp.height:=Trunc(tex_bmp_rct_pts[1].y-tex_bmp_rct_pts[0].y);
      tex_bmp.Canvas.Draw(0,0,loaded_picture.Bitmap);
      EventGroupsCalc(calc_arr,[6,8,9,18,23,30,31,32]);
    end;
end; {$endregion}
procedure TTex.TexToBmp(rect_dst:TPtRect; canvas_dst:TCanvas); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with canvas_dst,rect_dst do
    if is_tex_enabled then
      StretchDraw
      (
        Rect
        (
          left,
          top,
          right,
          bottom
        ),
        tex_bmp
      );
end; {$endregion}
procedure TTex.AlignPictureToCenter;                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  tex_bmp_rct_width,tex_bmp_rct_height: integer;
begin
  if is_tex_enabled then
    begin
      tex_bmp_rct_width :=loaded_picture.width;
      tex_bmp_rct_height:=loaded_picture.height;
    end
  else
    begin
      tex_bmp_rct_width :={512}Trunc(tex_bmp_rct_origin_pts[1].x)-Trunc(tex_bmp_rct_origin_pts[0].x);
      tex_bmp_rct_height:={512}Trunc(tex_bmp_rct_origin_pts[1].y)-Trunc(tex_bmp_rct_origin_pts[0].y);
    end;
  tex_bmp_rct_pts[0].x:=((splitters_arr[1]^   +
                          splitters_arr[3]^   -
                          tex_bmp_rct_width+
                          splitter_thickness)/2);
  tex_bmp_rct_pts[0].y:=((splitters_arr[5]^    +
                          splitters_arr[2]^    -
                          tex_bmp_rct_height+
                          splitter_thickness)/2);
  tex_bmp_rct_pts[1].x:=tex_bmp_rct_pts[0].x+tex_bmp_rct_width ;
  tex_bmp_rct_pts[1].y:=tex_bmp_rct_pts[0].y+tex_bmp_rct_height;
end; {$endregion}
procedure TTex.FilBkTexObj(constref bktex_ind:TColor);         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if show_tex then
    with obj_var.obj_arr[obj_var.bktex_inds_obj_arr[bktex_ind]] do
      TexToBmp(PtRct(tex_bmp_rct_pts),srf_var_ptr^.srf_bmp.Canvas);
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.TextureListItemMouseDown(sender:TObject; button:TMouseButton; shift:TShiftState; x,y:integer); {$region -fold}
{var
  item_index,i,j: integer;}
begin
  {item_index:=Trunc(tex_list_item_pos_x/tex_var.tex_list_item_size);
  if (item_index<=FP_Image_List.ControlCount-1) then
    begin
      (FP_Image_List.Controls[item_index] as TSpeedButton).Color:=$00884E2B;
      for i:=0 to item_index-1 do
        (FP_Image_List.Controls[i] as TSpeedButton).Color:=$00A6A6A6;
      for j:=item_index+1 to FP_Image_List.ControlCount-1 do
        (FP_Image_List.Controls[j] as TSpeedButton).Color:=$00A6A6A6;
    end;}
end; {$endregion}
procedure TF_MainForm.SB_Load_ImageClick      (sender:TObject);                                                      {$region -fold}
begin
  SB_Load_Image.Down:=False;
  OpenPictureDialog1.Options:=OpenPictureDialog1.Options+[ofFileMustExist];
  if (not OpenPictureDialog1.Execute) then
    Exit;
  try
    tex_var.loaded_picture.LoadFromFile(OpenPictureDialog1.Filename);
  except
    on E: Exception do
      MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
  end;
  tex_var.LoadTexture;
  MI_Antialiasing.Checked:=True;
  tex_var.srf_var_ptr^.srf_bmp.Canvas.Antialiasingmode:=amOn;
end; {$endregion}
procedure TF_MainForm.SB_Save_ImageClick      (sender:TObject);                                                      {$region -fold}
begin
  SB_Save_Image.Down:=False;
  if tex_var.loaded_picture.Graphic=Nil then
    begin
      MessageDlg('No image','Please open an image, before save',mtError,[mbOk],0);
      Exit;
    end;
  SavePictureDialog1.Options:=SavePictureDialog1.Options+[ofPathMustExist];
  if (not SavePictureDialog1.Execute) then
    Exit;
  try
    tex_var.loaded_picture.SaveToFile(SavePictureDialog1.Filename);
  except
    on E: Exception do
      MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
  end;
end; {$endregion}
{$endregion}

// (Grid) Сетка:
{LI} {$region -fold}
constructor TRGrid.Create(w,h:TColor);                                                                                                          {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  srf_var_ptr:=@srf_var;
  obj_var.Add(kooRGrid,srf_var_ptr^.world_axis_shift);
  CreateNode('Regular Grid','');
  ObjIndsCalc;
  ScTIndsCalc;
  CngPnVsCalc;
  rgrid_dnt  :=64;
  rgrid_color:=$00ABAFA3;
  show_grid  :=True;
end; {$endregion}
destructor  TRGrid.Destroy;                                                                                                                     {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure   TRGrid.RGridToBmp(constref pvt:TPtPosF; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; rct_clp_ptr:PPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  sht_pow_mul  : double;
  w_inc,h_inc  : double;
  sht_pow_mul_ : integer;
  w_inc_,h_inc_: integer;
  pvt_x,pvt_y  : integer;
  i,x0,y0,x1,y1: integer;
begin
  with rct_clp_ptr^ do
    begin
      sht_pow_mul :=rgrid_dnt*Power(DEFAULT_SCL_MUL,cmr_var.scl_dif);
      sht_pow_mul_:=Trunc(sht_pow_mul*$10000);
      pvt_x       :=Trunc(pvt.x      *$10000);
      pvt_y       :=Trunc(pvt.y      *$10000);

      // Horizontal Lines:
      x0    :=left;
      x1    :=left+width;
      h_inc :=0;
      h_inc_:=Trunc(h_inc*$10000);
      for i :=0 to Trunc((pvt.y-top)/sht_pow_mul) do
        begin
          y0:=(pvt_y-h_inc_)>>16;
          if LineHC(x0,y0,x1,rct_clp_ptr^) then
             LineH (x0,y0,x1,bmp_dst_ptr,bmp_dst_width,{clRed}rgrid_color);
          h_inc_+=sht_pow_mul_;
        end;
      h_inc :=sht_pow_mul;
      h_inc_:=Trunc(h_inc*$10000);
      for i :=0 to Trunc((bottom-pvt.y)/sht_pow_mul)-1 do
        begin
          y0:=(pvt_y+h_inc_)>>16;
          if LineHC(x0,y0,x1,rct_clp_ptr^) then
             LineH (x0,y0,x1,bmp_dst_ptr,bmp_dst_width,{clGreen}rgrid_color);
          h_inc_+=sht_pow_mul_;
        end;

      // Vertical Lines:
      y0    :=top;
      y1    :=top+height;
      w_inc :=0;
      w_inc_:=Trunc(w_inc*$10000);
      for i :=0 to Trunc((pvt.x-left)/sht_pow_mul) do
        begin
          x0:=(pvt_x-w_inc_)>>16;
          if LineVC(x0,y0,y1,rct_clp_ptr^) then
             LineV (x0,y0,y1,bmp_dst_ptr,bmp_dst_width,{clWhite}rgrid_color);
          w_inc_+=sht_pow_mul_;
        end;
      w_inc :=sht_pow_mul;
      w_inc_:=Trunc(w_inc*$10000);
      for i :=0 to Trunc((right-pvt.x)/sht_pow_mul)-1 do
        begin
          x0:=(pvt_x+w_inc_)>>16;
          if LineVC(x0,y0,y1,rct_clp_ptr^) then
             LineV (x0,y0,y1,bmp_dst_ptr,bmp_dst_width,{clBlack}rgrid_color);
          w_inc_+=sht_pow_mul_;
        end;

    end;
end; {$endregion}
procedure   TRGrid.FilRGridObj(constref rgrid_ind:TColor);                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
begin
  with srf_var_ptr^ do
    if show_grid then
      begin
        obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.rgrid_inds_obj_arr[rgrid_ind]]);
        with obj_arr_ptr^ do
          RGridToBmp(PtPosF(world_axis.x+world_axis_shift.x,
                            world_axis.y+world_axis_shift.y),
                            bkgnd_ptr,
                            bkgnd_width,
                            rct_clp_ptr);
      end;
end; {$endregion}
procedure   TRGrid.MovRGridObj(constref rgrid_ind:TColor);                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
begin
  with srf_var_ptr^ do
    if show_grid then
      begin
        obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.rgrid_inds_obj_arr[rgrid_ind]]);
        with obj_arr_ptr^ do
          RGridToBmp(PtPosF(world_axis.x+world_axis_shift.x,
                            world_axis.y+world_axis_shift.y),
                            bkgnd_ptr,
                            bkgnd_width,
                            rct_dst_ptr);
      end;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_RGridClick      (sender:TObject);                                                                                                                  {$region -fold}
begin
  DrawingPanelsSetVisibility1(down_rgrid_ptr,P_RGrid,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_rgrid_ptr^) then
    Exit;
end; {$endregion}
procedure TF_MainForm.SB_RGrid_ColorClick(sender:TObject);                                                                                                                  {$region -fold}
begin
  CD_Select_Color.Color:=SB_RGrid_Color.Color;
  CD_Select_Color.Execute;
  rgr_var.rgrid_color  :=SetColorInv(CD_Select_Color.Color);
  SB_RGrid_Color.Color :=CD_Select_Color.Color;
  SB_RGrid_Color.Down  :=False;
  rgr_var.srf_var_ptr^.EventGroupsCalc(calc_arr,[30]);
  SpeedButtonRepaint;
end; {$endregion}
{$endregion}

// (Snap Grid) Сетка привязки:
{LI} {$region -fold}
constructor TSGrid.Create(w,h:TColor);                                                                                                          {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  srf_var_ptr:=@srf_var;
  obj_var.Add(kooSGrid,srf_var_ptr^.world_axis_shift);
  CreateNode('Snap Grid','');
  ObjIndsCalc;
  ScTIndsCalc;
  CngPnVsCalc;
  sgrid_dnt     :=16;
  sgrid_color   :=SetColorInv($007B6693);
  show_snap_grid:=True;
end; {$endregion}
destructor  TSGrid.Destroy;                                                                                                                     {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure   TSGrid.SGridToBmp(constref pvt:TPtPosF; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; rct_clp_ptr:PPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  sht_pow_mul  : double;
  w_inc,h_inc  : double;
  sht_pow_mul_ : integer;
  w_inc_,h_inc_: integer;
  pvt_x,pvt_y  : integer;
  i,x0,y0,x1,y1: integer;
begin
  with rct_clp_ptr^ do
    begin
      sht_pow_mul :=sgrid_dnt*Power(DEFAULT_SCL_MUL,cmr_var.scl_dif);
      sht_pow_mul_:=Trunc(sht_pow_mul*$10000);
      pvt_x       :=Trunc(pvt.x      *$10000);
      pvt_y       :=Trunc(pvt.y      *$10000);

      // Horizontal Lines:
      x0    :=left;
      x1    :=left+width;
      h_inc :=0;
      h_inc_:=Trunc(h_inc*$10000);
      for i :=0 to Trunc((pvt.y-top)/sht_pow_mul) do
        begin
          y0:=(pvt_y-h_inc_)>>16;
          if LineHC(x0,y0,x1,rct_clp_ptr^) then
             LineH (x0,y0,x1,bmp_dst_ptr,bmp_dst_width,{clRed}sgrid_color);
          h_inc_+=sht_pow_mul_;
        end;
      h_inc :=sht_pow_mul;
      h_inc_:=Trunc(h_inc*$10000);
      for i :=0 to Trunc((bottom-pvt.y)/sht_pow_mul)-1 do
        begin
          y0:=(pvt_y+h_inc_)>>16;
          if LineHC(x0,y0,x1,rct_clp_ptr^) then
             LineH (x0,y0,x1,bmp_dst_ptr,bmp_dst_width,{clGreen}sgrid_color);
          h_inc_+=sht_pow_mul_;
        end;

      // Vertical Lines:
      y0    :=top;
      y1    :=top+height;
      w_inc :=0;
      w_inc_:=Trunc(w_inc*$10000);
      for i :=0 to Trunc((pvt.x-left)/sht_pow_mul) do
        begin
          x0:=(pvt_x-w_inc_)>>16;
          if LineVC(x0,y0,y1,rct_clp_ptr^) then
             LineV (x0,y0,y1,bmp_dst_ptr,bmp_dst_width,{clWhite}sgrid_color);
          w_inc_+=sht_pow_mul_;
        end;
      w_inc :=sht_pow_mul;
      w_inc_:=Trunc(w_inc*$10000);
      for i :=0 to Trunc((right-pvt.x)/sht_pow_mul)-1 do
        begin
          x0:=(pvt_x+w_inc_)>>16;
          if LineVC(x0,y0,y1,rct_clp_ptr^) then
             LineV (x0,y0,y1,bmp_dst_ptr,bmp_dst_width,{clBlack}sgrid_color);
          w_inc_+=sht_pow_mul_;
        end;

    end;
end; {$endregion}
procedure   TSGrid.FilSGridObj(constref sgrid_ind:TColor);                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
begin   
  with srf_var_ptr^ do
    if show_snap_grid then
      begin   
        obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.sgrid_inds_obj_arr[sgrid_ind]]);
        with obj_arr_ptr^ do
          SGridToBmp(PtPosF(world_axis.x+world_axis_shift.x,
                            world_axis.y+world_axis_shift.y),
                            bkgnd_ptr,
                            bkgnd_width,
                            rct_clp_ptr);
      end;
end; {$endregion}
procedure   TSGrid.MovSGridObj(constref sgrid_ind:TColor);                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
begin
  with srf_var_ptr^ do
    if show_snap_grid then
      begin
        obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.sgrid_inds_obj_arr[sgrid_ind]]);
        with obj_arr_ptr^ do
          SGridToBmp(PtPosF(world_axis.x+world_axis_shift.x,
                            world_axis.y+world_axis_shift.y),
                            bkgnd_ptr,
                            bkgnd_width,
                            rct_dst_ptr);
      end;
end; {$endregion}
procedure   TSGrid.AlignPts(var pts:TPtPosFArr; const sel_pts_inds:TColorArr; const pts_cnt,sel_pts_cnt:TColor);                                {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_SGridClick                                (sender:TObject);                                                                                        {$region -fold}
begin
  DrawingPanelsSetVisibility1(down_sgrid_ptr,P_SGrid,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_sgrid_ptr^) then
    Exit;
end; {$endregion}
procedure TF_MainForm.P_2D_Operations_AutomaticMouseEnter          (sender:TObject);                                                                                        {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.P_2D_Operations_AutomaticMouseLeave          (sender:TObject);                                                                                        {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.SE_Align_2D_Points_Precision_UMouseEnter     (sender:TObject);                                                                                        {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.SE_Align_2D_Points_Precision_VMouseEnter     (sender:TObject);                                                                                        {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.SE_Align_2D_Points_Precision_UChange         (sender:TObject);                                                                                        {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.SE_Align_2D_Points_Precision_VChange         (sender:TObject);                                                                                        {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.SE_Align_2D_Points_Precision_UMouseLeave     (sender:TObject);                                                                                        {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.SE_Align_2D_Points_Precision_VMouseLeave     (sender:TObject);                                                                                        {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.CB_Align_2D_Points_Show_Snap_GridChange      (sender:TObject);                                                                                        {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.CB_Align_2D_Points_Snap_Grid_VisibilityChange(sender:TObject);                                                                                        {$region -fold}
begin
end; {$endregion}
{$endregion}

// (UV Grid) UV сетка:
{LI} {$region -fold}
constructor TUV.Create(w,h:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
destructor TUV.Destroy;             {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
{$endregion}

// (Intersection Graph) Граф пересечений:
{LI} {$region -fold}
constructor TISGraph.Create(w,h:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
begin

end; {$endregion}
destructor  TISGraph.Destroy;            {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure TISGraph.ISGraphCalc;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  i,j: integer;
  k  : integer=0;
  v_x: double =0.0;
  v_y: double =0.0;}
begin
  {if show_is_graph then
    if (spline_obj_count>1) then
      for i:=0 to spline_obj_count-1 do
        begin
          k+=spline_obj_pts_count[i];
          for j:=k to k+spline_obj_pts_count[i+1]-1 do
            v_x+=spline_pts[j].x;
          is_graph_pts[i].x:=v_x/spline_obj_pts_count[i+1];
          v_x:=0;
          for j:=k to k+spline_obj_pts_count[i+1]-1 do
            v_y+=spline_pts[j].y;
          is_graph_pts[i].y:=v_y/spline_obj_pts_count[i+1];
          v_y:=0;
        end;}
end; {$endregion}
procedure TISGraph.ISGraphDraw;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  i: integer;}
begin
  {with main_canvas_var.main_bmp.Canvas do
    if show_is_graph then
      if (spline_obj_count>1) then
        begin
          Pen.Mode:=pmCopy;
          Pen.Color:=clYellow;
          MoveTo(Trunc(is_graph_pts[spline_obj_count-1].x),
                 Trunc(is_graph_pts[spline_obj_count-1].y));
          for i:=0 to spline_obj_count-1 do
            LineTo(Trunc(is_graph_pts[i].x),
                   Trunc(is_graph_pts[i].y));
        end;}
end; {$endregion}
{$endregion}

// (Text) Текст:
{LI} {$region -fold}
constructor TFText.Create(w,h:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  srf_var_ptr:=@srf_var;
  global_prop:=ftext_default_prop;
end; {$endregion}
destructor TFText.Destroy;             {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_TextClick                 (sender:TObject); {$region -fold}
begin
  DrawingPanelsSetVisibility1(down_text_ptr,P_Text,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_text_ptr^) then
    Exit;
end; {$endregion}
{Drawing}
procedure TF_MainForm.P_Text_Drawing_PropMouseEnter(sender:TObject); {$region -fold}
begin
  P_Text_Drawing_Prop.Color:=HighLight(P_Text_Drawing_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Text_Drawing_PropMouseLeave(sender:TObject); {$region -fold}
begin
  P_Text_Drawing_Prop.Color:=Darken(P_Text_Drawing_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Text_SettingsMouseEnter    (sender:TObject); {$region -fold}
begin
  P_Text_Settings       .Color:=HighLight(P_Text_Settings       .Color,0,0,0,0,0,16);
  P_Text_Settings_Header.Color:=HighLight(P_Text_Settings_Header.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Text_SettingsMouseLeave    (sender:TObject); {$region -fold}
begin
  P_Text_Settings       .Color:=Darken(P_Text_Settings       .Color,0,0,0,0,0,16);
  P_Text_Settings_Header.Color:=Darken(P_Text_Settings_Header.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.CB_Text_BackgroundChange     (sender:TObject); {$region -fold}
begin
  txt_var.global_prop.bkgnd_draw:=not txt_var.global_prop.bkgnd_draw;
end; {$endregion}
procedure TF_MainForm.SB_Text_Select_FontClick     (sender:TObject); {$region -fold}
begin
  //SB_Text_Select_Font.Down:=False;
  if (not FontDialog1.Execute) then
    Exit;
  try
    with FontDialog1,Font do
      begin
        {SetTextInfo(txt_var.srf_var_ptr^.srf_bmp.Canvas,height,color,name,charset);
        txt_var.srf_var_ptr^.srf_bmp.Canvas.TextOut(10,400,'Start Demo');}
      end;
  except
    on E: Exception do
      MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
  end;
end; {$endregion}
{$endregion}

// (Brush) Кисть:
{LI} {$region -fold}
procedure BrushDraw(x,y:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_BrushClick(sender:TObject);                     {$region -fold}
begin
  DrawingPanelsSetVisibility1(down_brush_ptr,P_Brush,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_brush_ptr^) then
    Exit;
end; {$endregion}
{$endregion}

// (Spray) Спрей:
{LI} {$region -fold}
procedure SprayDraw(x,y,r:integer; custom_color:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rad,a  : double;
  i,m1,m2: integer;
begin
  a  :=Random*2*pi;
  rad:=Random*r;
  m1 :=Trunc(rad*Cos(a));
  m2 :=Trunc(rad*Sin(a));
  for i:=0 to 100 do
    tex_var.loaded_picture.Bitmap.Canvas.Pixels[X+m1,Y+m2]:=custom_color;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_SprayClick(sender:TObject);                                            {$region -fold}
begin
  DrawingPanelsSetVisibility1(down_spray_ptr,P_Spray,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_spray_ptr^) then
    Exit;
end; {$endregion}
{$endregion}

// (Spline) Сплайн:
{LI} {$region -fold}
constructor TCurve.Create          (constref w,h              :TColor);                                                                                                          {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  srf_var_ptr:=@srf_var;

  // spline edges bounding rectangles:
  rct_eds_big_img:=TFastLine.Create;
  with rct_eds_big_img do
    begin
      BuffersInit(w,h,False,True,False,False);
      SetBkgnd   (srf_var_ptr^.srf_bmp_ptr,srf_var_ptr^.srf_bmp.width,srf_var_ptr^.srf_bmp.height,@srf_var_ptr^.inn_wnd_rct);
    end;

  // spline points bounding rectangles:
  rct_pts_big_img:=TFastLine.Create;
  with rct_pts_big_img do
    begin
      BuffersInit(w,h,False,True,False,False);
      SetBkgnd   (srf_var_ptr^.srf_bmp_ptr,srf_var_ptr^.srf_bmp.width,srf_var_ptr^.srf_bmp.height,@srf_var_ptr^.inn_wnd_rct);
    end;

  // spline edges:
  eds_big_img:=TFastLine.Create;
  with eds_big_img do
    begin
      BuffersInit(w,h,True,True,False,True);
      SetBkgnd   (srf_var_ptr^.srf_bmp_ptr,srf_var_ptr^.srf_bmp.width,srf_var_ptr^.srf_bmp.height,@srf_var_ptr^.inn_wnd_rct);
    end;

  // spline points:
  pts_big_img:=TFastLine.Create;
  with pts_big_img do
    begin
      BuffersInit(w,h,True,True,False,True);
      SetBkgnd   (srf_var_ptr^.srf_bmp_ptr,srf_var_ptr^.srf_bmp.width,srf_var_ptr^.srf_bmp.height,@srf_var_ptr^.inn_wnd_rct);
    end;

  // duplicated points:
  SetLength      (dup_pts_arr,w*h);

  global_prop        :=curve_default_prop;
  has_hid_ln_elim_sln:=False;
  cur_tlt_dwn_btn_ind:=-1;
  show_spline        :=True;
  FmlSplineInit;
  SetLength(fml_pts,global_prop.cycloid_pts_cnt);

end; {$endregion}
destructor  TCurve.Destroy;                                                                                                                                                      {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure TCurve.PrimitiveComp     (constref spline_ind       :TColor;  constref pmt_var_ptr,pmt_big_var_ptr:PFastLine; pmt_bld_stl:TDrawingStyle);                    {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pmt_var_ptr^,fst_img,fast_image_data,fast_image_proc_var do
    begin
      with rct_vis do
        SetRctPos
        (
          left,
          top
        );
      with pmt_big_var_ptr^ do
        SetValInfo
        (
          ln_arr1_ptr,
          ln_arr1_ptr,
          ln_arr1_ptr,
          ln_arr_width,
          ln_arr_height
        );
      with obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]] do
        SetBkgnd
        (
          bkgnd_ptr,
          bkgnd_width,
          bkgnd_height,
          pmt_var_ptr^.rct_clp_ptr^
        );
      bmp_src_rct_clp          :=PtRct(rct_vis);
      img_kind                 :=1{11};
      pix_drw_type             :=1; //must be in range of [0..002]
      fx_cnt                   :=1; //must be in range of [0..255]
      fx_arr[0].rep_cnt        :=1; //must be in range of [0..255]
      fx_arr[0].nt_pix_srf_type:=1; //must be in range of [0..001]
      fx_arr[0].nt_pix_cfx_type:=GetEnumVal(pmt_bld_stl);
      fx_arr[0].pt_pix_srf_type:=1; //must be in range of [0..001]
      fx_arr[0].pt_pix_cfx_type:=fx_arr[0].nt_pix_cfx_type;
    //nt_pix_clp_type          :=0;
    //nt_pix_srf_type          :=0;
      col_trans_arr[2]         :=064;
      col_trans_arr[4]         :=100;
      col_trans_arr[5]         :=100;
      //pmt_big_var_ptr^.ln_arr0_ptr:=@pmt_big_var_ptr^.ln_arr0[0];
      if local_prop.byte_mode and (not down_select_items_ptr^) then
        begin
          bmp_alpha_ptr2:=pmt_big_var_ptr^.ln_arr0_ptr;
          better_quality:=local_prop.better_quality;
        end
      else
        begin
          bmp_alpha_ptr2:=Nil;
          better_quality:=False;
        end;
      remove_brunching_none:=local_prop.remove_brunching_none;
      need_store_value     :=down_select_items_ptr^;
      CmpProc[11];
      SetRctPos(bmp_src_rct_clp);
      SetSdrType;
      ShaderType;
    end;
end; {$endregion}
procedure TCurve.AddPoint          (constref x,y              :integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; var color_info:TColorInfo; constref rct_clp:TPtRect; var add_spline_calc_:boolean; sleep_:boolean=False); {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rad,a: double;
  m1   : integer=0;
  m2   : integer=0;
begin
  add_spline_calc_:=True;
  Inc(sln_pts_cnt);
  Inc(sln_pts_cnt_add);

  if (global_prop.sln_mode=smSpray) then
    begin
      a  :=Random*2*pi;
      rad:={Random*}global_prop.spray_rad;
      m1 :=Trunc(rad*Cos(a));
      m2 :=Trunc(rad*Sin(a));
    end;

  AddListItem(PtPosF(x-srf_var_ptr^.world_axis_shift.x+m1,y-srf_var_ptr^.world_axis_shift.y+m2),first_item,p1,p2);
  {SetLength(sln_pts_add,sln_pts_cnt_add);
  sln_pts_add[sln_pts_cnt_add-1].x:=x-srf_var_ptr^.world_axis_shift.x;
  sln_pts_add[sln_pts_cnt_add-1].y:=y-srf_var_ptr^.world_axis_shift.y;}

  SetColorInfo(clRed,color_info);
  Point(x+m1,y+m2,
        bmp_dst_ptr,
        bmp_dst_width,
        color_info,
        rct_clp);
  if sleep_ then
    {$ifdef Windows}
    Sleep (global_prop.sln_pts_frq);
    {$else}
    USleep(global_prop.sln_pts_frq*1000000);
    {$endif}
end; {$endregion}
procedure TCurve.RctSplineRct0     (constref spline_ind       :TColor;  var      rct_out_,rct_ent_:TRect);                                                             {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_eds_img_arr[spline_ind] do
    rct_out_:=Rect
    (
      rct_clp_ptr^.left,
      rct_clp_ptr^.top,
      rct_clp_ptr^.right,
      rct_clp_ptr^.bottom
    );
end; {$endregion}
procedure TCurve.RctSplineRct1     (constref spline_ind       :TColor;  var      rct_out_,rct_ent_:TRect);                                                             {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct_ent_:=PtsRngRctCalc
  (
    sln_pts,
    rct_bnd_ind_arr[spline_ind],
    partial_pts_sum[spline_ind],
    partial_pts_sum[spline_ind]+sln_obj_pts_cnt[spline_ind]-1
  );
end; {$endregion}
procedure TCurve.RctSplineRct2     (constref spline_ind       :TColor;  var      rct_out_,rct_ent_:TRect);                                                             {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PtRct(sln_pts,rct_bnd_ind_arr[spline_ind],rct_ent_);
end; {$endregion}
procedure TCurve.RctSplineRctEds   (constref spline_ind       :TColor;  constref rct_out_,rct_ent_:TRect);                                                             {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_eds_img_arr[spline_ind],local_prop do
    begin

      {Final   Rectangle} {$region -fold}
      rct_wnd:=eds_img_arr[spline_ind].rct_wnd; {$endregion}

      {Entire  Rectangle} {$region -fold}
      rct_ent:=eds_img_arr[spline_ind].rct_ent; {$endregion}

      {Clipped Rectangle} {$region -fold}
      rct_vis:=eds_img_arr[spline_ind].rct_vis; {$endregion}

    end;
end; {$endregion}
procedure TCurve.RctSplineRctPts   (constref spline_ind       :TColor;  constref rct_out_,rct_ent_:TRect);                                                             {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_pts_img_arr[spline_ind],local_prop do
    begin

      {Final   Rectangle} {$region -fold}
      rct_wnd:=pts_img_arr[spline_ind].rct_wnd; {$endregion}

      {Entire  Rectangle} {$region -fold}
      rct_ent:=pts_img_arr[spline_ind].rct_ent; {$endregion}

      {Clipped Rectangle} {$region -fold}
      rct_vis:=pts_img_arr[spline_ind].rct_vis; {$endregion}

    end;
end; {$endregion}
procedure TCurve.RctSplineEds      (constref spline_ind       :TColor;  constref rct_out_,rct_ent_:TRect);                                                             {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Final   Rectangle} {$region -fold}
      rct_wnd:=rct_out_; {$endregion}

      {Entire  Rectangle} {$region -fold}
      with rct_ent do
        begin
          obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
          left       :=rct_ent_.left  -eds_width_half-1+eds_width_odd+obj_arr_ptr^.world_axis_shift.x;
          top        :=rct_ent_.top   -eds_width_half-1+eds_width_odd+obj_arr_ptr^.world_axis_shift.y;
          right      :=rct_ent_.right +eds_width_half+1              +obj_arr_ptr^.world_axis_shift.x;
          bottom     :=rct_ent_.bottom+eds_width_half+1              +obj_arr_ptr^.world_axis_shift.y;
          width      :=right-left;
          height     :=bottom-top;
        end; {$endregion}

      {Clipped Rectangle} {$region -fold}
      rct_vis:=ClippedRct(rct_wnd,rct_ent,False); {$endregion}

    end;
end; {$endregion}
procedure TCurve.RctSplinePts      (constref spline_ind       :TColor;  constref rct_out_,rct_ent_:TRect);                                                             {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin

      {Final   Rectangle} {$region -fold}
      rct_wnd:=rct_out_; {$endregion}

      {Entire  Rectangle} {$region -fold}
      with rct_ent do
        begin
          obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
          left       :=rct_ent_.left  -pts_rct_inn_width >>1-pts_rct_tns_left  {{?}-1{?}}+pts_rct_width__odd+obj_arr_ptr^.world_axis_shift.x;
          top        :=rct_ent_.top   -pts_rct_inn_height>>1-pts_rct_tns_top   {{?}-1{?}}+pts_rct_height_odd+obj_arr_ptr^.world_axis_shift.y;
          right      :=rct_ent_.right +pts_rct_inn_width >>1+pts_rct_tns_right {{?}+1{?}}                   +obj_arr_ptr^.world_axis_shift.x;
          bottom     :=rct_ent_.bottom+pts_rct_inn_height>>1+pts_rct_tns_bottom{{?}+1{?}}                   +obj_arr_ptr^.world_axis_shift.y;
          width      :=right-left;
          height     :=bottom-top;
        end; {$endregion}

      {Clipped Rectangle} {$region -fold}
      rct_vis:=ClippedRct(rct_wnd,rct_ent,False); {$endregion}

    end;
end; {$endregion}
procedure TCurve.RctSplineObj0     (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_ent_: TRect;
  rct_out_: TRect;
begin
  RctSplineRct0  (spline_ind,rct_out_,rct_ent_);
  RctSplineRct1  (spline_ind,rct_out_,rct_ent_);
  RctSplineEds   (spline_ind,rct_out_,rct_ent_);
  RctSplinePts   (spline_ind,rct_out_,rct_ent_);
  RctSplineRctEds(spline_ind,rct_out_,rct_ent_);
  RctSplineRctPts(spline_ind,rct_out_,rct_ent_);
end; {$endregion}
procedure TCurve.RctSplineObj1     (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_ent_: TRect;
  rct_out_: TRect;
begin
  RctSplineRct0  (spline_ind,rct_out_,rct_ent_);
  RctSplineRct2  (spline_ind,rct_out_,rct_ent_);
  RctSplineEds   (spline_ind,rct_out_,rct_ent_);
  RctSplinePts   (spline_ind,rct_out_,rct_ent_);
  RctSplineRctEds(spline_ind,rct_out_,rct_ent_);
  RctSplineRctPts(spline_ind,rct_out_,rct_ent_);
end; {$endregion}
procedure TCurve.RctSplineAll0     (constref start_ind,end_ind:TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to sln_obj_cnt-1 do
    begin
      j:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].t_ind;
      if (j>=start_ind) and (j<=end_ind) then
        RctSplineObj0(i);
    end;
end; {$endregion}
procedure TCurve.RctSplineAll1     (constref start_ind,end_ind:TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to sln_obj_cnt-1 do
    begin
      j:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].t_ind;
      if (j>=start_ind) and (j<=end_ind) then
        begin
          if (has_sel_pts[i]=0) then
            Continue;
          RctSplineObj0(i);
        end;
    end;
end; {$endregion}
procedure TCurve.RctSplineAll2     (constref start_ind,end_ind:TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to sln_obj_cnt-1 do
    begin
      j:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].t_ind;
      if (j>=start_ind) and (j<=end_ind) then
        RctSplineObj1(i);
    end;
end; {$endregion}
procedure TCurve.RctSplineAll3     (constref start_ind,end_ind:TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to sln_obj_cnt-1 do
    begin
      j:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].t_ind;
      if (j>=start_ind) and (j<=end_ind) then
        begin
          if (has_sel_pts[i]=0) then
            Continue;
          RctSplineObj1(i);
        end;
    end;
end; {$endregion}
procedure TCurve.AddSplineObj;                                                                                                                                         {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  sln_pts_ptr     : PPtPosF;
  sln_pts_add_ptr : PPtPosF;
  m,i,d_cnt       : integer;
  sln_pts_cnt_add2: integer;
begin

  {Misc. Precalc.---------------} {$region -fold}
  Inc   (sln_obj_cnt);
  m    :=sln_obj_cnt-1;
  d_cnt:=sln_pts_cnt-sln_pts_cnt_add; {$endregion}

  {Buffers Init.----------------} {$region -fold}
  SetLength(sln_sprite_counter_pos_arr,sln_obj_cnt);
  SetLength(sln_sprite_counter_rad_arr,sln_obj_cnt);
  SetLength(sln_sprite_counter_pow_arr,sln_obj_cnt);
  Randomize;
  sln_sprite_counter_rad_arr[m]:={064}002+Random(030);
  sln_sprite_counter_pow_arr[m]:={016}200+Random(032);
  SetLength(rct_eds_img_arr    ,sln_obj_cnt);
  SetLength(rct_pts_img_arr    ,sln_obj_cnt);
  SetLength(    eds_img_arr    ,sln_obj_cnt);
  SetLength(    pts_img_arr    ,sln_obj_cnt);
  SetLength(partial_pts_sum    ,sln_obj_cnt);
  SetLength(sln_obj_pts_cnt    ,sln_obj_cnt);
  SetLength(has_sel_pts        ,sln_obj_cnt);
  SetLength(rct_bnd_ind_arr    ,sln_obj_cnt);
  SetLength(sln_pts_reserved   ,sln_obj_cnt);
  SetLength(sln_vis_eds_ind    ,sln_obj_cnt);
  SetLength(sln_pts            ,sln_pts_cnt);
  SetLength(sln_obj_ind        ,sln_pts_cnt);
  SetLength(fst_lst_sln_obj_pts,sln_pts_cnt);
  SetLength(has_edge           ,sln_pts_cnt);

  with sel_var do
    begin
      SetLength(out_or_inn_subgraph_pts,sln_pts_cnt);
      SetLength(sel_pts_inds           ,sln_pts_cnt);
      SetLength(is_point_selected      ,sln_pts_cnt);
      SetLength(is_point_in_circle     ,sln_pts_cnt);
      SetLength(is_point_pos_calc      ,sln_pts_cnt);
    end;

  if (sln_pts_cnt_add>0) then
    begin
      if (global_prop.sln_type=stFreeHand) then
        begin
          SetLength(sln_pts_add,sln_pts_cnt_add );
          ListToArr(sln_pts_add,first_item,p1,p2);
          FreeList2(            first_item,p1,p2);
        end;
      sln_pts_ptr    :=Unaligned(@sln_pts    [d_cnt]);
      sln_pts_add_ptr:=Unaligned(@sln_pts_add[00000]);
      for i:=0 to sln_pts_cnt_add-1 do
        (sln_pts_ptr+i)^:=(sln_pts_add_ptr+i)^;
      SetLength(sln_pts_add,0);
      sln_pts_cnt_add2:=sln_pts_cnt_add;
      sln_pts_cnt_add :=0;
    end;

  // spline edges bounding rectangles:
  rct_eds_img_arr[m]           :=TFastLine.Create;
  rct_eds_img_arr[m].local_prop:=global_prop;
  // spline points bounding rectangles:
  rct_pts_img_arr[m]           :=TFastLine.Create;
  rct_pts_img_arr[m].local_prop:=global_prop;
  // spline edges:
      eds_img_arr[m]           :=TFastLine.Create;
      eds_img_arr[m].local_prop:=global_prop;
  // spline points:
      pts_img_arr[m]           :=TFastLine.Create;
      pts_img_arr[m].local_prop:=global_prop; {$endregion}

  {Spline Object Calc.----------} {$region -fold}
  if (sln_obj_cnt=1) then
    begin
      partial_pts_sum[0]:=0;
      sln_obj_pts_cnt[0]:=sln_pts_cnt;
    end;
  if (sln_obj_cnt>1) then
    begin
      partial_pts_sum[m]:=partial_pts_sum[m-1]+sln_obj_pts_cnt[m-1];
      sln_obj_pts_cnt[m]:=sln_pts_cnt         -partial_pts_sum[m  ];
    end;
  if (sln_obj_pts_cnt[m]=1) then // if spline object has 1 point
    begin
      fst_lst_sln_obj_pts[partial_pts_sum[m]                     ]:=3; // set first spline object point
      fst_lst_sln_obj_pts[partial_pts_sum[m]+sln_obj_pts_cnt[m]-1]:=3; // set last  spline object point
    end;
  if (sln_obj_pts_cnt[m]>1) then // if spline object has more than 1 point
    begin
      fst_lst_sln_obj_pts[partial_pts_sum[m]                     ]:=1; // set first spline object point
      fst_lst_sln_obj_pts[partial_pts_sum[m]+sln_obj_pts_cnt[m]-1]:=2; // set last  spline object point
    end;
  if (global_prop.sln_mode=smSpray) and (global_prop.sln_type=stFreeHand) then
    FillByte ((@has_edge[partial_pts_sum[m]])^,sln_obj_pts_cnt[m]-1,1);
  {for i:=0 to sln_obj_pts_cnt[m]-1 do
    begin
      has_edge[partial_pts_sum[m]+i]:=Random(2);
    end;}
  FillDWord((@sln_obj_ind[partial_pts_sum[m]])^,sln_obj_pts_cnt[m],m);
  sln_eds_cnt:=sln_pts_cnt-sln_obj_cnt; {$endregion}

  {Aligning Points--------------} {$region -fold}
  {if snp_grd_var.align_pts then
    with sel_pts_var do
      snp_grd_var.AlignPts(sln_pts,sel_pts_inds,sln_pts_cnt,sel_pts_cnt);} {$endregion}

  {Spline Init.-----------------} {$region -fold}

  // spline edges bounding rectangles:
  with rct_eds_img_arr[m],local_prop do
    begin
      rct_clp_ptr:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[obj_var.curve_cnt-1]].rct_clp_ptr;
      pts_col_inv:=SetColorInv(clRed);
      {Create Sprite--} {$region -fold}
      fst_img:=TFastImageItem.Create
      (
        bmp_dst_ptr,
        bmp_dst_width,
        bmp_dst_height,
        rct_clp_ptr^,
        PtRct(rct_vis),
        0
      ); {$endregion}
    end;

  // spline points bounding rectangles:
  with rct_pts_img_arr[m],local_prop do
    begin
      rct_clp_ptr:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[obj_var.curve_cnt-1]].rct_clp_ptr;
      pts_col_inv:=SetColorInv(clBlue);
      {Create Sprite--} {$region -fold}
      fst_img:=TFastImageItem.Create
      (
        bmp_dst_ptr,
        bmp_dst_width,
        bmp_dst_height,
        rct_clp_ptr^,
        PtRct(rct_vis),
        0
      ); {$endregion}
    end;

  // spline edges:
  with eds_img_arr[m],local_prop do
    begin
      rct_clp_ptr:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[obj_var.curve_cnt-1]].rct_clp_ptr;
      if eds_col_fall_off then
        begin
          eds_col:=Highlight(global_prop.eds_col,0,0,0,0,0,global_prop.eds_col_fall_off_inc);
          if   (global_prop.eds_col_fall_off_inc<>255) then
            Inc(global_prop.eds_col_fall_off_inc);
        end
      else
      if eds_col_rnd then
        RndSplineCol(local_prop,eds_col,eds_col_inv,eds_col_ptr,F_MainForm.SB_Spline_Edges_Color);
      eds_show   :=(eds_show) and
                   (eds_width<>0) and
                   (sln_obj_pts_cnt[m]<>1);
      cnc_ends   :=(cnc_ends) and
                   (sln_obj_pts_cnt[m]>2);
      eds_col_inv:=SetColorInv(eds_col);
      if hid_ln_elim then
        begin
          SetLength(useless_arr,sln_obj_pts_cnt[m]-1);
          has_hid_ln_elim_sln:=True;
        end;
      if best_precision then
        SetLength(sln_pts_reserved[sln_obj_cnt-1],sln_pts_cnt_add2);
      if byte_mode then
        has_byte_mode_sln:=True;
      {Create Sprite--} {$region -fold}
      fst_img:=TFastImageItem.Create
      (
        bmp_dst_ptr,
        bmp_dst_width,
        bmp_dst_height,
        rct_clp_ptr^,
        PtRct(rct_vis),
        0
      ); {$endregion}
    end;

  // spline points:
  with pts_img_arr[m],local_prop do
    begin
      rct_clp_ptr:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[obj_var.curve_cnt-1]].rct_clp_ptr;
      if pts_col_fall_off then
        begin
          pts_col:=Highlight(global_prop.pts_col,0,0,0,0,0,global_prop.pts_col_fall_off_inc);
          if   (global_prop.pts_col_fall_off_inc<>255) then
            Inc(global_prop.pts_col_fall_off_inc);
        end
      else
      if pts_col_rnd then
        RndSplineCol(local_prop,pts_col,pts_col_inv,pts_col_ptr,F_MainForm.SB_Spline_Points_Color);
      pts_show   :=(pts_show) and
                   (pts_width <>0) and
                   (pts_height<>0);
      pts_col_inv:=SetColorInv(pts_col);
      if byte_mode then
        has_byte_mode_sln:=True;
      SetRctDupId(local_prop);
      {Create Sprite--} {$region -fold}
      fst_img:=TFastImageItem.Create
      (
        bmp_dst_ptr,
        bmp_dst_width,
        bmp_dst_height,
        rct_clp_ptr^,
        PtRct(rct_vis),
        0
      ); {$endregion}
    end; {$endregion}

  {Spline Object Rectangle Init.} {$region -fold}
  RctSplineObj0(m); {$endregion}

end; {$endregion}
procedure TCurve.AddSplineRctEds   (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_eds_img_arr[spline_ind],local_prop do
    begin
      pts_rct_inn_width :=rct_ent.width -2;
      pts_rct_inn_height:=rct_ent.height-2;
      pts_rct_tns_left  :=1;
      pts_rct_tns_top   :=1;
      pts_rct_tns_right :=1;
      pts_rct_tns_bottom:=1;
      SetRctWidth (local_prop);
      SetRctHeight(local_prop);
      SetRctValues(local_prop);
      Rectangle
      (
        pts_rct_width__half-pts_rct_width__odd+rct_ent.left,
        pts_rct_height_half-pts_rct_height_odd+rct_ent.top ,
        rct_eds_big_img.ln_arr1_ptr,
        rct_eds_big_img.ln_arr_width,
        rct_eds_big_img.ln_arr_height,
        PtRct(rct_vis),
        local_prop,
        @PPFloodFillAdd
      );
    end;
end; {$endregion}
procedure TCurve.AddSplineRctPts   (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_pts_img_arr[spline_ind],local_prop do
    begin
      pts_rct_inn_width :=rct_ent.width -2;
      pts_rct_inn_height:=rct_ent.height-2;
      pts_rct_tns_left  :=1;
      pts_rct_tns_top   :=1;
      pts_rct_tns_right :=1;
      pts_rct_tns_bottom:=1;
      SetRctWidth (local_prop);
      SetRctHeight(local_prop);
      SetRctValues(local_prop);
      Rectangle
      (
        pts_rct_width__half-pts_rct_width__odd+rct_ent.left,
        pts_rct_height_half-pts_rct_height_odd+rct_ent.top ,
        rct_pts_big_img.ln_arr1_ptr,
        rct_pts_big_img.ln_arr_width,
        rct_pts_big_img.ln_arr_height,
        PtRct(rct_vis),
        local_prop,
        @PPFloodFillAdd
      );
    end;
end; {$endregion}
procedure TCurve.AddSplineEds00    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  rct_out        : TPtRect;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  x0,y0,x1,y1,b,i: integer;
  max_w_h_div_2  : integer;
  min_w_h_div_2  : integer;
  rct_rad        : double;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b            :=partial_pts_sum[spline_ind];
      obj_arr_ptr  :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr  :=Unaligned(@sln_pts [b]);
      has_edge_ptr :=Unaligned(@has_edge[b]);
      rct_out      :=PtRct(rct_clp_ptr^.left  +0,
                           rct_clp_ptr^.top   +0,
                           rct_clp_ptr^.right -1,
                           rct_clp_ptr^.bottom-1);
      max_w_h_div_2:=Max(rct_out.width,rct_out.height)>>1;
      min_w_h_div_2:=Min(rct_out.width,rct_out.height)>>1;
      rct_rad      :=sqrt(sqr(max_w_h_div_2)+sqr(min_w_h_div_2)); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine1
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  rct_out,
                  Unaligned(@LinePHL  ),
                  Unaligned(@LinePHL20),
                  Unaligned(@LineSHL20)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                with eds_big_img do
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_out)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad,0)} then
                        ClippedLine1
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                    end;
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine1
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    )
                  else
                    ClippedLine1
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                if (has_edge_ptr^=0) then
                  begin
                    x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                    if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_out)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad+1,0)} then
                      begin
                        ClippedLine1
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          ClippedLine1
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL20),
                            Unaligned(@LineSHL20)
                          )
                        else
                          ClippedLine1
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL20),
                            Unaligned(@LineSHL20)
                          );
                      end;
                    Inc(sln_pts_ptr );
                    Inc(has_edge_ptr);
                  end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      ClippedLine1
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end
                  else
                    begin
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      ClippedLine1
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                if (has_edge_ptr^=0) then
                  begin
                    x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                    if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_out)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad+2,0)} then
                      begin
                        ClippedLine1
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          begin
                            ClippedLine1
                            (
                              x0+0,
                              y0+1,
                              x1+0,
                              y1+1,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20)
                            );
                            ClippedLine1
                            (
                              x0+0,
                              y0-1,
                              x1+0,
                              y1-1,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20)
                            );
                          end
                        else
                          begin
                            ClippedLine1
                            (
                              x0+1,
                              y0+0,
                              x1+1,
                              y1+0,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20)
                            );
                            ClippedLine1
                            (
                              x0-1,
                              y0+0,
                              x1-1,
                              y1+0,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20)
                            );
                          end;
                      end;
                    Inc(sln_pts_ptr );
                    Inc(has_edge_ptr);
                  end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds01    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  x0,y0,x1,y1,b,i: integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                LinePHL
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  Unaligned(@LinePHL20),
                  Unaligned(@LineSHL20)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                with eds_big_img do
                  if (has_edge_ptr^=0) then
                    LinePHL
                    (
                      Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                      Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                      Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                      Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    )
                  else
                    LinePHL
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                if (has_edge_ptr^=0) then
                  begin
                    x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                    LinePHL
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      LinePHL
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      )
                    else
                      LinePHL
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    Inc(sln_pts_ptr );
                    Inc(has_edge_ptr);
                  end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      LinePHL
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end
                  else
                    begin
                      LinePHL
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      LinePHL
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                if (has_edge_ptr^=0) then
                  begin
                    x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                    LinePHL
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      begin
                        LinePHL
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                        LinePHL
                        (
                          x0+0,
                          y0-1,
                          x1+0,
                          y1-1,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                      end
                    else
                      begin
                        LinePHL
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                        LinePHL
                        (
                          x0-1,
                          y0+0,
                          x1-1,
                          y1+0,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                      end;
                    Inc(sln_pts_ptr );
                    Inc(has_edge_ptr);
                  end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds02    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  rct_out        : TPtRect;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  x0,y0,x1,y1,b,i: integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]);
      rct_out     :=PtRct(rct_clp_ptr^.left  +0,
                          rct_clp_ptr^.top   +0,
                          rct_clp_ptr^.right -1,
                          rct_clp_ptr^.bottom-1); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if (not (sel_var.is_point_selected[b+00000000000000000000000000000] or
                     sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1])) then
              if cnc_ends then
                with eds_big_img do
                  ClippedLine1
                  (
                    Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if (not (sel_var.is_point_selected[b+i] or
                         sel_var.is_point_selected[b+i+1])) then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      ClippedLine1
                      (
                        Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                        Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if (not (sel_var.is_point_selected[b+00000000000000000000000000000] or
                     sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1])) then
              if cnc_ends then
                with eds_big_img do
                  begin
                    x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                    ClippedLine1
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      )
                    else
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                  end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if (not (sel_var.is_point_selected[b+i] or
                         sel_var.is_point_selected[b+i+1])) then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      begin
                        x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        ClippedLine1
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          ClippedLine1
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL20),
                            Unaligned(@LineSHL20)
                          )
                        else
                          ClippedLine1
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL20),
                            Unaligned(@LineSHL20)
                          );
                      end;
                  Inc(sln_pts_ptr);
                  Inc(has_edge_ptr);
              end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if (not (sel_var.is_point_selected[b+00000000000000000000000000000] or
                     sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1])) then
              if cnc_ends then
                with eds_big_img do
                  begin
                    x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                    ClippedLine1
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      begin
                        ClippedLine1
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                        ClippedLine1
                        (
                          x0+0,
                          y0-1,
                          x1+0,
                          y1-1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                      end
                    else
                      begin
                        ClippedLine1
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                        ClippedLine1
                        (
                          x0-1,
                          y0+0,
                          x1-1,
                          y1+0,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                      end;
                  end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if (not (sel_var.is_point_selected[b+i] or
                         sel_var.is_point_selected[b+i+1])) then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      begin
                        x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        ClippedLine1
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          begin
                            ClippedLine1
                            (
                              x0+0,
                              y0+1,
                              x1+0,
                              y1+1,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20)
                            );
                            ClippedLine1
                            (
                              x0+0,
                              y0-1,
                              x1+0,
                              y1-1,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20)
                            );
                          end
                        else
                          begin
                            ClippedLine1
                            (
                              x0+1,
                              y0+0,
                              x1+1,
                              y1+0,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20)
                            );
                            ClippedLine1
                            (
                              x0-1,
                              y0+0,
                              x1-1,
                              y1+0,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20)
                            );
                          end;
                      end;
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds03    (constref spline_ind       :TColor); {TODO: optimization}                                                                                              {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  rct_out        : TPtRect;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  x0,y0,x1,y1,b,i: integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]);
      rct_out     :=PtRct(rct_clp_ptr^.left  +0,
                          rct_clp_ptr^.top   +0,
                          rct_clp_ptr^.right -1,
                          rct_clp_ptr^.bottom-1); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if sel_var.is_point_selected[b+00000000000000000000000000000] or
               sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1] then
              if cnc_ends then
                with eds_big_img do
                  ClippedLine1
                  (
                    Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if sel_var.is_point_selected[b+i+0] or
                   sel_var.is_point_selected[b+i+1] then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      ClippedLine1
                      (
                        Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                        Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if sel_var.is_point_selected[b+00000000000000000000000000000] or
               sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1] then
              if cnc_ends then
                with eds_big_img do
                  begin
                    x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                    ClippedLine1
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      )
                    else
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                  end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if sel_var.is_point_selected[b+i+0] or
                   sel_var.is_point_selected[b+i+1] then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      begin
                        x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        ClippedLine1
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          ClippedLine1
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL20),
                            Unaligned(@LineSHL20)
                          )
                        else
                          ClippedLine1
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL20),
                            Unaligned(@LineSHL20)
                          );
                      end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
              end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if sel_var.is_point_selected[b+00000000000000000000000000000] or
               sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1] then
              if cnc_ends then
                with eds_big_img do
                  begin
                    x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                    ClippedLine1
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      begin
                        ClippedLine1
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                        ClippedLine1
                        (
                          x0+0,
                          y0-1,
                          x1+0,
                          y1-1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                      end
                    else
                      begin
                        ClippedLine1
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                        ClippedLine1
                        (
                          x0-1,
                          y0+0,
                          x1-1,
                          y1+0,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                      end;
                  end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if sel_var.is_point_selected[b+i+0] or
                   sel_var.is_point_selected[b+i+1] then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      begin
                        x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        ClippedLine1
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          begin
                            ClippedLine1
                            (
                              x0+0,
                              y0+1,
                              x1+0,
                              y1+1,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20)
                            );
                            ClippedLine1
                            (
                              x0+0,
                              y0-1,
                              x1+0,
                              y1-1,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20)
                            );
                          end
                        else
                          begin
                            ClippedLine1
                            (
                              x0+1,
                              y0+0,
                              x1+1,
                              y1+0,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20)
                            );
                            ClippedLine1
                            (
                              x0-1,
                              y0+0,
                              x1-1,
                              y1+0,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20)
                            );
                          end;
                      end;
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds04    (constref spline_ind       :TColor); {TODO: optimization}                                                                                              {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  rct_out        : TPtRect;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  x0,y0,x1,y1,b,i: integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]);
      rct_out     :=PtRct(rct_clp_ptr^.left  +0,
                          rct_clp_ptr^.top   +0,
                          rct_clp_ptr^.right -1,
                          rct_clp_ptr^.bottom-1); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if sel_var.is_point_selected[b+00000000000000000000000000000] or
               sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1] then
              if cnc_ends then
                with eds_big_img do
                  ClippedLine1
                  (
                    Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL10),
                    Unaligned(@LineSHL10)
                  ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if sel_var.is_point_selected[b+i+0] or
                   sel_var.is_point_selected[b+i+1] then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      ClippedLine1
                      (
                        Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                        Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL10),
                        Unaligned(@LineSHL10)
                      );
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if sel_var.is_point_selected[b+00000000000000000000000000000] or
               sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1] then
              if cnc_ends then
                with eds_big_img do
                  begin
                    x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                    ClippedLine1
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL10),
                      Unaligned(@LineSHL10)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL10),
                        Unaligned(@LineSHL10)
                      )
                    else
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL10),
                        Unaligned(@LineSHL10)
                      );
                  end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if sel_var.is_point_selected[b+i+0] or
                   sel_var.is_point_selected[b+i+1] then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      begin
                        x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        ClippedLine1
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL10),
                          Unaligned(@LineSHL10)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          ClippedLine1
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL10),
                            Unaligned(@LineSHL10)
                          )
                        else
                          ClippedLine1
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL10),
                            Unaligned(@LineSHL10)
                          );
                      end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
              end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if sel_var.is_point_selected[b+00000000000000000000000000000] or
               sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1] then
              if cnc_ends then
                with eds_big_img do
                  begin
                    x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                    ClippedLine1
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL10),
                      Unaligned(@LineSHL10)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      begin
                        ClippedLine1
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL10),
                          Unaligned(@LineSHL10)
                        );
                        ClippedLine1
                        (
                          x0+0,
                          y0-1,
                          x1+0,
                          y1-1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL10),
                          Unaligned(@LineSHL10)
                        );
                      end
                    else
                      begin
                        ClippedLine1
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL10),
                          Unaligned(@LineSHL10)
                        );
                        ClippedLine1
                        (
                          x0-1,
                          y0+0,
                          x1-1,
                          y1+0,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL10),
                          Unaligned(@LineSHL10)
                        );
                      end;
                  end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if sel_var.is_point_selected[b+i+0] or
                   sel_var.is_point_selected[b+i+1] then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      begin
                        x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        ClippedLine1
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL10),
                          Unaligned(@LineSHL10)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          begin
                            ClippedLine1
                            (
                              x0+0,
                              y0+1,
                              x1+0,
                              y1+1,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL10),
                              Unaligned(@LineSHL10)
                            );
                            ClippedLine1
                            (
                              x0+0,
                              y0-1,
                              x1+0,
                              y1-1,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL10),
                              Unaligned(@LineSHL10)
                            );
                          end
                        else
                          begin
                            ClippedLine1
                            (
                              x0+1,
                              y0+0,
                              x1+1,
                              y1+0,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL10),
                              Unaligned(@LineSHL10)
                            );
                            ClippedLine1
                            (
                              x0-1,
                              y0+0,
                              x1-1,
                              y1+0,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL10),
                              Unaligned(@LineSHL10)
                            );
                          end;
                      end;
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds05    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr        : PObjInfo;
  rct_out            : TPtRect;
  sln_pts_ptr        : PPtPosF;
  sln_pts_ptr2       : PPtPosF;
  sln_vis_eds_ind_ptr: PColor;
  x0,y0,x1,y1,b,i    : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b                  :=partial_pts_sum[spline_ind];
      obj_arr_ptr        :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr        :=Unaligned(@sln_pts[b]);
      sln_vis_eds_ind_ptr:=@sln_vis_eds_ind[spline_ind,0];
      rct_out            :=PtRct(rct_clp_ptr^.left  +0,
                                 rct_clp_ptr^.top   +0,
                                 rct_clp_ptr^.right -1,
                                 rct_clp_ptr^.bottom-1); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine1
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  rct_out,
                  Unaligned(@LinePHL  ),
                  Unaligned(@LinePHL20),
                  Unaligned(@LineSHL20)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  ClippedLine1
                  (
                    Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine1
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    )
                  else
                    ClippedLine1
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0:=Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine1
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    )
                  else
                    ClippedLine1
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      ClippedLine1
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end
                  else
                    begin
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      ClippedLine1
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0:=Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      ClippedLine1
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end
                  else
                    begin
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      ClippedLine1
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end;
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds06    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr        : PObjInfo;
  sln_pts_ptr        : PPtPosF;
  sln_pts_ptr2       : PPtPosF;
  sln_vis_eds_ind_ptr: PColor;
  x0,y0,x1,y1,b,i    : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b                  :=partial_pts_sum[spline_ind];
      obj_arr_ptr        :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr        :=Unaligned(@sln_pts[b]);
      sln_vis_eds_ind_ptr:=@sln_vis_eds_ind[spline_ind,0]; {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                LinePHL
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  Unaligned(@LinePHL20),
                  Unaligned(@LineSHL20)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  LinePHL
                  (
                    Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    )
                  else
                    LinePHL
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0:=Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    )
                  else
                    LinePHL
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      LinePHL
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end
                  else
                    begin
                      LinePHL
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      LinePHL
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0:=Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      LinePHL
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end
                  else
                    begin
                      LinePHL
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      LinePHL
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end;
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds07    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  rct_out        : TPtRect;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  pt_shift       : TPtPos;
  pt             : double;
  pt2            : TPtPosF;
  bmp_dst_ptr2   : PInteger;
  x0,y0,x1,y1,b,i: integer;
  eds_col_inv2   : integer;
label
  label0;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.-----------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]);
      rct_out     :=PtRct(rct_clp_ptr^.left,
                          rct_clp_ptr^.top ,
                          rct_clp_ptr^.right -1,
                          rct_clp_ptr^.bottom-1); {$endregion}

      {Save Points Shift--------------------------------------} {$region -fold}
      pt_shift:=PtPos(rct_ent.left-rct_clp_ptr^.left,
                      rct_ent.top -rct_clp_ptr^.top); {$endregion}

      {Save Points(Best Precision Mode)-----------------------} {$region -fold}
      if best_precision then
        ArrToArr1(@sln_pts[b],@sln_pts_reserved[spline_ind,0],sln_obj_pts_cnt[spline_ind]); {$endregion}

      {Move Spline to Left-Top Point of Inner Window Rectangle} {$region -fold}
      PtsMov(pt_shift,sln_pts,b,b+sln_obj_pts_cnt[spline_ind]-1);
      PtsMov(pt_shift,rct_ent); {$endregion}

      {Fit Spline to Inner Window Rectangle-------------------} {$region -fold}
      if (rct_ent.height/rct_ent.width>=rct_clp_ptr^.height/rct_clp_ptr^.width) then
        pt:=rct_ent.height/rct_clp_ptr^.height
      else
        pt:=rct_ent.width /rct_clp_ptr^.width;
      PtsScl
      (
        PtPosF(rct_ent.left-obj_arr_ptr^.world_axis_shift.x,
               rct_ent.top -obj_arr_ptr^.world_axis_shift.y),
        sln_pts,
        PtPosF(pt,pt),
        sdDown,
        b,
        b+sln_obj_pts_cnt[spline_ind]-1
      );
      pt2.x:=rct_ent.left-obj_arr_ptr^.world_axis_shift.x;
      pt2.y:=rct_ent.top -obj_arr_ptr^.world_axis_shift.y;
      PtsScl
      (
        PtPosF(rct_ent.left-obj_arr_ptr^.world_axis_shift.x,
               rct_ent.top -obj_arr_ptr^.world_axis_shift.y),
        rct_ent,
        PtPosF(pt,pt),
        sdDown
      );
      rct_vis:=ClippedRct(rct_clp_ptr^,rct_ent,False); {$endregion}

      {Save and Set Destination Surface Handle----------------} {$region -fold}
      bmp_dst_ptr2           :=eds_big_img.bmp_dst_ptr;
      eds_big_img.bmp_dst_ptr:=@eds_useless_fld_arr[0]; {$endregion}

      {Save and Set Color(inverted value)---------------------} {$region -fold}
      eds_col_inv2                      :=eds_big_img.local_prop.eds_col_inv;
      eds_big_img.local_prop.eds_col_inv:=1; {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Spline Object Edges-------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    ClippedLine1
                    (
                      Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                      Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                      Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                      Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL30),
                      Unaligned(@LineSHL30)
                    );
                  Inc(sln_pts_ptr           );
                  Inc(has_edge_ptr          );
                  Inc(local_prop.eds_col_inv);
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Spline Object Edges-------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      ClippedLine1
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL30),
                        Unaligned(@LineSHL30)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        ClippedLine1
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30)
                        )
                      else
                        ClippedLine1
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30)
                        );
                    end;
                  Inc(sln_pts_ptr           );
                  Inc(has_edge_ptr          );
                  Inc(local_prop.eds_col_inv);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Spline Object Edges-------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      ClippedLine1
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL30),
                        Unaligned(@LineSHL30)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        begin
                          ClippedLine1
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30)
                          );
                          ClippedLine1
                          (
                            x0+0,
                            y0-1,
                            x1+0,
                            y1-1,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30)
                          );
                        end
                      else
                        begin
                          ClippedLine1
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30)
                          );
                          ClippedLine1
                          (
                            x0-1,
                            y0+0,
                            x1-1,
                            y1+0,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30)
                          );
                        end;
                    end;
                  Inc(sln_pts_ptr           );
                  Inc(has_edge_ptr          );
                  Inc(local_prop.eds_col_inv);
                end; {$endregion}

          end;
      end;

      {Reset Points(Best Precision Mode)----------------------} {$region -fold}
      if best_precision then
        begin
          ArrToArr2(@sln_pts[b],@sln_pts_reserved[spline_ind,0],sln_obj_pts_cnt[spline_ind]);
          goto label0;
        end; {$endregion}

      {Reset Spline Size--------------------------------------} {$region -fold}
      PtsScl
      (
        pt2,
        sln_pts,
        PtPosF(pt,pt),
        sdUp,
        b,
        b+sln_obj_pts_cnt[spline_ind]-1
      ); {$endregion}

      {Reset Spline Position----------------------------------} {$region -fold}
      PtsMov(PtPos(-pt_shift.x,-pt_shift.y),sln_pts,b,b+sln_obj_pts_cnt[spline_ind]-1); {$endregion}

      {Recalc. Spline Bounding Rectangles(All!)---------------} {$region -fold}
      label0:
      RctSplineObj1(spline_ind){RctSplineObj0(spline_ind)}; {$endregion}

      {Reset Destination Surface Handle-----------------------} {$region -fold}
      eds_big_img.bmp_dst_ptr:=bmp_dst_ptr2; {$endregion}

      {Reset Color(inverted value)----------------------------} {$region -fold}
      eds_big_img.local_prop.eds_col_inv:=eds_col_inv2; {$endregion}

    end;
end; {$endregion}
procedure TCurve.AddSplineEds08    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  rct_out        : TPtRect;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  x0,y0,x1,y1,b,i: integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]);
      rct_out     :=PtRct(rct_clp_ptr^.left  +0,
                          rct_clp_ptr^.top   +0,
                          rct_clp_ptr^.right -1,
                          rct_clp_ptr^.bottom-1); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine1
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  rct_out,
                  Unaligned(@LinePHL  ),
                  Unaligned(@LinePHL02),
                  Unaligned(@LineSHL00)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                with eds_big_img do
                  if (has_edge_ptr^=0) then
                    ClippedLine1
                    (
                      Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                      Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                      Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                      Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    );
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine1
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    )
                  else
                    ClippedLine1
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      ClippedLine1
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        ClippedLine1
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL02),
                          Unaligned(@LineSHL00)
                        )
                      else
                        ClippedLine1
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL02),
                          Unaligned(@LineSHL00)
                        );
                    end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      ClippedLine1
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        begin
                          ClippedLine1
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL02),
                            Unaligned(@LineSHL00)
                          );
                          ClippedLine1
                          (
                            x0+0,
                            y0-1,
                            x1+0,
                            y1-1,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL02),
                            Unaligned(@LineSHL00)
                          );
                        end
                      else
                        begin
                          ClippedLine1
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL02),
                            Unaligned(@LineSHL00)
                          );
                          ClippedLine1
                          (
                            x0-1,
                            y0+0,
                            x1-1,
                            y1+0,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL02),
                            Unaligned(@LineSHL00)
                          );
                        end;
                    end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds09    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  x0,y0,x1,y1,b,i: integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                LinePHL
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  Unaligned(@LinePHL02),
                  Unaligned(@LineSHL00)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                with eds_big_img do
                  if (has_edge_ptr^=0) then
                    LinePHL
                    (
                      Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                      Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                      Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                      Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    );
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    )
                  else
                    LinePHL
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      LinePHL
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        LinePHL
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          Unaligned(@LinePHL02),
                          Unaligned(@LineSHL00)
                        )
                      else
                        LinePHL
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          Unaligned(@LinePHL02),
                          Unaligned(@LineSHL00)
                        );
                    end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      LinePHL
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      LinePHL
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        begin
                          LinePHL
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            Unaligned(@LinePHL02),
                            Unaligned(@LineSHL00)
                          );
                          LinePHL
                          (
                            x0+0,
                            y0-1,
                            x1+0,
                            y1-1,
                            Unaligned(@LinePHL02),
                            Unaligned(@LineSHL00)
                          );
                        end
                      else
                        begin
                          LinePHL
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            Unaligned(@LinePHL02),
                            Unaligned(@LineSHL00)
                          );
                          LinePHL
                          (
                            x0-1,
                            y0+0,
                            x1-1,
                            y1+0,
                            Unaligned(@LinePHL02),
                            Unaligned(@LineSHL00)
                          );
                        end;
                    end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds10    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr        : PObjInfo;
  rct_out            : TPtRect;
  sln_pts_ptr        : PPtPosF;
  sln_pts_ptr2       : PPtPosF;
  sln_vis_eds_ind_ptr: PColor;
  x0,y0,x1,y1,b,i    : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b                  :=partial_pts_sum[spline_ind];
      obj_arr_ptr        :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr        :=Unaligned(@sln_pts[b]);
      sln_vis_eds_ind_ptr:=@sln_vis_eds_ind[spline_ind,0];
      rct_out            :=PtRct(rct_clp_ptr^.left  +0,
                                 rct_clp_ptr^.top   +0,
                                 rct_clp_ptr^.right -1,
                                 rct_clp_ptr^.bottom-1); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine1
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  rct_out,
                  Unaligned(@LinePHL  ),
                  Unaligned(@LinePHL02),
                  Unaligned(@LineSHL00)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  ClippedLine1
                  (
                    Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine1
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    )
                  else
                    ClippedLine1
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0:=Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine1
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    )
                  else
                    ClippedLine1
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    );
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0:=Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end;
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds11    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr        : PObjInfo;
  sln_pts_ptr        : PPtPosF;
  sln_pts_ptr2       : PPtPosF;
  sln_vis_eds_ind_ptr: PColor;
  x0,y0,x1,y1,b,i    : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b                  :=partial_pts_sum[spline_ind];
      obj_arr_ptr        :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr        :=Unaligned(@sln_pts[b]);
      sln_vis_eds_ind_ptr:=@sln_vis_eds_ind[spline_ind,0]; {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                LinePHL
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  Unaligned(@LinePHL02),
                  Unaligned(@LineSHL00)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  LinePHL
                  (
                    Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    )
                  else
                    LinePHL
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0:=Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    )
                  else
                    LinePHL
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    );
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      LinePHL
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0:=Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      LinePHL
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end;
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds12    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  rct_out        : TPtRect;
  sln_pts_ptr    : PPtPosF;
  x0,y0,x1,y1,b,i: integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      rct_out    :=PtRct(rct_clp_ptr^.left  +0,
                         rct_clp_ptr^.top   +0,
                         rct_clp_ptr^.right -1,
                         rct_clp_ptr^.bottom-1); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine1
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  rct_out,
                  Unaligned(@LinePHL  ),
                  Unaligned(@LinePHL20),
                  Unaligned(@LineSHL20)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  ClippedLine1
                  (
                    Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine1
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    )
                  else
                    ClippedLine1
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine1
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    )
                  else
                    ClippedLine1
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      ClippedLine1
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end
                  else
                    begin
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      ClippedLine1
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      ClippedLine1
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end
                  else
                    begin
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      ClippedLine1
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end;
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds13    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  sln_pts_ptr    : PPtPosF;
  x0,y0,x1,y1,b,i: integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                LinePHL
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  Unaligned(@LinePHL20),
                  Unaligned(@LineSHL20)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  LinePHL
                  (
                    Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    )
                  else
                    LinePHL
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    )
                  else
                    LinePHL
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20)
                    );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      LinePHL
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end
                  else
                    begin
                      LinePHL
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      LinePHL
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      LinePHL
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end
                  else
                    begin
                      LinePHL
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                      LinePHL
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20)
                      );
                    end;
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds14    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  rct_out        : TPtRect;
  sln_pts_ptr    : PPtPosF;
  x0,y0,x1,y1,b,i: integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      rct_out    :=PtRct(rct_clp_ptr^.left  +0,
                         rct_clp_ptr^.top   +0,
                         rct_clp_ptr^.right -1,
                         rct_clp_ptr^.bottom-1); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine1
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  rct_out,
                  Unaligned(@LinePHL  ),
                  Unaligned(@LinePHL02),
                  Unaligned(@LineSHL00)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  ClippedLine1
                  (
                    Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine1
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    )
                  else
                    ClippedLine1
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine1
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    )
                  else
                    ClippedLine1
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end;
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds15    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  sln_pts_ptr    : PPtPosF;
  x0,y0,x1,y1,b,i: integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                LinePHL
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  Unaligned(@LinePHL02),
                  Unaligned(@LineSHL00)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  LinePHL
                  (
                    Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    )
                  else
                    LinePHL
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    )
                  else
                    LinePHL
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      Unaligned(@LinePHL02),
                      Unaligned(@LineSHL00)
                    );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      LinePHL
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL02),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      LinePHL
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        Unaligned(@LinePHL02),
                        Unaligned(@LineSHL00)
                      );
                    end;
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds16    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  rct_out        : TPtRect;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  x0,y0,x1,y1,b,i: integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]);
      rct_out     :=PtRct(rct_clp_ptr^.left  +0,
                          rct_clp_ptr^.top   +0,
                          rct_clp_ptr^.right -1,
                          rct_clp_ptr^.bottom-1); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine1
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  rct_out,
                  Unaligned(@LinePHL  ),
                  Unaligned(@LinePHL00),
                  Unaligned(@LineSHL00)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                with eds_big_img do
                  if (has_edge_ptr^=0) then
                    ClippedLine1
                    (
                      Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                      Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                      Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                      Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    );
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine1
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    )
                  else
                    ClippedLine1
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      ClippedLine1
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        ClippedLine1
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL00),
                          Unaligned(@LineSHL00)
                        )
                      else
                        ClippedLine1
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL00),
                          Unaligned(@LineSHL00)
                        );
                    end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      ClippedLine1
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        begin
                          ClippedLine1
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL00),
                            Unaligned(@LineSHL00)
                          );
                          ClippedLine1
                          (
                            x0+0,
                            y0-1,
                            x1+0,
                            y1-1,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL00),
                            Unaligned(@LineSHL00)
                          );
                        end
                      else
                        begin
                          ClippedLine1
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL00),
                            Unaligned(@LineSHL00)
                          );
                          ClippedLine1
                          (
                            x0-1,
                            y0+0,
                            x1-1,
                            y1+0,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL00),
                            Unaligned(@LineSHL00)
                          );
                        end;
                    end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds17    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  x0,y0,x1,y1,b,i: integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                LinePHL
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  Unaligned(@LinePHL00),
                  Unaligned(@LineSHL00)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                with eds_big_img do
                  if (has_edge_ptr^=0) then
                    LinePHL
                    (
                      Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                      Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                      Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                      Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    );
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    )
                  else
                    LinePHL
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      LinePHL
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        LinePHL
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          Unaligned(@LinePHL00),
                          Unaligned(@LineSHL00)
                        )
                      else
                        LinePHL
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          Unaligned(@LinePHL00),
                          Unaligned(@LineSHL00)
                        );
                    end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      LinePHL
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                      y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                      LinePHL
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        begin
                          LinePHL
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            Unaligned(@LinePHL00),
                            Unaligned(@LineSHL00)
                          );
                          LinePHL
                          (
                            x0+0,
                            y0-1,
                            x1+0,
                            y1-1,
                            Unaligned(@LinePHL00),
                            Unaligned(@LineSHL00)
                          );
                        end
                      else
                        begin
                          LinePHL
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            Unaligned(@LinePHL00),
                            Unaligned(@LineSHL00)
                          );
                          LinePHL
                          (
                            x0-1,
                            y0+0,
                            x1-1,
                            y1+0,
                            Unaligned(@LinePHL00),
                            Unaligned(@LineSHL00)
                          );
                        end;
                    end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds18    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr        : PObjInfo;
  rct_out            : TPtRect;
  sln_pts_ptr        : PPtPosF;
  sln_pts_ptr2       : PPtPosF;
  sln_vis_eds_ind_ptr: PColor;
  x0,y0,x1,y1,b,i    : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b                  :=partial_pts_sum[spline_ind];
      obj_arr_ptr        :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr        :=Unaligned(@sln_pts[b]);
      sln_vis_eds_ind_ptr:=@sln_vis_eds_ind[spline_ind,0];
      rct_out            :=PtRct(rct_clp_ptr^.left  +0,
                                 rct_clp_ptr^.top   +0,
                                 rct_clp_ptr^.right -1,
                                 rct_clp_ptr^.bottom-1); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine1
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  rct_out,
                  Unaligned(@LinePHL  ),
                  Unaligned(@LinePHL00),
                  Unaligned(@LineSHL00)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  ClippedLine1
                  (
                    Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine1
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    )
                  else
                    ClippedLine1
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0:=Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine1
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    )
                  else
                    ClippedLine1
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    );
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0:=Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end;
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds19    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr        : PObjInfo;
  sln_pts_ptr        : PPtPosF;
  sln_pts_ptr2       : PPtPosF;
  sln_vis_eds_ind_ptr: PColor;
  x0,y0,x1,y1,b,i    : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b                  :=partial_pts_sum[spline_ind];
      obj_arr_ptr        :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr        :=Unaligned(@sln_pts[b]);
      sln_vis_eds_ind_ptr:=@sln_vis_eds_ind[spline_ind,0]; {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                LinePHL
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  Unaligned(@LinePHL00),
                  Unaligned(@LineSHL00)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  LinePHL
                  (
                    Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    )
                  else
                    LinePHL
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0:=Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    )
                  else
                    LinePHL
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    );
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      LinePHL
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0:=Trunc((sln_pts_ptr2+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr2+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr2+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr2+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      LinePHL
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end;
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds20    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  rct_out        : TPtRect;
  sln_pts_ptr    : PPtPosF;
  x0,y0,x1,y1,b,i: integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      rct_out    :=PtRct(rct_clp_ptr^.left  +0,
                         rct_clp_ptr^.top   +0,
                         rct_clp_ptr^.right -1,
                         rct_clp_ptr^.bottom-1); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine1
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  rct_out,
                  Unaligned(@LinePHL  ),
                  Unaligned(@LinePHL00),
                  Unaligned(@LineSHL00)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  ClippedLine1
                  (
                    Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine1
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    )
                  else
                    ClippedLine1
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine1
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    )
                  else
                    ClippedLine1
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  ClippedLine1
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      ClippedLine1
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end;
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds21    (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  sln_pts_ptr    : PPtPosF;
  x0,y0,x1,y1,b,i: integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]); {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                LinePHL
                (
                  Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                  Unaligned(@LinePHL00),
                  Unaligned(@LineSHL00)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  LinePHL
                  (
                    Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    )
                  else
                    LinePHL
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    )
                  else
                    LinePHL
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00)
                    );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      LinePHL
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                  y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                  LinePHL
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end
                  else
                    begin
                      LinePHL
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                      LinePHL
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00)
                      );
                    end;
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplinePts0     (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  dup_pts_arr_ptr: PPtPos3;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
          if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
            begin
              dup_pts_arr_ptr:=Unaligned(@dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width]);
              if (dup_pts_arr_ptr^*dup_pts_id    ) and
                 (dup_pts_arr_ptr^.dup_pts_cnt =0) then
                begin
                  dup_pts_arr_ptr^.dup_pts_cnt:=1;
                  Rectangle
                  (
                    pt.x,
                    pt.y,
                    pts_big_img.ln_arr1_ptr,
                    pts_big_img.ln_arr_width,
                    pts_big_img.ln_arr_height,
                    PtRct(rct_vis),
                    local_prop,
                    @PPFloodFillAdd
                  );
                end;
            end
          else
            Rectangle
            (
              pt.x,
              pt.y,
              pts_big_img.ln_arr1_ptr,
              pts_big_img.ln_arr_width,
              pts_big_img.ln_arr_height,
              PtRct(rct_vis),
              local_prop,
              @PPFloodFillAdd
            );
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.AddSplinePts1     (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  dup_pts_arr_ptr: PPtPos3;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          if (not sel_var.is_point_selected[b+i]) then
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                begin
                  dup_pts_arr_ptr:=Unaligned(@dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width]);
                  if (dup_pts_arr_ptr^*dup_pts_id    ) and
                     (dup_pts_arr_ptr^.dup_pts_cnt =0) then
                    begin
                      dup_pts_arr_ptr^.dup_pts_cnt:=1;
                      Rectangle
                      (
                        pt.x,
                        pt.y,
                        pts_big_img.ln_arr1_ptr,
                        pts_big_img.ln_arr_width,
                        pts_big_img.ln_arr_height,
                        PtRct(rct_vis),
                        local_prop,
                        @PPFloodFillAdd
                      );
                    end;
                end
              else
                Rectangle
                (
                  pt.x,
                  pt.y,
                  pts_big_img.ln_arr1_ptr,
                  pts_big_img.ln_arr_width,
                  pts_big_img.ln_arr_height,
                  PtRct(rct_vis),
                  local_prop,
                  @PPFloodFillAdd
                );
            end;
          Inc(sln_pts_ptr);
        end
    end;
end; {$endregion}
procedure TCurve.AddSplinePts2     (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  dup_pts_arr_ptr: PPtPos3;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          if sel_var.is_point_selected[b+i] then
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                begin
                  dup_pts_arr_ptr:=Unaligned(@dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width]);
                  if (not (dup_pts_arr_ptr^*dup_pts_id)   ) and
                     (     dup_pts_arr_ptr^.dup_pts_cnt =0) then
                    begin
                           dup_pts_arr_ptr^.dup_pts_cnt:=1;
                      Rectangle
                      (
                        pt.x,
                        pt.y,
                        pts_big_img.ln_arr1_ptr,
                        pts_big_img.ln_arr_width,
                        pts_big_img.ln_arr_height,
                        PtRct(rct_vis),
                        local_prop,
                        @PPFloodFillAdd
                      );
                    end;
                end
              else
                Rectangle
                (
                  pt.x,
                  pt.y,
                  pts_big_img.ln_arr1_ptr,
                  pts_big_img.ln_arr_width,
                  pts_big_img.ln_arr_height,
                  PtRct(rct_vis),
                  local_prop,
                  @PPFloodFillAdd
                );
            end;
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.AddSplinePts3     (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  dup_pts_arr_ptr: PPtPos3;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          if sel_var.is_point_selected[b+i] then
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                begin
                  dup_pts_arr_ptr:=Unaligned(@dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width]);
                  if (dup_pts_arr_ptr^*dup_pts_id    ) and
                     (dup_pts_arr_ptr^.dup_pts_cnt =0) then
                    begin
                      dup_pts_arr_ptr^.dup_pts_cnt:=1;
                      Rectangle
                      (
                        pt.x,
                        pt.y,
                        pts_big_img.ln_arr1_ptr,
                        pts_big_img.ln_arr_width,
                        pts_big_img.ln_arr_height,
                        PtRct(rct_vis),
                        local_prop,
                        @PPFloodFillSub
                      );
                    end;
                end
              else
                Rectangle
                (
                  pt.x,
                  pt.y,
                  pts_big_img.ln_arr1_ptr,
                  pts_big_img.ln_arr_width,
                  pts_big_img.ln_arr_height,
                  PtRct(rct_vis),
                  local_prop,
                  @PPFloodFillSub
                );
            end;
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.AddSplinePts4     (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  dup_pts_arr_ptr: PPtPos3;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
          if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
            begin
              dup_pts_arr_ptr:=Unaligned(@dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width]);
              if (dup_pts_arr_ptr^*dup_pts_id    ) and
                 (dup_pts_arr_ptr^.dup_pts_cnt =0) then
                begin
                  dup_pts_arr_ptr^.dup_pts_cnt:=1;
                  Rectangle
                  (
                    pt.x,
                    pt.y,
                    pts_big_img.ln_arr0_ptr,
                    pts_big_img.ln_arr_width,
                    pts_big_img.ln_arr_height,
                    PtRct(rct_vis),
                    local_prop,
                    @PPFloodFill
                  );
                end;
            end
          else
            Rectangle
            (
              pt.x,
              pt.y,
              pts_big_img.ln_arr0_ptr,
              pts_big_img.ln_arr_width,
              pts_big_img.ln_arr_height,
              PtRct(rct_vis),
              local_prop,
              @PPFloodFill
            );
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.AddSplinePts5     (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  dup_pts_arr_ptr: PPtPos3;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          if (not sel_var.is_point_selected[b+i]) then
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                begin
                  dup_pts_arr_ptr:=Unaligned(@dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width]);
                  if (dup_pts_arr_ptr^*dup_pts_id    ) and
                     (dup_pts_arr_ptr^.dup_pts_cnt =0) then
                    begin
                      dup_pts_arr_ptr^.dup_pts_cnt:=1;
                      Rectangle
                      (
                        pt.x,
                        pt.y,
                        pts_big_img.ln_arr0_ptr,
                        pts_big_img.ln_arr_width,
                        pts_big_img.ln_arr_height,
                        PtRct(rct_vis),
                        local_prop,
                        @PPFloodFill
                      );
                    end;
                end
              else
                Rectangle
                (
                  pt.x,
                  pt.y,
                  pts_big_img.ln_arr0_ptr,
                  pts_big_img.ln_arr_width,
                  pts_big_img.ln_arr_height,
                  PtRct(rct_vis),
                  local_prop,
                  @PPFloodFill
                );
            end;
          Inc(sln_pts_ptr);
        end
    end;
end; {$endregion}
procedure TCurve.AddSplinePts6     (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  dup_pts_arr_ptr: PPtPos3;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          if sel_var.is_point_selected[b+i] then
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                begin
                  dup_pts_arr_ptr:=Unaligned(@dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width]);
                  if (not (dup_pts_arr_ptr^*dup_pts_id)   ) and
                     (     dup_pts_arr_ptr^.dup_pts_cnt =0) then
                    begin
                           dup_pts_arr_ptr^.dup_pts_cnt:=1;
                      Rectangle
                      (
                        pt.x,
                        pt.y,
                        pts_big_img.ln_arr0_ptr,
                        pts_big_img.ln_arr_width,
                        pts_big_img.ln_arr_height,
                        PtRct(rct_vis),
                        local_prop,
                        @PPFloodFill
                      );
                    end;
                end
              else
                Rectangle
                (
                  pt.x,
                  pt.y,
                  pts_big_img.ln_arr0_ptr,
                  pts_big_img.ln_arr_width,
                  pts_big_img.ln_arr_height,
                  PtRct(rct_vis),
                  local_prop,
                  @PPFloodFill
                );
            end;
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.AddSplinePts7     (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  dup_pts_arr_ptr: PPtPos3;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          if sel_var.is_point_selected[b+i] then
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                begin
                  dup_pts_arr_ptr:=Unaligned(@dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width]);
                  if (dup_pts_arr_ptr^*dup_pts_id    ) and
                     (dup_pts_arr_ptr^.dup_pts_cnt =0) then
                    begin
                      dup_pts_arr_ptr^.dup_pts_cnt:=1;
                      Rectangle
                      (
                        pt.x,
                        pt.y,
                        pts_big_img.ln_arr0_ptr,
                        pts_big_img.ln_arr_width,
                        pts_big_img.ln_arr_height,
                        PtRct(rct_vis),
                        local_prop,
                        @PPFloodFill
                      );
                    end;
                end
              else
                Rectangle
                (
                  pt.x,
                  pt.y,
                  pts_big_img.ln_arr0_ptr,
                  pts_big_img.ln_arr_width,
                  pts_big_img.ln_arr_height,
                  PtRct(rct_vis),
                  local_prop,
                  @PPFloodFill
                );
            end;
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.AddSplineDupPts0  (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
  sln_pts_ptr: PPtPosF;
  pt         : TPtPos;
  b,i        : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      //if (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^)) then
        for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
          begin
            pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                      Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
            if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
              dup_pts_id.SetEqual2(dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width],dup_pts_id);
            Inc(sln_pts_ptr);
          end;
    end;
end; {$endregion}
procedure TCurve.AddSplineDupPts1  (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
  sln_pts_ptr: PPtPosF;
  pt         : TPtPos;
  b,i        : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      //if (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^)) then
        for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
          begin
            if (not sel_var.is_point_selected[b+i]) then
              begin
                pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                          Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
                if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                  dup_pts_id.SetEqual2(dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width],dup_pts_id);
              end;
            Inc(sln_pts_ptr);
          end;
    end;
end; {$endregion}
procedure TCurve.AddSplineDupPts2  (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
  sln_pts_ptr: PPtPosF;
  pt         : TPtPos;
  b,i        : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      //if (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^)) then
        for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
          begin
            if (not sel_var.is_point_selected[b+i]) then
              begin
                pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                          Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
                if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                  dup_pts_id.SetEqual2(dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width],dup_pts_id);
              end;
            Inc(sln_pts_ptr);
          end;
    end;
end; {$endregion}
procedure TCurve.AddSplineDupPts3  (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
  sln_pts_ptr: PPtPosF;
  pt         : TPtPos;
  b,i        : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      //if (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^)) then
        for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
          begin
            if sel_var.is_point_selected[b+i] then
              begin
                pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                          Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
                if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                  dup_pts_id.SetEqual2(dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width],dup_pts_id);
              end;
            Inc(sln_pts_ptr);
          end;
    end;
end; {$endregion}
procedure TCurve.AddSplineDupPtsAll(constref start_ind,end_ind:TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
  sln_pts_ptr: PPtPosF;
  pt         : TPtPos;
  b,i,j      : integer;
begin
  for j:=start_ind to end_ind do
    with pts_img_arr[j] do
      begin
        b          :=partial_pts_sum[j];
        obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[j]]);
        sln_pts_ptr:=Unaligned(@sln_pts[b]);
        if (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^)) then
          for i:=0 to sln_obj_pts_cnt[j]-1 do
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                begin
                  dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width].obj_ind:=j;
                  dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width].pts_ind:=partial_pts_sum[j]+i;
                end;
              Inc(sln_pts_ptr);
            end;
      end;
end; {$endregion}
procedure TCurve.ClrSplineDupPts0  (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
  sln_pts_ptr: PPtPosF;
  pt         : TPtPos;
  b,i        : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
          if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
            dup_pts_id.SetEqual1(dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width],Default(TPtPos3));
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.ClrSplineDupPts1  (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
  sln_pts_ptr: PPtPosF;
  pt         : TPtPos;
  b,i        : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          if (not sel_var.is_point_selected[b+i]) then
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                dup_pts_id.SetEqual1(dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width],Default(TPtPos3));
            end;
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.ClrSplineDupPts2  (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
  sln_pts_ptr: PPtPosF;
  pt         : TPtPos;
  b,i        : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          begin
            pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                      Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
            if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
              dup_pts_id.SetEqual1(dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width],Default(TPtPos3));
          end;
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.ClrSplineDupPts3  (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
  sln_pts_ptr: PPtPosF;
  pt         : TPtPos;
  b,i        : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          if sel_var.is_point_selected[b+i] then
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                dup_pts_id.SetEqual1(dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width],Default(TPtPos3));
            end;
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.ClrSplineRctEds   (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_eds_img_arr[spline_ind],local_prop,fst_img,fast_image_data,fast_image_proc_var do
    if (rct_eds_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) and (nt_pix_cnt<>0) then
      begin
        fast_image_data_ptr0:=@fast_image_data;
        NTBeginProc[2];
        NTColorProc[0];
      end;
end; {$endregion}
procedure TCurve.ClrSplineRctPts   (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_pts_img_arr[spline_ind],local_prop,fst_img,fast_image_data,fast_image_proc_var do
    if (rct_pts_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) and (nt_pix_cnt<>0) then
      begin
        fast_image_data_ptr0:=@fast_image_data;
        NTBeginProc[2];
        NTColorProc[0];
      end;
end; {$endregion}
procedure TCurve.ClrSplineEds      (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with eds_img_arr[spline_ind],local_prop,fst_img,fast_image_data,fast_image_proc_var do
    if (eds_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) and (nt_pix_cnt<>0) then
      begin
        fast_image_data_ptr0:=@fast_image_data;
        NTBeginProc[2];
        NTColorProc[0];
      end;
end; {$endregion}
procedure TCurve.ClrSplinePts      (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pts_img_arr[spline_ind],local_prop,fst_img,fast_image_data,fast_image_proc_var do
    if (pts_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) and (nt_pix_cnt<>0) then
      begin
        fast_image_data_ptr0:=@fast_image_data;
        NTBeginProc[2];
        NTColorProc[0];
      end;
end; {$endregion}
procedure TCurve.ClrSplineAll      (constref start_ind,end_ind:TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j,k         : integer;
  editor_or_game: set of byte;
begin
  editor_or_game:=[0,1+Byte(obj_var.res_var_ptr^)];
  for i:=sln_obj_cnt-1 downto 0 do
    begin
      j:=obj_var.curve_inds_sct_arr[i];
      if (j>=start_ind) and (j<=end_ind) then
        if (obj_var.obj_arr[obj_var.obj_inds_arr[j]].obj_show in editor_or_game) then
          begin
            k:=obj_var.obj_arr[obj_var.obj_inds_arr[j]].k_ind;
            ClrSplinePts   (k);
            ClrSplineEds   (k);
            ClrSplineRctPts(k);
            ClrSplineRctEds(k);
          end;
    end;
end; {$endregion}
procedure TCurve.CrtSplineRctEds   (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_eds_img_arr[spline_ind],local_prop,fst_img,fast_image_data,fast_image_proc_var do
    begin

      fast_image_data_ptr0:=@fast_image_data;

      {Compress Sprite} {$region -fold}
      // clear buffers:
      ClrArr({%0000011111111111}%0000000011111111);
      // set color of edges  bounding rectangle sprite:
      SetPPInfo(clRed);
      // compress edges  bounding rectangle sprite:
      PrimitiveComp(spline_ind,@rct_eds_img_arr[spline_ind],@rct_eds_big_img,dsAlphablend); {$endregion}

      {Clear Buffer---} {$region -fold}
      FilNTValueArrA(rct_eds_big_img.ln_arr1,
                     rct_eds_big_img.ln_arr_width); {$endregion}

    end;
end; {$endregion}
procedure TCurve.CrtSplineRctPts   (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_pts_img_arr[spline_ind],local_prop,fst_img,fast_image_data,fast_image_proc_var do
    begin

      fast_image_data_ptr0:=@fast_image_data;

      {Compress Sprite} {$region -fold}
      // clear buffers:
      ClrArr({%0000011111111111}%0000000011111111);
      // set color of edges  bounding rectangle sprite:
      SetPPInfo(clBlue);
      // compress edges  bounding rectangle sprite:
      PrimitiveComp(spline_ind,@rct_pts_img_arr[spline_ind],@rct_pts_big_img,dsAlphablend); {$endregion}

      {Clear Buffer---} {$region -fold}
      FilNTValueArrA(rct_pts_big_img.ln_arr1,
                     rct_pts_big_img.ln_arr_width); {$endregion}

    end;
end; {$endregion}
procedure TCurve.CrtSplineEds      (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with eds_img_arr[spline_ind],local_prop,fst_img,fast_image_data,fast_image_proc_var do
    begin

      fast_image_data_ptr0:=@fast_image_data;

      {Compress Sprite} {$region -fold}
      // clear buffers:
      ClrArr({%0000011111111111}%0000000011111111);

      // set color of spline edges:
      SetPPInfo(eds_col);

      // compress edges sprite:
      PrimitiveComp(spline_ind,@eds_img_arr[spline_ind],@eds_big_img,eds_bld_stl); {$endregion}

      {Antialiasing---} {$region -fold}
      {if sln_eds_var_ptr^.spline_local_prop.ed_aa then
        begin
          BorderCalc1
          (
            sln_eds_var_ptr^.f_ln_arr1 ,
            sln_eds_var_ptr^.f_brd_arr1,
            sln_eds_var_ptr^.f_bmp_width,
            sln_eds_var_ptr^.f_bmp_width,
            0,
            0,
            sln_eds_var_ptr^.obj_rect_vis.Width ,
            sln_eds_var_ptr^.obj_rect_vis.Height,
            sln_eds_var_ptr^.aa_nz_arr_items_count
          );
          BorderCalc2
          (
            sln_eds_var_ptr^.f_ln_arr1 ,
            sln_eds_var_ptr^.f_brd_arr1,
            sln_eds_var_ptr^.f_brd_arr2,
            sln_eds_var_ptr^.f_bmp_width,
            sln_eds_var_ptr^.f_bmp_width,
            0,
            0,
            sln_eds_var_ptr^.obj_rect_vis.Width ,
            sln_eds_var_ptr^.obj_rect_vis.Height,
            sln_eds_var_ptr^.aa_line_count
          );
          BorderFill
          (
            sln_eds_var_ptr^.f_brd_arr2,
            sln_eds_var_ptr^.obj_rect_vis.Left,
            sln_eds_var_ptr^.obj_rect_vis.Top,
            m_c_var.srf_bmp_ptr,
            m_c_var.srf_bmp.Width ,
            sln_eds_var_ptr^.aa_line_count,
            sln_eds_var_ptr^.spline_local_prop.ed_color
          );
        end;} {$endregion}

      {Clear Buffer---} {$region -fold}
      if byte_mode and (not down_select_items_ptr^) then
        FilNTValueArrB(eds_big_img.ln_arr0,
                       eds_big_img.ln_arr_width)
      else
        FilNTValueArrA(eds_big_img.ln_arr1,
                       eds_big_img.ln_arr_width); {$endregion}

    end;
end; {$endregion}
procedure TCurve.CrtSplinePts      (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pts_img_arr[spline_ind],local_prop,fst_img,fast_image_data,fast_image_proc_var do
    begin

      fast_image_data_ptr0:=@fast_image_data;

      {Compress Sprite} {$region -fold}
      // clear buffers:
      ClrArr({%0000011111111111}%0000000011111111);

      // set color of spline points:
      SetPPInfo(pts_col);

      // compress points sprite:
      PrimitiveComp(spline_ind,@pts_img_arr[spline_ind],@pts_big_img,pts_bld_stl); {$endregion}

      {Clear Buffer---} {$region -fold}
      if byte_mode and (not down_select_items_ptr^) then
        FilNTValueArrB(pts_big_img.ln_arr0,
                       pts_big_img.ln_arr_width)
      else
        FilNTValueArrA(pts_big_img.ln_arr1,
                       pts_big_img.ln_arr_width); {$endregion}

    end;
end; {$endregion}
procedure TCurve.CrtSplineAll0     (constref start_ind,end_ind:TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=start_ind to end_ind do
    begin
      j:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].t_ind;
      if (j>=start_ind) and (j<=end_ind) then
        begin
          CrtSplineRctEds(i);
          CrtSplineRctPts(i);
          CrtSplineEds   (i);
          CrtSplinePts   (i);
        end;
    end;
end; {$endregion}
procedure TCurve.CrtSplineAll1     (constref start_ind,end_ind:TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=start_ind to end_ind do
    begin
      j:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].t_ind;
      if (j>=start_ind) and (j<=end_ind) then
        begin
          if (has_sel_pts[i]=0) then
            Continue;
          CrtSplineRctEds(i);
          CrtSplineRctPts(i);
          CrtSplineEds   (i);
          CrtSplinePts   (i);
        end;
    end;
end; {$endregion}
procedure TCurve.FilSplineRctEds   (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  i: integer;}
begin
  with rct_eds_img_arr[spline_ind],local_prop,fst_img,fast_image_data,fast_image_proc_var do
    if (rct_eds_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) and (nt_pix_cnt<>0) then
      begin
        fast_image_data_ptr0:=@fast_image_data;
        if lazy_repaint_prev and lazy_repaint then
          begin
            SetRctPos(rct_vis.left,rct_vis.top);
            bmp_src_rct_clp:=PtRct(rct_vis);
          end;
        if down_select_items_ptr^ then
          StrNTLowerBmpA;
        SdrProc[3];
        {for i:=0 to   fx_arr[0].rep_cnt-1 do
          NTValueProc[fx_arr[0].nt_value_proc_ind];}
      end;
end; {$endregion}
procedure TCurve.FilSplineRctPts   (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  i: integer;}
begin
  with rct_pts_img_arr[spline_ind],local_prop,fst_img,fast_image_data,fast_image_proc_var do
    if (rct_pts_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) and (nt_pix_cnt<>0) then
      begin
        fast_image_data_ptr0:=@fast_image_data;
        if lazy_repaint_prev and lazy_repaint then
          begin
            SetRctPos(rct_vis.left,rct_vis.top);
            bmp_src_rct_clp:=PtRct(rct_vis);
          end;
        if down_select_items_ptr^ then
          StrNTLowerBmpA;
        SdrProc[3];
        {for i:=0 to   fx_arr[0].rep_cnt-1 do
          NTValueProc[fx_arr[0].nt_value_proc_ind];}
      end;
end; {$endregion}
procedure TCurve.FilSplineEds      (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  i: integer;}
begin
  with eds_img_arr[spline_ind],local_prop,fst_img,fast_image_data,fast_image_proc_var do
    if (eds_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) and (nt_pix_cnt<>0) then
      begin
        fast_image_data_ptr0:=@fast_image_data;
        if lazy_repaint_prev and lazy_repaint then
          begin
            SetRctPos(rct_vis.left,rct_vis.top);
            bmp_src_rct_clp:=PtRct(rct_vis);
          end;
        if down_select_items_ptr^ then
          StrNTLowerBmpA;
        SdrProc[3];
        {for i:=0 to   fx_arr[0].rep_cnt-1 do
          NTValueProc[fx_arr[0].nt_value_proc_ind];}
      end;
end; {$endregion}
procedure TCurve.FilSplinePts      (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  i: integer;}
begin
  with pts_img_arr[spline_ind],local_prop,fst_img,fast_image_data,fast_image_proc_var do
    if (pts_show and (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^))) and (nt_pix_cnt<>0) then
      begin
        fast_image_data_ptr0:=@fast_image_data;
        if lazy_repaint_prev and lazy_repaint then
          begin
            SetRctPos(rct_vis.left,rct_vis.top);
            bmp_src_rct_clp:=PtRct(rct_vis);
          end;
        if down_select_items_ptr^ then
          StrNTLowerBmpA;
        SdrProc[3];
        {for i:=0 to   fx_arr[0].rep_cnt-1 do
          NTValueProc[fx_arr[0].nt_value_proc_ind];}
      end;
end; {$endregion}
procedure TCurve.FilSplineObj      (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if show_spline then
    begin
      FilSplineRctEds(spline_ind);
      FilSplineRctPts(spline_ind);
      FilSplineEds   (spline_ind);
      FilSplinePts   (spline_ind);
    end;
end; {$endregion}
procedure TCurve.FilSplineAll      (constref start_ind,end_ind:TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  if show_spline then
    for i:=0 to sln_obj_cnt-1 do
      begin
        j:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].t_ind;
        if (j>=start_ind) and (j<=end_ind) then
          FilSplineObj(i);
      end;
end; {$endregion}
procedure TCurve.FmlSplineInit;                                                                                                                                        {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FmlSplineObj[0]:=@Cycloid;
  FmlSplineObj[1]:=@Epicycloid;
  FmlSplineObj[2]:=@Rose;
  FmlSplineObj[3]:=@Spiral;
  FmlSplineObj[4]:=@Superellipse;
end; {$endregion}
procedure TCurve.FmlSplinePrev     (constref fml_pts_cnt      :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_out   : TPtRect;
  color_info: TColorInfo;
  eds_col_  : TColor;
  i         : integer;
begin
  if down_play_anim_ptr^ then
    Exit;
  with srf_var_ptr^,global_prop do
    begin
      sln_pts_cnt_add:=fml_pts_cnt;
      with PtRct(tex_var.tex_bmp_rct_pts) do
        FmlSplineObj[cur_tlt_dwn_btn_ind](world_axis.x+world_axis_shift.x,
                                          world_axis.y+world_axis_shift.y);
      sln_pts_cnt_add:=0;
      BmpToBmp2(srf_bmp_ptr ,low_bmp_ptr ,srf_bmp.width,low_bmp2.width,inn_wnd_rct,inn_wnd_mrg);
      BmpToBmp2(low_bmp_ptr ,low_bmp2_ptr,srf_bmp.width,low_bmp2.width,inn_wnd_rct,inn_wnd_mrg);
      BmpToBmp2(low_bmp2_ptr,srf_bmp_ptr ,srf_bmp.width,low_bmp2.width,inn_wnd_rct,inn_wnd_mrg);
      color_info:=Default(TColorInfo);
      SetColorInfo(SetColorInv(clRed),color_info);
      with inn_wnd_rct do
        rct_out:=PtRct(left,top,right-1,bottom-1);

      with sel_var.outer_subgraph_img do
        begin
          ArrClear(ln_arr0,rct_out,ln_arr_width);
          ArrClear(ln_arr2,rct_out);
          for i:=0 to fml_pts_cnt-2 do
            ClippedLine1
            (
              Trunc(fml_pts[i+0].x),
              Trunc(fml_pts[i+0].y),
              Trunc(fml_pts[i+1].x),
              Trunc(fml_pts[i+1].y),
              rct_out,
              Unaligned(@LineSME),
              Nil,
              Nil
            );
          if cnc_ends then
            ClippedLine1
            (
              Trunc(fml_pts[0            ].x),
              Trunc(fml_pts[0            ].y),
              Trunc(fml_pts[fml_pts_cnt-1].x),
              Trunc(fml_pts[fml_pts_cnt-1].y),
              rct_out,
              Unaligned(@LineSME),
              Nil,
              Nil
            );
          eds_col_:=eds_col;
          eds_col :=clRed;
          FillBuffer(rct_out);
          eds_col :=eds_col_;
        end;
      {LineABCG
      (
        fml_pts,
        0,
        fml_pts_cnt-1,
        srf_bmp_ptr,
        srf_bmp.width,
        color_info,
        rct,
        PtPos(0,0),
        cnc_ends and (fml_pts_cnt>2)
      );}
      if show_collider then
        begin
          SetColorInfo(clBlue,color_info);
          LineABCE
          (
            fml_pts,
            0,
            fml_pts_cnt-1,
            srf_bmp_ptr,
            srf_bmp.width,
            color_info,
            rct_out,
            PtPos(0,0),
            10,
            cnc_ends and (fml_pts_cnt>2)
          );
        end;
      if show_world_axis then
        WorldAxisDraw;
      CnvToCnv (srf_bmp_rct,F_MainForm.Canvas,srf_bmp.Canvas,SRCCOPY);
      BmpToBmp2(low_bmp_ptr,srf_bmp_ptr,srf_bmp.width,low_bmp2.width,inn_wnd_rct,inn_wnd_mrg);
    end;
end; {$endregion}
procedure TCurve.Cycloid           (constref x,y              :integer);                                                                                               {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fml_pts_ptr: PPtPosF;
  dt         : double;
  j          : integer;
  n          : integer=0;
  t          : double =0.0;
  a          : double =0.0;
begin
  with global_prop do
    begin
      if (sln_pts_cnt_add=0) then
        Exit;
      case cycloid_dir_x of
        mdLeft :
          begin
            case cycloid_dir_y of
              mdUp:
                begin
                  a:=-cycloid_loop_rad/pi;
                  n:=(cycloid_loop_cnt<<1);
                end;
              mdDown:
                begin
                  a:=  cycloid_loop_rad/pi;
                  n:=-(cycloid_loop_cnt<<1);
                end;
            end;
          end;
        mdRight:
          begin
            case cycloid_dir_y of
              mdUp:
                begin
                  a:=- cycloid_loop_rad/pi;
                  n:=-(cycloid_loop_cnt<<1);
                end;
              mdDown:
                begin
                  a:= cycloid_loop_rad/pi;
                  n:=(cycloid_loop_cnt<<1);
                end;
            end;
          end;
      end;
      dt         :=n*pi/sln_pts_cnt_add;
      fml_pts_ptr:=Unaligned(@fml_pts[0]);
      for j:=0 to sln_pts_cnt_add-1 do
        begin
          fml_pts_ptr^.x:=x+a*(t-Sin(t*cycloid_curvature)){x+a*Sin(t) - circle};
          fml_pts_ptr^.y:=y+a*(1-Cos(t*cycloid_curvature)){y+a*Cos(t) - circle};
          Inc(fml_pts_ptr);
          t+=dt;
        end;
    end;
end; {$endregion}
procedure TCurve.Epicycloid        (constref x,y              :integer);                                                                                               {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fml_pts_ptr     : PPtPosF;
  t0,t1,t2,t3,dt,k: double;
  j               : integer;
begin
  with global_prop do
    begin
      if (sln_pts_cnt_add=0) then
        Exit;
      dt         :=epicycloid_angle*FULL_ROT/sln_pts_cnt_add;
      case fml_type of
        (sfEpicycloid ): k:=epicycloid_petals_cnt+1;
        (sfHypocycloid): k:=epicycloid_petals_cnt-1;
      end;
      t0         :=epicycloid_rad*0.1;
      t1         :=epicycloid_rot;
      t2         :=epicycloid_rot;
      t3         :=dt*k;
      fml_pts_ptr:=Unaligned(@fml_pts[0]);
      case fml_type of
        (sfEpicycloid):
          for j:=0 to sln_pts_cnt_add-1 do
            begin
              fml_pts_ptr^.x:=x+t0*(k*cos(t1)-Cos(t2));
              fml_pts_ptr^.y:=y+t0*(k*sin(t1)-Sin(t2));
              Inc(fml_pts_ptr);
              t1+=dt;
              t2+=t3;
            end;
        (sfHypocycloid):
          for j:=0 to sln_pts_cnt_add-1 do
            begin
              fml_pts_ptr^.x:=x+t0*(k*cos(t1)+Cos(t2));{t0*((100-64)*Cos(t1)+k*Cos((100-64/64)*t1))}
              fml_pts_ptr^.y:=y+t0*(k*sin(t1)-Sin(t2));{t0*((100-64)*Sin(t1)-k*Sin((100-64/64)*t1))}
              Inc(fml_pts_ptr);
              t1+=dt;
              t2+=t3;
            end;
      end;
    end;
end; {$endregion}
procedure TCurve.Rose              (constref x,y              :integer);                                                                                               {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fml_pts_ptr: PPtPosF;
  t0,t1,dt   : double;
  j          : integer;
begin
  with global_prop do
    begin
      if (sln_pts_cnt_add=0) then
        Exit;
      dt         :=rose_angle*FULL_ROT/sln_pts_cnt_add;
      t0         :=rose_rad;
      t1         :=rose_rot;
      fml_pts_ptr:=Unaligned(@fml_pts[0]);
      if (not rose_mobius_grid) then
        for j:=0 to sln_pts_cnt_add-1 do
          begin
            fml_pts_ptr^.x:=x+t0*Sin(rose_petals_cnt*t1)*Cos(t1);
            fml_pts_ptr^.y:=y+t0*Sin(rose_petals_cnt*t1)*Sin(t1);
            Inc(fml_pts_ptr);
            t1+=dt;
          end
      else
        for j:=0 to sln_pts_cnt_add-1 do
          begin
            fml_pts_ptr^.x:=x+t0*Cos(rose_petals_cnt*t1)*Cos(t1);
            fml_pts_ptr^.y:=y+t0*Sin(rose_petals_cnt*t1)*Sin(t1);
            Inc(fml_pts_ptr);
            t1+=dt;
          end;
    end;
end; {$endregion}
procedure TCurve.Spiral            (constref x,y              :integer);                                                                                               {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fml_pts_ptr: PPtPosF;
  t0,t1,t2,dt: double;
  j          : integer;
begin
  with global_prop do
    begin
      if (sln_pts_cnt_add=0) then
        Exit;
      dt         :=spiral_angle*FULL_ROT/sln_pts_cnt_add;
      t0         :=spiral_rad*0.1;
      t1         :=spiral_rot;
      fml_pts_ptr:=Unaligned(@fml_pts[0]);
      if (spiral_coil_step=1) then
        for j:=0 to sln_pts_cnt_add-1 do
          begin
            fml_pts_ptr^.x:=x+t0*t1*cos(t1);
            fml_pts_ptr^.y:=y+t0*t1*sin(t1);
            Inc(fml_pts_ptr);
            t1+=dt;
          end
      else
        begin
          if (spiral_coil_step<=0) and (spiral_rot=0) then
            t1:=dt;
          for j:=0 to sln_pts_cnt_add-1 do
            begin
              t2            :=Exp(spiral_coil_step*Ln(t1));
              fml_pts_ptr^.x:=x+t0*t2*cos(t1);
              fml_pts_ptr^.y:=y+t0*t2*sin(t1);
              Inc(fml_pts_ptr);
              t1+=dt;
            end;
        end;
    end;
end; {$endregion}
procedure TCurve.Superellipse      (constref x,y              :integer);                                                                                               {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fml_pts_ptr: PPtPosF;
  t0,t1,dt   : double;
  j          : integer;
begin
  with global_prop do
    begin
      if (sln_pts_cnt_add=0) then
        Exit;
      dt         :=superellipse_angle*FULL_ROT/sln_pts_cnt_add;
      t0         :=superellipse_rad;
      t1         :=superellipse_rot;
      fml_pts_ptr:=Unaligned(@fml_pts[0]);
      for j:=0 to sln_pts_cnt_add-1 do
        begin
          fml_pts_ptr^.x:=x+t0*Exp(superellipse_curvature0*Abs(Cos(t1)))*superellipse_curvature2*sign(Cos(t1));
          fml_pts_ptr^.y:=y+t0*Exp(superellipse_curvature1*Abs(Sin(t1)))*superellipse_curvature3*sign(Sin(t1));
          Inc(fml_pts_ptr);
          t1+=dt;
        end;
    end;
end; {$endregion}
procedure TCurve.HasSplineEds      (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with eds_img_arr[spline_ind],local_prop do
    if (not hid_ln_elim) then
      begin
        has_ln_cnt:=ArrNzItCnt(@has_edge[partial_pts_sum[spline_ind]],
                               sln_obj_pts_cnt[spline_ind]-1,
                               False);
        if (has_ln_cnt=0) then
          Exit;
        SetLength (sln_vis_eds_ind[spline_ind],
                   has_ln_cnt);
        ArrNzItCrt(@has_edge[partial_pts_sum[spline_ind]],
                   @sln_vis_eds_ind[spline_ind,0],
                   sln_obj_pts_cnt [spline_ind]-1,
                   has_ln_cnt);
      end;
end; {$endregion}
procedure TCurve.MovSplineRctEds   (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
begin
  with rct_eds_img_arr[spline_ind],local_prop do
    begin
      obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]];
      MDCalc(rct_ent,cmr_var.mov_dir,PtPos(obj_arr_ptr^.parallax_shift));
      if (rct_eds_show and (not IsRct1OutOfRct2(rct_ent,obj_arr_ptr^.rct_dst_ptr^))) then
        begin

          {Misc. Precalc.------------------------------------------------------------} {$region -fold}
          SetBkgnd
          (
            obj_arr_ptr^.bkgnd_ptr,
            obj_arr_ptr^.bkgnd_width,
            obj_arr_ptr^.bkgnd_height,
            obj_arr_ptr^.rct_clp_ptr
          ); {$endregion}

          {Drawing Of Spline Object Edges Bounding Rectangle-------------------------} {$region -fold}
          Rectangle
          (
            pts_rct_width__half-pts_rct_width__odd+rct_ent.left,
            pts_rct_height_half-pts_rct_height_odd+rct_ent.top ,
            bmp_dst_ptr,
            bmp_dst_width,
            bmp_dst_height,
            obj_arr_ptr^.rct_dst_ptr^,
            local_prop
          ); {$endregion}

        end;
    end;
end; {$endregion}
procedure TCurve.MovSplineRctPts   (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
begin
  with rct_pts_img_arr[spline_ind],local_prop do
    begin
      obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]];
      MDCalc(rct_ent,cmr_var.mov_dir,PtPos(obj_arr_ptr^.parallax_shift));
      if (rct_pts_show and (not IsRct1OutOfRct2(rct_ent,obj_arr_ptr^.rct_dst_ptr^))) then
        begin

          {Misc. Precalc.------------------------------------------------------------} {$region -fold}
          SetBkgnd
          (
            obj_arr_ptr^.bkgnd_ptr,
            obj_arr_ptr^.bkgnd_width,
            obj_arr_ptr^.bkgnd_height,
            obj_arr_ptr^.rct_clp_ptr
          ); {$endregion}

          {Drawing Of Spline Object Edges Bounding Rectangle-------------------------} {$region -fold}
          Rectangle
          (
            pts_rct_width__half-pts_rct_width__odd+rct_ent.left,
            pts_rct_height_half-pts_rct_height_odd+rct_ent.top ,
            bmp_dst_ptr,
            bmp_dst_width,
            bmp_dst_height,
            obj_arr_ptr^.rct_dst_ptr^,
            local_prop
          ); {$endregion}

        end;
    end;
end; {$endregion}
procedure TCurve.MovSplineEds0     (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  sln_pts_ptr    : PPtPosF;
  rct_out        : TPtRect;
  x0,y0,x1,y1,b,i: integer;
  max_w_h_div_2  : integer;
  min_w_h_div_2  : integer;
  rct_rad        : double;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin
      obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]];
      MDCalc(rct_ent,cmr_var.mov_dir,PtPos(obj_arr_ptr^.parallax_shift));
      if (eds_show and (not IsRct1OutOfRct2(rct_ent,obj_arr_ptr^.rct_dst_ptr^))) then
        begin

          {Misc. Precalc.------------------------------------------------------------} {$region -fold}
          b:=partial_pts_sum[spline_ind];
          SetBkgnd
          (
            obj_arr_ptr^.bkgnd_ptr,
            obj_arr_ptr^.bkgnd_width,
            obj_arr_ptr^.bkgnd_height,
            obj_arr_ptr^.rct_clp_ptr
          );
          rct_out:=PtRct(obj_arr_ptr^.rct_dst_ptr^.left  +0,
                         obj_arr_ptr^.rct_dst_ptr^.top   +0,
                         obj_arr_ptr^.rct_dst_ptr^.right -1,
                         obj_arr_ptr^.rct_dst_ptr^.bottom-1);
          max_w_h_div_2:=Max(rct_out.width,rct_out.height)>>1;
          min_w_h_div_2:=Min(rct_out.width,rct_out.height)>>1;
          rct_rad      :=sqrt(sqr(max_w_h_div_2)+sqr(min_w_h_div_2)); {$endregion}

          case eds_width of
            1:
              begin

                {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                if cnc_ends then
                  ClippedLine1
                  (
                    Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL30),
                    Unaligned(@LineSHL30)
                  ); {$endregion}

                {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                sln_pts_ptr:=Unaligned(@sln_pts[b]);
                for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
                  begin
                    x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                    if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_out)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad,0)} then
                      ClippedLine1
                      (
                        Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                        Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                        Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL30),
                        Unaligned(@LineSHL30)
                      );
                    Inc(sln_pts_ptr);
                  end; {$endregion}

              end;

            2:
              begin

                {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                if cnc_ends then
                  begin
                    x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                    ClippedLine1
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL30),
                      Unaligned(@LineSHL30)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL30),
                        Unaligned(@LineSHL30)
                      )
                    else
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL30),
                        Unaligned(@LineSHL30)
                      )
                  end; {$endregion}

                {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                sln_pts_ptr:=Unaligned(@sln_pts[b]);
                for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
                  begin
                    x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                    if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_out)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad+1,0)} then
                      begin
                        ClippedLine1
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          ClippedLine1
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30)
                          )
                        else
                          ClippedLine1
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30)
                          );
                      end;
                    Inc(sln_pts_ptr);
                  end; {$endregion}

              end;
            3:
              begin

                {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                if cnc_ends then
                  begin
                    x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                    ClippedLine1
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL30),
                      Unaligned(@LineSHL30)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      begin
                        ClippedLine1
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30)
                        );
                        ClippedLine1
                        (
                          x0+0,
                          y0-1,
                          x1+0,
                          y1-1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30)
                        );
                      end
                    else
                      begin
                        ClippedLine1
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30)
                        );
                        ClippedLine1
                        (
                          x0-1,
                          y0+0,
                          x1-1,
                          y1+0,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30)
                        );
                      end;
                  end; {$endregion}

                {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                sln_pts_ptr:=Unaligned(@sln_pts[b]);
                for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
                  begin
                    x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                    if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_out)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad+2,0)} then
                      begin
                        ClippedLine1
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          begin
                            ClippedLine1
                            (
                              x0+0,
                              y0+1,
                              x1+0,
                              y1+1,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30)
                            );
                            ClippedLine1
                            (
                              x0+0,
                              y0-1,
                              x1+0,
                              y1-1,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30)
                            );
                          end
                        else
                          begin
                            ClippedLine1
                            (
                              x0+1,
                              y0+0,
                              x1+1,
                              y1+0,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30)
                            );
                            ClippedLine1
                            (
                              x0-1,
                              y0+0,
                              x1-1,
                              y1+0,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30)
                            );
                          end;
                      end;
                    Inc(sln_pts_ptr);
                  end; {$endregion}

              end;
          end;

        end;
    end;
end; {$endregion}
procedure TCurve.MovSplineEds1     (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  sln_pts_ptr    : PPtPosF;
  rct_out        : TPtRect;
  x0,y0,x1,y1,b,i: integer;
  max_w_h_div_2  : integer;
  min_w_h_div_2  : integer;
  rct_rad        : double;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin
      obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]];
      MDCalc(rct_ent,cmr_var.mov_dir,PtPos(obj_arr_ptr^.parallax_shift));
      if (eds_show and (not IsRct1OutOfRct2(rct_ent,obj_arr_ptr^.rct_dst_ptr^))) then
        begin

          {Misc. Precalc.------------------------------------------------------------} {$region -fold}
          b:=partial_pts_sum[spline_ind];
          SetBkgnd
          (
            obj_arr_ptr^.bkgnd_ptr,
            obj_arr_ptr^.bkgnd_width,
            obj_arr_ptr^.bkgnd_height,
            obj_arr_ptr^.rct_clp_ptr
          );
          rct_out:=PtRct(obj_arr_ptr^.rct_dst_ptr^.left  +0,
                         obj_arr_ptr^.rct_dst_ptr^.top   +0,
                         obj_arr_ptr^.rct_dst_ptr^.right -1,
                         obj_arr_ptr^.rct_dst_ptr^.bottom-1);
          max_w_h_div_2:=Max(rct_out.width,rct_out.height)>>1;
          min_w_h_div_2:=Min(rct_out.width,rct_out.height)>>1;
          rct_rad      :=sqrt(sqr(max_w_h_div_2)+sqr(min_w_h_div_2)); {$endregion}

          case eds_width of
            1:
              begin

                {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                if (not (sel_var.is_point_selected[b+00000000000000000000000000000] or
                         sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1])) then
                  if cnc_ends then
                    ClippedLine1
                    (
                      Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                      Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                      Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                      Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL30),
                      Unaligned(@LineSHL30)
                    ); {$endregion}

                {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                sln_pts_ptr:=Unaligned(@sln_pts[b]);
                for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
                  begin
                    if (not (sel_var.is_point_selected[b+i] or
                             sel_var.is_point_selected[b+i+1])) then
                      begin
                        x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_out)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad,0)} then
                          ClippedLine1
                          (
                            Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x,
                            Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y,
                            Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x,
                            Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30)
                          );
                      end;
                    Inc(sln_pts_ptr);
                  end; {$endregion}

              end;

            2:
              begin

                {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                if (not (sel_var.is_point_selected[b+00000000000000000000000000000] or
                         sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1])) then
                  if cnc_ends then
                    begin
                      x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                      y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                      x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                      y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                      ClippedLine1
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL30),
                        Unaligned(@LineSHL30)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        ClippedLine1
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30)
                        )
                      else
                        ClippedLine1
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30)
                        )
                    end; {$endregion}

                {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                sln_pts_ptr:=Unaligned(@sln_pts[b]);
                for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
                  begin
                    if (not (sel_var.is_point_selected[b+i] or
                             sel_var.is_point_selected[b+i+1])) then
                      begin
                        x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_out)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad+1,0)} then
                          begin
                            ClippedLine1
                            (
                              x0,
                              y0,
                              x1,
                              y1,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30)
                            );
                            if (Abs(y1-y0)<Abs(x1-x0)) then
                              ClippedLine1
                              (
                                x0+0,
                                y0+1,
                                x1+0,
                                y1+1,
                                rct_out,
                                Unaligned(@LinePHL  ),
                                Unaligned(@LinePHL30),
                                Unaligned(@LineSHL30)
                              )
                            else
                              ClippedLine1
                              (
                                x0+1,
                                y0+0,
                                x1+1,
                                y1+0,
                                rct_out,
                                Unaligned(@LinePHL  ),
                                Unaligned(@LinePHL30),
                                Unaligned(@LineSHL30)
                              );
                          end;
                      end;
                    Inc(sln_pts_ptr);
                  end; {$endregion}

              end;
            3:
              begin

                {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                if (not (sel_var.is_point_selected[b+00000000000000000000000000000] or
                         sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1])) then
                  if cnc_ends then
                    begin
                      x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                      y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                      x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                      y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                      ClippedLine1
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL30),
                        Unaligned(@LineSHL30)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        begin
                          ClippedLine1
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30)
                          );
                          ClippedLine1
                          (
                            x0+0,
                            y0-1,
                            x1+0,
                            y1-1,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30)
                          );
                        end
                      else
                        begin
                          ClippedLine1
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30)
                          );
                          ClippedLine1
                          (
                            x0-1,
                            y0+0,
                            x1-1,
                            y1+0,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30)
                          );
                        end;
                    end; {$endregion}

                {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                sln_pts_ptr:=Unaligned(@sln_pts[b]);
                for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
                  begin
                    if (not (sel_var.is_point_selected[b+i] or
                             sel_var.is_point_selected[b+i+1])) then
                      begin
                        x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_out)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad+2,0)} then
                          begin
                            ClippedLine1
                            (
                              x0,
                              y0,
                              x1,
                              y1,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30)
                            );
                            if (Abs(y1-y0)<Abs(x1-x0)) then
                              begin
                                ClippedLine1
                                (
                                  x0+0,
                                  y0+1,
                                  x1+0,
                                  y1+1,
                                  rct_out,
                                  Unaligned(@LinePHL  ),
                                  Unaligned(@LinePHL30),
                                  Unaligned(@LineSHL30)
                                );
                                ClippedLine1
                                (
                                  x0+0,
                                  y0-1,
                                  x1+0,
                                  y1-1,
                                  rct_out,
                                  Unaligned(@LinePHL  ),
                                  Unaligned(@LinePHL30),
                                  Unaligned(@LineSHL30)
                                );
                              end
                            else
                              begin
                                ClippedLine1
                                (
                                  x0+1,
                                  y0+0,
                                  x1+1,
                                  y1+0,
                                  rct_out,
                                  Unaligned(@LinePHL  ),
                                  Unaligned(@LinePHL30),
                                  Unaligned(@LineSHL30)
                                );
                                ClippedLine1
                                (
                                  x0-1,
                                  y0+0,
                                  x1-1,
                                  y1+0,
                                  rct_out,
                                  Unaligned(@LinePHL  ),
                                  Unaligned(@LinePHL30),
                                  Unaligned(@LineSHL30)
                                );
                              end;
                          end;
                      end;
                    Inc(sln_pts_ptr);
                  end; {$endregion}

              end;
          end;

        end;
    end;
end; {$endregion}
procedure TCurve.MovSplineEds2     (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjInfo;
  sln_pts_ptr    : PPtPosF;
  useless_arr_ptr: PByte;
  rct_out        : TPtRect;
  x0,y0,x1,y1,b,i: integer;
  max_w_h_div_2  : integer;
  min_w_h_div_2  : integer;
  rct_rad        : double;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin
      obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]];
      MDCalc(rct_ent,cmr_var.mov_dir,PtPos(obj_arr_ptr^.parallax_shift));
      if (eds_show and (not IsRct1OutOfRct2(rct_ent,obj_arr_ptr^.rct_dst_ptr^))) then
        begin

          {Misc. Precalc.------------------------------------------------------------} {$region -fold}
          b:=partial_pts_sum[spline_ind];
          SetBkgnd
          (
            obj_arr_ptr^.bkgnd_ptr,
            obj_arr_ptr^.bkgnd_width,
            obj_arr_ptr^.bkgnd_height,
            obj_arr_ptr^.rct_clp_ptr
          );
          rct_out:=PtRct(obj_arr_ptr^.rct_dst_ptr^.left  +0,
                         obj_arr_ptr^.rct_dst_ptr^.top   +0,
                         obj_arr_ptr^.rct_dst_ptr^.right -1,
                         obj_arr_ptr^.rct_dst_ptr^.bottom-1);
          max_w_h_div_2:=Max(rct_out.width,rct_out.height)>>1;
          min_w_h_div_2:=Min(rct_out.width,rct_out.height)>>1;
          rct_rad      :=sqrt(sqr(max_w_h_div_2)+sqr(min_w_h_div_2)); {$endregion}

          case eds_width of
            1:
              begin

                {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                if cnc_ends then
                  ClippedLine1
                  (
                    Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y,
                    Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x,
                    Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y,
                    rct_out,
                    Unaligned(@LinePHL  ),
                    Unaligned(@LinePHL30),
                    Unaligned(@LineSHL30)
                  ); {$endregion}

                {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                useless_arr_ptr:=Unaligned(@useless_arr[0]);
                sln_pts_ptr    :=Unaligned(@sln_pts    [b]);
                for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
                  begin
                    if (useless_arr_ptr^=1) then
                      begin
                        x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_out)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad,0)} then
                          ClippedLine1
                          (
                            x0,
                            y0,
                            x1,
                            y1,
                            rct_out,
                            Unaligned(@LinePHL  ),
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30)
                          );
                      end;
                    Inc(useless_arr_ptr);
                    Inc(sln_pts_ptr);
                  end; {$endregion}

              end;

            2:
              begin

                {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                if cnc_ends then
                  begin
                    x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                    ClippedLine1
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL30),
                      Unaligned(@LineSHL30)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      ClippedLine1
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL30),
                        Unaligned(@LineSHL30)
                      )
                    else
                      ClippedLine1
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_out,
                        Unaligned(@LinePHL  ),
                        Unaligned(@LinePHL30),
                        Unaligned(@LineSHL30)
                      );
                  end; {$endregion}

                {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                useless_arr_ptr:=Unaligned(@useless_arr[0]);
                sln_pts_ptr    :=Unaligned(@sln_pts    [b]);
                for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
                  begin
                    if (useless_arr_ptr^=1) then
                      begin
                        x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_out)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad+1,0)} then
                          begin
                            ClippedLine1
                            (
                              x0,
                              y0,
                              x1,
                              y1,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30)
                            );
                            if (Abs(y1-y0)<Abs(x1-x0)) then
                              ClippedLine1
                              (
                                x0+0,
                                y0+1,
                                x1+0,
                                y1+1,
                                rct_out,
                                Unaligned(@LinePHL  ),
                                Unaligned(@LinePHL30),
                                Unaligned(@LineSHL30)
                              )
                            else
                              ClippedLine1
                              (
                                x0+1,
                                y0+0,
                                x1+1,
                                y1+0,
                                rct_out,
                                Unaligned(@LinePHL  ),
                                Unaligned(@LinePHL30),
                                Unaligned(@LineSHL30)
                              );
                          end;
                      end;
                    Inc(useless_arr_ptr);
                    Inc(sln_pts_ptr);
                  end; {$endregion}

              end;
            3:
              begin

                {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                if cnc_ends then
                  begin
                    x0:=Trunc(sln_pts[b+00000000000000000000000000000].x)+obj_arr_ptr^.world_axis_shift.x;
                    y0:=Trunc(sln_pts[b+00000000000000000000000000000].y)+obj_arr_ptr^.world_axis_shift.y;
                    x1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x)+obj_arr_ptr^.world_axis_shift.x;
                    y1:=Trunc(sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y)+obj_arr_ptr^.world_axis_shift.y;
                    ClippedLine1
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      rct_out,
                      Unaligned(@LinePHL  ),
                      Unaligned(@LinePHL30),
                      Unaligned(@LineSHL30)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      begin
                        ClippedLine1
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30)
                        );
                        ClippedLine1
                        (
                          x0+0,
                          y0-1,
                          x1+0,
                          y1-1,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30)
                        );
                      end
                    else
                      begin
                        ClippedLine1
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30)
                        );
                        ClippedLine1
                        (
                          x0-1,
                          y0+0,
                          x1-1,
                          y1+0,
                          rct_out,
                          Unaligned(@LinePHL  ),
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30)
                        );
                      end;
                  end; {$endregion}

                {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                useless_arr_ptr:=Unaligned(@useless_arr[0]);
                sln_pts_ptr    :=Unaligned(@sln_pts    [b]);
                for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
                  begin
                    if (useless_arr_ptr^=1) then
                      begin
                        x0:=Trunc((sln_pts_ptr+0)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y0:=Trunc((sln_pts_ptr+0)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        x1:=Trunc((sln_pts_ptr+1)^.x)+obj_arr_ptr^.world_axis_shift.x;
                        y1:=Trunc((sln_pts_ptr+1)^.y)+obj_arr_ptr^.world_axis_shift.y;
                        if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_out)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad+2,0)} then
                          begin
                            ClippedLine1
                            (
                              x0,
                              y0,
                              x1,
                              y1,
                              rct_out,
                              Unaligned(@LinePHL  ),
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30)
                            );
                            if (Abs(y1-y0)<Abs(x1-x0)) then
                              begin
                                ClippedLine1
                                (
                                  x0+0,
                                  y0+1,
                                  x1+0,
                                  y1+1,
                                  rct_out,
                                  Unaligned(@LinePHL  ),
                                  Unaligned(@LinePHL30),
                                  Unaligned(@LineSHL30)
                                );
                                ClippedLine1
                                (
                                  x0+0,
                                  y0-1,
                                  x1+0,
                                  y1-1,
                                  rct_out,
                                  Unaligned(@LinePHL  ),
                                  Unaligned(@LinePHL30),
                                  Unaligned(@LineSHL30)
                                );
                              end
                            else
                              begin
                                ClippedLine1
                                (
                                  x0+1,
                                  y0+0,
                                  x1+1,
                                  y1+0,
                                  rct_out,
                                  Unaligned(@LinePHL  ),
                                  Unaligned(@LinePHL30),
                                  Unaligned(@LineSHL30)
                                );
                                ClippedLine1
                                (
                                  x0-1,
                                  y0+0,
                                  x1-1,
                                  y1+0,
                                  rct_out,
                                  Unaligned(@LinePHL  ),
                                  Unaligned(@LinePHL30),
                                  Unaligned(@LineSHL30)
                                );
                              end;
                          end;
                      end;
                    Inc(useless_arr_ptr);
                    Inc(sln_pts_ptr);
                  end; {$endregion}

              end;
          end;

        end;
    end;
end; {$endregion}
procedure TCurve.MovSplinePts0     (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
  sln_pts_ptr: PPtPosF;
  b,i        : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]];
      MDCalc(rct_ent,cmr_var.mov_dir,PtPos(obj_arr_ptr^.parallax_shift));
      if (pts_show and (not IsRct1OutOfRct2(rct_ent,obj_arr_ptr^.rct_dst_ptr^))) then
        begin

          {Misc. Precalc.-----------------} {$region -fold}
          b:=partial_pts_sum[spline_ind];
          SetBkgnd
          (
            obj_arr_ptr^.bkgnd_ptr,
            obj_arr_ptr^.bkgnd_width,
            obj_arr_ptr^.bkgnd_height,
            obj_arr_ptr^.rct_clp_ptr
          ); {$endregion}

          {Drawing Of Spline Object Points} {$region -fold}
          sln_pts_ptr:=Unaligned(@sln_pts[b]);
          for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
            begin
              Rectangle
              (
                Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y,
                bmp_dst_ptr,
                bmp_dst_width,
                bmp_dst_height,
                obj_arr_ptr^.rct_dst_ptr^,
                local_prop
              );
              Inc(sln_pts_ptr);
            end; {$endregion}

        end;
    end;
end; {$endregion}
procedure TCurve.MovSplinePts1     (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
  sln_pts_ptr: PPtPosF;
  b,i        : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]];
      MDCalc(rct_ent,cmr_var.mov_dir,PtPos(obj_arr_ptr^.parallax_shift));
      if (pts_show and (not IsRct1OutOfRct2(rct_ent,obj_arr_ptr^.rct_dst_ptr^))) then
        begin

          {Misc. Precalc.-----------------} {$region -fold}
          b:=partial_pts_sum[spline_ind];
          SetBkgnd
          (
            obj_arr_ptr^.bkgnd_ptr,
            obj_arr_ptr^.bkgnd_width,
            obj_arr_ptr^.bkgnd_height,
            obj_arr_ptr^.rct_clp_ptr
          ); {$endregion}

          {Drawing Of Spline Object Points} {$region -fold}
          sln_pts_ptr:=Unaligned(@sln_pts[b]);
          for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
            begin
              if (not sel_var.is_point_selected[b+i]) then
                Rectangle
                (
                  Trunc(sln_pts_ptr^.x)+obj_arr_ptr^.world_axis_shift.x,
                  Trunc(sln_pts_ptr^.y)+obj_arr_ptr^.world_axis_shift.y,
                  bmp_dst_ptr,
                  bmp_dst_width,
                  bmp_dst_height,
                  obj_arr_ptr^.rct_dst_ptr^,
                  local_prop
                );
              Inc(sln_pts_ptr);
            end; {$endregion}

        end;
    end;
end; {$endregion}
procedure TCurve.MovSplineObj      (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (not show_spline) then
    Exit;
  MovSplineRctEds(spline_ind);
  MovSplineRctPts(spline_ind);
  if (has_sel_pts[spline_ind]=0) then
    begin
      if (not eds_img_arr[spline_ind].local_prop.hid_ln_elim) then
        MovSplineEds0(spline_ind)
      else
        MovSplineEds2(spline_ind);
        MovSplinePts0(spline_ind);
    end
  else
    begin
      MovSplineEds1(spline_ind);
      MovSplinePts1(spline_ind);
    end;
end; {$endregion}
procedure TCurve.MovSplineAll      (constref start_ind,end_ind:TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=start_ind to end_ind do
    begin
      MovSplineRctEds(i);
      MovSplineRctPts(i);
      if (has_sel_pts[i]=0) then
        begin
          if (not eds_img_arr[i].local_prop.hid_ln_elim) then
            MovSplineEds0(i)
          else
            MovSplineEds2(i);
          MovSplinePts0(i);
        end
      else
        begin
          MovSplineEds1(i);
          MovSplinePts1(i);
        end;
    end;
end; {$endregion}
procedure TCurve.RepSplineRctEds   (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_eds_img_arr[spline_ind],local_prop,fst_img,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      ResNTValueArr(rct_eds_big_img.ln_arr1,
                    rct_eds_big_img.ln_arr_width);
    end;
end; {$endregion}
procedure TCurve.RepSplineRctPts   (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_pts_img_arr[spline_ind],local_prop,fst_img,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      ResNTValueArr(rct_pts_big_img.ln_arr1,
                    rct_pts_big_img.ln_arr_width);
    end;
end; {$endregion}
procedure TCurve.RepSplineEds      (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with eds_img_arr[spline_ind],local_prop,fst_img,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      ResNTValueArr(eds_big_img.ln_arr1,
                    eds_big_img.ln_arr_width);
    end;
end; {$endregion}
procedure TCurve.RepSplinePts      (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pts_img_arr[spline_ind],local_prop,fst_img,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      ResNTValueArr(pts_big_img.ln_arr1,
                    pts_big_img.ln_arr_width);
    end;
end; {$endregion}
procedure TCurve.RndSplineCol      (var      local_prop       :TCurveProp; var col,col_inv:TColor; var col_ptr:PInteger; constref btn:TSpeedButton);                   {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with local_prop do
   begin
     col     :=Random($7FFFFFFF);
     col_inv :=SetColorInv(col);
     col_ptr :=@btn.Color;
     col_ptr^:=col;
     btn.Repaint;
   end;
end; {$endregion}
procedure TCurve.RndSplineObj      (constref pt               :TPtPos; constref w,h:TColor);                                                                           {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  sln_pts_add_ptr: PPtPosF;
  i,w_,h_        : integer;
begin
  Randomize;
  w_             :=pt.x-w>>1;
  h_             :=pt.y-h>>1;
  sln_pts_cnt_add:=global_prop.pts_cnt_val;
  Inc(sln_pts_cnt,sln_pts_cnt_add);
  SetLength(sln_pts_add,0);
  SetLength(sln_pts_add,sln_pts_cnt_add);
  sln_pts_add_ptr:=Unaligned(@sln_pts_add[0]);
  for i:=0 to sln_pts_cnt_add-1 do
    begin
      (sln_pts_add_ptr+i)^.x:=w_+Random(w);
      (sln_pts_add_ptr+i)^.y:=h_+Random(h);
    end;
  {for i:=0 to Trunc(sln_pts_cnt_add/2)-1 do
    begin
      sln_pts_add[i<<1+0].x:=w_;
      sln_pts_add[i<<1+0].y:=h_;
      sln_pts_add[i<<1+1].x:=w_+w;
      sln_pts_add[i<<1+1].y:=h_+h;
    end;}
end; {$endregion}
procedure TCurve.SmpSplinePts      (constref spline_ind       :TColor);                                                                                                {inline;} {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k1,k2        : double;
  i,m1,m2,m3,m4: integer;
begin
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_SplineClick                                         (sender:TObject); {$region -fold}
begin
  DrawingPanelsSetVisibility1(down_spline_ptr,P_Spline,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_spline_ptr^) then
    Exit;
  AddDocContent(RM_Description,curve_doc_str_arr,curve_doc_font_arr,0);
end; {$endregion}
{Edges-------}
procedure TF_MainForm.P_Spline_Edges_PropMouseEnter                          (sender:TObject); {$region -fold}
begin
  P_Spline_Edges_Prop.Color:=HighLight(P_Spline_Edges_Prop.Color,0,0,0,0,0,16);
  //P_Spline_Edges_Prop.Color:=NAV_SEL_COL_1;
end; {$endregion}
procedure TF_MainForm.P_Spline_Edges_PropMouseLeave                          (sender:TObject); {$region -fold}
begin
  P_Spline_Edges_Prop.Color:=Darken(P_Spline_Edges_Prop.Color,0,0,0,0,0,16);
  //P_Spline_Edges_Prop.Color:=$00BAB5A3;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Edges_StyleSelect                            (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.eds_bld_stl:=TDrawingStyle(CB_Spline_Edges_Style.ItemIndex);
end; {$endregion}
procedure TF_MainForm.SB_Spline_Edges_ShowClick                              (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Edges_Show,sln_var.global_prop.eds_show);
end; {$endregion}
procedure TF_MainForm.SB_Spline_Edges_ColorClick                             (sender:TObject); {$region -fold}
begin
  CD_Select_Color.Color:=SB_Spline_Edges_Color.Color;
  CD_Select_Color.Execute;
  with sln_var.global_prop do
    begin
      eds_col    :=CD_Select_Color.Color;
      eds_col_inv:=SetColorInv(eds_col);
    end;
  SB_Spline_Edges_Color.Color:=CD_Select_Color.Color;
  SB_Spline_Edges_Color.Down :=False;
end; {$endregion}
procedure TF_MainForm.SB_Spline_Edges_Color_RandomClick                      (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Edges_Color_Random,sln_var.global_prop.eds_col_rnd);
end; {$endregion}
procedure TF_MainForm.SB_Spline_Edges_Color_FallOffClick                     (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Edges_Color_FallOff,sln_var.global_prop.eds_col_fall_off);
end; {$endregion}
procedure TF_MainForm.CB_Spline_Edges_Show_BoundsChange                      (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.rct_eds_show:=not sln_var.global_prop.rct_eds_show;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Edges_ShapeSelect                            (sender:TObject); {$region -fold}
begin
  case CB_Spline_Edges_Shape.ItemIndex of
    0:
      begin
        L_Spline_Edges_Width         .Enabled:=True;
        SE_Spline_Edges_Width        .Enabled:=True;
        L_Spline_Edges_Dash_Length   .Enabled:=False;
        SE_Spline_Edges_Dash_Length  .Enabled:=False;
        L_Spline_Edges_Points_Radius .Enabled:=False;
        SE_Spline_Edges_Points_Radius.Enabled:=False;
      end;
    1:
      begin
        L_Spline_Edges_Width         .Enabled:=True;
        SE_Spline_Edges_Width        .Enabled:=True;
        L_Spline_Edges_Dash_Length   .Enabled:=True;
        SE_Spline_Edges_Dash_Length  .Enabled:=True;
        L_Spline_Edges_Points_Radius .Enabled:=False;
        SE_Spline_Edges_Points_Radius.Enabled:=False;
      end;
    2:
      begin
        L_Spline_Edges_Width         .Enabled:=False;
        SE_Spline_Edges_Width        .Enabled:=False;
        L_Spline_Edges_Dash_Length   .Enabled:=False;
        SE_Spline_Edges_Dash_Length  .Enabled:=False;
        L_Spline_Edges_Points_Radius .Enabled:=True;
        SE_Spline_Edges_Points_Radius.Enabled:=True;
      end;
  end;
end; {$endregion}
procedure TF_MainForm.P_Spline_EdgesMouseEnter                               (sender:TObject); {$region -fold}
begin
  P_Spline_Edges     .Color:=HighLight(P_Spline_Edges     .Color,0,0,0,0,0,16);
  P_Spline_Edges_Line.Color:=HighLight(P_Spline_Edges_Line.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_EdgesMouseLeave                               (sender:TObject); {$region -fold}
begin
  P_Spline_Edges     .Color:=Darken(P_Spline_Edges     .Color,0,0,0,0,0,16);
  P_Spline_Edges_Line.Color:=Darken(P_Spline_Edges_Line.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.CB_Spline_Edges_Anti_AliasingChange                    (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.eds_aa:=not sln_var.global_prop.eds_aa;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Edges_WidthChange                            (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.eds_width:=SE_Spline_Edges_Width.value;
  SetEdsWidth(sln_var.global_prop);
end; {$endregion}
procedure TF_MainForm.CB_Spline_Connect_EndsChange                           (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.cnc_ends:=not sln_var.global_prop.cnc_ends;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Invert_OrderChange                           (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_ord_inv:=not sln_var.global_prop.pts_ord_inv;
end; {$endregion}
{Points------}
procedure TF_MainForm.P_Spline_Points_PropMouseEnter                         (sender:TObject); {$region -fold}
begin
  P_Spline_Points_Prop.Color:=HighLight(P_Spline_Points_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Points_PropMouseLeave                         (sender:TObject); {$region -fold}
begin
  P_Spline_Points_Prop.Color:=Darken(P_Spline_Points_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.CB_Spline_Points_StyleSelect                           (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_bld_stl:=TDrawingStyle(CB_Spline_Points_Style.ItemIndex);
end; {$endregion}
procedure TF_MainForm.SB_Spline_Points_ShowClick                             (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Points_Show,sln_var.global_prop.pts_show);
end; {$endregion}
procedure TF_MainForm.SB_Spline_Points_ColorClick                            (sender:TObject); {$region -fold}
begin
  CD_Select_Color.Color:=SB_Spline_Points_Color.Color;
  CD_Select_Color.Execute;
  with sln_var.global_prop do
    begin
      pts_col    :=CD_Select_Color.Color;
      pts_col_inv:=SetColorInv(pts_col);
    end;
  SB_Spline_Points_Color.Color:=CD_Select_Color.Color;
  SB_Spline_Points_Color.Down :=False;
end; {$endregion}
procedure TF_MainForm.SB_Spline_Points_Color_RandomClick                     (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Points_Color_Random,sln_var.global_prop.pts_col_rnd);
end; {$endregion}
procedure TF_MainForm.SB_Spline_Points_Color_FallOffClick                    (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Points_Color_FallOff,sln_var.global_prop.pts_col_fall_off);
end; {$endregion}
procedure TF_MainForm.CB_Spline_Points_Show_BoundsChange                     (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.rct_pts_show:=not sln_var.global_prop.rct_pts_show;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Points_ShapeSelect                           (sender:TObject); {$region -fold}
begin
  case CB_Spline_Points_Shape.ItemIndex of
    0:
      begin
        P_Spline_Points.Visible:=True;

      end;
    1:
      begin
        P_Spline_Points.Visible:=False;

      end;
    2:
      begin
        P_Spline_Points.Visible:=False;

      end;
    3:
      begin
        P_Spline_Points.Visible:=False;

      end;
  end;
end; {$endregion}
procedure TF_MainForm.P_Spline_PointsMouseEnter                              (sender:TObject); {$region -fold}
begin
  P_Spline_Points_Rectangle_Thickness      .Color:=HighLight(P_Spline_Points_Rectangle_Thickness      .Color,0,0,0,0,0,16);
  P_Spline_Points_Rectangle_Inner_Rectangle.Color:=HighLight(P_Spline_Points_Rectangle_Inner_Rectangle.Color,0,0,0,0,0,16);
  P_Spline_Points                          .Color:=HighLight(P_Spline_Points                          .Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_PointsMouseLeave                              (sender:TObject); {$region -fold}
begin
  P_Spline_Points_Rectangle_Thickness      .Color:=Darken(P_Spline_Points_Rectangle_Thickness      .Color,0,0,0,0,0,16);
  P_Spline_Points_Rectangle_Inner_Rectangle.Color:=Darken(P_Spline_Points_Rectangle_Inner_Rectangle.Color,0,0,0,0,0,16);
  P_Spline_Points                          .Color:=Darken(P_Spline_Points                          .Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.SE_Spline_Points_Rectangle_Thikness_LeftChange         (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_rct_tns_left:=SE_Spline_Points_Rectangle_Thikness_Left.value;
  SetRctWidth (sln_var.global_prop);
  SetRctValues(sln_var.global_prop);
  SetRctDupId (sln_var.global_prop);
end; {$endregion}
procedure TF_MainForm.SE_Spline_Points_Rectangle_Thikness_TopChange          (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_rct_tns_top:=SE_Spline_Points_Rectangle_Thikness_Top.value;
  SetRctHeight(sln_var.global_prop);
  SetRctValues(sln_var.global_prop);
  SetRctDupId (sln_var.global_prop);
end; {$endregion}
procedure TF_MainForm.SE_Spline_Points_Rectangle_Thikness_RightChange        (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_rct_tns_right:=SE_Spline_Points_Rectangle_Thikness_Right.value;
  SetRctWidth (sln_var.global_prop);
  SetRctValues(sln_var.global_prop);
  SetRctDupId (sln_var.global_prop);
end; {$endregion}
procedure TF_MainForm.SE_Spline_Points_Rectangle_Thikness_BottomChange       (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_rct_tns_bottom:=SE_Spline_Points_Rectangle_Thikness_Bottom.value;
  SetRctHeight(sln_var.global_prop);
  SetRctValues(sln_var.global_prop);
  SetRctDupId (sln_var.global_prop);
end; {$endregion}
procedure TF_MainForm.SE_Spline_Points_Rectangle_Inner_Rectangle_WidthChange (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_rct_inn_width:=SE_Spline_Points_Rectangle_Inner_Rectangle_Width.value;
  SetRctWidth (sln_var.global_prop);
  SetRctValues(sln_var.global_prop);
  SetRctDupId (sln_var.global_prop);
end; {$endregion}
procedure TF_MainForm.SE_Spline_Points_Rectangle_Inner_Rectangle_HeightChange(sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_rct_inn_height:=SE_Spline_Points_Rectangle_Inner_Rectangle_Height.value;
  SetRctHeight(sln_var.global_prop);
  SetRctValues(sln_var.global_prop);
  SetRctDupId (sln_var.global_prop);
end; {$endregion}
{Drawing-----}
procedure PanelToProp;                                                                 inline; {$region -fold}
begin

end; {$endregion}
procedure DrawCanvas;                                                                  inline; {$region -fold}
begin
  with sln_var,srf_var_ptr^ do
    begin
      LowerBmpToMainBmp;
      if show_world_axis then
        WorldAxisDraw;
      CnvToCnv(srf_bmp_rct,F_MainForm.Canvas,srf_bmp.Canvas,SRCCOPY);
    end;
end; {$endregion}
function CycloidRangeCheck     : boolean;                                              inline; {$region -fold}
begin
  with sln_var,global_prop do
    Result:=(cycloid_pts_cnt <2) or
            (cycloid_loop_cnt=0) or
            (cycloid_loop_rad=0);
  if Result then
    DrawCanvas;
end; {$endregion}
function EpicycloidRangeCheck  : boolean;                                              inline; {$region -fold}
begin
  with sln_var,global_prop do
    Result:=((fml_type=(sfEpicycloid )) and (epicycloid_petals_cnt=0)) or
            ((fml_type=(sfHypocycloid)) and (epicycloid_petals_cnt<3)) or
            (epicycloid_pts_cnt<2)                                     or
            (epicycloid_rad    =0)                                     or
            (epicycloid_angle  =0);
  if Result then
    DrawCanvas;
end; {$endregion}
function RoseRangeCheck        : boolean;                                              inline; {$region -fold}
begin
  with sln_var,global_prop do
    Result:=(rose_pts_cnt   <3) or
            (rose_petals_cnt=0) or
            (rose_rad       =0);
  if Result then
    DrawCanvas;
end; {$endregion}
function SpiralRangeCheck      : boolean;                                              inline; {$region -fold}
begin
  with sln_var,global_prop do
    Result:=(spiral_pts_cnt<2) or
            (spiral_rad    =0);
  if Result then
    DrawCanvas;
end; {$endregion}
function SuperellipseRangeCheck: boolean;                                              inline; {$region -fold}
begin
  with sln_var,global_prop do
    Result:=(superellipse_pts_cnt   <2) or
            (superellipse_rad       =0) or
            (superellipse_curvature0=0) or
            (superellipse_curvature1=0);
  if Result then
    DrawCanvas;
end; {$endregion}
procedure SplineModeSelect;                                                            inline; {$region -fold}
begin
  with F_MainForm do
    begin
      L_Spline_Points_Freq  .visible :=((CB_Spline_Mode.ItemIndex=0) or (CB_Spline_Mode.ItemIndex=2));
      SE_Spline_Pts_Freq    .visible :=((CB_Spline_Mode.ItemIndex=0) or (CB_Spline_Mode.ItemIndex=2));
      L_Spline_Spray_Radius .visible := (CB_Spline_Mode.ItemIndex=2);
      SE_Spline_Spray_Radius.visible := (CB_Spline_Mode.ItemIndex=2);
      sln_var.global_prop   .sln_mode:=TSplineMode(CB_Spline_Mode.ItemIndex);
    end;
end; {$endregion}
procedure TF_MainForm.P_Spline_Drawing_PropMouseEnter                        (sender:TObject); {$region -fold}
begin
  P_Spline_Drawing_Prop.Color:=HighLight(P_Spline_Drawing_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Drawing_PropMouseLeave                        (sender:TObject); {$region -fold}
begin
  P_Spline_Drawing_Prop.Color:=Darken(P_Spline_Drawing_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.CB_Spline_TypeSelect                                   (sender:TObject); {$region -fold}
var
  b0,b1,b2,b3: boolean;
begin
  if down_play_anim_ptr^ then
    Exit;
  with sln_var,global_prop do
    begin
      b0:=(CB_Spline_Type.ItemIndex=0);
      b1:=(CB_Spline_Type.ItemIndex=1);
      b2:=(CB_Spline_Type.ItemIndex=2);
      b3:=(CB_Spline_Type.ItemIndex=3);
      sln_type:=TSplineType(CB_Spline_Type.ItemIndex);
      if (not (b0 or b2)) and (cur_tlt_dwn_btn_ind<>-1) then
        L_Spline_Templates_Name.Caption:=sln_tlt_nam_arr1[cur_tlt_dwn_btn_ind];
      case cur_tlt_dwn_btn_ind of
        0: P_Spline_Cycloid     .Visible:=not (b0 or b2 or b3);
        1: P_Spline_Epicycloid  .Visible:=not (b0 or b2 or b3);
        2: P_Spline_Rose        .Visible:=not (b0 or b2 or b3);
        3: P_Spline_Spiral      .Visible:=not (b0 or b2 or b3);
        4: P_Spline_Superellipse.Visible:=not (b0 or b2 or b3);
      end;
      P_Spline_Freehand        .Visible:=b0;
      P_Spline_Templates       .Visible:=b1 or b2 or b3;
      BB_Spline_Templates_Left .Visible:=b1;
      P_Spline_Template_List1  .Visible:=b1;
      BB_Spline_Templates_Right.Visible:=b1;
      L_Spline_Points_Count    .Visible:=b2;
      SE_Spline_Points_Count   .Visible:=b2;
      SB_Spline_Load           .Visible:=b3;
      if (b2 or b3) then
        L_Spline_Templates_Name.Caption:='';
      if (b0 or b2 or b3) then
        srf_var_ptr^.EventGroupsCalc(calc_arr,[30])
      else
        if (cur_tlt_dwn_btn_ind<>-1) then
          case cur_tlt_dwn_btn_ind of
            0:
              begin
                if CycloidRangeCheck then
                  Exit;
                SetLength    (fml_pts,cycloid_pts_cnt);
                FmlSplinePrev(        cycloid_pts_cnt);
              end;
            1:
              begin
                if EpicycloidRangeCheck then
                  Exit;
                SetLength    (fml_pts,epicycloid_pts_cnt);
                FmlSplinePrev(        epicycloid_pts_cnt);
              end;
            2:
              begin
                if RoseRangeCheck then
                  Exit;
                SetLength    (fml_pts,rose_pts_cnt);
                FmlSplinePrev(        rose_pts_cnt);
              end;
            3:
              begin
                if SpiralRangeCheck then
                  Exit;
                SetLength    (fml_pts,spiral_pts_cnt);
                FmlSplinePrev(        spiral_pts_cnt);
              end;
            4:
              begin
                if SuperellipseRangeCheck then
                  Exit;
                SetLength    (fml_pts,superellipse_pts_cnt);
                FmlSplinePrev(        superellipse_pts_cnt);
              end;
          end;
    end;
  VisibilityChange(b0 or b2 or b3);
end; {$endregion}
procedure TF_MainForm.P_Spline_FreehandMouseEnter                            (sender:TObject); {$region -fold}
begin
  P_Spline_Freehand         .Color:=HighLight(P_Spline_Freehand         .Color,0,0,0,0,0,16);
  P_Spline_Freehand_Settings.Color:=HighLight(P_Spline_Freehand_Settings.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_FreehandMouseLeave                            (sender:TObject); {$region -fold}
begin
  P_Spline_Freehand         .Color:=Darken(P_Spline_Freehand         .Color,0,0,0,0,0,16);
  P_Spline_Freehand_Settings.Color:=Darken(P_Spline_Freehand_Settings.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.CB_Spline_ModeSelect                                   (sender:TObject); {$region -fold}
begin
  SplineModeSelect;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Pts_FreqChange                               (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.sln_pts_frq:=SE_Spline_Pts_Freq.value;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Pts_FreqEnter                                (sender:TObject); {$region -fold}
begin
  KeysDisable1;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Pts_FreqExit                                 (sender:TObject); {$region -fold}
begin
  KeysEnable1;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Pts_FreqMouseDown                            (sender:TObject; button:TMouseButton; shift:TShiftState; x,y:integer); {$region -fold}
begin
  KeysDisable0;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Spray_RadiusChange                           (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.spray_rad:=SE_Spline_Spray_Radius.value;
end; {$endregion}
procedure TF_MainForm.BB_Spline_Templates_LeftClick                          (sender:TObject); {$region -fold}
begin
  ButtonMoveToPrevPos(P_Spline_Template_List,SB_Spline_Template_Superellipse,100,SB_Spline_Template_Superellipse.width,0,ptLeft);
end; {$endregion}
procedure TF_MainForm.BB_Spline_Templates_RightClick                         (sender:TObject); {$region -fold}
begin
  ButtonMoveToSuccPos(P_Spline_Template_List,SB_Spline_Template_Cycloid,000,SB_Spline_Template_Cycloid.width,0,ptLeft);
end; {$endregion}
procedure TF_MainForm.P_Spline_Template_ListMouseWheelUp                     (sender:TObject; shift:TShiftState; mousepos:TPoint; var Handled:boolean); {$region -fold}
begin
  //SB_Drawing.VertScrollBar.Position:=0;
  SB_Drawing.VertScrollBar.Visible:=False;
  ButtonMoveToPrevPos(P_Spline_Template_List,SB_Spline_Template_Superellipse,100,SB_Spline_Template_Superellipse.width,0,ptLeft);
end; {$endregion}
procedure TF_MainForm.P_Spline_Template_ListMouseWheelDown                   (sender:TObject; shift:TShiftState; mousepos:TPoint; var Handled:boolean); {$region -fold}
begin
  //SB_Drawing.VertScrollBar.Position:=0;
  SB_Drawing.VertScrollBar.Visible:=False;
  ButtonMoveToSuccPos(P_Spline_Template_List,SB_Spline_Template_Cycloid,000,SB_Spline_Template_Cycloid.width,0,ptLeft);
end; {$endregion}
procedure TF_MainForm.P_Spline_Template_ListPaint                            (sender:TObject); {$region -fold}
begin
  ButtonColorize(P_Spline_Template_List);
end; {$endregion}
procedure TF_MainForm.SplinesTemplatesNamesInit                            (sln_var_:TCurve ); {$region -fold}
begin
  with sln_var_ do
    begin
      sln_tlt_nam_arr1[0]:='Cycloid';
      sln_tlt_nam_arr1[1]:='Epicycloid';
      sln_tlt_nam_arr1[2]:='Rose';
      sln_tlt_nam_arr1[3]:='Spiral';
      sln_tlt_nam_arr1[4]:='Superellipse';
      sln_tlt_nam_arr2[0]:=@SB_Spline_Template_Cycloid     .Down;
      sln_tlt_nam_arr2[1]:=@SB_Spline_Template_Epicycloid  .Down;
      sln_tlt_nam_arr2[2]:=@SB_Spline_Template_Rose        .Down;
      sln_tlt_nam_arr2[3]:=@SB_Spline_Template_Spiral      .Down;
      sln_tlt_nam_arr2[4]:=@SB_Spline_Template_Superellipse.Down;
    end;
end; {$endregion}
procedure TF_MainForm.SB_Spline_TemplateClick                                (sender:TObject); {$region -fold}
type
  PPanel=^TPanel;
var
  panel_arr: array[0..4] of PPanel;
  i        : integer;

  procedure PanelsVisible; {$region -fold}
  var
    j: integer;
  begin
    for j:=0 to 4 do
      panel_arr[j]^.visible:=False;
  end; {$endregion}

begin
  panel_arr[0]:=@P_Spline_Cycloid;
  panel_arr[1]:=@P_Spline_Epicycloid;
  panel_arr[2]:=@P_Spline_Rose;
  panel_arr[3]:=@P_Spline_Spiral;
  panel_arr[4]:=@P_Spline_Superellipse;
  DefocusControl(ActiveControl,True);
  with sln_var do
    begin
      cur_tlt_dwn_btn_ind:=-1;
      for i:=0 to P_Spline_Template_List.ControlCount-1 do
        if sln_tlt_nam_arr2[i]^ then
          begin
            cur_tlt_dwn_btn_ind:=i;
            Break;
          end;
      if (cur_tlt_dwn_btn_ind<>-1) then
        begin
          L_Spline_Templates_Name.Caption:=sln_tlt_nam_arr1[cur_tlt_dwn_btn_ind];
          case cur_tlt_dwn_btn_ind of
            0:
              begin
                PanelsVisible;
                global_prop.fml_type :=sfCycloid;
                panel_arr[0]^.visible:=True;
                if CycloidRangeCheck then
                  Exit;
                SetLength    (fml_pts,global_prop.cycloid_pts_cnt);
                FmlSplinePrev(        global_prop.cycloid_pts_cnt);
              end;
            1:
              begin
                PanelsVisible;
                if not CB_Spline_Epicycloid_Hypocycloid.Checked then
                  global_prop.fml_type:=sfEpicycloid
                else
                  global_prop.fml_type:=sfHypocycloid;
                panel_arr[1]^.visible :=True;
                if EpicycloidRangeCheck then
                  Exit;
                SetLength    (fml_pts,global_prop.epicycloid_pts_cnt);
                FmlSplinePrev(        global_prop.epicycloid_pts_cnt);
              end;
            2:
              begin
                PanelsVisible;
                global_prop.fml_type :=sfRose;
                panel_arr[2]^.visible:=True;
                if RoseRangeCheck then
                  Exit;
                SetLength    (fml_pts,global_prop.rose_pts_cnt);
                FmlSplinePrev(        global_prop.rose_pts_cnt);
              end;
            3:
              begin
                PanelsVisible;
                global_prop.fml_type:=sfSpiral;
                panel_arr[3]^.visible:=True;
                if SpiralRangeCheck then
                  Exit;
                SetLength    (fml_pts,global_prop.spiral_pts_cnt);
                FmlSplinePrev(        global_prop.spiral_pts_cnt);
              end;
            4:
              begin
                PanelsVisible;
                global_prop.fml_type:=sfSuperellipse;
                panel_arr[4]^.visible:=True;
                if SuperellipseRangeCheck then
                  Exit;
                SetLength    (fml_pts,global_prop.superellipse_pts_cnt);
                FmlSplinePrev(        global_prop.superellipse_pts_cnt);
              end;
          end;
        end
      else
        begin
          L_Spline_Templates_Name.Caption:='';
          sln_pts_cnt_add                :=0;
          PanelsVisible;
          srf_var_ptr^.EventGroupsCalc(calc_arr,[30]);
        end;
    end;
end; {$endregion}
procedure TF_MainForm.P_Spline_TemplatesMouseEnter                           (sender:TObject); {$region -fold}
begin
  P_Spline_Templates_Properties.Color:=HighLight(P_Spline_Templates_Properties.Color,0,0,0,0,0,16);
  P_Spline_Templates           .Color:=HighLight(P_Spline_Templates           .Color,0,0,0,0,0,16);
  SB_Drawing.VertScrollBar.Visible:=True;
end; {$endregion}
procedure TF_MainForm.P_Spline_TemplatesMouseLeave                           (sender:TObject); {$region -fold}
begin
  P_Spline_Templates_Properties.Color:=Darken(P_Spline_Templates_Properties.Color,0,0,0,0,0,16);
  P_Spline_Templates           .Color:=Darken(P_Spline_Templates           .Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Template_ListMouseEnter                       (sender:TObject); {$region -fold}
begin
  //vert_sc_bar_pos:=SB_Drawing.VertScrollBar.Position;
  //SB_Drawing.OnMouseWheelDown:=Nil;
  //SB_Drawing.OnMouseWheelUp:=Nil;
  //SB_Drawing.VertScrollBar.Position:=SB_Drawing.VertScrollBar.Position+10;
  //SB_Drawing.VertScrollBar.Visible:=False;
  P_Spline_Template_List.Color   :=HighLight(P_Spline_Template_List.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Template_ListMouseLeave                       (sender:TObject); {$region -fold}
begin
  //SB_Drawing.VertScrollBar.Visible:=True;
  P_Spline_Template_List.Color:=Darken(P_Spline_Template_List.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.BB_Spline_GenerateClick                                (sender:TObject); {$region -fold}
begin
  with sln_var,srf_var_ptr^,global_prop do
    begin
      if (not show_spline) then
        Exit;
      case CB_Spline_Type.ItemIndex of
        1:
          begin
            if (cur_tlt_dwn_btn_ind=-1) then
              Exit;
            case cur_tlt_dwn_btn_ind of
              0:
                begin
                  if CycloidRangeCheck then
                    Exit;
                  sln_pts_cnt_add:=cycloid_pts_cnt;
                end;
              1:
                begin
                  if EpicycloidRangeCheck then
                    Exit;
                  sln_pts_cnt_add:=epicycloid_pts_cnt;
                end;
              2:
                begin
                  if RoseRangeCheck then
                    Exit;
                  sln_pts_cnt_add:=rose_pts_cnt;
                end;
              3:
                begin
                  if SpiralRangeCheck then
                    Exit;
                  sln_pts_cnt_add:=spiral_pts_cnt;
                end;
              4:
                begin
                  if SuperellipseRangeCheck then
                    Exit;
                  sln_pts_cnt_add:=superellipse_pts_cnt;
                end;
            end;
            FmlSplineObj[cur_tlt_dwn_btn_ind](world_axis.x,world_axis.y);
            Inc(sln_pts_cnt,sln_pts_cnt_add);
            sln_pts_add:=fml_pts;
            EventGroupsCalc(calc_arr,[12,16,30,33,41,48]);
          end;
        2:
          begin
            if (pts_cnt_val=0) then
              Exit;
            RndSplineObj(world_axis,512{256},512{256});
            EventGroupsCalc(calc_arr,[12,16,30,33,40,41,48]);
          end;
      end;
    end;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Cycloid_Points_CountChange                   (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      cycloid_pts_cnt:=SE_Spline_Cycloid_Points_Count.value;
      if CycloidRangeCheck then
        Exit;
      SetLength(fml_pts,cycloid_pts_cnt);
      FmlSplinePrev(cycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Cycloid_Loops_CountChange                    (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      cycloid_loop_cnt:=SE_Spline_Cycloid_Loops_Count.value;
      if CycloidRangeCheck then
        Exit;
      FmlSplinePrev(cycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Cycloid_RadiusChange                        (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      cycloid_loop_rad:=FSE_Spline_Cycloid_Radius.value;
      if CycloidRangeCheck then
        Exit;
      FmlSplinePrev(cycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Cycloid_CurvatureChange                     (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      cycloid_curvature:=FSE_Spline_Cycloid_Curvature.value;
      FmlSplinePrev(cycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Cycloid_Direction_XSelect                    (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      cycloid_dir_x:=TMovingDirection(CB_Spline_Cycloid_Direction_X.ItemIndex);
      FmlSplinePrev(cycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Cycloid_Direction_YSelect                    (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      cycloid_dir_y:=TMovingDirection(CB_Spline_Cycloid_Direction_Y.ItemIndex+2);
      FmlSplinePrev(cycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Epicycloid_Points_CountChange                (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      epicycloid_pts_cnt:=SE_Spline_Epicycloid_Points_Count.value;
      if EpicycloidRangeCheck then
        Exit;
      SetLength    (fml_pts,epicycloid_pts_cnt);
      FmlSplinePrev(        epicycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Epicycloid_Petals_CountChange               (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      epicycloid_petals_cnt:=FSE_Spline_Epicycloid_Petals_Count.value;
      if EpicycloidRangeCheck then
        Exit;
      FmlSplinePrev(epicycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Epicycloid_RadiusChange                     (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      epicycloid_rad:=FSE_Spline_Epicycloid_Radius.value;
      if EpicycloidRangeCheck then
        Exit;
      FmlSplinePrev(epicycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Epicycloid_RotationChange                   (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      epicycloid_rot:=FSE_Spline_Epicycloid_Rotation.value;
      FmlSplinePrev(epicycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Epicycloid_AngleChange                      (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      epicycloid_angle:=FSE_Spline_Epicycloid_Angle.value;
      if EpicycloidRangeCheck then
        Exit;
      FmlSplinePrev(epicycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Epicycloid_HypocycloidChange                 (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      if CB_Spline_Epicycloid_Hypocycloid.Checked then
        fml_type:=sfHypocycloid
      else
        fml_type:=sfEpicycloid;
      if EpicycloidRangeCheck then
        Exit;
      FmlSplinePrev(epicycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Rose_Points_CountChange                      (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      rose_pts_cnt:=SE_Spline_Rose_Points_Count.value;
      if RoseRangeCheck then
        Exit;
      SetLength    (fml_pts,rose_pts_cnt);
      FmlSplinePrev(        rose_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Rose_Petals_CountChange                     (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      rose_petals_cnt:=FSE_Spline_Rose_Petals_Count.value;
      if RoseRangeCheck then
        Exit;
      FmlSplinePrev(rose_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Rose_RadiusChange                           (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      rose_rad:=FSE_Spline_Rose_Radius.value;
      if RoseRangeCheck then
        Exit;
      FmlSplinePrev(rose_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Rose_RotationChange                         (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      rose_rot:=FSE_Spline_Rose_Rotation.value;
      FmlSplinePrev(rose_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Rose_AngleChange                            (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      rose_angle:=FSE_Spline_Rose_Angle.value;
      FmlSplinePrev(rose_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Rose_Mobius_GridChange               (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      rose_mobius_grid:=CB_Spline_Rose_Mobius_Grid.Checked;
      FmlSplinePrev(rose_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Spiral_Points_CountChange                    (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      spiral_pts_cnt:=SE_Spline_Spiral_Points_Count.value;
      if SpiralRangeCheck then
        Exit;
      SetLength    (fml_pts,spiral_pts_cnt);
      FmlSplinePrev(        spiral_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Spiral_Coil_StepChange                      (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      spiral_coil_step:=FSE_Spline_Spiral_Coil_Step.value;
      FmlSplinePrev(spiral_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Spiral_RadiusChange                         (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      spiral_rad:=FSE_Spline_Spiral_Radius.value;
      if SpiralRangeCheck then
        Exit;
      FmlSplinePrev(spiral_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Spiral_RotationChange                       (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      spiral_rot:=FSE_Spline_Spiral_Rotation.value;
      FmlSplinePrev(spiral_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Spiral_AngleChange                          (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      spiral_angle:=FSE_Spline_Spiral_Angle.value;
      FmlSplinePrev(spiral_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Superellipse_Points_CountChange              (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      superellipse_pts_cnt:=SE_Spline_Superellipse_Points_Count.value;
      if SuperellipseRangeCheck then
        Exit;
      SetLength    (fml_pts,superellipse_pts_cnt);
      FmlSplinePrev(        superellipse_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Superellipse_Curvature0Change               (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      superellipse_curvature0:=FSE_Spline_Superellipse_Curvature0.value;
      if SuperellipseRangeCheck then
        Exit;
      FmlSplinePrev(superellipse_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Superellipse_Curvature1Change               (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      superellipse_curvature1:=FSE_Spline_Superellipse_Curvature1.value;
      if SuperellipseRangeCheck then
        Exit;
      FmlSplinePrev(superellipse_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Superellipse_Curvature2Change               (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      superellipse_curvature2:=FSE_Spline_Superellipse_Curvature2.value;

      FmlSplinePrev(superellipse_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Superellipse_Curvature3Change               (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      superellipse_curvature3:=FSE_Spline_Superellipse_Curvature3.value;
      FmlSplinePrev(superellipse_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Superellipse_RadiusChange                   (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      superellipse_rad:=FSE_Spline_Superellipse_Radius.value;
      if SuperellipseRangeCheck then
        Exit;
      FmlSplinePrev(superellipse_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Points_CountChange                           (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_cnt_val:=SE_Spline_Points_Count.Value;
end; {$endregion}
procedure TF_MainForm.SB_Spline_LoadClick                                    (sender:TObject); {$region -fold}
var
  sln_pts_add_ptr                       : PPtPosF;
  i,line_cnt,pts_coord_start_pos,pts_cnt: integer;
  file_import                           : text;
  file_path,file_line                   : string;
  x_start,y_start                       : boolean;
label
  label0;
begin
  SB_Spline_Load.Down   :=False;
  OD_Spline_Load.Options:=OD_Spline_Load.Options+[ofFileMustExist];
  if (not OD_Spline_Load.Execute) then
    Exit;
  try
    file_path:=OD_Spline_Load.Filename;
    AssignFile(file_import,file_path);
    Reset     (file_import);
    line_cnt:=0;
    pts_cnt :=0;
    while (not EOF(file_import)) do
      begin
        ReadLn(file_import,file_line);
        Inc(line_cnt);
        for i:=0 to Length(file_line)-1 do
          if (file_line[i+0]='p') and
             (file_line[i+1]='o') and
             (file_line[i+2]='i') and
             (file_line[i+3]='n') and
             (file_line[i+4]='t') and
             (file_line[i+5]='s') and
             (file_line[i+6]=#61) and
             (file_line[i+7]=#34) then
            begin
              pts_coord_start_pos:=i+8;
              Break;
            end;
        for i:=pts_coord_start_pos to Length(file_line)-1 do
          begin
            if (file_line[i]=#32) then
              Continue
            else
            if (file_line[i]=#34) then
              goto label0
            else
            if (file_line[i] in [#48..#57]) and ((file_line[i-1]=#32) or (file_line[i-1]=#34)) then
              Inc(pts_cnt);
          end;
      end;
    label0:
    pts_cnt:=pts_cnt>>1;
    Reset(file_import);
    for i:=0 to line_cnt-1 do
      ReadLn(file_import,file_line);
    with sln_var do
      begin
        sln_pts_cnt_add:=global_prop.pts_cnt;
        Inc(sln_pts_cnt,sln_pts_cnt_add);
        SetLength(sln_pts_add,0);
        SetLength(sln_pts_add,sln_pts_cnt_add);
        sln_pts_add_ptr:=Unaligned(@sln_pts_add[0]);
        for i:=pts_coord_start_pos to Length(file_line)-1 do
          begin
            if (file_line[i] in [#48..#57]) and ((file_line[i-1]=#32) or (file_line[i-1]=#34)) then
              begin
                if not y_start then
                  sln_pts_add_ptr^.x:=Ord(file_line[i]);
                //
              end;
          end;
      end;
  except
    on E: Exception do
      MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
  end;
end; {$endregion}
{Optimization}
procedure TF_MainForm.P_Spline_Optimization_PropMouseEnter                   (sender:TObject); {$region -fold}
begin
  P_Spline_Optimization_Prop.Color:=HighLight(P_Spline_Optimization_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_PropMouseLeave                   (sender:TObject); {$region -fold}
begin
  P_Spline_Optimization_Prop.Color:=Darken(P_Spline_Optimization_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.CB_Spline_Edges_LODChange                              (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.eds_lod            :=not sln_var.global_prop.eds_lod;
  FSE_Spline_Simplification_Angle.Enabled:=CB_Spline_Edges_LOD.Checked;
  L_Spline_Simplification_Angle  .Enabled:=CB_Spline_Edges_LOD.Checked;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Simplification_AngleChange                  (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.eds_simpl_angle:=FSE_Spline_Simplification_Angle.Value;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Simplification_AngleEditingDone             (sender:TObject); {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.CB_Spline_Hidden_Line_EliminationChange                (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.hid_ln_elim:=not sln_var.global_prop.hid_ln_elim;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Best_PrecisionChange                         (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.best_precision:=not sln_var.global_prop.best_precision;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Lazy_RepaintChange                           (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.lazy_repaint:=not sln_var.global_prop.lazy_repaint;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Byte_ModeChange                              (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.byte_mode     :=not sln_var.global_prop.byte_mode;
  CB_Spline_Better_Quality.Enabled  :=CB_Spline_Byte_Mode.Checked;
  sln_var.global_prop.better_quality:=CB_Spline_Better_Quality.Checked and sln_var.global_prop.byte_mode;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Better_QualityChange                     (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.better_quality:=not sln_var.global_prop.better_quality;
end; {$endregion}
procedure TF_MainForm.CB_Spline_On_Out_Of_WindowChange                       (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.free_mem_on_out_of_wnd:=not sln_var.global_prop.free_mem_on_out_of_wnd;
end; {$endregion}
procedure TF_MainForm.CB_Spline_On_Scale_DownChange                          (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.free_mem_on_scale_down:=not sln_var.global_prop.free_mem_on_scale_down;
end; {$endregion}
procedure TF_MainForm.RB_Spline_AdaptiveChange                               (sender:TObject); {$region -fold}
begin
  with sln_var.global_prop do
    begin
      remove_brunching_constant:=RB_Spline_Constant.Checked;
      remove_brunching_none    :=RB_Spline_None    .Checked;
    end;
end; {$endregion}
{Dynamics----}
procedure TF_MainForm.CB_Spline_Dynamics_StyleSelect                         (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.dyn_stl:=TDynamicsStyle(CB_Spline_Dynamics_Style.ItemIndex);
end; {$endregion}
procedure TF_MainForm.P_Spline_Dynamics_PropMouseEnter                       (sender:TObject); {$region -fold}
begin
  P_Spline_Dynamics_Prop.Color:=HighLight(P_Spline_Dynamics_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Dynamics_PropMouseLeave                       (sender:TObject); {$region -fold}
begin
  P_Spline_Dynamics_Prop.Color:=Darken(P_Spline_Dynamics_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
{Save--------}
procedure TF_MainForm.P_Spline_Save_PropMouseEnter                           (sender:TObject); {$region -fold}
begin
  P_Spline_Save_Prop.Color:=HighLight(P_Spline_Save_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Save_PropMouseLeave                           (sender:TObject); {$region -fold}
begin
  P_Spline_Save_Prop.Color:=Darken(P_Spline_Save_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
{$endregion}

// (Select Points/Items) Выделение точек/обьектов:
{LI} {$region -fold}
constructor TSelIts.Create(constref w,h:TColor);                                                                                                                {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  srf_var_ptr         :=@srf_var;

  OuterSubgraphProc[0]:=@OuterSubgraphCalc0;
  OuterSubgraphProc[1]:=@OuterSubgraphCalc1;
  OuterSubgraphProc[2]:=@OuterSubgraphCalc2;

  InnerSubgraphProc[0]:=@InnerSubgraphCalc0;
  InnerSubgraphProc[1]:=@InnerSubgraphCalc1;
  InnerSubgraphProc[2]:=@InnerSubgraphCalc2;

  WholeSubgraphProc[0]:=@WholeSubgraphDraw0;
  WholeSubgraphProc[1]:=@WholeSubgraphDraw1;
  WholeSubgraphProc[2]:=@WholeSubgraphDraw2;

  // outer subgraph:
  outer_subgraph_img:=TFastLine.Create;
  with outer_subgraph_img,local_prop do
    begin
      local_prop :=curve_default_prop;
      eds_col    :=clLime;
      eds_col_inv:=SetColorInv(eds_col);
      eds_aa     :=True;
      clp_stl    :=csRemoveEdges;
      SetColorInfo(eds_col,color_info);
      with args do
        begin
          alpha:=016;
          pow  :=016;
          d    :=016;
        end;
    end;

  // inner subgraph:
  inner_subgraph_img:=TFastLine.Create;
  with inner_subgraph_img,local_prop do
    begin
      local_prop :=curve_default_prop;
      eds_col    :=clTeal;
      eds_col_inv:=SetColorInv(eds_col);
      eds_aa     :=True;
      clp_stl    :=csRemoveEdges;
      SetColorInfo(eds_col,color_info);
      with args do
        begin
          alpha:=016;
          pow  :=016;
          d    :=016;
        end;
    end;

  // selected points:
  sel_pts_big_img:=TFastLine.Create;
  with sel_pts_big_img,local_prop do
    begin
      //rct_clp           :=PtRct(0,0,bkgnd_width,bkgnd_height);
      //rct_clp_ptr       :=@rct_clp;
      selit_prop        :=selit_default_prop;
      local_prop        :=curve_default_prop;
      eds_col           :=clGreen;
      eds_col_inv       :=SetColorInv(eds_col);
      eds_aa            :=True;
      eds_bld_stl       :=dsAdditive;
      pts_col           :=clLime;
      pts_col_inv       :=SetColorInv(pts_col);
      SetColorInfo(eds_col,color_info);
      with args do
        begin
          alpha:=016;
          pow  :=016;
          d    :=016;
        end;
      BuffersInit(w,h,False,True,False,False);
      SetBkgnd   (srf_var_ptr^.srf_bmp_ptr,srf_var_ptr^.srf_bmp.width,srf_var_ptr^.srf_bmp.height,@srf_var_ptr^.inn_wnd_rct{rct_clp_ptr});
    end;

  // selected points bounds:
  with sel_bounds_prop do
    begin
      sel_bounds_prop   :=curve_default_prop;
      pts_bld_stl       :=dsInverse;
      pts_col           :=clBlue;
      pts_col_inv       :=SetColorInv(pts_col);
      pts_rct_tns_left  :=1;
      pts_rct_tns_top   :=1;
      pts_rct_tns_right :=1;
      pts_rct_tns_bottom:=1;
    end;

  sel_pts_rct_mrgn          :=32;
  bucket_rct.Width          :=8;
  bucket_rct.Height         :=8;
  is_not_abst_obj_kind_after:=True;

end; {$endregion}
destructor  TSelIts.Destroy;                                                                                                                                    {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure BucketSizeChange(chng_val:integer);                                                                                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,bucket_mul,m1,m2: integer;
begin
  with sel_var,srf_var_ptr^ do
    begin
      bucket_mul        :=4;
      bucket_rct.Width :=Trunc(sqrt(sel_pts_rct.width*sel_pts_rct.height*chng_val)/(10*bucket_mul));
      bucket_rct.Height:=Trunc(sqrt(sel_pts_rct.width*sel_pts_rct.height*chng_val)/(10*bucket_mul));
      ncs_adv_clip_rect :=NCSRectCalc(sel_pts_rct,
                                      bucket_rct.width,
                                      bucket_rct.height);
      LowerBmpToMainBmp;
      with srf_bmp.Canvas do
        begin
          Pen.Color:=bucket_rct_color;
          m1:=Trunc(ncs_adv_clip_rect.width /bucket_rct.width )-2;
          m2:=Trunc(ncs_adv_clip_rect.height/bucket_rct.height)-2;
          for i:=0 to m1 do
            Line(Trunc(ncs_adv_clip_rect.left)+bucket_rct.width*(i+1),
                 Trunc(ncs_adv_clip_rect.top ),
                 Trunc(ncs_adv_clip_rect.left)+bucket_rct.width*(i+1),
                 Trunc(ncs_adv_clip_rect.top )+Trunc(ncs_adv_clip_rect.height));
          for i:=0 to m2 do
            Line(Trunc(ncs_adv_clip_rect.left),
                 Trunc(ncs_adv_clip_rect.top )+bucket_rct.height*(i+1),
                 Trunc(ncs_adv_clip_rect.left)+Trunc(ncs_adv_clip_rect.width),
                 Trunc(ncs_adv_clip_rect.top )+bucket_rct.height*(i+1));
        end;
      InvalidateInnerWindow;
      {$ifdef Windows}
      Sleep(2);
      {$else}
      USleep(2000000);
      {$endif}
    end;
end; {$endregion}
procedure IsObjColorAMaskColor;                                                                                                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sel_var do
    begin
      if (outer_subgraph_img.local_prop.eds_col =clBlack) then
        begin
          outer_subgraph_img.local_prop.eds_col:=$01;
          F_MainForm.CD_Select_Color.Color     :=$01;
        end;
      if (inner_subgraph_img.local_prop.eds_col =clBlack) then
        begin
          inner_subgraph_img.local_prop.eds_col:=$01;
          F_MainForm.CD_Select_Color.Color     :=$01;
        end;
      if (sel_pts_big_img.local_prop.eds_col   =clBlack) then
        begin
          sel_pts_big_img.local_prop.eds_col  :=$01;
          F_MainForm.CD_Select_Color.Color    :=$01;
        end;
    end;
end; {$endregion}
procedure TSelIts.FillSelBmpAndSelPtsBRectDraw;                                                                                                         inline; {$ifdef linux}[local];{$endif} {$region -fold}
begin
  if exp0 then
    if show_spline then
      with srf_var_ptr^,sln_var,pvt_var do
        begin
          LowerBmpToMainBmp;
          if outer_subgraph_img.local_prop.eds_show then
            OuterSubgraphDraw(Trunc(pvt_var.pvt_pos.X),
                              Trunc(pvt_var.pvt_pos.Y),
                              pvt_var.pvt_pos,
                              sln_pts,
                              srf_bmp_ptr,
                              inn_wnd_rct);
          if inner_subgraph_img.local_prop.eds_show and (not IsRct1OutOfRct2(sel_var.sel_pts_rct,inn_wnd_rct)) then
            InnerSubgraphDraw(Trunc(pvt_var.pvt_pos.X),
                              Trunc(pvt_var.pvt_pos.Y),
                              pvt_var.pvt_pos,
                              sln_pts,
                              srf_bmp_ptr,
                              ClippedRct(inn_wnd_rct,sel_pts_rct));
          if sel_pts_big_img.local_prop.eds_show then
            SelectdPointsDraw(Trunc(pvt_var.pvt_pos.X),
                              Trunc(pvt_var.pvt_pos.Y),
                              pvt_var.pvt_pos,
                              sln_pts,
                              srf_bmp_ptr,
                              inn_wnd_rct);
          if sel_bounds_prop.rct_eds_show then
            SelectdPointsBnds(Trunc(pvt_var.pvt_pos.X),
                              Trunc(pvt_var.pvt_pos.Y),
                              pvt_var.pvt_pos,
                              sln_pts,
                              srf_bmp_ptr,
                              inn_wnd_rct);
          CnvToCnv                         (srf_bmp_rct,
                                            F_MainForm.
                                            Canvas,
                                            srf_bmp.Canvas,
                                            SRCCOPY{NOTSRCCOPY});
        end;
end; {$endregion}
constructor TCrcSel.Create;                                                                                                                                     {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  crc_sel_col :=clGreen;
  crc_rad     :=10;
  crc_rad_sqr :=crc_rad*crc_rad;
  draw_crc_sel:=True;
end; {$endregion}
destructor  TCrcSel.Destroy;                                                                                                                                    {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure TCrcSel.CircleSelection        (x,y:integer; constref m_c_var:TSurface; constref s_c_var:TSelIts; constref pts:TPtPosFArr; constref pts_cnt:TColor; constref sel_draw:boolean=True); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  color_info     : TColorInfo;
  obj_arr_ptr    : PObjInfo;
  i,j,m1,m2,m3,m4: integer;
  pts_col_inv,v,w: TColor;
begin

  {Set Bounding Rectangle---------------} {$region -fold}
  with m_c_var.inn_wnd_rct do
    begin
      m1:=left  +inn_wnd_mrg;
      m2:=top   +inn_wnd_mrg;
      m3:=right -inn_wnd_mrg;
      m4:=bottom-inn_wnd_mrg;
    end; {$endregion}

  {Drawing Of Selected Points Rectangles} {$region -fold}
  with m_c_var,s_c_var,sln_var do
    begin
      if sel_draw then
        begin
          //SetColorInfo(clRed,color_info);
          sel_pts_big_img.bmp_dst_ptr :=srf_bmp_ptr;
          sel_pts_big_img.ln_arr_width:=srf_bmp_rct.Width;
          if ((X-crc_rad>m1)  and
              (X+crc_rad<m3)  and
              (Y-crc_rad>m2)  and
              (Y+crc_rad<m4)) then
            begin
              for i:=0 to sln_obj_cnt-1 do
                if RctCrcInt(pts_img_arr[i].rct_vis,x,y,crc_rad) then
                  begin
                    pts_col_inv                          :=pts_img_arr[i] .local_prop.pts_col_inv;
                    pts_img_arr[i].local_prop.pts_col_inv:=sel_pts_big_img.local_prop.pts_col_inv;
                    obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[partial_pts_sum[i]]]]);
                    for j:=partial_pts_sum[i] to partial_pts_sum[i]+sln_obj_pts_cnt[i]-1 do
                      if (sqr(Trunc(pts[j].x)+obj_arr_ptr^.world_axis_shift.x-x)+
                          sqr(Trunc(pts[j].y)+obj_arr_ptr^.world_axis_shift.y-y)<crc_rad_sqr) and
                         (not is_point_selected[j])                                          then
                        begin
                          is_point_selected[j]     :=True;
                          sel_pts_inds[sel_pts_cnt]:=j;
                          Inc(sel_pts_cnt);
                          v:=Trunc(pts[j].x)+obj_arr_ptr^.world_axis_shift.x;
                          w:=Trunc(pts[j].y)+obj_arr_ptr^.world_axis_shift.y;
                          Rectangle
                          (
                            v,
                            w,
                            low_bmp2_ptr,
                            low_bmp2.width,
                            low_bmp2.height,
                            inn_wnd_rct,
                            pts_img_arr[i].local_prop
                          );
                          {Point(v,
                                w,
                                low_bmp2_ptr,
                                low_bmp2.width,
                                color_info,
                                inn_wnd_rct);}
                        end;
                    pts_img_arr[i].local_prop.pts_col_inv:=pts_col_inv;
                  end;
            end
          else
            begin
              for i:=0 to sln_obj_cnt-1 do
                if RctCrcInt(pts_img_arr[i].rct_vis,x,y,crc_rad) then
                  begin
                    pts_col_inv                          :=pts_img_arr[i] .local_prop.pts_col_inv;
                    pts_img_arr[i].local_prop.pts_col_inv:=sel_pts_big_img.local_prop.pts_col_inv;
                    obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[partial_pts_sum[i]]]]);
                    for j:=partial_pts_sum[i] to partial_pts_sum[i]+sln_obj_pts_cnt[i]-1 do
                      if (          pts[j].x +obj_arr_ptr^.world_axis_shift.x>m1)             and
                         (          pts[j].x +obj_arr_ptr^.world_axis_shift.x<m3)             and
                         (          pts[j].y +obj_arr_ptr^.world_axis_shift.y>m2)             and
                         (          pts[j].y +obj_arr_ptr^.world_axis_shift.y<m4)             and
                         (sqr(Trunc(pts[j].x)+obj_arr_ptr^.world_axis_shift.x-x)+
                          sqr(Trunc(pts[j].y)+obj_arr_ptr^.world_axis_shift.y-y)<crc_rad_sqr) and
                         (not is_point_selected[j])                                          then
                        begin
                          is_point_selected[j]     :=True;
                          sel_pts_inds[sel_pts_cnt]:=j;
                          Inc(sel_pts_cnt);
                          v:=Trunc(pts[j].x)+obj_arr_ptr^.world_axis_shift.x;
                          w:=Trunc(pts[j].y)+obj_arr_ptr^.world_axis_shift.y;
                          Rectangle
                          (
                            v,
                            w,
                            low_bmp2_ptr,
                            low_bmp2.width,
                            low_bmp2.height,
                            inn_wnd_rct,
                            pts_img_arr[i].local_prop
                          );
                          {Point(v,
                                w,
                                low_bmp2_ptr,
                                low_bmp2.width,
                                color_info,
                                inn_wnd_rct);}
                        end;
                    pts_img_arr[i].local_prop.pts_col_inv:=pts_col_inv;
                  end;
            end;
        end
      else
        begin
          sel_pts_big_img.bmp_dst_ptr :=srf_bmp_ptr;
          sel_pts_big_img.ln_arr_width:=srf_bmp_rct.Width;
          if ((X-crc_rad>m1)  and
              (X+crc_rad<m3)  and
              (Y-crc_rad>m2)  and
              (Y+crc_rad<m4)) then
            begin
              for i:=0 to sln_obj_cnt-1 do
                if RctCrcInt(pts_img_arr[i].rct_vis,x,y,crc_rad) then
                  begin
                    obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[partial_pts_sum[i]]]]);
                    for j:=partial_pts_sum[i] to partial_pts_sum[i]+sln_obj_pts_cnt[i]-1 do
                      if (sqr(Trunc(pts[j].x)+obj_arr_ptr^.world_axis_shift.x-x)+
                          sqr(Trunc(pts[j].y)+obj_arr_ptr^.world_axis_shift.y-y)<crc_rad_sqr) and
                         (not is_point_selected[j])                                          then
                        begin
                          is_point_selected[j]     :=True;
                          sel_pts_inds[sel_pts_cnt]:=j;
                          Inc(sel_pts_cnt);
                        end;
                  end;
            end
          else
            begin
              for i:=0 to sln_obj_cnt-1 do
                if RctCrcInt(pts_img_arr[i].rct_vis,x,y,crc_rad) then
                  begin
                    obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[partial_pts_sum[i]]]]);
                    for j:=partial_pts_sum[i] to partial_pts_sum[i]+sln_obj_pts_cnt[i]-1 do
                      if (          pts[j].x +obj_arr_ptr^.world_axis_shift.x>m1)             and
                         (          pts[j].x +obj_arr_ptr^.world_axis_shift.x<m3)             and
                         (          pts[j].y +obj_arr_ptr^.world_axis_shift.y>m2)             and
                         (          pts[j].y +obj_arr_ptr^.world_axis_shift.y<m4)             and
                         (sqr(Trunc(pts[j].x)+obj_arr_ptr^.world_axis_shift.x-x)+
                          sqr(Trunc(pts[j].y)+obj_arr_ptr^.world_axis_shift.y-y)<crc_rad_sqr) and
                         (not is_point_selected[j])                                          then
                        begin
                          is_point_selected[j]     :=True;
                          sel_pts_inds[sel_pts_cnt]:=j;
                          Inc(sel_pts_cnt);
                        end;
                  end;
            end;
        end
    end; {$endregion}

end; {$endregion}
procedure TCrcSel.CircleSelectionModeDraw(x,y:integer; constref m_c_var:TSurface);                                                                      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with srf_var_ptr^ do
    if IsPtInRct(x,y,PtRct(inn_wnd_rct.left  +crc_rad,
                           inn_wnd_rct.top   +crc_rad,
                           inn_wnd_rct.right -crc_rad,
                           inn_wnd_rct.bottom-crc_rad)) then
      Circle (x,y,crc_rad,srf_bmp_ptr,            srf_bmp.width,crc_sel_col)
    else
      CircleC(x,y,crc_rad,srf_bmp_ptr,inn_wnd_rct,srf_bmp.width,crc_sel_col);
end; {$endregion}
procedure TCrcSel.ResizeCircleSelectionModeDraw;                                                                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  sel_pos: TPtPos;
begin
  GetCursorPos(TPoint(sel_pos));
  sel_pos           :=TPtPos(F_MainForm.ScreenToClient(TPoint(sel_pos)));
  crc_sel_rct.left  :=sel_pos.x-crc_rad;
  crc_sel_rct.top   :=sel_pos.y-crc_rad;
  crc_sel_rct.width :=crc_rad<<1;
  crc_sel_rct.height:=crc_rad<<1;
end; {$endregion}
constructor TBrsSel.Create;                                                                                                                                     {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  draw_brs_sel:=False;
end; {$endregion}
destructor  TBrsSel.Destroy;                                                                                                                                    {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
constructor TRctSel.Create;                                                                                                                                     {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct_width:=10;
end; {$endregion}
destructor  TRctSel.Destroy;                                                                                                                                    {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure TSelIts.ChangeSelectionMode(item_ind:TColor);                                                                                                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  crc_sel_var.draw_crc_sel :=item_ind in [0..1];
  brs_sel_var.draw_brs_sel :=False;
  selit_prop.selection_mode:=TSelectionMode(item_ind);
  case selit_prop.selection_mode of
    smCircle,smBrush:
      with crc_sel_var do
        begin
          ResizeCircleSelectionModeDraw;
          AddCircleSelection;
          CrtCircleSelection;
          FilSelPtsObj(crc_sel_rct.left,crc_sel_rct.top);
        end;
  end;
  //InvalidateInnerWindow;
end; {$endregion}
procedure TSelIts.AddCircleSelection;                                                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  with sel_pts_big_img,local_prop,crc_sel_var do
    begin
      Circle(crc_rad+1,crc_rad+1,crc_rad,ln_arr1_ptr,ln_arr_width,1);
      if (selit_prop.selection_mode=smBrush) then
        begin
          Circle(crc_rad+0001,crc_rad+0001,crc_rad-0006,ln_arr1_ptr,ln_arr_width,1);
          LineH (000000000001,crc_rad+0001,000000000008,ln_arr1_ptr,ln_arr_width,1);
          LineH (crc_rad<<1-6,crc_rad+0001,crc_rad<<1+1,ln_arr1_ptr,ln_arr_width,1);
          LineV (crc_rad+0001,000000000001,000000000008,ln_arr1_ptr,ln_arr_width,1);
          LineV (crc_rad+0001,crc_rad<<1-6,crc_rad<<1+1,ln_arr1_ptr,ln_arr_width,1);
          {for i:=0 to 100 do
            (ln_arr1_ptr+Random(crc_rad<<1)+Random(crc_rad<<1)*ln_arr_width)^:=1;}
        end;
    end;
end; {$endregion}
procedure TSelIts.PrimitiveComp(constref pmt_img_ptr:PFastLine; pmt_bld_stl:TDrawingStyle);                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  bmp_alpha_ptr2_: PByte;
begin
  with pmt_img_ptr^,local_prop,fst_img,fast_image_data,fast_image_proc_var do
    begin
      with rct_vis do
        SetRctPos
        (
          left,
          top
        );
      SetValInfo
      (
        ln_arr1_ptr,
        ln_arr1_ptr,
        ln_arr1_ptr,
        ln_arr_width,
        ln_arr_height
      );
      SetBkgnd
      (
        bmp_dst_ptr,
        bmp_dst_width,
        bmp_dst_height,
        pmt_img_ptr^.rct_clp_ptr^
      );
      bmp_src_rct_clp          :=PtRct(rct_vis);
      img_kind                 :={1}5;
      pix_drw_type             :=1; //must be in range of [0..002]
      fx_cnt                   :=1; //must be in range of [0..255]
      fx_arr[0].rep_cnt        :=1; //must be in range of [0..255]
      fx_arr[0].nt_pix_srf_type:=1; //must be in range of [0..001]
      fx_arr[0].nt_pix_cfx_type:=GetEnumVal(pmt_bld_stl);
      fx_arr[0].pt_pix_srf_type:=1; //must be in range of [0..001]
      fx_arr[0].pt_pix_cfx_type:=fx_arr[0].nt_pix_cfx_type;
    //nt_pix_srf_type          :=0;
    //pt_pix_srf_type          :=0;
      col_trans_arr[2]         :=064;
      col_trans_arr[4]         :=100;
      col_trans_arr[5]         :=100;
      CmpProc[11];

      {Edges Anti-Aliasing---} {$region -fold}
      if eds_aa then
        begin

          fast_image_data_ptr0:=@fast_image_data;

          {Calc. Anti-Aliased Border----------} {$region -fold}
          {ArrClear    (aa_arr1,
                       PtRct(rct_vis),
                       ln_arr_width);}
          {Fast_Primitives.}
          //ArrClear(srf_var_ptr^.test_bmp_ptr,srf_var_ptr^.inn_wnd_rct,srf_var_ptr^.test_bmp.width,1,1,1,1);

          BorderCalc1 (ln_arr1,
                       aa_arr1,
                       ln_arr_width,
                       ln_arr_width,
                       PtRct(rct_vis){,
                       aa_nz_arr_items_count});
          //ArrFill (aa_arr1,srf_var_ptr^.test_bmp_ptr,srf_var_ptr^.test_bmp.width,srf_var_ptr^.test_bmp.height,srf_var_ptr^.inn_wnd_rct,False);
          {bmp_alpha_ptr2_:=bmp_alpha_ptr2;
          bmp_alpha_ptr2:=@aa_arr1[0];
          CrtPTCountArrB;
          CrtPTShiftArrB;
          CrtPTCntIndArr;
          bmp_alpha_ptr2:=bmp_alpha_ptr2_;}
          BorderCalc20(ln_arr1,
                       aa_arr1,
                       aa_arr2,
                       ln_arr_width,
                       ln_arr_width,
                       PtRct(rct_vis),
                       aa_line_cnt);
          {ArrFill (aa_arr1,srf_var_ptr^.test_bmp_ptr,srf_var_ptr^.test_bmp.width,srf_var_ptr^.test_bmp.height,srf_var_ptr^.inn_wnd_rct,False);
          F_MainForm.Memo1.Lines.Text:=IntToStr(2 or 3){IntToStr(nt_pix_cnt)+';'+IntToStr(pt_pix_cnt)+';'+IntToStr(pt_pix_intr_cnt_arr[1])};} {$endregion}

          {Clear Buffer-----------------------} {$region -fold}
          FilNTValueArrA(ln_arr1,ln_arr_width); {$endregion}

          {Fill Anti-Aliased Border-----------} {$region -fold}
          BorderFill(aa_arr2,
                     0,
                     0,
                     ln_arr1_ptr,
                     ln_arr_width,
                     aa_line_cnt,
                     eds_col,
                     args); {$endregion}

          {Compress Anti-Aliased Alpha Channel} {$region -fold}
          CrtPTCountBmpO;
          CrtPTShiftBmpO;
          CrtPTCntIndArr;
          StrPTAlphaArrO; {$endregion}

          {Clear Buffer-----------------------} {$region -fold}
          FilPTValueArrA(ln_arr1,ln_arr_width);
          FilPTValueArrB(aa_arr1,ln_arr_width); {$endregion}

        end; {$endregion}

      SetRctPos(bmp_src_rct_clp);
      SetSdrType;
    end;
end; {$endregion}
procedure TSelIts.CrtCircleSelection;                                                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sel_pts_big_img,local_prop,fst_img,fast_image_proc_var do
    begin

      fast_image_data_ptr0:=@fast_image_data;

      {Set Bounding Rectangle} {$region -fold}
      with rct_vis do
        begin
          left  :=0;
          top   :=0;
          right :=crc_sel_var.crc_rad<<1+3;
          bottom:=right;
          width :=right-left;
          height:=bottom-top;
        end; {$endregion}

      {Create Sprite---------} {$region -fold}
      if (fst_img=Nil) then
          fst_img:=TFastImageItem.Create
          (
            bmp_dst_ptr,
            bmp_dst_width,
            bmp_dst_height,
            rct_clp_ptr^,
            PtRct(rct_vis),
            0
          ); {$endregion}

      {Compress Sprite-------} {$region -fold}
      // clear buffers:
      ClrArr({%0000011111111111}%0000000011111111);

      // set color of spline edges:
      SetPPInfo(eds_col);

      // compress edges sprite:
      PrimitiveComp(@sel_pts_big_img,eds_bld_stl); {$endregion}

    end;
end; {$endregion}
procedure TSelIts.FilSelPtsObj(constref x,y:integer);                                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sel_pts_big_img,fst_img,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      SetRctPos(x,y);
      SdrProc[3];
    end;
end; {$endregion}
procedure TSelIts.MinimizeCircleSelection;                                                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with crc_sel_var do
    begin
      crc_rad     :=10;
      crc_rad_sqr :=crc_rad*crc_rad;
      ResizeCircleSelectionModeDraw;
      AddCircleSelection;
      CrtCircleSelection;
      FilSelPtsObj(crc_sel_rct.left,crc_sel_rct.top);
    end;
end; {$endregion}
procedure TSelIts.SelectAllPts(const pts_cnt,eds_cnt:TColor);                                                                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TSelIts.SubgraphCalc(var has_sel_pts:T1Byte1Arr; constref pts:TPtPosFArr; constref fst_lst_sln_obj_pts:TEnum0Arr; constref obj_ind:TColorArr; constref sln_obj_cnt:TColor; constref sln_pts_cnt:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  outer_subgraph1_ptr        : PEdge;
  outer_subgraph2_ptr        : PEdge;
  outer_subgraph3_ptr        : PEdge;
  inner_subgraph__ptr        : PEdge;
  sl_pt_subgraph__ptr        : PSlPt;
  obj_ind_ptr                : PInteger;
  sel_pts_inds_ptr           : PInteger;
  is_point_selected_ptr      : PByteBool;
  out_or_inn_subgraph_pts_ptr: PByte;
  fst_lst_sln_obj_pts_ptr    : PByte;
  has_sel_pts_ptr            : PByte;
  f_arr                      : TColorArr;
  i,c                        : integer;
  b                          : integer;
begin

  {Misc. Precalc.-------------------------------} {$region -fold}
  c:=Min(2*sel_pts_cnt,sln_pts_cnt); {$endregion}

  {Clear Arrays---------------------------------} {$region -fold}
  SetLength(outer_subgraph1,0);
  SetLength(outer_subgraph2,0);
  SetLength(outer_subgraph3,0);
  SetLength(inner_subgraph_,0);
  SetLength(sl_pt_subgraph_,0);
  FillByte((@has_sel_pts[0])^,Length(has_sel_pts),0); {$endregion}

  {Create Arrays--------------------------------} {$region -fold}
  SetLength(outer_subgraph1,c          );
  SetLength(outer_subgraph2,c          );
  SetLength(outer_subgraph3,c          );
  SetLength(inner_subgraph_,sel_pts_cnt);
  SetLength(sl_pt_subgraph_,sel_pts_cnt); {$endregion}

  {Outer, Inner Subgraph and Single Points Calc.} {$region -fold}
  obj_ind_ptr                :=Unaligned(@obj_ind                [0]);
  fst_lst_sln_obj_pts_ptr    :=Unaligned(@fst_lst_sln_obj_pts    [0]);
  is_point_selected_ptr      :=Unaligned(@is_point_selected      [0]);
  has_sel_pts_ptr            :=Unaligned(@has_sel_pts            [0]);
  sel_pts_inds_ptr           :=Unaligned(@sel_pts_inds           [0]);
  outer_subgraph1_ptr        :=Unaligned(@outer_subgraph1        [0]);
  outer_subgraph2_ptr        :=Unaligned(@outer_subgraph2        [0]);
  outer_subgraph3_ptr        :=Unaligned(@outer_subgraph3        [0]);
  inner_subgraph__ptr        :=Unaligned(@inner_subgraph_        [0]);
  sl_pt_subgraph__ptr        :=Unaligned(@sl_pt_subgraph_        [0]);
  out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
  for i:=0 to sel_pts_cnt-1 do
    begin
      case (fst_lst_sln_obj_pts_ptr+sel_pts_inds_ptr^)^ of
        0: {Inner  Spline Object Point} {$region -fold}
          begin
            if (is_point_selected_ptr+sel_pts_inds_ptr^-1)^ then
              begin
                {Inner Subgraph Calc.}
                {--------------------}//(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^-1)^:= 2;
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:= 2;
                {--------------------}inner_subgraph__ptr^.first_point                  := 00000000000+sel_pts_inds_ptr^-1;
                {--------------------}inner_subgraph__ptr^.last_point                   := 00000000000+sel_pts_inds_ptr^+0;
                {--------------------}inner_subgraph__ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                case (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^ of
                  0: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=2;
                  1: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=3;
                  2: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=2;
                  3: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=3;
                end;
                Inc(inner_subgraph__ptr);
                if (not (is_point_selected_ptr+sel_pts_inds_ptr^+1)^) then
                  begin
                    {Outer Subgraph 3 Calc.}
                    {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+1)^:= 1;
                    {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:= 1;
                    {--------------------}outer_subgraph3_ptr^.first_point                  := 00000000000+sel_pts_inds_ptr^+1;
                    {--------------------}outer_subgraph3_ptr^.last_point                   := 00000000000+sel_pts_inds_ptr^+0;
                    {--------------------}outer_subgraph3_ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                    case (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^ of
                      0: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=1;
                      1: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=1;
                      2: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=3;
                      3: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=3;
                    end;
                    Inc(outer_subgraph3_ptr);
                  end;
              end
            else
              begin
                if (is_point_selected_ptr+sel_pts_inds_ptr^+1)^ then
                  begin
                    {Outer Subgraph 3 Calc.}
                    {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^-1)^:= 1;
                    {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:= 1;
                    {--------------------}outer_subgraph3_ptr^.first_point                  := 00000000000+sel_pts_inds_ptr^-1;
                    {--------------------}outer_subgraph3_ptr^.last_point                   := 00000000000+sel_pts_inds_ptr^+0;
                    {--------------------}outer_subgraph3_ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                    case (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^ of
                      0: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=1;
                      1: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=1;
                      2: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=3;
                      3: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=3;
                    end;
                    Inc(outer_subgraph3_ptr);
                  end
                else
                  begin
                    {Outer Subgraph 1,2 Calc.}
                    {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^-1)^:= 1;
                    {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:= 1;
                    {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+1)^:= 1;
                    {--------------------}outer_subgraph1_ptr^.first_point                  := 00000000000+sel_pts_inds_ptr^-1;
                    {--------------------}outer_subgraph1_ptr^.last_point                   := 00000000000+sel_pts_inds_ptr^+0;
                    {--------------------}outer_subgraph1_ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                    {--------------------}outer_subgraph2_ptr^.first_point                  := 00000000000+sel_pts_inds_ptr^+1;
                    {--------------------}outer_subgraph2_ptr^.last_point                   := 00000000000+sel_pts_inds_ptr^+0;
                    {--------------------}outer_subgraph2_ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                    case (has_sel_pts_ptr+outer_subgraph2_ptr^.obj_ind)^ of
                      0: (has_sel_pts_ptr+outer_subgraph2_ptr^.obj_ind)^:=1;
                      1: (has_sel_pts_ptr+outer_subgraph2_ptr^.obj_ind)^:=1;
                      2: (has_sel_pts_ptr+outer_subgraph2_ptr^.obj_ind)^:=3;
                      3: (has_sel_pts_ptr+outer_subgraph2_ptr^.obj_ind)^:=3;
                    end;
                    Inc(outer_subgraph1_ptr);
                    Inc(outer_subgraph2_ptr);
                  end;
              end;
          end; {$endregion}
        1: {First  Spline Object Point} {$region -fold}
          begin
            if (not (is_point_selected_ptr+sel_pts_inds_ptr^+1)^) then
              begin
                {Outer Subgraph 3 Calc.}
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+1)^:= 1;
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:= 1;
                {--------------------}outer_subgraph3_ptr^.first_point                  := 00000000000+sel_pts_inds_ptr^+1;
                {--------------------}outer_subgraph3_ptr^.last_point                   := 00000000000+sel_pts_inds_ptr^+0;
                {--------------------}outer_subgraph3_ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                case (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^ of
                  0: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=1;
                  1: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=1;
                  2: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=3;
                  3: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=3;
                end;
                Inc(outer_subgraph3_ptr);
              end
            else
              begin
                {Inner Subgraph Calc.}
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+1)^:= 2;
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:= 2;
                {--------------------}inner_subgraph__ptr^.first_point                  := 00000000000+sel_pts_inds_ptr^+0;
                {--------------------}inner_subgraph__ptr^.last_point                   := 00000000000+sel_pts_inds_ptr^+1;
                {--------------------}inner_subgraph__ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                case (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^ of
                  0: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=2;
                  1: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=3;
                  2: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=2;
                  3: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=3;
                end;
                Inc(inner_subgraph__ptr);
              end;
          end; {$endregion}
        2: {Last   Spline Object Point} {$region -fold}
          begin
            if (is_point_selected_ptr+sel_pts_inds_ptr^-1)^ then
              begin
                {Inner Subgraph Calc.}
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^-1)^:=2;
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:=2;
                {--------------------}inner_subgraph__ptr^.first_point                  :=000000000000+sel_pts_inds_ptr^-1;
                {--------------------}inner_subgraph__ptr^.last_point                   :=000000000000+sel_pts_inds_ptr^+0;
                {--------------------}inner_subgraph__ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                case (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^ of
                  0: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=2;
                  1: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=3;
                  2: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=2;
                  3: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=3;
                end;
                Inc(inner_subgraph__ptr);
              end
            else
              begin
                {Outer Subgraph 3 Calc.}
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^-1)^:=1;
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:=1;
                {--------------------}outer_subgraph3_ptr^.first_point                  :=000000000000+sel_pts_inds_ptr^-1;
                {--------------------}outer_subgraph3_ptr^.last_point                   :=000000000000+sel_pts_inds_ptr^+0;
                {--------------------}outer_subgraph3_ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                case (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^ of
                  0: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=1;
                  1: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=1;
                  2: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=3;
                  3: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=3;
                end;
                Inc(outer_subgraph3_ptr);
              end;
          end; {$endregion}
        3: {Single Spline Object Point} {$region -fold}
          begin
             {--------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:=2;
             {--------------}sl_pt_subgraph__ptr^.point                        :=000000000000+sel_pts_inds_ptr^;
             {--------------}sl_pt_subgraph__ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^)^;
            (has_sel_pts_ptr+sl_pt_subgraph__ptr^.obj_ind)^:=4;
            Inc(sl_pt_subgraph__ptr);
          end; {$endregion}
      end;
      Inc(sel_pts_inds_ptr);
    end; {$endregion}

  {Edges Count----------------------------------} {$region -fold}
  outer_subgraph1_eds_cnt:=PEdge(outer_subgraph1_ptr)-PEdge(@outer_subgraph1[0]);
  outer_subgraph2_eds_cnt:=PEdge(outer_subgraph2_ptr)-PEdge(@outer_subgraph2[0]);
  outer_subgraph3_eds_cnt:=PEdge(outer_subgraph3_ptr)-PEdge(@outer_subgraph3[0]);
  inner_subgraph__eds_cnt:=PEdge(inner_subgraph__ptr)-PEdge(@inner_subgraph_[0]);
  sl_pt_subgraph__eds_cnt:=PSlPt(sl_pt_subgraph__ptr)-PSlPt(@sl_pt_subgraph_[0]); {$endregion}

  {Count of Splines with Selected Points--------} {$region -fold}
  sln_with_sel_pts_cnt:=ArrNzItCnt(has_sel_pts,4); {$endregion}

  {Selected Points Rectangle Calc.--------------} {$region -fold}
  sel_pts_rct:=obj_var.PtsRngIndsRctCalc
  (
    pts,
    sel_pts_inds,
    sel_pts_cnt
  );
  with sel_pts_rct do
    begin
      left  :=sel_pts_rct.left  -sel_pts_rct_mrgn;
      top   :=sel_pts_rct.top   -sel_pts_rct_mrgn;
      right :=sel_pts_rct.right +sel_pts_rct_mrgn;
      bottom:=sel_pts_rct.bottom+sel_pts_rct_mrgn;
      width :=right-left;
      height:=bottom-top;
    end; {$endregion}

  {Minimal Index of Selected Spline-------------} {$region -fold}
  f_arr:=Nil;
  f_arr:=TColorArr.Create
  (
    obj_var.Min9(obj_var.curve_inds_obj_arr,outer_subgraph1,obj_var.obj_cnt-1,outer_subgraph1_eds_cnt),
    obj_var.Min9(obj_var.curve_inds_obj_arr,outer_subgraph2,obj_var.obj_cnt-1,outer_subgraph2_eds_cnt),
    obj_var.Min9(obj_var.curve_inds_obj_arr,outer_subgraph3,obj_var.obj_cnt-1,outer_subgraph3_eds_cnt),
    obj_var.Min9(obj_var.curve_inds_obj_arr,inner_subgraph_,obj_var.obj_cnt-1,inner_subgraph__eds_cnt),
    obj_var.Min9(obj_var.curve_inds_obj_arr,sl_pt_subgraph_,obj_var.obj_cnt-1,sl_pt_subgraph__eds_cnt)
  );
  sel_obj_min_ind:=Min5(f_arr,obj_var.obj_cnt-1,5); {$endregion}

end; {$endregion}
procedure TSelIts.UnselectedPtsCalc0(constref fst_lst_sln_obj_pts:TEnum0Arr; var pts:TPtPosFArr; constref pvt_pos_curr,pvt_pos_prev:TPtPosF);           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                : PPtPosF;
  selected_pts_inds_ptr  : PInteger;
  fst_lst_sln_obj_pts_ptr: PByte;
  is_pt_selected_ptr     : PByteBool;
  i,n1,n2                : integer;
begin

  {Misc. Precalc.----------------------------------------} {$region -fold}
  n1:=Trunc(pvt_pos_curr.x)-Trunc(pvt_pos_prev.x);
  n2:=Trunc(pvt_pos_curr.y)-Trunc(pvt_pos_prev.y); {$endregion}

  {Calculation Of Inner Subgraph Points On Unselect Pivot} {$region -fold}
  pts_ptr                :=Unaligned(@pts                [0]);
  fst_lst_sln_obj_pts_ptr:=Unaligned(@fst_lst_sln_obj_pts[0]);
  is_pt_selected_ptr     :=Unaligned(@is_point_selected  [0]);
  selected_pts_inds_ptr  :=Unaligned(@sel_pts_inds       [0]);
  {if {inner_subgraph_img.local_prop.eds_show or}
    (inner_subgraph_img.local_prop.eds_show and (not outer_subgraph_img.local_prop.eds_show)) then}
    for i:=0 to sel_pts_cnt-1 do
      begin
        case (fst_lst_sln_obj_pts_ptr+selected_pts_inds_ptr^)^ of
         {0: {Inner  Spline Object Point} {$region -fold}
            if (is_pt_selected_ptr+selected_pts_inds_ptr^-1)^ and
               (is_pt_selected_ptr+selected_pts_inds_ptr^+1)^ then
              begin
                (pts_ptr+selected_pts_inds_ptr^)^.x+=n1;
                (pts_ptr+selected_pts_inds_ptr^)^.y+=n2;
              end; {$endregion}
          1: {First  Spline Object Point} {$region -fold}
            if (is_pt_selected_ptr+selected_pts_inds_ptr^+1)^ then
              begin
                (pts_ptr+selected_pts_inds_ptr^)^.x+=n1;
                (pts_ptr+selected_pts_inds_ptr^)^.y+=n2;
              end; {$endregion}
          2: {Last   Spline Object Point} {$region -fold}
            if (is_pt_selected_ptr+selected_pts_inds_ptr^-1)^ then
              begin
                (pts_ptr+selected_pts_inds_ptr^)^.x+=n1;
                (pts_ptr+selected_pts_inds_ptr^)^.y+=n2;
              end; {$endregion}
         }3: {Single Spline Object Point} {$region -fold}
            begin
              (pts_ptr+selected_pts_inds_ptr^)^.x+=n1;
              (pts_ptr+selected_pts_inds_ptr^)^.y+=n2;
            end; {$endregion}
        end;
        Inc(selected_pts_inds_ptr);
      end
  {else
    for i:=0 to sel_pts_cnt-1 do
      begin
        case (fst_lst_sln_obj_pts_ptr+selected_pts_inds_ptr^)^ of
          0: {Inner  Spline Object Point} {$region -fold}
            if (is_pt_selected_ptr+selected_pts_inds_ptr^-1)^ and
               (is_pt_selected_ptr+selected_pts_inds_ptr^+1)^ then
              begin
                (pts_ptr+selected_pts_inds_ptr^)^.x+=n1;
                (pts_ptr+selected_pts_inds_ptr^)^.y+=n2;
              end; {$endregion}
          1: {First  Spline Object Point} {$region -fold}
            if (is_pt_selected_ptr+selected_pts_inds_ptr^+1)^ then
              begin
                (pts_ptr+selected_pts_inds_ptr^)^.x+=n1;
                (pts_ptr+selected_pts_inds_ptr^)^.y+=n2;
              end; {$endregion}
          2: {Last   Spline Object Point} {$region -fold}
            if (is_pt_selected_ptr+selected_pts_inds_ptr^-1)^ then
              begin
                (pts_ptr+selected_pts_inds_ptr^)^.x+=n1;
                (pts_ptr+selected_pts_inds_ptr^)^.y+=n2;
              end; {$endregion}
          3: {Single Spline Object Point} {$region -fold}
            begin
              (pts_ptr+selected_pts_inds_ptr^)^.x+=n1;
              (pts_ptr+selected_pts_inds_ptr^)^.y+=n2;
            end; {$endregion}
        end;
        Inc(selected_pts_inds_ptr);
      end}; {$endregion}

end; {$endregion}
procedure TSelIts.UnselectedPtsCalc1(constref fst_lst_sln_obj_pts:TEnum0Arr; var pts:TPtPosFArr; constref pvt_pos_curr,pvt_pos_prev:TPtPosF);           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  outer_subgraph1_ptr        : PEdge;
  outer_subgraph3_ptr        : PEdge;
  inner_subgraph__ptr        : PEdge;
  out_or_inn_subgraph_pts_ptr: PByte;
  pts_f3,pts_l3              : TPtPosF;
  pts_ptr                    : PPtPosF;
  i,n1,n2                    : integer;
begin

  {Misc. Precalc.----------------------------------------} {$region -fold}
  n1:=Trunc(pvt_pos_curr.x)-Trunc(pvt_pos_prev.x);
  n2:=Trunc(pvt_pos_curr.y)-Trunc(pvt_pos_prev.y); {$endregion}

  {Calculation Of Inner Subgraph Points On Unselect Pivot} {$region -fold}
  pts_ptr:=Unaligned(@pts[0]);
  if (not (outer_subgraph_img.local_prop.eds_show  and (not inner_subgraph_img.local_prop.eds_show))) then
    begin
      if (outer_subgraph1_eds_cnt>0) then
        begin
          outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
          for i:=0 to  outer_subgraph1_eds_cnt-1 do
            begin
              is_point_pos_calc[outer_subgraph1_ptr^.last_point]:=True;
              (pts_ptr+outer_subgraph1_ptr^.last_point)^.x+=n1;
              (pts_ptr+outer_subgraph1_ptr^.last_point)^.y+=n2;
              Inc     (outer_subgraph1_ptr);
            end;
        end;
      if (outer_subgraph3_eds_cnt>0) then
        begin
          outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
          for i:=0 to  outer_subgraph3_eds_cnt-1 do
            begin
              is_point_pos_calc[outer_subgraph3_ptr^.last_point]:=True;
              (pts_ptr+outer_subgraph3_ptr^.last_point)^.x+=n1;
              (pts_ptr+outer_subgraph3_ptr^.last_point)^.y+=n2;
              Inc     (outer_subgraph3_ptr);
            end;
        end;
    end
  else
    begin
      if (outer_subgraph1_eds_cnt>0) then
        begin
          outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
          for i:=0 to  outer_subgraph1_eds_cnt-1 do
            begin
              is_point_pos_calc[outer_subgraph1_ptr^.last_point]:=True;
              Inc              (outer_subgraph1_ptr);
            end;
        end;
      if (outer_subgraph3_eds_cnt>0) then
        begin
          outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
          for i:=0 to  outer_subgraph3_eds_cnt-1 do
            begin
              is_point_pos_calc[outer_subgraph3_ptr^.last_point]:=True;
              Inc              (outer_subgraph3_ptr);
            end;
        end;
    end;
  {if (outer_subgraph_img.local_prop.eds_show  and (not inner_subgraph_img.local_prop.eds_show)) then
    begin
      n1:=Trunc(pvt_pos_curr.x)-Trunc(pvt_var.pvt_origin.x);
      n2:=Trunc(pvt_pos_curr.y)-Trunc(pvt_var.pvt_origin.y);
    end;}
  if (outer_subgraph3_eds_cnt>0) then
    begin
      out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
      inner_subgraph__ptr        :=Unaligned(@inner_subgraph_        [0]);
      for i:=0 to  inner_subgraph__eds_cnt-1 do
        begin
          pts_f3:=(pts_ptr+inner_subgraph__ptr^.first_point)^;
          pts_l3:=(pts_ptr+inner_subgraph__ptr^.last_point )^;
          if ((out_or_inn_subgraph_pts_ptr+inner_subgraph__ptr^.first_point)^=2) then
            if (not is_point_pos_calc[inner_subgraph__ptr^.first_point]) then
              begin
                pts_f3.x+=n1;
                pts_f3.y+=n2;
                is_point_pos_calc[inner_subgraph__ptr^.first_point]:=True;
              end;
          if ((out_or_inn_subgraph_pts_ptr+inner_subgraph__ptr^.last_point )^=2) then
            if (not is_point_pos_calc[inner_subgraph__ptr^.last_point]) then
              begin
                pts_l3.x+=n1;
                pts_l3.y+=n2;
                is_point_pos_calc[inner_subgraph__ptr^.last_point]:=True;
              end;
          (pts_ptr+inner_subgraph__ptr^.first_point)^:=pts_f3;
          (pts_ptr+inner_subgraph__ptr^.last_point )^:=pts_l3;
          Inc(inner_subgraph__ptr);
        end;
     end; {$endregion}

  SelPtsIndsToFalse2;

end; {$endregion}
procedure TSelIts.SelPtsIndsToFalse1;                                                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  selected_pts_inds_ptr      : PInteger;
  is_point_selected_ptr      : PByteBool;
  is_point_pos_calc_ptr      : PByteBool;
  out_or_inn_subgraph_pts_ptr: PByte;
  i                          : integer;
begin
  is_point_selected_ptr:=Unaligned(@is_point_selected[0]);
  is_point_pos_calc_ptr:=Unaligned(@is_point_pos_calc[0]);
  selected_pts_inds_ptr:=Unaligned(@sel_pts_inds     [0]);
  out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
  for i:=0 to sel_pts_cnt-1 do
    begin
      (out_or_inn_subgraph_pts_ptr+selected_pts_inds_ptr^)^:=0;
      (is_point_selected_ptr      +selected_pts_inds_ptr^)^:=False;
      (is_point_pos_calc_ptr      +selected_pts_inds_ptr^)^:=False;
      Inc(selected_pts_inds_ptr);
    end;
end; {$endregion}
procedure TSelIts.SelPtsIndsToFalse2;                                                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  selected_pts_inds_ptr: PInteger;
  is_point_pos_calc_ptr: PByteBool;
  i                    : integer;
begin
  is_point_pos_calc_ptr:=Unaligned(@is_point_pos_calc[0]);
  selected_pts_inds_ptr:=Unaligned(@sel_pts_inds     [0]);
  for i:=0 to sel_pts_cnt-1 do
    begin
      (is_point_pos_calc_ptr+selected_pts_inds_ptr^)^:=False;
      Inc(selected_pts_inds_ptr);
    end;
end; {$endregion}
procedure TSelIts.DuplicatedPtsCalc;                                                                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  i,j,k,v,m1,m2: integer;}
begin
  {
  v:=100;
  m1:=5;
  m2:=5;
  duplicated_pts_count:=0;
  for k:=0 to spline_pts_count-1 do
    is_point_duplicated[k]:=False;
  with F_MainForm.Canvas do
    begin
      Pen.Mode :=pmCopy;
      Pen.Color:=clYellow;
      for i:=0 to m1 do
        for j:=0 to m2 do
          for k:=0 to spline_pts_count-1 do
            if (spline_pts[k].x>i*v) and (spline_pts[k].x<=(i+1)*v) and
               (spline_pts[k].y>j*v) and (spline_pts[k].y<=(j+1)*v) then
              if (not is_point_duplicated[k]) then
                begin
                  is_point_duplicated[k]:=True;
                  Rectangle(spline_pts[k].x-4,
                            spline_pts[k].y-4,
                            spline_pts[k].x+5,
                            spline_pts[k].y+5);
                  Inc(duplicated_pts_count);
                end;
    end;
  }
  {
  for i:=0 to spline_pts_count-1 do
    for j:=i+1 to spline_pts_count do
      if (not is_point_duplicated[i]) and
         (not is_point_duplicated[j]) then
        if (spline_pts[i].x=spline_pts[j].x) then
          if (spline_pts[i].y=spline_pts[j].y) then
            begin
              is_point_duplicated[i]:=True;
              is_point_duplicated[j]:=True;
              Break;
            end;
  }
end; {$endregion}
procedure TSelIts.AdvancedClipCalc(pts:TPtPosFArr; pts_cnt:TColor; is_pt_marked:TBool1Arr);                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  i,m,clip_rad: integer;}
begin
  {m:=clip_rad*clip_rad;
  for i:=0 to pts_count do
    if (pts[i].x-X)*(pts[i].x-X)+
       (pts[i].y-Y)*(pts[i].y-Y)>=m then
      begin

      end;}
end; {$endregion}
procedure TSelIts.DuplicatedPtsToBmp;                                                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  i: integer;}
begin
  {
  with F_MainForm.Canvas do
    begin
      Pen.Mode :=pmCopy;
      Pen.Color:=clFuchsia;
      for i:=0 to spline_pts_count-1 do
        if is_point_duplicated[i] then
          Rectangle(spline_pts[i].x-4,
                    spline_pts[i].y-4,
                    spline_pts[i].x+5,
                    spline_pts[i].y+5);
    end;
  }
end; {$endregion}
procedure TSelIts.OuterSubgraphCalc0(x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct_clp  :TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr            : PPtPosF;
  outer_subgraph1_ptr: PEdge;
  outer_subgraph3_ptr: PEdge;
  i                  : integer;
begin

  if (outer_subgraph1_eds_cnt=0) and
     (outer_subgraph3_eds_cnt=0) then
    Exit;

  if fill_bmp_only then
    Exit;

  {Drawing Of Outer Subgraph Lines} {$region -fold}
  if (outer_subgraph1_eds_cnt>0) then
    begin
      pts_ptr            :=Unaligned(@pts            [0]);
      outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
      for i:=0 to outer_subgraph1_eds_cnt-1 do
        begin
          is_point_pos_calc[outer_subgraph1_ptr^.last_point]:=True;
          (pts_ptr+outer_subgraph1_ptr^.last_point)^.x+=pvt_var.pos_dif.x;
          (pts_ptr+outer_subgraph1_ptr^.last_point)^.y+=pvt_var.pos_dif.y;
          Inc(outer_subgraph1_ptr);
        end;
    end;
  if (outer_subgraph3_eds_cnt>0) then
    begin
      pts_ptr            :=Unaligned(@pts            [0]);
      outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
      for i:=0 to outer_subgraph3_eds_cnt-1 do
        begin
          is_point_pos_calc[outer_subgraph3_ptr^.last_point]:=True;
          (pts_ptr+outer_subgraph3_ptr^.last_point)^.x+=pvt_var.pos_dif.x;
          (pts_ptr+outer_subgraph3_ptr^.last_point)^.y+=pvt_var.pos_dif.y;
          Inc(outer_subgraph3_ptr);
        end;
    end; {$endregion}

end; {$endregion}
procedure TSelIts.OuterSubgraphCalc1(x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct_clp  :TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr            : PPtPosF;
  outer_subgraph1_ptr: PEdge;
  outer_subgraph3_ptr: PEdge;
  i                  : integer;
begin

  if (outer_subgraph1_eds_cnt=0) and
     (outer_subgraph3_eds_cnt=0) then
    Exit;

  if fill_bmp_only then
    Exit;

  if (pvt_var.scl_dir=sdNone) then
    Exit;

  {Drawing Of Outer Subgraph Lines} {$region -fold}
  if (outer_subgraph1_eds_cnt>0) then
    begin
      pts_ptr            :=Unaligned(@pts            [0]);
      outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
      for i:=0 to outer_subgraph1_eds_cnt-1 do
        begin
          is_point_pos_calc[outer_subgraph1_ptr^.last_point]:=True;
          (pts_ptr+outer_subgraph1_ptr^.last_point)^.x*=pvt_var.pvt_scl.x;
          (pts_ptr+outer_subgraph1_ptr^.last_point)^.x+=pvt_var.scl_dif.x;
          (pts_ptr+outer_subgraph1_ptr^.last_point)^.y*=pvt_var.pvt_scl.y;
          (pts_ptr+outer_subgraph1_ptr^.last_point)^.y+=pvt_var.scl_dif.y;
          Inc(outer_subgraph1_ptr);
        end;
    end;
  if (outer_subgraph3_eds_cnt>0) then
    begin
      pts_ptr            :=Unaligned(@pts            [0]);
      outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
      for i:=0 to outer_subgraph3_eds_cnt-1 do
        begin
          is_point_pos_calc[outer_subgraph3_ptr^.last_point]:=True;
          (pts_ptr+outer_subgraph3_ptr^.last_point)^.x*=pvt_var.pvt_scl.x;
          (pts_ptr+outer_subgraph3_ptr^.last_point)^.x+=pvt_var.scl_dif.x;
          (pts_ptr+outer_subgraph3_ptr^.last_point)^.y*=pvt_var.pvt_scl.y;
          (pts_ptr+outer_subgraph3_ptr^.last_point)^.y+=pvt_var.scl_dif.y;
          Inc(outer_subgraph3_ptr);
        end;
    end; {$endregion}

end; {$endregion}
procedure TSelIts.OuterSubgraphCalc2(x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct_clp  :TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr            : PPtPosF;
  outer_subgraph1_ptr: PEdge;
  outer_subgraph3_ptr: PEdge;
  i                  : integer;
begin
  {
  if (outer_subgraph1_eds_cnt=0) and
     (outer_subgraph3_eds_cnt=0) then
    Exit;

  if fill_bmp_only then
    Exit;

  {Misc. Precalc.-----------------} {$region -fold}
  n1:=x-Trunc(pvt.x);
  n2:=y-Trunc(pvt.y); {$endregion}

  {Drawing Of Outer Subgraph Lines} {$region -fold}
  if (outer_subgraph1_eds_cnt>0) then
    begin
      pts_ptr            :=Unaligned(@pts            [0]);
      outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
      for i:=0 to outer_subgraph1_eds_cnt-1 do
        begin
          is_point_pos_calc[outer_subgraph1_ptr^.last_point]:=True;
          (pts_ptr+outer_subgraph1_ptr^.last_point)^.x+=n1;
          (pts_ptr+outer_subgraph1_ptr^.last_point)^.y+=n2;
          Inc(outer_subgraph1_ptr);
        end;
    end;
  if (outer_subgraph3_eds_cnt>0) then
    begin
      pts_ptr            :=Unaligned(@pts            [0]);
      outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
      for i:=0 to outer_subgraph3_eds_cnt-1 do
        begin
          is_point_pos_calc[outer_subgraph3_ptr^.last_point]:=True;
          (pts_ptr+outer_subgraph3_ptr^.last_point)^.x+=n1;
          (pts_ptr+outer_subgraph3_ptr^.last_point)^.y+=n2;
          Inc(outer_subgraph3_ptr);
        end;
    end; {$endregion}
  }
end; {$endregion}
procedure TSelIts.OuterSubgraphDraw (x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct_clp  :TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr1       : PObjInfo;
  obj_arr_ptr2       : PObjInfo;
  rct                : TPtRect;
  pts_ptr            : PPtPosF;
  pts_f1,pts_l1      : TPtPosF;
  pts_f2,pts_l2      : TPtPosF;
  pts_f3,pts_l3      : TPtPosF;
  outer_subgraph1_ptr: PEdge;
  outer_subgraph2_ptr: PEdge;
  outer_subgraph3_ptr: PEdge;
  i,m1,m2,m3,m4      : integer;
label
  lbl_flood_fill_only;
begin

  if (outer_subgraph1_eds_cnt=0) and
     (outer_subgraph3_eds_cnt=0) then
    Exit;

  outer_subgraph_img.bmp_dst_ptr:=bmp_dst_ptr;

  if fill_bmp_only then
    goto lbl_flood_fill_only;

  {Set Drawing Bounds(Inner Window)} {$region -fold}
  with rct_clp do
    begin
      m1:=left  +{outer_subgraph_img.}grid_pt_rad;
      m2:=top   +{outer_subgraph_img.}grid_pt_rad;
      m3:=right -{outer_subgraph_img.}grid_pt_rad-1;
      m4:=bottom-{outer_subgraph_img.}grid_pt_rad-1;
    end;
  rct:=PtRct(m1,m2,m3,m4); {$endregion}

  {Clear Arrays--------------------} {$region -fold}
  with outer_subgraph_img,local_prop do
    begin
      ArrClear(ln_arr0,rct_clp,ln_arr_width);
      ArrClear(ln_arr2,rct_clp);
    end; {$endregion}

  {Drawing Of Outer Subgraph Lines-} {$region -fold}
  with outer_subgraph_img do
    case local_prop.clp_stl of
      (csClippedEdges1 ): {Clipped Edges 1(Slow  )} {$region -fold}
        begin
          {Drawing Of Outer Subgraph 1,2} {$region -fold}
          if (outer_subgraph1_eds_cnt>0) then
            begin
              pts_ptr            :=Unaligned(@pts            [0]);
              outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
              outer_subgraph2_ptr:=Unaligned(@outer_subgraph2[0]);
              for i:=0 to outer_subgraph1_eds_cnt-1 do
                begin
                  if (sln_var.has_edge[Min(outer_subgraph1_ptr^.first_point,outer_subgraph1_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph1_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph1_ptr^.last_point ]]]);
                      ClippedLine1
                      (
                        Trunc((pts_ptr+outer_subgraph1_ptr^.first_point)^.x)+obj_arr_ptr1^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph1_ptr^.first_point)^.y)+obj_arr_ptr1^.world_axis_shift.y,
                        Trunc((pts_ptr+outer_subgraph1_ptr^.last_point )^.x)+obj_arr_ptr2^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph1_ptr^.last_point )^.y)+obj_arr_ptr2^.world_axis_shift.y,
                        rct,
                        Unaligned(@LineSME),
                        Nil,
                        Nil
                      );
                    end;
                  if (sln_var.has_edge[Min(outer_subgraph2_ptr^.first_point,outer_subgraph2_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph2_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph2_ptr^.last_point ]]]);
                      ClippedLine1
                      (
                        Trunc((pts_ptr+outer_subgraph2_ptr^.first_point)^.x)+obj_arr_ptr1^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph2_ptr^.first_point)^.y)+obj_arr_ptr1^.world_axis_shift.y,
                        Trunc((pts_ptr+outer_subgraph2_ptr^.last_point )^.x)+obj_arr_ptr2^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph2_ptr^.last_point )^.y)+obj_arr_ptr2^.world_axis_shift.y,
                        rct,
                        Unaligned(@LineSME),
                        Nil,
                        Nil
                      );
                    end;
                  Inc(outer_subgraph1_ptr);
                  Inc(outer_subgraph2_ptr);
                end;
            end; {$endregion}
          {Drawing Of Outer Subgraph 3  } {$region -fold}
          if (outer_subgraph3_eds_cnt>0) then
            begin
              pts_ptr            :=Unaligned(@pts            [0]);
              outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
              for i:=0 to outer_subgraph3_eds_cnt-1 do
                begin
                  if (sln_var.has_edge[Min(outer_subgraph3_ptr^.first_point,outer_subgraph3_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph3_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph3_ptr^.last_point ]]]);
                      ClippedLine1
                      (
                        Trunc((pts_ptr+outer_subgraph3_ptr^.first_point)^.x)+obj_arr_ptr1^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph3_ptr^.first_point)^.y)+obj_arr_ptr1^.world_axis_shift.y,
                        Trunc((pts_ptr+outer_subgraph3_ptr^.last_point )^.x)+obj_arr_ptr2^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph3_ptr^.last_point )^.y)+obj_arr_ptr2^.world_axis_shift.y,
                        rct,
                        Unaligned(@LineSME),
                        Nil,
                        Nil
                      );
                    end;
                  Inc(outer_subgraph3_ptr);
                end;
            end; {$endregion}
        end; {$endregion}
      (csClippedEdges2 ): {Clipped Edges 2(Slow  )} {$region -fold}
        begin
          {Drawing Of Outer Subgraph 1,2} {$region -fold}
          if (outer_subgraph1_eds_cnt>0) then
            begin
              pts_ptr            :=Unaligned(@pts            [0]);
              outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
              outer_subgraph2_ptr:=Unaligned(@outer_subgraph2[0]);
              for i:=0 to outer_subgraph1_eds_cnt-1 do
                begin
                  if (sln_var.has_edge[Min(outer_subgraph1_ptr^.first_point,outer_subgraph1_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph1_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph1_ptr^.last_point ]]]);
                      ClippedLine2
                      (
                        Trunc((pts_ptr+outer_subgraph1_ptr^.first_point)^.x)+obj_arr_ptr1^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph1_ptr^.first_point)^.y)+obj_arr_ptr1^.world_axis_shift.y,
                        Trunc((pts_ptr+outer_subgraph1_ptr^.last_point )^.x)+obj_arr_ptr2^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph1_ptr^.last_point )^.y)+obj_arr_ptr2^.world_axis_shift.y,
                        rct,
                        Unaligned(@LineSME),
                        Nil,
                        Nil
                      );
                    end;
                  if (sln_var.has_edge[Min(outer_subgraph2_ptr^.first_point,outer_subgraph2_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph2_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph2_ptr^.last_point ]]]);
                      ClippedLine2
                      (
                        Trunc((pts_ptr+outer_subgraph2_ptr^.first_point)^.x)+obj_arr_ptr1^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph2_ptr^.first_point)^.y)+obj_arr_ptr1^.world_axis_shift.y,
                        Trunc((pts_ptr+outer_subgraph2_ptr^.last_point )^.x)+obj_arr_ptr2^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph2_ptr^.last_point )^.y)+obj_arr_ptr2^.world_axis_shift.y,
                        rct,
                        Unaligned(@LineSME),
                        Nil,
                        Nil
                      );
                    end;
                  Inc(outer_subgraph1_ptr);
                  Inc(outer_subgraph2_ptr);
                end;
            end; {$endregion}
          {Drawing Of Outer Subgraph 3  } {$region -fold}
          if (outer_subgraph3_eds_cnt>0) then
            begin
              pts_ptr            :=Unaligned(@pts            [0]);
              outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
              for i:=0 to outer_subgraph3_eds_cnt-1 do
                begin
                  if (sln_var.has_edge[Min(outer_subgraph3_ptr^.first_point,outer_subgraph3_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph3_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph3_ptr^.last_point ]]]);
                      ClippedLine2
                      (
                        Trunc((pts_ptr+outer_subgraph3_ptr^.first_point)^.x)+obj_arr_ptr1^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph3_ptr^.first_point)^.y)+obj_arr_ptr1^.world_axis_shift.y,
                        Trunc((pts_ptr+outer_subgraph3_ptr^.last_point )^.x)+obj_arr_ptr2^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph3_ptr^.last_point )^.y)+obj_arr_ptr2^.world_axis_shift.y,
                        rct,
                        Unaligned(@LineSME),
                        Nil,
                        Nil
                      );
                    end;
                  Inc(outer_subgraph3_ptr);
                end;
            end; {$endregion}
        end; {$endregion}
      (csRemoveEdges   ): {Remove Edges---(Fast  )} {$region -fold}
        begin
          {Drawing Of Outer Subgraph 1,2} {$region -fold}
          if (outer_subgraph1_eds_cnt>0) then
            begin
              pts_ptr            :=Unaligned(@pts            [0]);
              outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
              outer_subgraph2_ptr:=Unaligned(@outer_subgraph2[0]);
              for i:=0 to outer_subgraph1_eds_cnt-1 do
                begin
                  pts_f1      :=(pts_ptr+outer_subgraph1_ptr^.first_point)^;
                  pts_l1      :=(pts_ptr+outer_subgraph1_ptr^.last_point )^;
                  obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph1_ptr^.first_point]]]);
                  obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph1_ptr^.last_point ]]]);
                  if IsPtInRct(PtPosF(pts_f1.x+obj_arr_ptr1^.world_axis_shift.x,pts_f1.y+obj_arr_ptr1^.world_axis_shift.y),rct) and
                     IsPtInRct(PtPosF(pts_l1.x+obj_arr_ptr2^.world_axis_shift.x,pts_l1.y+obj_arr_ptr2^.world_axis_shift.y),rct) and
                     (sln_var.has_edge[Min(outer_subgraph1_ptr^.first_point,outer_subgraph1_ptr^.last_point)]=0)               then
                    LineSMN
                    (
                      Trunc(pts_f1.x)+obj_arr_ptr1^.world_axis_shift.x,
                      Trunc(pts_f1.y)+obj_arr_ptr1^.world_axis_shift.y,
                      Trunc(pts_l1.x)+obj_arr_ptr2^.world_axis_shift.x,
                      Trunc(pts_l1.y)+obj_arr_ptr2^.world_axis_shift.y
                    );
                  pts_f2      :=(pts_ptr+outer_subgraph2_ptr^.first_point)^;
                  pts_l2      :=(pts_ptr+outer_subgraph2_ptr^.last_point )^;
                  obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph2_ptr^.first_point]]]);
                  obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph2_ptr^.last_point ]]]);
                  if IsPtInRct(PtPosF(pts_f2.x+obj_arr_ptr1^.world_axis_shift.x,pts_f2.y+obj_arr_ptr1^.world_axis_shift.y),rct) and
                     IsPtInRct(PtPosF(pts_l2.x+obj_arr_ptr2^.world_axis_shift.x,pts_l2.y+obj_arr_ptr2^.world_axis_shift.y),rct) and
                     (sln_var.has_edge[Min(outer_subgraph2_ptr^.first_point,outer_subgraph2_ptr^.last_point)]=0)               then
                    LineSMN
                    (
                      Trunc(pts_f2.x)+obj_arr_ptr1^.world_axis_shift.x,
                      Trunc(pts_f2.y)+obj_arr_ptr1^.world_axis_shift.y,
                      Trunc(pts_l2.x)+obj_arr_ptr2^.world_axis_shift.x,
                      Trunc(pts_l2.y)+obj_arr_ptr2^.world_axis_shift.y
                    );
                  Inc(outer_subgraph1_ptr);
                  Inc(outer_subgraph2_ptr);
                end;
            end; {$endregion}
          {Drawing Of Outer Subgraph 3  } {$region -fold}
          if (outer_subgraph3_eds_cnt>0) then
            begin
              pts_ptr            :=Unaligned(@pts            [0]);
              outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
              for i:=0 to outer_subgraph3_eds_cnt-1 do
                begin
                  pts_f3      :=(pts_ptr+outer_subgraph3_ptr^.first_point)^;
                  pts_l3      :=(pts_ptr+outer_subgraph3_ptr^.last_point )^;
                  obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph3_ptr^.first_point]]]);
                  obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph3_ptr^.last_point ]]]);
                  if IsPtInRct(PtPosF(pts_f3.x+obj_arr_ptr1^.world_axis_shift.x,pts_f3.y+obj_arr_ptr1^.world_axis_shift.y),rct) and
                     IsPtInRct(PtPosF(pts_l3.x+obj_arr_ptr2^.world_axis_shift.x,pts_l3.y+obj_arr_ptr2^.world_axis_shift.y),rct) and
                     (sln_var.has_edge[Min(outer_subgraph3_ptr^.first_point,outer_subgraph3_ptr^.last_point)]=0)   then
                    LineSMN
                    (
                      Trunc(pts_f3.x)+obj_arr_ptr1^.world_axis_shift.x,
                      Trunc(pts_f3.y)+obj_arr_ptr1^.world_axis_shift.y,
                      Trunc(pts_l3.x)+obj_arr_ptr2^.world_axis_shift.x,
                      Trunc(pts_l3.y)+obj_arr_ptr2^.world_axis_shift.y
                    );
                Inc(outer_subgraph3_ptr);
              end;
            end; {$endregion}
        end; {$endregion}
      (csResilientEdges): {Resilient Edges(Unreal)} {$region -fold}
        begin
          {Drawing Of Outer Subgraph 1,2} {$region -fold}
          if (outer_subgraph1_eds_cnt>0) then
            begin
              pts_ptr            :=Unaligned(@pts            [0]);
              outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
              outer_subgraph2_ptr:=Unaligned(@outer_subgraph2[0]);
              for i:=0 to outer_subgraph1_eds_cnt-1 do
                begin
                  if (sln_var.has_edge[Min(outer_subgraph1_ptr^.first_point,outer_subgraph1_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph1_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph1_ptr^.last_point ]]]);
                      ClippedLine2
                      (
                        Trunc((pts_ptr+outer_subgraph1_ptr^.first_point)^.x)+obj_arr_ptr1^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph1_ptr^.first_point)^.y)+obj_arr_ptr1^.world_axis_shift.y,
                        Trunc((pts_ptr+outer_subgraph1_ptr^.last_point )^.x)+obj_arr_ptr2^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph1_ptr^.last_point )^.y)+obj_arr_ptr2^.world_axis_shift.y,
                        rct
                      );
                      LineR
                      (
                        ln_pos.x0,
                        ln_pos.y0,
                        ln_pos.x1,
                        ln_pos.y1,
                        bmp_dst_ptr,
                        ln_arr_width,
                        color_info,
                        16
                      );
                    end;
                  if (sln_var.has_edge[Min(outer_subgraph2_ptr^.first_point,outer_subgraph2_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph2_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph2_ptr^.last_point ]]]);
                      ClippedLine2
                      (
                        Trunc((pts_ptr+outer_subgraph2_ptr^.first_point)^.x)+obj_arr_ptr1^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph2_ptr^.first_point)^.y)+obj_arr_ptr1^.world_axis_shift.y,
                        Trunc((pts_ptr+outer_subgraph2_ptr^.last_point )^.x)+obj_arr_ptr2^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph2_ptr^.last_point )^.y)+obj_arr_ptr2^.world_axis_shift.y,
                        rct
                      );
                      LineR
                      (
                        ln_pos.x0,
                        ln_pos.y0,
                        ln_pos.x1,
                        ln_pos.y1,
                        bmp_dst_ptr,
                        ln_arr_width,
                        color_info,
                        16
                      );
                    end;
                  Inc(outer_subgraph1_ptr);
                  Inc(outer_subgraph2_ptr);
                end;
            end; {$endregion}
          {Drawing Of Outer Subgraph 3  } {$region -fold}
          if (outer_subgraph3_eds_cnt>0) then
            begin
              pts_ptr            :=Unaligned(@pts            [0]);
              outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
              for i:=0 to outer_subgraph3_eds_cnt-1 do
                begin
                  if (sln_var.has_edge[Min(outer_subgraph3_ptr^.first_point,outer_subgraph3_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph3_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph3_ptr^.last_point ]]]);
                      ClippedLine2
                      (
                        Trunc((pts_ptr+outer_subgraph3_ptr^.first_point)^.x)+obj_arr_ptr1^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph3_ptr^.first_point)^.y)+obj_arr_ptr1^.world_axis_shift.y,
                        Trunc((pts_ptr+outer_subgraph3_ptr^.last_point )^.x)+obj_arr_ptr2^.world_axis_shift.x,
                        Trunc((pts_ptr+outer_subgraph3_ptr^.last_point )^.y)+obj_arr_ptr2^.world_axis_shift.y,
                        rct
                      );
                      LineR
                      (
                        ln_pos.x0,
                        ln_pos.y0,
                        ln_pos.x1,
                        ln_pos.y1,
                        bmp_dst_ptr,
                        ln_arr_width,
                        color_info,
                        16
                      );
                    end;
                  Inc(outer_subgraph3_ptr);
                end;
            end; {$endregion}
          Exit;
        end; {$endregion}
      (csAdvancedClip  ): {Advanced Clip--(Turbo )} {$region -fold}
        begin
          {TODO}
          {n:=CheckDensity1(outer_subgraph_f_ln_var.f_ln_arr0,
                            outer_subgraph_f_ln_var.f_ln_arr2,
                            rect_clp.Width,
                            rect_clp.Height);}
        end; {$endregion}
    end; {$endregion}

  lbl_flood_fill_only:

  {Fill Subgraph Lines-------------} {$region -fold}
  outer_subgraph_img.FillBuffer(rct_clp); {$endregion}

end; {$endregion}
procedure TSelIts.InnerSubgraphCalc0(x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct_clp  :TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                    : PPtPosF;
  pts_f3,pts_l3              : TPtPosF;
  inner_subgraph_ptr         : PEdge;
  out_or_inn_subgraph_pts_ptr: PByte;
  i                          : integer;
begin

  if (inner_subgraph__eds_cnt=0) then
    Exit;

  if fill_bmp_only then
    Exit;

  {Drawing Of Inner Subgraph Lines} {$region -fold}
  pts_ptr                    :=Unaligned(@pts                    [0]);
  inner_subgraph_ptr         :=Unaligned(@inner_subgraph_        [0]);
  out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
  for i:=0 to inner_subgraph__eds_cnt-1 do
    begin
      pts_f3:=(pts_ptr+inner_subgraph_ptr^.first_point)^;
      pts_l3:=(pts_ptr+inner_subgraph_ptr^.last_point )^;
      if ((out_or_inn_subgraph_pts_ptr+inner_subgraph_ptr^.first_point)^=2) then
        if (not is_point_pos_calc[inner_subgraph_ptr^.first_point]) then
          begin
            pts_f3.x+=pvt_var.pos_dif.x;
            pts_f3.y+=pvt_var.pos_dif.y;
            is_point_pos_calc[inner_subgraph_ptr^.first_point]:=True;
          end;
      if ((out_or_inn_subgraph_pts_ptr+inner_subgraph_ptr^.last_point )^=2) then
        if (not is_point_pos_calc[inner_subgraph_ptr^.last_point]) then
          begin
            pts_l3.x+=pvt_var.pos_dif.x;
            pts_l3.y+=pvt_var.pos_dif.y;
            is_point_pos_calc[inner_subgraph_ptr^.last_point]:=True;
          end;
      (pts_ptr+inner_subgraph_ptr^.first_point)^:=pts_f3;
      (pts_ptr+inner_subgraph_ptr^.last_point )^:=pts_l3;
      Inc(inner_subgraph_ptr);
    end; {$endregion}

end; {$endregion}
procedure TSelIts.InnerSubgraphCalc1(x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct_clp  :TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                    : PPtPosF;
  pts_f3,pts_l3              : TPtPosF;
  inner_subgraph_ptr         : PEdge;
  out_or_inn_subgraph_pts_ptr: PByte;
  i                          : integer;
begin

  if (inner_subgraph__eds_cnt=0) then
    Exit;

  if fill_bmp_only then
    Exit;

  if (pvt_var.scl_dir=sdNone) then
    Exit;

  {Drawing Of Inner Subgraph Lines} {$region -fold}
  pts_ptr                    :=Unaligned(@pts                    [0]);
  inner_subgraph_ptr         :=Unaligned(@inner_subgraph_        [0]);
  out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
  for i:=0 to inner_subgraph__eds_cnt-1 do
    begin
      pts_f3:=(pts_ptr+inner_subgraph_ptr^.first_point)^;
      pts_l3:=(pts_ptr+inner_subgraph_ptr^.last_point )^;
      if ((out_or_inn_subgraph_pts_ptr+inner_subgraph_ptr^.first_point)^=2) then
        if (not is_point_pos_calc[inner_subgraph_ptr^.first_point]) then
          begin
            pts_f3.x*=pvt_var.pvt_scl.x;
            pts_f3.x+=pvt_var.scl_dif.x;
            pts_f3.y*=pvt_var.pvt_scl.y;
            pts_f3.y+=pvt_var.scl_dif.y;
            is_point_pos_calc[inner_subgraph_ptr^.first_point]:=True;
          end;
      if ((out_or_inn_subgraph_pts_ptr+inner_subgraph_ptr^.last_point )^=2) then
        if (not is_point_pos_calc[inner_subgraph_ptr^.last_point]) then
          begin
            pts_l3.x*=pvt_var.pvt_scl.x;
            pts_l3.x+=pvt_var.scl_dif.x;
            pts_l3.y*=pvt_var.pvt_scl.y;
            pts_l3.y+=pvt_var.scl_dif.y;
            is_point_pos_calc[inner_subgraph_ptr^.last_point]:=True;
          end;
      (pts_ptr+inner_subgraph_ptr^.first_point)^:=pts_f3;
      (pts_ptr+inner_subgraph_ptr^.last_point )^:=pts_l3;
      Inc(inner_subgraph_ptr);
    end; {$endregion}

end; {$endregion}
procedure TSelIts.InnerSubgraphCalc2(x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct_clp  :TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                    : PPtPosF;
  pts_f3,pts_l3              : TPtPosF;
  inner_subgraph_ptr         : PEdge;
  out_or_inn_subgraph_pts_ptr: PByte;
  i                          : integer;
  n1,n2                      : double;
begin
  {
  if (inner_subgraph__eds_cnt=0) then
    Exit;

  if fill_bmp_only then
    Exit;

  {Drawing Of Inner Subgraph Lines} {$region -fold}
  pts_ptr                    :=Unaligned(@pts                    [0]);
  inner_subgraph_ptr         :=Unaligned(@inner_subgraph_        [0]);
  out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
  for i:=0 to inner_subgraph__eds_cnt-1 do
    begin
      pts_f3:=(pts_ptr+inner_subgraph_ptr^.first_point)^;
      pts_l3:=(pts_ptr+inner_subgraph_ptr^.last_point )^;
      if ((out_or_inn_subgraph_pts_ptr+inner_subgraph_ptr^.first_point)^=2) then
        if (not is_point_pos_calc[inner_subgraph_ptr^.first_point]) then
          begin
            pts_f3.x+=n1;
            pts_f3.y+=n2;
            is_point_pos_calc[inner_subgraph_ptr^.first_point]:=True;
          end;
      if ((out_or_inn_subgraph_pts_ptr+inner_subgraph_ptr^.last_point )^=2) then
        if (not is_point_pos_calc[inner_subgraph_ptr^.last_point]) then
          begin
            pts_l3.x+=n1;
            pts_l3.y+=n2;
            is_point_pos_calc[inner_subgraph_ptr^.last_point]:=True;
          end;
      (pts_ptr+inner_subgraph_ptr^.first_point)^:=pts_f3;
      (pts_ptr+inner_subgraph_ptr^.last_point )^:=pts_l3;
      Inc(inner_subgraph_ptr);
    end; {$endregion}
  }
end; {$endregion}
procedure TSelIts.InnerSubgraphDraw (x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct_clp  :TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr1               : PObjInfo;
  obj_arr_ptr2               : PObjInfo;
  rct                        : TPtRect;
  pts_ptr                    : PPtPosF;
  pts_f3,pts_l3              : TPtPosF;
  inner_subgraph_ptr         : PEdge;
  out_or_inn_subgraph_pts_ptr: PByte;
  i,m1,m2,m3,m4              : integer;
label
  lbl_flood_fill_only;
begin

  if (inner_subgraph__eds_cnt=0) then
    Exit;

  if fill_bmp_only then
    goto lbl_flood_fill_only;

  {Set Drawing Bounds(Inner Window)} {$region -fold}
  with rct_clp do
    begin
      m1:=left  +{inner_subgraph_img.}grid_pt_rad;
      m2:=top   +{inner_subgraph_img.}grid_pt_rad;
      m3:=right -{inner_subgraph_img.}grid_pt_rad-1;
      m4:=bottom-{inner_subgraph_img.}grid_pt_rad-1;
    end;
  rct:=PtRct(m1,m2,m3,m4); {$endregion}

  {Clear Arrays--------------------} {$region -fold}
  with inner_subgraph_img,local_prop do
    begin
      ArrClear(ln_arr0,rct_clp,ln_arr_width);
      ArrClear(ln_arr2,rct_clp);
    end; {$endregion}

  {Drawing Of Inner Subgraph Lines-} {$region -fold}
  with inner_subgraph_img do
    case local_prop.clp_stl of
      (csClippedEdges1 ): {Clipped Edges 1(Slow  )} {$region -fold}
        if (inner_subgraph__eds_cnt>0) then
          begin
            pts_ptr                    :=Unaligned(@pts                    [0]);
            inner_subgraph_ptr         :=Unaligned(@inner_subgraph_        [0]);
            out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
            for i:=0 to inner_subgraph__eds_cnt-1 do
              begin
                if (sln_var.has_edge[Min(inner_subgraph_ptr^.first_point,inner_subgraph_ptr^.last_point)]=0) then
                  begin
                    pts_f3      :=(pts_ptr+inner_subgraph_ptr^.first_point)^;
                    pts_l3      :=(pts_ptr+inner_subgraph_ptr^.last_point )^;
                    obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[inner_subgraph_ptr^.first_point]]]);
                    obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[inner_subgraph_ptr^.last_point ]]]);
                    ClippedLine1
                    (
                      Trunc(pts_f3.x)+obj_arr_ptr1^.world_axis_shift.x,
                      Trunc(pts_f3.y)+obj_arr_ptr1^.world_axis_shift.y,
                      Trunc(pts_l3.x)+obj_arr_ptr2^.world_axis_shift.x,
                      Trunc(pts_l3.y)+obj_arr_ptr2^.world_axis_shift.y,
                      rct,
                      Unaligned(@LineSME),
                      Nil,
                      Nil
                    );
                  end;
                Inc(inner_subgraph_ptr);
              end;
          end; {$endregion}
      (csClippedEdges2 ): {Clipped Edges 2(Slow  )} {$region -fold}
        if (inner_subgraph__eds_cnt>0) then
          begin
            pts_ptr                    :=Unaligned(@pts                    [0]);
            inner_subgraph_ptr         :=Unaligned(@inner_subgraph_        [0]);
            out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
            for i:=0 to inner_subgraph__eds_cnt-1 do
              begin
                if (sln_var.has_edge[Min(inner_subgraph_ptr^.first_point,inner_subgraph_ptr^.last_point)]=0) then
                  begin
                    pts_f3      :=(pts_ptr+inner_subgraph_ptr^.first_point)^;
                    pts_l3      :=(pts_ptr+inner_subgraph_ptr^.last_point )^;
                    obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[inner_subgraph_ptr^.first_point]]]);
                    obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[inner_subgraph_ptr^.last_point ]]]);
                    ClippedLine2
                    (
                      Trunc(pts_f3.x)+obj_arr_ptr1^.world_axis_shift.x,
                      Trunc(pts_f3.y)+obj_arr_ptr1^.world_axis_shift.y,
                      Trunc(pts_l3.x)+obj_arr_ptr2^.world_axis_shift.x,
                      Trunc(pts_l3.y)+obj_arr_ptr2^.world_axis_shift.y,
                      rct,
                      Unaligned(@LineSME),
                      Nil,
                      Nil
                    );
                  end;
                Inc(inner_subgraph_ptr);
              end;
          end; {$endregion}
      (csRemoveEdges   ): {Remove Edges---(Fast  )} {$region -fold}
        if (inner_subgraph__eds_cnt>0) then
          begin
            pts_ptr                    :=Unaligned(@pts                    [0]);
            inner_subgraph_ptr         :=Unaligned(@inner_subgraph_        [0]);
            out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
            for i:=0 to inner_subgraph__eds_cnt-1 do
              begin
                pts_f3      :=(pts_ptr+inner_subgraph_ptr^.first_point)^;
                pts_l3      :=(pts_ptr+inner_subgraph_ptr^.last_point )^;
                obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[inner_subgraph_ptr^.first_point]]]);
                obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[inner_subgraph_ptr^.last_point ]]]);
                if (
                   (pts_f3.x+obj_arr_ptr1^.world_axis_shift.x>m1) and
                   (pts_f3.x+obj_arr_ptr1^.world_axis_shift.x<m3) and
                   (pts_f3.y+obj_arr_ptr1^.world_axis_shift.y>m2) and
                   (pts_f3.y+obj_arr_ptr1^.world_axis_shift.y<m4)
                   )
                  then
                    if (
                       (pts_l3.x+obj_arr_ptr2^.world_axis_shift.x>m1) and
                       (pts_l3.x+obj_arr_ptr2^.world_axis_shift.x<m3) and
                       (pts_l3.y+obj_arr_ptr2^.world_axis_shift.y>m2) and
                       (pts_l3.y+obj_arr_ptr2^.world_axis_shift.y<m4)
                       )
                      then
                        if (sln_var.has_edge[Min(inner_subgraph_ptr^.first_point,inner_subgraph_ptr^.last_point)]=0) then
                          LineSMN
                          (
                            Trunc(pts_f3.x)+obj_arr_ptr1^.world_axis_shift.x,
                            Trunc(pts_f3.y)+obj_arr_ptr1^.world_axis_shift.y,
                            Trunc(pts_l3.x)+obj_arr_ptr2^.world_axis_shift.x,
                            Trunc(pts_l3.y)+obj_arr_ptr2^.world_axis_shift.y
                          );
                Inc(inner_subgraph_ptr);
              end;
          end; {$endregion}
      (csResilientEdges): {Resilient Edges(Unreal)} {$region -fold}
        if (inner_subgraph__eds_cnt>0) then
          begin
            pts_ptr                    :=Unaligned(@pts                    [0]);
            inner_subgraph_ptr         :=Unaligned(@inner_subgraph_        [0]);
            out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
            for i:=0 to inner_subgraph__eds_cnt-1 do
              begin
                pts_f3      :=(pts_ptr+inner_subgraph_ptr^.first_point)^;
                pts_l3      :=(pts_ptr+inner_subgraph_ptr^.last_point )^;
                obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[inner_subgraph_ptr^.first_point]]]);
                obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[inner_subgraph_ptr^.last_point ]]]);
                ClippedLine2
                (
                  Trunc(pts_f3.x)+obj_arr_ptr1^.world_axis_shift.x,
                  Trunc(pts_f3.y)+obj_arr_ptr1^.world_axis_shift.y,
                  Trunc(pts_l3.x)+obj_arr_ptr2^.world_axis_shift.x,
                  Trunc(pts_l3.y)+obj_arr_ptr2^.world_axis_shift.y,
                  rct
                );
                if not((not IsPtInRct(PtPos(ln_pos.x0,ln_pos.y0),rct))  and
                       (not IsPtInRct(PtPos(ln_pos.x1,ln_pos.y1),rct))) then
                  if (sln_var.has_edge[Min(inner_subgraph_ptr^.first_point,inner_subgraph_ptr^.last_point)]=0) then
                    LineR
                    (
                      ln_pos.x0,
                      ln_pos.y0,
                      ln_pos.x1,
                      ln_pos.y1,
                      bmp_dst_ptr,
                      ln_arr_width,
                      color_info,
                      16
                    );
                Inc(inner_subgraph_ptr);
              end;
          end; {$endregion}
      (csAdvancedClip  ): {Advanced Clip--(Turbo )} {$region -fold}
        begin
          {n:=CheckDensity1(outer_subgraph_f_ln_var.f_ln_arr0,
                            outer_subgraph_f_ln_var.f_ln_arr2,
                            rect_clp.Width,
                            rect_clp.Height);}
        end; {$endregion}
    end; {$endregion}

  lbl_flood_fill_only:

  {Fill Subgraph Lines-------------} {$region -fold}
  inner_subgraph_img.FillBuffer(rct_clp); {$endregion}

end; {$endregion}
procedure TSelIts.SinglePtGraphCalc0(x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct_clp  :TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr            : PPtPosF;
  sl_pt_subgraph__ptr: PSlPt;
  i                  : integer;
begin

  if (sl_pt_subgraph__eds_cnt=0) then
    Exit;

  if fill_bmp_only then
    Exit;

  {Drawing Of Inner Subgraph Lines} {$region -fold}
  pts_ptr            :=Unaligned(@pts            [0]);
  sl_pt_subgraph__ptr:=Unaligned(@sl_pt_subgraph_[0]);
  for i:=0 to sl_pt_subgraph__eds_cnt-1 do
    begin
      (pts_ptr+sl_pt_subgraph__ptr^.point)^.x+=pvt_var.pos_dif.x;
      (pts_ptr+sl_pt_subgraph__ptr^.point)^.y+=pvt_var.pos_dif.y;
      Inc(sl_pt_subgraph__ptr);
    end; {$endregion}

end; {$endregion}
procedure TSelIts.SinglePtGraphCalc1(x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct_clp  :TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr            : PPtPosF;
  sl_pt_subgraph__ptr: PSlPt;
  i                  : integer;
begin

  if (sl_pt_subgraph__eds_cnt=0) then
    Exit;

  if fill_bmp_only then
    Exit;

  if (pvt_var.scl_dir=sdNone) then
    Exit;

  {Drawing Of Inner Subgraph Lines} {$region -fold}
  pts_ptr            :=Unaligned(@pts            [0]);
  sl_pt_subgraph__ptr:=Unaligned(@sl_pt_subgraph_[0]);
  for i:=0 to sl_pt_subgraph__eds_cnt-1 do
    begin
      (pts_ptr+sl_pt_subgraph__ptr^.point)^.x*=pvt_var.pvt_scl.x;
      (pts_ptr+sl_pt_subgraph__ptr^.point)^.x+=pvt_var.scl_dif.x;
      (pts_ptr+sl_pt_subgraph__ptr^.point)^.y*=pvt_var.pvt_scl.y;
      (pts_ptr+sl_pt_subgraph__ptr^.point)^.y+=pvt_var.scl_dif.y;
      Inc(sl_pt_subgraph__ptr);
    end; {$endregion}

end; {$endregion}
procedure TSelIts.SinglePtGraphCalc2(x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct_clp  :TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr            : PPtPosF;
  sl_pt_subgraph__ptr: PSlPt;
  i                  : integer;
begin
end; {$endregion}
procedure TSelIts.SelectdPointsCalc (x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct_clp  :TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TSelIts.SelectdPointsDraw (x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct_clp  :TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TSelIts.SelectdPointsBnds (x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct_clp  :TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  with sel_bounds_prop do
    begin
      pts_rct_inn_width :=Trunc(sel_pts_rct.width );
      pts_rct_inn_height:=Trunc(sel_pts_rct.height);
      SetRctWidth (sel_bounds_prop);
      SetRctHeight(sel_bounds_prop);
      SetRctValues(sel_bounds_prop);
      Fast_Primitives.Rectangle
      (
        Trunc(sel_pts_rct.left+pvt_var.pos_dif.x)+Trunc(sel_pts_rct.width )>>1-pts_rct_width__odd,
        Trunc(sel_pts_rct.top +pvt_var.pos_dif.y)+Trunc(sel_pts_rct.height)>>1-pts_rct_height_odd,
        bmp_dst_ptr,
        sel_pts_big_img.bmp_dst_width,
        sel_pts_big_img.bmp_dst_height,
        rct_clp,
        sel_bounds_prop
      );
    end;

end; {$endregion}
procedure TSelIts.WholeSubgraphDraw0(x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct1,rct2:TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Drawing of Outer Subgraph--------} {$region fold}
  OuterSubgraphCalc0(x,y,pvt,pts,bmp_dst_ptr,rct1);
  if outer_subgraph_img.local_prop.eds_show then
    OuterSubgraphDraw (x,y,pvt,pts,bmp_dst_ptr,rct1); {$endregion}

  {Drawing of Inner Subgraph--------} {$region fold}
  InnerSubgraphCalc0(x,y,pvt,pts,bmp_dst_ptr,rct2);
  if inner_subgraph_img.local_prop.eds_show then
    InnerSubgraphDraw (x,y,pvt,pts,bmp_dst_ptr,rct2); {$endregion}

  {Drawing of Single Point Graph----} {$region fold}
  SinglePtGraphCalc0(x,y,pvt,pts,bmp_dst_ptr,rct2); {$endregion}

  {Drawing of Selected Points-------} {$region fold}
  if sel_pts_big_img.local_prop.eds_show then
    begin
      SelectdPointsCalc(x,y,pvt,pts,bmp_dst_ptr,rct1);
      SelectdPointsDraw(x,y,pvt,pts,bmp_dst_ptr,rct1);
    end; {$endregion}

  {Drawing of Selected Points Bounds} {$region fold}
  if sel_bounds_prop.rct_eds_show then
    SelectdPointsBnds(x,y,pvt,pts,bmp_dst_ptr,rct1);
  SelPtsIndsToFalse2; {$endregion}

end; {$endregion}
procedure TSelIts.WholeSubgraphDraw1(x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct1,rct2:TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Drawing of Outer Subgraph--------} {$region fold}
  OuterSubgraphCalc1(x,y,pvt,pts,bmp_dst_ptr,rct1);
  if outer_subgraph_img.local_prop.eds_show then
    OuterSubgraphDraw (x,y,pvt,pts,bmp_dst_ptr,rct1); {$endregion}

  {Drawing of Inner Subgraph--------} {$region fold}
  InnerSubgraphCalc1(x,y,pvt,pts,bmp_dst_ptr,rct1);
  if inner_subgraph_img.local_prop.eds_show then
    InnerSubgraphDraw (x,y,pvt,pts,bmp_dst_ptr,rct1); {$endregion}

  {Drawing of Single Point Graph----} {$region fold}
  SinglePtGraphCalc1(x,y,pvt,pts,bmp_dst_ptr,rct2); {$endregion}

  {Drawing of Selected Points-------} {$region fold}
  if sel_pts_big_img.local_prop.eds_show then
    begin
      SelectdPointsCalc(x,y,pvt,pts,bmp_dst_ptr,rct1);
      SelectdPointsDraw(x,y,pvt,pts,bmp_dst_ptr,rct1);
    end; {$endregion}

  {Drawing of Selected Points Bounds} {$region fold}
  if sel_bounds_prop.rct_eds_show then
    SelectdPointsBnds(x,y,pvt,pts,bmp_dst_ptr,rct1);
  SelPtsIndsToFalse2; {$endregion}

end; {$endregion}
procedure TSelIts.WholeSubgraphDraw2(x,y:integer; constref pvt:TPtPosF; var pts:TPtPosFArr; constref bmp_dst_ptr:PInteger; constref rct1,rct2:TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Drawing of Outer Subgraph--------} {$region fold}
  OuterSubgraphCalc2(x,y,pvt,pts,bmp_dst_ptr,rct1);
  if outer_subgraph_img.local_prop.eds_show then
    OuterSubgraphDraw (x,y,pvt,pts,bmp_dst_ptr,rct1); {$endregion}

  {Drawing of Inner Subgraph--------} {$region fold}
  InnerSubgraphCalc2(x,y,pvt,pts,bmp_dst_ptr,rct1);
  if inner_subgraph_img.local_prop.eds_show then
    InnerSubgraphDraw (x,y,pvt,pts,bmp_dst_ptr,rct1); {$endregion}

  {Drawing of Single Point Graph----} {$region fold}
  SinglePtGraphCalc2(x,y,pvt,pts,bmp_dst_ptr,rct2); {$endregion}

  {Drawing of Selected Points-------} {$region fold}
  if sel_pts_big_img.local_prop.eds_show then
    begin
      SelectdPointsCalc(x,y,pvt,pts,bmp_dst_ptr,rct1);
      SelectdPointsDraw(x,y,pvt,pts,bmp_dst_ptr,rct1);
    end; {$endregion}

  {Drawing of Selected Points Bounds} {$region fold}
  if sel_bounds_prop.rct_eds_show then
    SelectdPointsBnds(x,y,pvt,pts,bmp_dst_ptr,rct1);
  SelPtsIndsToFalse2; {$endregion}

end; {$endregion}
procedure TSelIts.SelPvtAndSplineEdsToBmp;                                                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TSelIts.SelPtsIndsToBmp(var pts:TPtPosFArr);                                                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_Select_ItemsClick                            (sender:TObject); {$region -fold}
begin
  DrawingPanelsSetVisibility1(down_select_items_ptr,P_Select_Items,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_select_items_ptr^) then
    Exit;
end; {$endregion}
{Outer Subgraph}
procedure TF_MainForm.P_Select_Items_Outer_Subgraph_PropMouseEnter    (sender:TObject); {$region -fold}
begin
  P_Select_Items_Outer_Subgraph_Prop.Color:=HighLight(P_Select_Items_Outer_Subgraph_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Outer_Subgraph_PropMouseLeave    (sender:TObject); {$region -fold}
begin
  P_Select_Items_Outer_Subgraph_Prop.Color:=Darken(P_Select_Items_Outer_Subgraph_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.SB_Select_Items_Outer_Subgraph_ShowClick        (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Select_Items_Outer_Subgraph_Show,sel_var.outer_subgraph_img.local_prop.eds_show);
  with sel_var do
    begin
      //fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      //fill_bmp_only:=False;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Outer_Subgraph_Line_StyleSelect (sender:TObject); {$region -fold}
begin
  with sel_var,outer_subgraph_img,local_prop do
    begin
      with args do
        begin
          alpha:=016;
          pow  :=016;
          d    :=016;
        end;
      case CB_Select_Items_Outer_Subgraph_Line_Style.ItemIndex of
        0:
          begin
            eds_bld_stl:=dsMonochrome;
            args.alpha :=016;
          end;
        1: eds_bld_stl :=dsAdditive;
        2:
          begin
            eds_bld_stl:=dsAlphaBlend;
            args.alpha :=127{64};
          end;
        3: eds_bld_stl :=dsInverse;
        4:
          begin
            eds_bld_stl:=dsHighlight;
            args.pow   :=064;
          end;
        5:
          begin
            eds_bld_stl:=dsDarken;
            args.pow   :=064;
          end;
        6:
          begin
            eds_bld_stl:=dsGrayscaleR;
            args.d     :=064;
          end;
        7:
          begin
            eds_bld_stl:=dsGrayscaleG;
            args.d     :=064;
          end;
        8:
          begin
            eds_bld_stl:=dsGrayscaleB;
            args.d     :=064;
          end;
        9: eds_bld_stl :=dsMononoise;
      end;
      pp_dec_2_proc_ind:=GetEnumVal(eds_bld_stl);
      if (eds_bld_stl=dsMonochrome) then
        pp_dec_2_proc_ind:=2;
      fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      fill_bmp_only:=False;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Outer_Subgraph_Clip_StyleSelect (sender:TObject); {$region -fold}
begin
  with sel_var,outer_subgraph_img,local_prop do
    begin
      clp_stl:=TClipStyle(CB_Select_Items_Outer_Subgraph_Clip_Style.ItemIndex);
      FillSelBmpAndSelPtsBRectDraw;
    end;
end; {$endregion}
procedure TF_MainForm.SB_Select_Items_Outer_Subgraph_ColorClick       (sender:TObject); {$region -fold}
begin
  CD_Select_Color.Color:=SB_Select_Items_Outer_Subgraph_Color.Color;
  CD_Select_Color.Execute;
  with sel_var do
    begin
      IsObjColorAMaskColor;
      with outer_subgraph_img,local_prop do
        begin
          eds_col:=CD_Select_Color.Color;
          if (clp_stl=csResilientEdges) then
            SetColorInfo(eds_col,color_info);
          fill_bmp_only:=True;
          FillSelBmpAndSelPtsBRectDraw;
          fill_bmp_only:=False;
        end;
    end;
  SB_Select_Items_Outer_Subgraph_Color.Color:=CD_Select_Color.Color;
  SB_Select_Items_Outer_Subgraph_Color.Down :=False;
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Outer_Subgraph_Show_BoundsChange(sender:TObject); {$region -fold}
begin
end; {$endregion}
{Inner Subgraph}
procedure TF_MainForm.P_Select_Items_Inner_Subgraph_PropMouseEnter    (sender:TObject); {$region -fold}
begin
  P_Select_Items_Inner_Subgraph_Prop.Color:=HighLight(P_Select_Items_Inner_Subgraph_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Inner_Subgraph_PropMouseLeave    (sender:TObject); {$region -fold}
begin
  P_Select_Items_Inner_Subgraph_Prop.Color:=Darken(P_Select_Items_Inner_Subgraph_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.SB_Select_Items_Inner_Subgraph_ShowClick        (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Select_Items_Inner_Subgraph_Show,sel_var.inner_subgraph_img.local_prop.eds_show);
  with sel_var do
    begin
      //fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      //fill_bmp_only:=False;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Inner_Subgraph_Line_StyleSelect (sender:TObject); {$region -fold}
begin
  with sel_var,inner_subgraph_img,local_prop do
    begin
      with args do
        begin
          alpha:=016;
          pow  :=016;
          d    :=016;
        end;
      case CB_Select_Items_Inner_Subgraph_Line_Style.ItemIndex of
        0:
          begin
            eds_bld_stl:=dsMonochrome;
            args.alpha :=016;
          end;
        1: eds_bld_stl :=dsAdditive;
        2:
          begin
            eds_bld_stl:=dsAlphaBlend;
            args.alpha :=127{64};
          end;
        3: eds_bld_stl :=dsInverse;
        4:
          begin
            eds_bld_stl:=dsHighlight;
            args.pow   :=064;
          end;
        5:
          begin
            eds_bld_stl:=dsDarken;
            args.pow   :=064;
          end;
        6:
          begin
            eds_bld_stl:=dsGrayscaleR;
            args.d     :=064;
          end;
        7:
          begin
            eds_bld_stl:=dsGrayscaleG;
            args.d     :=064;
          end;
        8:
          begin
            eds_bld_stl:=dsGrayscaleB;
            args.d     :=064;
          end;
        9: eds_bld_stl :=dsMononoise;
      end;
      pp_dec_2_proc_ind:=GetEnumVal(eds_bld_stl);
      if (eds_bld_stl=dsMonochrome) then
        pp_dec_2_proc_ind:=2;
      fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      fill_bmp_only:=False;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Inner_Subgraph_Clip_StyleSelect (sender:TObject); {$region -fold}
begin
  with sel_var,inner_subgraph_img,local_prop do
    begin
      clp_stl:=TClipStyle(CB_Select_Items_Inner_Subgraph_Clip_Style.ItemIndex);
      FillSelBmpAndSelPtsBRectDraw;
    end;
end; {$endregion}
procedure TF_MainForm.SB_Select_Items_Inner_Subgraph_ColorClick       (sender:TObject); {$region -fold}
begin
  CD_Select_Color.Color:=SB_Select_Items_Inner_Subgraph_Color.Color;
  CD_Select_Color.Execute;
  with sel_var do
    begin
      IsObjColorAMaskColor;
      with inner_subgraph_img,local_prop do
        begin
          eds_col:=CD_Select_Color.Color;
          if (clp_stl=csResilientEdges) then
            SetColorInfo(eds_col,color_info);
          fill_bmp_only:=True;
          FillSelBmpAndSelPtsBRectDraw;
          fill_bmp_only:=False;
        end;
    end;
  SB_Select_Items_Inner_Subgraph_Color.Color:=CD_Select_Color.Color;
  SB_Select_Items_Inner_Subgraph_Color.Down :=False;
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Inner_Subgraph_Show_BoundsChange(sender:TObject); {$region -fold}
begin
  with sel_var do
    begin
      sel_bounds_prop.rct_eds_show:=not sel_bounds_prop.rct_eds_show;
      fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      fill_bmp_only:=False;
    end;
end; {$endregion}
{Selection-----}
procedure TF_MainForm.P_Select_Items_Selection_PropMouseEnter         (sender:TObject); {$region -fold}
begin
  P_Select_Items_Selection_Prop.Color:=HighLight(P_Select_Items_Selection_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Selection_PropMouseLeave         (sender:TObject); {$region -fold}
begin
  P_Select_Items_Selection_Prop.Color:=Darken(P_Select_Items_Selection_Prop.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Selection_Background_StyleSelect(sender:TObject); {$region -fold}
begin
  sel_var.srf_var_ptr^.bg_style:=TBackgroundStyle(CB_Select_Items_Selection_Background_Style.ItemIndex);
  bkg_pp_calc                  :=(CB_Select_Items_Selection_Background_Style.ItemIndex in [0..2]) xor (CB_Select_Items_Selection_Background_Style.ItemIndex=3);
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Selection_Drawing_ModeSelect    (sender:TObject); {$region -fold}
begin
  sel_var.ChangeSelectionMode(CB_Select_Items_Selection_Drawing_Mode.ItemIndex);
end; {$endregion}
procedure TF_MainForm.SB_Select_Items_Selection_ColorClick            (sender:TObject); {$region -fold}
begin
  CD_Select_Color.Color:=SB_Select_Items_Selection_Color.Color;
  CD_Select_Color.Execute;
  with sel_var,sel_pts_big_img,local_prop,fst_img,fast_image_proc_var do
    begin
      eds_col             :=CD_Select_Color.Color;
      fast_image_data_ptr0:=@fast_image_data;
      SetPPInfo(eds_col);
    end;
  SB_Select_Items_Selection_Color.Color:=CD_Select_Color.Color;
  SB_Select_Items_Selection_Color.Down :=False;
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Selection_HighlightChange       (sender:TObject); {$region -fold}
begin

end; {$endregion}

procedure TF_MainForm.SE_Select_Points_Bucket_SizeChange              (sender:TObject); {$region -fold}
begin
  if show_spline then
    if (sel_var.sel_pts_cnt>0) then
      begin
        bucket_size_change:=True;
        BucketSizeChange(SE_Select_Points_Bucket_Size.Value);
        bucket_size_change:=False;
      end;
end; {$endregion}
procedure TF_MainForm.SB_Selected_Points_Select_ColorClick            (sender:TObject); {$region -fold}
begin
  CD_Select_Color.Execute;
  sel_var.sel_pts_big_img.local_prop.eds_col:=CD_Select_Color.Color;
  IsObjColorAMaskColor;
  {Fill Selected Bmp}
  if exp0 then
    begin
        with sel_var do
          begin
            {Fill Selected Bmp(Inner Subgraph)}
            {TODO}
            {Fill Selected Bmp(Selected Points)}
            {TODO}
        end;
      InvalidateInnerWindow;
    end;
  SB_Selected_Points_Select_Color.Down:=False;
end; {$endregion}
procedure TF_MainForm.CB_Select_Points_Show_BoundsChange              (sender:TObject); {$region -fold}
begin
  with sel_var do
    begin
      sel_bounds_prop.rct_eds_show:=CB_Select_Points_Show_Bounds.Checked;
      fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      fill_bmp_only:=False;
    end;
end; {$endregion}
{$endregion}

// (Local Pivot) Локальная ось:
{LI} {$region -fold}
constructor TPivot.Create(w,h:TColor);                                                                                                        {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  srf_var_ptr         :=@srf_var;

  SelPtsCalcProc   [0]:=@SelPtsPosCalc;
  SelPtsCalcProc   [1]:=@SelPtsSclCalc;
  SelPtsCalcProc   [2]:=@SelPtsRotCalc;

  SelPtsRctCalcProc[0]:=@SelPtsRctPosCalc;
  SelPtsRctCalcProc[1]:=@SelPtsRctSclCalc;
  SelPtsRctCalcProc[2]:=@SelPtsRctRotCalc;

  {Miscellaneous Settings-------} {$region -fold}
  snap_mode             :=Default(TSnapMode);
  pvt_draw_sel_eds_off.x:=1.0;
  move_pvt_to_pt_button :=True;
  pvt_scl               :=PtPosF(DEFAULT_SCL_MUL,
                                 DEFAULT_SCL_MUL); {$endregion}

  {Create Pivot Icon------------} {$region -fold}
  LocalAxisCreate; {$endregion}

  {Create Selection Tools Marker} {$region -fold}
  SelectionToolsMarkerCreate; {$endregion}

end; {$endregion}
destructor  TPivot.Destroy;                                                                                                                   {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure TPivot.LocalAxisCreate;                                                                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // Create World Axis Icon:
  SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
  with srf_var_ptr^ do
    sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
    (
      srf_bmp_ptr,
      srf_bmp.width,
      srf_bmp.height,
      inn_wnd_rct,
      max_sprite_w_h_rct,
      Application.Location+LOCAL_AXIS_ICON,
      @F_MainForm.IL_Local_Axis.GetBitmap,
      0
    );
  local_axis_bmp_ind:=Length(sprite_sheet_arr)-1;
  with sprite_sheet_arr[local_axis_bmp_ind],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;

      SetPPInfo(clRed);
      SetGrad  (0,bmp_ftimg_height-1,Random($FFFFFF),Random($FFFFFF));

      col_trans_arr[01]:=132;
      col_trans_arr[02]:=032;
      col_trans_arr[03]:=132;
      col_trans_arr[04]:=132;
      col_trans_arr[05]:=132;
      col_trans_arr[06]:=132;
      col_trans_arr[07]:=132;
      col_trans_arr[08]:=132;
      col_trans_arr[09]:=132;
      col_trans_arr[10]:=0;
      col_trans_arr[11]:=255;
      col_trans_arr[12]:=0;
      col_trans_arr[13]:=255;
      col_trans_arr[14]:=0;
      col_trans_arr[15]:=255;
      col_trans_arr[16]:=0;

      pix_drw_type             :=00{01}; //must be in range of [0..002]
      nt_pix_cfx_type          :=02{00};
      pt_pix_cfx_type          :=02{00};
      fx_cnt                   :=00{01}; //must be in range of [0..255]

      fx_arr[0].rep_cnt        :=01{02}; //must be in range of [0..255]

      fx_arr[0].nt_pix_srf_type:=01    ; //must be in range of [0..001]
      fx_arr[0].nt_pix_cfx_type:=17    ; //must be in range of [0..255]
      fx_arr[0].nt_pix_cng_type:=00    ; //must be in range of [0..001]

      fx_arr[0].pt_pix_srf_type:=01    ; //must be in range of [0..001]
      fx_arr[0].pt_pix_cfx_type:=17    ; //must be in range of [0..255]
      fx_arr[0].pt_pix_cng_type:=00    ; //must be in range of [0..001]
    end;
end; {$endregion}
procedure TPivot.LocalAxisDraw     (constref x,y:integer);                                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sprite_sheet_arr[local_axis_bmp_ind],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      SetRctPos(x-bmp_ftimg_width_origin >>1,
                y-bmp_ftimg_height_origin>>1);
      SdrProc[3];
    end;
end; {$endregion}
procedure TPivot.LocalAxisHighLight(constref x,y:integer);                                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sprite_sheet_arr[local_axis_bmp_ind],fast_image_data do
    begin
      pix_drw_type             :=01; //must be in range of [0..002]
      nt_pix_cfx_type          :=04;
      pt_pix_cfx_type          :=04;
      fx_cnt                   :=01; //must be in range of [0..255]

      fx_arr[0].rep_cnt        :=01; //must be in range of [0..255]

      fx_arr[0].nt_pix_srf_type:=01; //must be in range of [0..001]
      fx_arr[0].nt_pix_cfx_type:=04; //must be in range of [0..255]
      fx_arr[0].nt_pix_cng_type:=00; //must be in range of [0..001]

      fx_arr[0].pt_pix_srf_type:=01; //must be in range of [0..001]
      fx_arr[0].pt_pix_cfx_type:=04; //must be in range of [0..255]
      fx_arr[0].pt_pix_cng_type:=00; //must be in range of [0..001]

      LocalAxisDraw(x,y);

      pix_drw_type             :=00; //must be in range of [0..002]
      nt_pix_cfx_type          :=02;
      pt_pix_cfx_type          :=02;
      fx_cnt                   :=00; //must be in range of [0..255]

      fx_arr[0].rep_cnt        :=00; //must be in range of [0..255]
    end;
end; {$endregion}
procedure TPivot.SelectionToolsMarkerCreate;                                                                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
  sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
  (
    srf_var_ptr^.srf_bmp_ptr,
    srf_var_ptr^.srf_bmp.width,
    srf_var_ptr^.srf_bmp.height,
    srf_var_ptr^.inn_wnd_rct,
    max_sprite_w_h_rct,
    Application.Location+SELECTION_TOOLS_MARKER_ICON,
    @F_MainForm.IL_Select_Points.GetBitmap,
    0
  );
  sel_tls_mrk_ind:=Length(sprite_sheet_arr)-1;
  // Drawing Settings:
  with sprite_sheet_arr[sel_tls_mrk_ind],fast_image_data do
    begin
      col_trans_arr[02]:=64;
      pix_drw_type     :=0; //must be in range of [0..002]
      nt_pix_srf_type  :=1; //must be in range of [0..002]
      nt_pix_cfx_type  :=2; //must be in range of [0..002]
      nt_pix_cng_type  :=1; //must be in range of [0..001]
      pt_pix_srf_type  :=1; //must be in range of [0..002]
      pt_pix_cfx_type  :=2; //must be in range of [0..002]
      pt_pix_cng_type  :=1; //must be in range of [0..001]
      fx_cnt           :=0; //must be in range of [0..255]
    end;
end; {$endregion}
procedure TPivot.SelectionToolsMarkerDraw(constref x,y:integer);                                                                      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sprite_sheet_arr[sel_tls_mrk_ind],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      SetRctPos(x-bmp_ftimg_width_origin >>1,
                y-bmp_ftimg_height_origin>>1);
      SdrProc[3];
    end;
end; {$endregion}
procedure TPivot.SetPivotAxisRect(constref pt_rct:TPtRect; constref margin:TColor=10);                                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pvt_axis_rect:=PtRct(pt_rct.left  +margin,
                       pt_rct.top   +margin,
                       pt_rct.right -margin,
                       pt_rct.bottom-margin);
end; {$endregion}
procedure TPivot.PivotCalc(constref pts:TPtPosFArr; constref sel_pts_inds:TColorArr; constref sel_pts_cnt:TColor);                            {$ifdef Linux}[local];{$endif} {$region -fold}
var
  sel_pts_inds_ptr: PInteger;
  p               : TPtPosF;
  i,j,sel_obj_ind : integer;
  sel_obj_pts_cnt : integer;
begin
  p               :=Default(TPtPosF);
  pvt_pos         :=Default(TPtPosF);
  sel_pts_inds_ptr:=Unaligned(@sel_pts_inds[0]);
  for i:=0 to sel_pts_cnt-1 do
    begin
      p.x+=pts[sel_pts_inds_ptr^].x;
      p.y+=pts[sel_pts_inds_ptr^].y;
      Inc(sel_pts_inds_ptr);
    end;
  j                 :=0;
  weighted_pvt_shift:=Default(TPtPos);
  while (j<sel_pts_cnt) do
    begin
      sel_obj_pts_cnt:=0;
      sel_obj_ind    :=sln_var.sln_obj_ind[sel_pts_inds[j]];
      while (j<sel_pts_cnt) do
        begin
          if (sln_var.sln_obj_ind[sel_pts_inds[j]]=sel_obj_ind) then
            begin
              Inc(j);
              Inc(sel_obj_pts_cnt);
            end
          else
            Break;
        end;
      weighted_pvt_shift.x+=sel_obj_pts_cnt*obj_var.obj_arr[obj_var.curve_inds_obj_arr[sel_obj_ind]].world_axis_shift.x;
      weighted_pvt_shift.y+=sel_obj_pts_cnt*obj_var.obj_arr[obj_var.curve_inds_obj_arr[sel_obj_ind]].world_axis_shift.y;
    end;
  pvt_pos.x :=(p.x+weighted_pvt_shift.x)/sel_pts_cnt;
  pvt_pos.y :=(p.y+weighted_pvt_shift.y)/sel_pts_cnt;
  pvt_origin:=pvt_pos;
end; {$endregion}
procedure TPivot.AlignPivotOnX(var x,y:integer; shift:TShiftState);                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if need_align_pivot_x then
    y:=align_pivot.y;
  if (shift=[ssCtrl]) then
    begin
      need_align_pivot_y:=False;
      if (not need_align_pivot_x) then
        align_pivot.y:=y;
      need_align_pivot_x:=True;
    end
  else
    need_align_pivot_x:=False;
end; {$endregion}
procedure TPivot.AlignPivotOnY(var x,y:integer; shift:TShiftState);                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if need_align_pivot_y then
    x:=align_pivot.x;
  if (shift=[ssShift]) then
    begin
      need_align_pivot_x:=False;
      if (not need_align_pivot_y) then
        align_pivot.x:=x;
      need_align_pivot_y:=True;
    end
  else
    need_align_pivot_y:=False;
end; {$endregion}
procedure TPivot.AlignPivotOnP(var x,y:integer; shift:TShiftState);                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (shift=[ssAlt]) then
    PivotToPoint(x,y,False,srf_var_ptr^,sln_var,sel_var,crc_sel_var);
end; {$endregion}
procedure TPivot.PivotToPoint     (x,y:integer;                  srf_var_:TSurface; sln_var_:TCurve; sel_var_:TSelIts; crc_sel_var_:TCrcSel); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr               : PPtPosF;
  obj_arr_ptr           : PObjInfo;
  is_point_in_circle_ptr: PByteBool;
  v,inf,sup             : double;
  i,j,ind_of_min        : integer;
begin

  inf                   :=0;
  sup                   :=crc_sel_var_.crc_rad_sqr;
  ind_of_min            :=0;
  snap_to_pt            :=False;

  pts_ptr               :=Unaligned(@sln_var_.sln_pts           [0]);
  is_point_in_circle_ptr:=Unaligned(@sel_var_.is_point_in_circle[0]);
  for i:=0 to sln_var_.sln_obj_cnt-1 do
    begin
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]]);
      for j:=0 to sln_var_.sln_obj_pts_cnt[i]-1 do
        begin
          v:=sqr(pts_ptr^.x-x+obj_arr_ptr^.world_axis_shift.x)+
             sqr(pts_ptr^.y-y+obj_arr_ptr^.world_axis_shift.y);
          if (v<=crc_sel_var_.crc_rad_sqr) then
            begin
              if (not is_point_in_circle_ptr^) then
                begin
                  is_point_in_circle_ptr^:=True;
                  if (v<=sup-inf) then
                    begin
                      inf       :=sup-v;
                      ind_of_min:=sln_var_.partial_pts_sum[i]+j;
                    end;
                end;
              if is_point_in_circle_ptr^ then
                 is_point_in_circle_ptr^:=False;
            end;
          Inc(pts_ptr);
          Inc(is_point_in_circle_ptr);
        end;
    end;

  snap_to_pt:=sqr(sln_var_.sln_pts[ind_of_min].x-x+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var_.sln_obj_ind[ind_of_min]]].world_axis_shift.x)+
              sqr(sln_var_.sln_pts[ind_of_min].y-y+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var_.sln_obj_ind[ind_of_min]]].world_axis_shift.y)<=crc_sel_var_.crc_rad_sqr;

  if snap_to_pt then
    begin
      pvt_pos.x:=sln_var_.sln_pts[ind_of_min].x+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var_.sln_obj_ind[ind_of_min]]].world_axis_shift.x;
      pvt_pos.y:=sln_var_.sln_pts[ind_of_min].y+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var_.sln_obj_ind[ind_of_min]]].world_axis_shift.y;
    end
  else
    begin
      pos_dif.x:=x-pvt_pos.x;
      pos_dif.y:=y-pvt_pos.y;
    end;
  pvt_to_pt_draw_pt:=snap_to_pt;

end; {$endregion}
procedure TPivot.PivotToPoint     (x,y:integer; b      :boolean; srf_var_:TSurface; sln_var_:TCurve; sel_var_:TSelIts; crc_sel_var_:TCrcSel); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr               : PPtPosF;
  prev_pvt_pos          : TPtPosF;
  obj_arr_ptr           : PObjInfo;
  is_point_in_circle_ptr: PByteBool;
  is_point_selected_ptr : PByteBool;
  v,inf,sup             : double;
  i,j,ind_of_min        : integer;
begin

  inf                   :=0;
  sup                   :=crc_sel_var_.crc_rad_sqr;
  ind_of_min            :=0;
  snap_to_pt            :=False;

  pts_ptr               :=Unaligned(@sln_var_.sln_pts           [0]);
  is_point_in_circle_ptr:=Unaligned(@sel_var_.is_point_in_circle[0]);
  is_point_selected_ptr :=Unaligned(@sel_var_.is_point_selected [0]);
  for i:=0 to sln_var_.sln_obj_cnt-1 do
    begin
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]]);
      for j:=0 to sln_var_.sln_obj_pts_cnt[i]-1 do
        begin
          v:=sqr(pts_ptr^.x-x+obj_arr_ptr^.world_axis_shift.x)+
             sqr(pts_ptr^.y-y+obj_arr_ptr^.world_axis_shift.y);
          if (v<=crc_sel_var_.crc_rad_sqr) and (not is_point_selected_ptr^) then
            begin
              if (not is_point_in_circle_ptr^) then
                begin
                  is_point_in_circle_ptr^:=True;
                  if (v<=sup-inf) then
                    begin
                      inf       :=sup-v;
                      ind_of_min:=sln_var_.partial_pts_sum[i]+j;
                    end;
                end;
              if is_point_in_circle_ptr^ then
                 is_point_in_circle_ptr^:=False;
            end;
          Inc(pts_ptr);
          Inc(is_point_in_circle_ptr);
          Inc(is_point_selected_ptr);
        end;
    end;

  snap_to_pt:=sqr(sln_var_.sln_pts[ind_of_min].x-x+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var_.sln_obj_ind[ind_of_min]]].world_axis_shift.x)+
              sqr(sln_var_.sln_pts[ind_of_min].y-y+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var_.sln_obj_ind[ind_of_min]]].world_axis_shift.y)<=crc_sel_var_.crc_rad_sqr;

  prev_pvt_pos:=pvt_pos;
  if snap_to_pt then
    begin
      pvt_pos.x:=sln_var_.sln_pts[ind_of_min].x+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var_.sln_obj_ind[ind_of_min]]].world_axis_shift.x;
      pvt_pos.y:=sln_var_.sln_pts[ind_of_min].y+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var_.sln_obj_ind[ind_of_min]]].world_axis_shift.y;
      if (snap_mode.first_time_snap=0) then
        begin
          snap_mode.first_time_snap:=1;
          pos_dif.x                :=pvt_pos.x-prev_pvt_pos.x;
          pos_dif.y                :=pvt_pos.y-prev_pvt_pos.y;
        end
      else
        begin
          snap_mode.first_time_snap:=2;
          pos_dif.x                :=0;
          pos_dif.y                :=0;
        end;
    end
  else
    begin
      snap_mode.first_time_snap:=0;
      pos_dif.x:=x-pvt_pos.x;
      pos_dif.y:=y-pvt_pos.y;
      pvt_pos.x:=x;
      pvt_pos.y:=y;
    end;
  pvt_to_pt_draw_pt:=snap_to_pt;

end; {$endregion}
procedure TPivot.PivotToPoint     (x,y:integer; density:TColor;  srf_var_:TSurface; sln_var_:TCurve; sel_var_:TSelIts; crc_sel_var_:TCrcSel); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt         : TPtPos;
  a,b,b2,c,m : double;
  i,d,pts_ind: integer;
begin

  {
    TLnPos=packed record
      x0,y0,x1,y1: integer;
    end;

    TPtPos=packed record
      x,y: integer;
    end;

    srf_var_ptr       - target drawing surface;
    srf_bmp           - target drawing surface(bitmap);
    srf_bmp_ptr       - pointer to target drawing surface(srf_bmp);
    rct_clp           - target drawing rectangular area;
    crc_rad           - circle radius;
    mos_mot_vec       - mouse motion vector;
    mos_mot_vec       : TLnPos;
    pvt_prev          - previous pivot;
    pvt_prev          : TPtPos;
    pvt               - pivot;
    pvt               : TPtPos;
    pvt_to_pt_draw_pt - checks if pivot needs to be drawn;
  }

  snap_to_pt:=False;
  density   :=Min(density,crc_sel_var_.crc_rad); // density between circles;

  mos_mot_vec.x1:=x;
  mos_mot_vec.y1:=y;

  for i:=1 to Trunc(crc_sel_var_.crc_rad/density) do
    begin
      d:=density*i;
      if IsPtInRct(x,y,PtRct(srf_var_.inn_wnd_rct.left  +d,
                             srf_var_.inn_wnd_rct.top   +d,
                             srf_var_.inn_wnd_rct.right -d,
                             srf_var_.inn_wnd_rct.bottom-d)) then
        begin
          if CircleW(x,y,d,sln_var_.dup_pts_arr,srf_var_.srf_bmp.width,pvt_pos) then // drawing of regular circle(wave)
            begin
              snap_to_pt:=True;
              Break;
            end;
        end
      else
        begin
          if CircleWC(x,y,d,sln_var_.dup_pts_arr,srf_var_.inn_wnd_rct,srf_var_.srf_bmp.width,pvt_pos) then // drawing of clipped circle(wave)
            begin
              snap_to_pt:=True;
              Break;
            end;
        end;
    end;

  pt       :=PtPos(pvt_pos);
  pts_ind  :=sln_var_.dup_pts_arr[pt.x+pt.y*sln_var_.pts_big_img.ln_arr_width].pts_ind;
  pvt_pos.x:=sln_var_.sln_pts[pts_ind].x+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var_.sln_obj_ind[pts_ind]]].world_axis_shift.x;
  pvt_pos.y:=sln_var_.sln_pts[pts_ind].y+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var_.sln_obj_ind[pts_ind]]].world_axis_shift.y;

  if snap_to_pt then
    begin
      //4*(m^2):=2*(b^2+c^2)-a^2;
      m :=  sqrt(sqr(mos_mot_vec.x0-mos_mot_vec.x1)+sqr(mos_mot_vec.y0-mos_mot_vec.y1));
      a :=2*sqrt(sqr(pvt_prev.x    -pvt_pos.x)     +sqr(pvt_prev.y    -pvt_pos.y));
      b :=  sqrt(sqr(mos_mot_vec.x1-pvt_pos.x)     +sqr(mos_mot_vec.y1-pvt_pos.y));
      b2:=  sqrt(sqr(pvt_pos.x     +pvt_prev.x     -    mos_mot_vec.x0-mos_mot_vec.x1)+
                 sqr(pvt_pos.y     +pvt_prev.y     -    mos_mot_vec.y0-mos_mot_vec.y1));
      c :=  sqrt(((4*m*m+a*a)/2)-b*b);
      if (Trunc(b2)=Max(Trunc(b),Trunc(c))) then
        begin
          pvt_pos.x:=pvt_prev.x;
          pvt_pos.y:=pvt_prev.y;
        end;
      pvt_prev.x:=pvt_pos.x;
      pvt_prev.y:=pvt_pos.y;
    end
  else
    begin
      pvt_pos.x:=x;
      pvt_pos.y:=y;
    end;
  pvt_to_pt_draw_pt:=snap_to_pt;

  with sel_var_,crc_sel_var_,crc_sel_rct do
    begin
      FilSelPtsObj(x-crc_rad,y-crc_rad);
      {if IsPtInRct(x,y,PtRct(rct_clp.left  +crc_rad,
                              rct_clp.top   +crc_rad,
                              rct_clp.right -crc_rad,
                              rct_clp.bottom-crc_rad)) then
        Circle (x,y,crc_rad,srf_var_ptr^.srf_bmp_ptr,                         srf_var_ptr^.srf_bmp.width,clBlue)
      else
        CircleC(x,y,crc_rad,srf_var_ptr^.srf_bmp_ptr,srf_var_ptr^.inn_wnd_rct,srf_var_ptr^.srf_bmp.width,clBlue);}
    end;

  mos_mot_vec.x0:=mos_mot_vec.x1;
  mos_mot_vec.y0:=mos_mot_vec.y1;

end; {$endregion}
procedure TPivot.SclSettings      (x,y:integer);                                                                                      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  curr_mouse_pos:=PtPosF(x,y);
  scl_dir       :=GetDir2(prev_mouse_pos,curr_mouse_pos,pvt_pos                );
                  SetMul (prev_mouse_pos,curr_mouse_pos,pvt_pos,pvt_scl,scl_dir);
  prev_mouse_pos:=curr_mouse_pos;
end; {$endregion}
procedure TPivot.SelPtsPosCalc    (x,y:integer);                                                                                      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if snap_mode.snap_event then
    Exit;
  pos_dif.x:=x-{Trunc(}pvt_pos.x{)};
  pos_dif.y:=y-{Trunc(}pvt_pos.y{)};
end; {$endregion}
procedure TPivot.SelPtsSclCalc    (x,y:integer);                                                                                      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if snap_mode.snap_event then
    Exit;
  scl_dif.x:=(pvt_pos.x-(weighted_pvt_shift.x/sel_var.sel_pts_cnt))*(1-pvt_scl.x);
  scl_dif.y:=(pvt_pos.y-(weighted_pvt_shift.y/sel_var.sel_pts_cnt))*(1-pvt_scl.y);
end; {$endregion}
procedure TPivot.SelPtsRotCalc    (x,y:integer);                                                                                      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if snap_mode.snap_event then
    Exit;
  // TODO
end; {$endregion}
procedure TPivot.SelPtsRctPosCalc (x,y:integer; var sel_pts_rect:TPtRectF);                                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if snap_mode.snap_event then
    Exit;
  with sel_pts_rect do
    begin
      Left  +=x-Trunc(pvt_pos.x);
      Top   +=y-Trunc(pvt_pos.y);
      Right +=x-Trunc(pvt_pos.x);
      Bottom+=y-Trunc(pvt_pos.y);
    end;
  pvt_pos:=PtPosF(x,y);
end; {$endregion}
procedure TPivot.SelPtsRctSclCalc (x,y:integer; var sel_pts_rect:TPtRectF);                                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if snap_mode.snap_event then
    Exit;
  pvt_scl:=PtPosF(DEFAULT_SCL_MUL,
                  DEFAULT_SCL_MUL);
  PtsScl(pvt_pos,sel_pts_rect,pvt_scl,scl_dir);
end; {$endregion}
procedure TPivot.SelPtsRctRotCalc (x,y:integer; var sel_pts_rect:TPtRectF);                                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if snap_mode.snap_event then
    Exit;
end; {$endregion}
procedure TPivot.IsPivotOutOfInnerWindow(var custom_rect:TPtRect; constref pvt_:TPtPosF);                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m1,m2,m3,m4: integer;
  x0,y0,x1,y1: integer;
  k,b,d:       integer;
begin

  begin
    pvt_marker_draw  :=False;
    pvt_marker_left  :=False;
    pvt_marker_top   :=False;
    pvt_marker_right :=False;
    pvt_marker_bottom:=False;
  end;

  with srf_var_ptr^ do
    begin
      m1:=custom_rect.Left;
      m2:=custom_rect.Top;
      m3:=custom_rect.Right;
      m4:=custom_rect.Bottom;
    end;

  x0:=Trunc((m1+m3)/2);
  y0:=Trunc((m2+m4)/2);
  x1:=Trunc(pvt_pos.x);
  y1:=Trunc(pvt_pos.y);

  k:=y1-y0;
  b:=y0*x1-y1*x0;
  d:=x1-x0;

  {Сверху-слева}
  if (pvt_pos.x<m1) and
     (pvt_pos.y<m2) then
    begin
      if ((k*m1+b)/d>m2) then
        begin
          pvt_marker_draw:=True;
          pvt_marker_left:=True;
          pvt_marker.x:=m1;
          pvt_marker.y:=(k*m1+b) div d;
        end
      else
        begin
          pvt_marker_draw:=True;
          pvt_marker_top :=True;
          pvt_marker.x:=(d*m2-b) div k;
          pvt_marker.y:=m2;
        end;
      Exit;
    end

  {Сверху}
  else
  if (pvt_pos.x>m1) and
     (pvt_pos.x<m3) and
     (pvt_pos.y<m2) then
    begin
      pvt_marker_draw:=True;
      pvt_marker_top :=True;
      pvt_marker.x:=(d*m2-b) div k;
      pvt_marker.y:=m2;
      Exit;
    end

  {Сверху-справа}
  else
  if (pvt_pos.x>m3) and
     (pvt_pos.y<m2) then
    begin
      if ((k*m3+b)/d>m2) then
        begin
          pvt_marker_draw :=True;
          pvt_marker_right:=True;
          pvt_marker.x:=m3;
          pvt_marker.y:=(k*m3+b) div d;
        end
      else
        begin
          pvt_marker_draw:=True;
          pvt_marker_top :=True;
          pvt_marker.x:=(d*m2-b) div k;
          pvt_marker.y:=m2;
        end;
      Exit;
    end

  {Слева}
  else
  if (pvt_pos.y>m2) and
     (pvt_pos.y<m4) and
     (pvt_pos.x<m1) then
    begin
      pvt_marker_draw:=True;
      pvt_marker_left:=True;
      pvt_marker.x:=m1;
      pvt_marker.y:=(k*m1+b) div d;
      Exit;
    end

  {Справа}
  else
  if (pvt_pos.y>m2) and
     (pvt_pos.y<m4) and
     (pvt_pos.x>m3) then
    begin
      pvt_marker_draw :=True;
      pvt_marker_right:=True;
      pvt_marker.x:=m3;
      pvt_marker.y:=(k*m3+b) div d;
      Exit;
    end

  {Снизу-слева}
  else
  if (pvt_pos.x<m1) and
     (pvt_pos.y>m4) then
    begin
      if ((k*m1+b)/d<m4) then
        begin
          pvt_marker_draw:=True;
          pvt_marker_left:=True;
          pvt_marker.x:=m1;
          pvt_marker.y:=(k*m1+b) div d;
        end
      else
        begin
          pvt_marker_draw  :=True;
          pvt_marker_bottom:=True;
          pvt_marker.x:=(d*m4-b) div k;
          pvt_marker.y:=m4;
        end;
      Exit;
    end

  {Снизу}
  else
  if (pvt_pos.x>m1) and
     (pvt_pos.x<m3) and
     (pvt_pos.y>m4) then
    begin
      pvt_marker_draw  :=True;
      pvt_marker_bottom:=True;
      pvt_marker.x:=(d*m4-b) div k;
      pvt_marker.y:=m4;
      Exit;
    end

  {Снизу-справа}
  else
  if (pvt_pos.x>m3) and
     (pvt_pos.y>m4) then
    begin
      if ((k*m3+b)/d<m4) then
        begin
          pvt_marker_draw:=True;
          pvt_marker_right:=True;
          pvt_marker.x:=m3;
          pvt_marker.y:=(k*m3+b) div d;
        end
      else
        begin
          pvt_marker_draw  :=True;
          pvt_marker_bottom:=True;
          pvt_marker.x:=(d*m4-b) div k;
          pvt_marker.y:=m4;
        end;
      Exit;
    end

  else
    pvt_marker_draw:=False;

end; {$endregion}
procedure TPivot.PivotToPointDraw(cnv_dst:TCanvas);                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with cnv_dst do
    begin
      Pen.Mode   :=pmcopy;
      Pen.Color  :=clRed;
      Brush.Style:=bsClear;
      Rectangle(Trunc(pvt_pos.x)-4,
                Trunc(pvt_pos.y)-4,
                Trunc(pvt_pos.x)+5,
                Trunc(pvt_pos.y)+5);
    end;
end; {$endregion}
procedure TPivot.PivotModeDraw   (cnv_dst:TCanvas);                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with cnv_dst do
    case pvt_mode of
      (pmPivotMove):
        begin
          Pen.Mode :=pmMerge;
          Pen.Color:=clRed;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-18,
                    Trunc(pvt_pos.x)+18,Trunc(pvt_pos.y));
          Pen.Width:=2;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-24,
                    Trunc(pvt_pos.x)+24,Trunc(pvt_pos.y));
          {
          Pen.Color:=clGreen;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y),
                    Trunc(pvt_pos.x)+60,Trunc(pvt_pos.y));
          LineTo   (Trunc(pvt_pos.x)+50,Trunc(pvt_pos.y)-2);
          LineTo   (Trunc(pvt_pos.x)+50,Trunc(pvt_pos.y)+2);
          LineTo   (Trunc(pvt_pos.x)+60,Trunc(pvt_pos.y));
          Pen.Color:=clBlue;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y),
                    Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-60);
          LineTo   (Trunc(pvt_pos.x)-2, Trunc(pvt_pos.y)-50);
          LineTo   (Trunc(pvt_pos.x)+2, Trunc(pvt_pos.y)-50);
          LineTo   (Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-60);
          }
          Pen.Width:=1;
        end;
      (pmPivotScale):
        begin
          Pen.Mode :=pmMerge;
          Pen.Color:=clRed;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-18,
                    Trunc(pvt_pos.x)+18,Trunc(pvt_pos.y)-18);
          Line     (Trunc(pvt_pos.x)+18,Trunc(pvt_pos.y)-18,
                    Trunc(pvt_pos.x)+18,Trunc(pvt_pos.y));
          Pen.Width:=2;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-24,
                    Trunc(pvt_pos.x)+24,Trunc(pvt_pos.y)-24);
          Line     (Trunc(pvt_pos.x)+24,Trunc(pvt_pos.y)-24,
                    Trunc(pvt_pos.x)+24,Trunc(pvt_pos.y));
          {
          Pen.Color:=clGreen;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y),
                    Trunc(pvt_pos.x)+60,Trunc(pvt_pos.y));
          LineTo   (Trunc(pvt_pos.x)+50,Trunc(pvt_pos.y)-2);
          LineTo   (Trunc(pvt_pos.x)+50,Trunc(pvt_pos.y)+2);
          LineTo   (Trunc(pvt_pos.x)+60,Trunc(pvt_pos.y));
          Pen.Color:=clBlue;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y),
                    Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-60);
          LineTo   (Trunc(pvt_pos.x)-2, Trunc(pvt_pos.y)-50);
          LineTo   (Trunc(pvt_pos.x)+2, Trunc(pvt_pos.y)-50);
          LineTo   (Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-60);
          }
          Pen.Width:=1;
        end;
      (pmPivotRotate):
        begin
          Brush.Style:=bsClear;
          Pen.Mode :=pmMerge;
          Pen.Color  :=clRed;
          Pen.Width  :=2;
          RadialPie(Trunc(pvt_pos.x)-24,Trunc(pvt_pos.y)+24,
                    Trunc(pvt_pos.x)+24,Trunc(pvt_pos.y)-24,3,-1440);
          Pen.Width  :=1;
          RadialPie(Trunc(pvt_pos.x)-18,Trunc(pvt_pos.y)+18,
                    Trunc(pvt_pos.x)+18,Trunc(pvt_pos.y)-18,3,-1440);
          {
          Pen.Color:=clGreen;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y),
                    Trunc(pvt_pos.x)+60,Trunc(pvt_pos.y));
          LineTo   (Trunc(pvt_pos.x)+50,Trunc(pvt_pos.y)-2);
          LineTo   (Trunc(pvt_pos.x)+50,Trunc(pvt_pos.y)+2);
          LineTo   (Trunc(pvt_pos.x)+60,Trunc(pvt_pos.y));
          Pen.Color:=clBlue;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y),
                    Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-60);
          LineTo   (Trunc(pvt_pos.x)-2, Trunc(pvt_pos.y)-50);
          LineTo   (Trunc(pvt_pos.x)+2, Trunc(pvt_pos.y)-50);
          LineTo   (Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-60);
          }
          Brush.Style:=bsSolid;
          Pen.Width:=1;
        end;
    end;
end; {$endregion}
procedure TPivot.PivotAxisDraw0  (cnv_dst:TCanvas; constref custom_rct:TPtRect; constref shift:TPtPos);                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with cnv_dst do
    begin

      Pen.Width:=3;

      Pen.Mode :=pmMerge;
      Pen.Color:=clGreen;
      Pen.Style:=psSolid;
      {$ifdef Windows}
      MoveTo(custom_rct.left ,Trunc(pvt_pos.y)+shift.y);
      Windows.LineTo(Handle  ,Trunc(pvt_pos.x)+shift.x-10,
                              Trunc(pvt_pos.y)+shift.y);
      MoveTo(custom_rct.right,Trunc(pvt_pos.y)+shift.y);
      Windows.LineTo(Handle  ,Trunc(pvt_pos.x)+shift.x+10,
                              Trunc(pvt_pos.y)+shift.y);
      MoveTo(                 Trunc(pvt_pos.x)+shift.x,custom_rct.top   );
      Windows.LineTo(Handle  ,Trunc(pvt_pos.x)+shift.x,
                              Trunc(pvt_pos.y)+shift.y-10);
      MoveTo(                 Trunc(pvt_pos.x)+shift.x,custom_rct.bottom);
      Windows.LineTo(Handle  ,Trunc(pvt_pos.x)+shift.x,
                              Trunc(pvt_pos.y)+shift.y+10);
      {$else}
      Line(custom_rct.left ,Trunc(pvt_pos.y)+shift.y,
                            Trunc(pvt_pos.x)+shift.x-10,
                            Trunc(pvt_pos.y)+shift.y);
      Line(custom_rct.right,Trunc(pvt_pos.y)+shift.y,
                            Trunc(pvt_pos.x)+shift.x+10,
                            Trunc(pvt_pos.y)+shift.y);
      Line(                 Trunc(pvt_pos.x)+shift.x,custom_rect.top   ,
                            Trunc(pvt_pos.x)+shift.x,
                            Trunc(pvt_pos.y)+shift.y-10);
      Line(                 Trunc(pvt_pos.x)+shift.x,custom_rect.bottom,
                            Trunc(pvt_pos.x)+shift.x,
                            Trunc(pvt_pos.y)+shift.y+10);
      {$endif}

      Pen.Mode :=pmCopy;
      Pen.Color:=clLime;
      Pen.Style:=psDash;
      {$ifdef Windows}
      MoveTo(custom_rct.left ,Trunc(pvt_pos.y)+shift.y);
      Windows.LineTo(Handle  ,Trunc(pvt_pos.x)+shift.x-10,
                              Trunc(pvt_pos.y)+shift.y);
      MoveTo(custom_rct.right,Trunc(pvt_pos.y)+shift.y);
      Windows.LineTo(Handle  ,Trunc(pvt_pos.x)+shift.x+10,
                              Trunc(pvt_pos.y)+shift.y);
      MoveTo(                 Trunc(pvt_pos.x)+shift.x,custom_rct.top   );
      Windows.LineTo(Handle  ,Trunc(pvt_pos.x)+shift.x,
                              Trunc(pvt_pos.y)+shift.y-10);
      MoveTo(                 Trunc(pvt_pos.x)+shift.x,custom_rct.bottom);
      Windows.LineTo(Handle  ,Trunc(pvt_pos.x)+shift.x,
                              Trunc(pvt_pos.y)+shift.y+10);
      {$else}
      Line(custom_rct.left ,Trunc(pvt_pos.y)+shift.y,
                            Trunc(pvt_pos.x)+shift.x-10,
                            Trunc(pvt_pos.y)+shift.y);
      Line(custom_rct.right,Trunc(pvt_pos.y)+shift.y,
                            Trunc(pvt_pos.x)+shift.x+10,
                            Trunc(pvt_pos.y)+shift.y);
      Line(                 Trunc(pvt_pos.x)+shift.x,custom_rct.top   ,
                            Trunc(pvt_pos.x)+shift.x,
                            Trunc(pvt_pos.y)+shift.y-10);
      Line(                 Trunc(pvt_pos.x)+shift.x,custom_rct.bottom,
                            Trunc(pvt_pos.x)+shift.x,
                            Trunc(pvt_pos.y)+shift.y+10);
      {$endif}

      Pen.Width:=1;
      Pen.Mode :=pmCopy;
      Pen.Style:=psSolid;

    end;
end; {$endregion}
procedure TPivot.PivotAxisDraw1  (cnv_dst:TCanvas; constref custom_rct:TPtRect; constref shift:TPtPos; x,y:integer);                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  color_info: TColorInfo;
  x0,y0     :integer;
begin
  SetColorInfo($007889E9,color_info);
  x0:=Trunc   (pvt_origin.x);
  y0:=Trunc   (pvt_origin.y);
  LineAC      (x0,y0,x,y,srf_var_ptr^.srf_bmp_ptr,srf_var_ptr^.srf_bmp.width,color_info,custom_rct);
  {with cnv_dst do
    begin

      Pen.Width:=3;

      Pen.Mode :=pmMerge;
      Pen.Color:=clRed;
      Pen.Style:=psSolid;
      {$ifdef Windows}
      MoveTo        (Trunc(pvt_origin.x),Trunc(pvt_origin.y));
      Windows.LineTo(Handle,x,y);
      {$else}
      Line(Trunc(pvt_origin.x),Trunc(pvt_origin.y),x,y);
      {$endif}

      Pen.Width:=1;
      Pen.Mode :=pmCopy;
      Pen.Style:=psSolid;

    end;}
end; {$endregion}
procedure TPivot.PivotBoundsDraw;                                                                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  //
end; {$endregion}
procedure TPivot.PivotAngleDraw;                                                                                                      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  //
end; {$endregion}
procedure TPivot.PivotDraw(constref shift:TPtPos; x,y:integer);                                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with srf_var_ptr^.srf_bmp do
    begin
      PivotModeDraw (Canvas);
      PivotAxisDraw0(Canvas,pvt_axis_rect,shift);
      PivotAxisDraw1(Canvas,pvt_axis_rect,shift,x,y);
      if (pvt_mode<>pmPivotMove) then
        SelectionToolsMarkerDraw(x,y);
      LocalAxisDraw (Trunc(pvt_pos.x),Trunc(pvt_pos.y));
    end;
end; {$endregion}
{$endregion}

// (Select Texture Region) Выделить область текстуры(фона):
{LI} {$region -fold}
procedure TF_MainForm.SB_Select_Texture_RegionClick(sender:TObject);

  procedure FillArrTest    (constref bmp_dst_ptr:PInteger; constref rct_dst:TPtRect; constref bmp_dst_width:integer); {$ifdef Linux}[local];{$endif} {$region -fold}
  var
    dst_pixel_ptr: PInteger;
    x,y          : integer;
  begin
    {dst_pixel_ptr:=Unaligned(bmp_dst_ptr+rct_dst.left+rct_dst.top*bmp_dst_width);
    Prefetch(dst_pixel_ptr);
    for y:=0 to rct_dst.height-1 do
      begin
        for x:=0 to rct_dst.width-1 do
          if ((dst_pixel_ptr+x)^=clRed{srf_var.bg_color}) then
            {(dst_pixel_ptr+x)^:=}{clBlack}BorderPixCh(dst_pixel_ptr+x,bmp_dst_width,clRed{srf_var.bg_color});
          {if ((dst_pixel_ptr+x)^=clRed{srf_var.bg_color}) then
            (dst_pixel_ptr+x)^:=RGB((Byte(    ((dst_pixel_ptr+x-bmp_dst_width-1)^)>>00)+Byte(    ((dst_pixel_ptr+x-bmp_dst_width+1)^)>>00)+Byte(    ((dst_pixel_ptr+x+bmp_dst_width-1)^)>>00)+Byte(    ((dst_pixel_ptr+x+bmp_dst_width+1)^)>>00))>>2,
                                    (Byte(Word((dst_pixel_ptr+x-bmp_dst_width-1)^)>>08)+Byte(Word((dst_pixel_ptr+x-bmp_dst_width+1)^)>>08)+Byte(Word((dst_pixel_ptr+x+bmp_dst_width-1)^)>>08)+Byte(Word((dst_pixel_ptr+x+bmp_dst_width+1)^)>>08))>>2,
                                    (Byte(    ((dst_pixel_ptr+x-bmp_dst_width-1)^)>>16)+Byte(    ((dst_pixel_ptr+x-bmp_dst_width+1)^)>>16)+Byte(    ((dst_pixel_ptr+x+bmp_dst_width-1)^)>>16)+Byte(    ((dst_pixel_ptr+x+bmp_dst_width+1)^)>>16))>>2);}
        Inc (dst_pixel_ptr,bmp_dst_width);
      end;}
  end; {$endregion}

  procedure PPFloodFillRot1(constref pvt:TPtPos; constref bmp_src_ptr:PInteger; var bmp_dst_ptr:PInteger; constref rct_dst,rct_clp:TPtRect; constref bmp_dst_width:longword; constref col:integer; constref angle:double); {$region -fold}
  var
    bmp_src_ptr2: PInteger;
    bmp_dst_ptr2: PInteger;
    c,s         : extended;
    r,a         : double;
    x,y,dx,dy   : integer;
    d_width     : integer;
  begin
    a           :=pi/2{10*(pi/180)};
    d_width     :=bmp_dst_width-rct_dst.width;
    bmp_src_ptr2:=@bmp_src_ptr[0{rct_dst.left+rct_dst.top*bmp_dst_width}];
    bmp_dst_ptr2:=@bmp_dst_ptr[0{rct_dst.left+rct_dst.top*bmp_dst_width}];
    for y:=0 to rct_dst.height-1 do
      begin
        for x:=0 to rct_dst.width-1 do
          begin
            r:=sqrt((x-pvt.x)*(x-pvt.x)+(y-pvt.y)*(y-pvt.y));
            SinCos(a+Arctan2((y-pvt.y),(x-pvt.x)),s,c);
            {s:=Sin(Arctan2((y-pvt.y),(x-pvt.x)));
            c:=Cos(Arctan2((y-pvt.y),(x-pvt.x)));}
            if (x>rct_clp.left) and (x<rct_clp.right -1) and
               (y>rct_clp.top ) and (y<rct_clp.bottom-1) then
              if (round(pvt.x+r*c)>rct_clp.left) and (round(pvt.x+r*c)<rct_clp.right -1) and
                 (round(pvt.y+r*s)>rct_clp.top ) and (round(pvt.y+r*s)<rct_clp.bottom-1) then
              bmp_dst_ptr2[(x{-pvt.x}{+rct_dst.left})+(y{-pvt.y}{+rct_dst.top})*bmp_dst_width]:=bmp_src_ptr2[round(pvt.x+r*c)+round(pvt.y+r*s)*bmp_dst_width];
          end;{
        Inc(bmp_src_ptr2,bmp_dst_width);}
      end;
  end; {$endregion}

  procedure BlurEmpty      (arr_src_ptr:PInteger; arr_dst_ptr:PInteger; constref bmp_dst_width,bmp_dst_height:longword); {$region -fold}
  var
    x,y  : integer;
    r,g,b: byte;
  begin
    for y:=0 to bmp_dst_height-1 do
      begin

        for x:=0 to bmp_dst_width-1 do
          begin
            if (y>1) and (y<bmp_dst_height-1) then
            if (arr_src_ptr^=0) then
              begin
                r:=(Red  ((arr_dst_ptr-bmp_dst_width-1)^){+Red  ((arr_dst_ptr-bmp_dst_width)^)}{+Red  ((arr_dst_ptr-bmp_dst_width+1)^)}{+Red  ((arr_dst_ptr-1)^)+Red  ((arr_dst_ptr+1)^)}{+Red  ((arr_dst_ptr+bmp_dst_width-1)^)}{+Red  ((arr_dst_ptr+bmp_dst_width)^)}+Red  ((arr_dst_ptr+bmp_dst_width+1)^))>>1{2}{3};
                g:=(Green((arr_dst_ptr-bmp_dst_width-1)^){+Green((arr_dst_ptr-bmp_dst_width)^)}{+Green((arr_dst_ptr-bmp_dst_width+1)^)}{+Green((arr_dst_ptr-1)^)+Green((arr_dst_ptr+1)^)}{+Green((arr_dst_ptr+bmp_dst_width-1)^)}{+Green((arr_dst_ptr+bmp_dst_width)^)}+Green((arr_dst_ptr+bmp_dst_width+1)^))>>1{2}{3};
                b:=(Blue ((arr_dst_ptr-bmp_dst_width-1)^){+Blue ((arr_dst_ptr-bmp_dst_width)^)}{+Blue ((arr_dst_ptr-bmp_dst_width+1)^)}{+Blue ((arr_dst_ptr-1)^)+Blue ((arr_dst_ptr+1)^)}{+Blue ((arr_dst_ptr+bmp_dst_width-1)^)}{+Blue ((arr_dst_ptr+bmp_dst_width)^)}+Blue ((arr_dst_ptr+bmp_dst_width+1)^))>>1{2}{3};
                arr_dst_ptr^:=RGB(r,g,b);
              end;
            Inc(arr_src_ptr);
            Inc(arr_dst_ptr);
          end;
      end;
  end; {$endregion}

  var
    i       : integer   ;
    col_info: TColorInfo;
    pt      : TPtPos    ;
    pt2     : TPtPosF   ;
    pt3     : TLnPosF   ;
    pt4     : TCrPosF   ;
    pt5     : TPtPosF   ;
    ln_sht  : double    ;
    dir_x   : shortint  ;
    dir_y   : shortint  ;
    l1,l2   : integer   ;
    ex_file : string    ;
    params  : string    ;

begin
  DrawingPanelsSetVisibility1(down_select_texture_region_ptr,P_Select_Texture_Region,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_select_texture_region_ptr^) then
    Exit;
  {
  PPBlurProc10(srf_var.srf_bmp_ptr,srf_var.srf_bmp_rct,srf_var.srf_bmp.width);
  PPContrast1(srf_var.srf_bmp_ptr,srf_var.inn_wnd_rct,srf_var.srf_bmp.width,10);
  SetTextInfo(srf_var.srf_bmp.Canvas,32);
  srf_var.srf_bmp.Canvas.TextOut(srf_var.world_axis.x+32,
                                 srf_var.world_axis.y,
                                 'Hello World');
  CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
  }
end;
{$endregion}

// (Buttons Cursors) Курсоры для кнопок:
{LI} {$region -fold}
procedure CursorInit(constref cur_ind,im_lst_ind:integer; constref location:string; constref ImgLstGetBmp:TProc1); {$region -fold}
var
  bmp_alpha,bmp_color: Graphics.TBitmap;
  icon_info          : TIconInfo;
begin
  if FileExists(location) then
    begin
      bmp_alpha:=CrtTPicInstFromHDDSrc(location).Bitmap;
      bmp_color:=CrtTPicInstFromHDDSrc(location).Bitmap;
    end
  else
    begin
      bmp_alpha:=CrtTBmpInstFromImgLst(ImgLstGetBmp,im_lst_ind);
      bmp_color:=CrtTBmpInstFromImgLst(ImgLstGetBmp,im_lst_ind);
    end;
  with icon_info do
    begin
      fIcon   :=false;
      xHotspot:=8;
      yHotspot:=22;
      hbmMask :=bmp_alpha.Handle;
      hbmColor:=bmp_color.Handle;
    end;
  Screen.Cursors[cur_ind]:=CreateIconIndirect(icon_info);
  bmp_alpha.Free;
  bmp_color.Free;
end; {$endregion}
{$endregion}

// (Animation) Анимация:
{LI} {$region -fold}
procedure TimeLineButtonsCreate;                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin

  // Create Buttons Positions  Array:
  SetLength(btn_pos_arr,Length(btn_pos_arr)+6);

  // Create Buttons Icons:
  SetLength(tmln_btn_inds_arr,6);
  with srf_var do
    for i:=0 to 5 do
      begin
        SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
        sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
        (
          srf_bmp_ptr,
          srf_bmp.width,
          srf_bmp.height,
          inn_wnd_rct,
          max_sprite_w_h_rct,
          Application.Location+TIMELINE_BUTTON_ICON_PREFIX+IntToStr(i)+'.png',
          @F_MainForm.IL_Butons_Icons.GetBitmap,
          i
        );
        tmln_btn_inds_arr[i]:=Length(sprite_sheet_arr)-1;
      end;

  // Create Button Background:
  SetLength(bckgd_btn_inds_arr,4);
  with srf_var do
    for i:=0 to 3 do
      begin
        SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
        sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
        (
          srf_bmp_ptr,
          srf_bmp.width,
          srf_bmp.height,
          inn_wnd_rct,
          max_sprite_w_h_rct,
          Application.Location+TIMELINE_BUTTON_ICON_PREFIX+IntToStr(6+i)+'.png',
          @F_MainForm.IL_Buttons_Background.GetBitmap,
          i
        );
        bckgd_btn_inds_arr[i]:=Length(sprite_sheet_arr)-1;
      end;

  // Drawing Settings: Buttons Icons:
  for i in [0,1,2,3,4,5] do
    with sprite_sheet_arr[tmln_btn_inds_arr[i]],fast_image_data,fast_image_proc_var do
      begin
        fast_image_data_ptr0:=@fast_image_data;

        SetPPInfo($0036261D);

        col_trans_arr[03]:=32;

        pix_drw_type             :=1; //must be in range of [0..002]
        nt_pix_srf_type          :=1; //must be in range of [0..002]
        nt_pix_cfx_type          :=2; //must be in range of [0..002]
        nt_pix_cng_type          :=0; //must be in range of [0..001]
        pt_pix_srf_type          :=1; //must be in range of [0..002]
        pt_pix_cfx_type          :=2; //must be in range of [0..002]
        pt_pix_cng_type          :=0; //must be in range of [0..001]

        fx_cnt                   :=1; //must be in range of [0..255]

        fx_arr[0].rep_cnt        :=1; //must be in range of [0..255]
        fx_arr[0].nt_pix_srf_type:=1; //must be in range of [0..001]
        fx_arr[0].nt_pix_cfx_type:=3; //must be in range of [0..255]
        fx_arr[0].nt_pix_cng_type:=1; //must be in range of [0..001]
        fx_arr[0].pt_pix_srf_type:=1; //must be in range of [0..001]
        fx_arr[0].pt_pix_cfx_type:=3; //must be in range of [0..255]
        fx_arr[0].pt_pix_cng_type:=1; //must be in range of [0..001]

        fx_arr[1].rep_cnt        :=1; //must be in range of [0..255]
        fx_arr[1].nt_pix_srf_type:=1; //must be in range of [0..001]
        fx_arr[1].nt_pix_cfx_type:=4; //must be in range of [0..255]
        fx_arr[1].nt_pix_cng_type:=1; //must be in range of [0..001]
        fx_arr[1].pt_pix_srf_type:=1; //must be in range of [0..001]
        fx_arr[1].pt_pix_cfx_type:=4; //must be in range of [0..255]
        fx_arr[1].pt_pix_cng_type:=1; //must be in range of [0..001]
      end;

  with sprite_sheet_arr[bckgd_btn_inds_arr[1]],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;

      SetPPInfo(clLtGray);

      //col_trans_arr[02]:=200;

      pix_drw_type             :=1; //must be in range of [0..002]
      nt_pix_srf_type          :=1; //must be in range of [0..002]
      nt_pix_cfx_type          :=2; //must be in range of [0..002]
      nt_pix_cng_type          :=0; //must be in range of [0..001]
      pt_pix_srf_type          :=1; //must be in range of [0..002]
      pt_pix_cfx_type          :=2; //must be in range of [0..002]
      pt_pix_cng_type          :=0; //must be in range of [0..001]

      fx_cnt                   :=1; //must be in range of [0..255]

      fx_arr[0].rep_cnt        :=1; //must be in range of [0..255]
      fx_arr[0].nt_pix_srf_type:=1; //must be in range of [0..001]
      fx_arr[0].nt_pix_cfx_type:=0; //must be in range of [0..255]
      fx_arr[0].nt_pix_cng_type:=1; //must be in range of [0..001]
      fx_arr[0].pt_pix_srf_type:=1; //must be in range of [0..001]
      fx_arr[0].pt_pix_cfx_type:=0; //must be in range of [0..255]
      fx_arr[0].pt_pix_cng_type:=1; //must be in range of [0..001]

      fx_arr[1].rep_cnt        :=1; //must be in range of [0..255]
      fx_arr[1].nt_pix_srf_type:=1; //must be in range of [0..001]
      fx_arr[1].nt_pix_cfx_type:=9; //must be in range of [0..255]
      fx_arr[1].nt_pix_cng_type:=1; //must be in range of [0..001]
      fx_arr[1].pt_pix_srf_type:=1; //must be in range of [0..001]
      fx_arr[1].pt_pix_cfx_type:=9; //must be in range of [0..255]
      fx_arr[1].pt_pix_cng_type:=1; //must be in range of [0..001]
    end;

end; {$endregion}
procedure CursorsCreate;                                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // Create Cursors Array:
  SetLength(cursors_inds_arr,Length(cursors_inds_arr)+1);
  SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
  // Create Cursor Icon:
  with srf_var do
    sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
    (
      srf_bmp_ptr,
      srf_bmp.width,
      srf_bmp.height,
      inn_wnd_rct,
      max_sprite_w_h_rct,
      Application.Location+DEFAULT_CURSOR_ICON,
      @F_MainForm.IL_Cursors_Icons.GetBitmap,
      0
    );
  cursors_inds_arr[Length(cursors_inds_arr)-1]:=Length(sprite_sheet_arr)-1;
end; {$endregion}
procedure TimeLineButtonsDraw(constref x,y:integer);                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  {x:=F_MainForm.S_Splitter2.Top-40;
  y:=F_MainForm.S_Splitter2.Width>>1-16+4;}
  btn_pos_arr[0].x:=y-80;
  btn_pos_arr[0].y:=x;
  btn_pos_arr[1].x:=y-40;
  btn_pos_arr[1].y:=x;
  btn_pos_arr[2].x:=y;
  btn_pos_arr[2].y:=x;
  btn_pos_arr[3].x:=y;
  btn_pos_arr[3].y:=x;
  btn_pos_arr[4].x:=y+40;
  btn_pos_arr[4].y:=x;
  btn_pos_arr[5].x:=y+80;
  btn_pos_arr[5].y:=x;
  for i in [0,1,2,4,5] do
    with sprite_sheet_arr[bckgd_btn_inds_arr[1]],fast_image_proc_var do
      begin
        fast_image_data_ptr0:=@fast_image_data;
        SetRctPos(btn_pos_arr[i].x,
                  btn_pos_arr[i].y);
        SdrProc[3];
      end;
  for i in [0,1,2,4,5] do
    with sprite_sheet_arr[tmln_btn_inds_arr[i]],fast_image_proc_var do
      begin
        fast_image_data_ptr0:=@fast_image_data;
        SetRctPos(btn_pos_arr[i].x,
                  btn_pos_arr[i].y);
        SdrProc[3];
      end;
  for i in [0,1,2,4,5] do
    with sprite_sheet_arr[bckgd_btn_inds_arr[3]],fast_image_proc_var do
      begin
        fast_image_data_ptr0:=@fast_image_data;
        SetRctPos(btn_pos_arr[i].x,
                  btn_pos_arr[i].y);
        SdrProc[3];
      end;
end; {$endregion}
procedure CursorDraw(constref x,y:integer; constref cur_ind:integer=0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sprite_sheet_arr[cursors_inds_arr[cur_ind]],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      SetRctPos(x,y);
      SdrProc[3];
    end;
end; {$endregion}
procedure CursorDraw;                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with srf_var do
    if IsPtInRct(cur_pos.x,cur_pos.y,inn_wnd_rct) then
      begin
        CursorDraw(cur_pos.x,cur_pos.y);
        CircleHighlight(cur_pos.x,cur_pos.y,
                        srf_bmp_ptr,
                        inn_wnd_rct,
                        srf_bmp.width,
                        Default(TColorInfo),
                        128,
                        045);
      end;
end; {$endregion}
//...
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_Play_AnimClick     (sender:TObject); {$region -fold}
var
  i: integer;
begin

  {with tlm_var do
    if (Length(tilemap_arr2)<>0) then
      begin
        with tilemap_arr2[High(tilemap_arr2)],fast_image_data,sln_prop_var do
          begin
            pts_col_inv       :=SetColorInv(clRed);
            pts_rct_inn_width :=tilemap_sprite_w_h.x-(pts_rct_tns_left+pts_rct_tns_right );
            pts_rct_inn_height:=tilemap_sprite_w_h.y-(pts_rct_tns_top +pts_rct_tns_bottom);
            SetRctWidth (sln_prop_var);
            SetRctHeight(sln_prop_var);
            SetRctValues(sln_prop_var);
          end;
      end;}

  if down_play_anim_ptr^ then
    begin
      cmr_var.mov_dir   :=mdNone;
      F_Hot_Keys.Visible:=False;
      F_Hot_Keys.Enabled:=False;
      //srf_var.bg_color:=clBlack;
    end
  else
    begin
      //srf_var.bg_color      :=$00666688;
      T_Logo1.Enabled       :=False;
      T_Logo2.Enabled       :=False;
      T_Logo3.Enabled       :=False;
      T_Menu .Enabled       :=False;
      T_Game .Enabled       :=False;
      {OpenGLControl2.Visible:=False;
      OpenGLControl2.Enabled:=False;}
      //time_interval         :=0;
    end;

  {with srf_var do
    main_char_pos:=PtPos(world_axis.x+world_axis_shift.x+main_char_pos_spawn_arr[Random(6)].x,
                         world_axis.y+world_axis_shift.y+main_char_pos_spawn_arr[Random(6)].y);

  with srf_var do
    Logo1_img.SetBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,inn_wnd_rct);
  with srf_var do
    Logo2_img.SetBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,inn_wnd_rct);}

  //LCLVLCPlayer_Intro.PlayFile(Application.Location+INTRO_MOVIE);

  {if down_play_anim_ptr^ then
    mciSendString(PChar('play "C:\Popl_Uniy_Orel.wav"' ),nil,0,0)
  else
    mciSendString(PChar('stop "C:\Popl_Uniy_Orel.wav"'),nil,0,0);}

  OpenGLControl2.Visible:=down_play_anim_ptr^;
  OpenGLControl2.Enabled:=down_play_anim_ptr^;
  with srf_var do
    begin
      // Get Target Render For OpenGL Output:
      GLBitmapInit(texture_id,srf_bmp,down_play_anim_ptr^);
      //if down_play_anim_ptr^ then
      GetObject(srf_bmp.Handle,SizeOf(buffer),@buffer);
    end;

  for i:=0 to 9999 do
    begin
      projectile_arr[i]:=projectile_default;
      with projectile_arr[i] do
        begin
          pt_ind:=-1;
          pt_0  :=PtPosF(srf_var.world_axis.x,
                         srf_var.world_axis.y);
          pt_p  :=pt_0;
          pt_n  :=pt_0;
          //pt_c :=pt_n;
          {v_0  +=Random(12);
          angle+=Random(90);}
          //projectile_arr[i].time-=TIME_DELTA;
        end;
    end;

  DrawingPanelsSetVisibility1(down_play_anim_ptr,P_Play_Anim,P_AnimK_Custom_Panel,prev_panel_animk,curr_panel_animk);
  DrawingPanelsSetVisibility2;

  {TODO}
  BB_Use_MagicClick(self);

  with obj_var,srf_var do
    if down_play_anim_ptr^ then
      begin
        SetObjBkgnd
        (
          low_bmp_ptr,
          low_bmp.width,
          low_bmp.height,
          @inn_wnd_rct,
          0,
          low_lr_obj_cnt-1
        );
        if (upp_lr_obj_cnt>0) then
          SetObjBkgnd
          (
            srf_bmp_ptr,
            srf_bmp.width,
            srf_bmp.height,
            @inn_wnd_rct,
            low_lr_obj_cnt,
            obj_cnt-1
          );
      end
    else
      SetObjBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct,0,obj_cnt-1);

  T_Game_Loop.Enabled:=down_play_anim_ptr^;
  //T_Logo1.Enabled:=down_play_anim_ptr^;


  VisibilityChange      (not down_play_anim_ptr^);
  show_visibility_panel:=not down_play_anim_ptr^;
  if (not down_play_anim_ptr^) then
    begin
      VisibilityChange(True);
      show_visibility_panel:=True;
    end;
  with srf_var,sln_var,fast_fluid_var do
    begin
      WaterWaveInit1;
      {if (sln_pts_cnt<>0) then
        WaterWaveInit(sln_pts,
                      sln_pts_cnt-sln_obj_pts_cnt[sln_obj_cnt-1],
                      sln_pts_cnt);}
      {WaterWaveInit(PtPosF(world_axis.x,
                           world_axis.y));}
    end;

end; {$endregion}
procedure TF_MainForm.BB_Load_FrameClick    (sender:TObject); {$region -fold}
var
  button_glyph: Graphics.TBitmap;
begin
  OpenPictureDialog1.Options:=OpenPictureDialog1.Options+[ofFileMustExist];
  if (not OpenPictureDialog1.Execute) then
    Exit;
  try
    sln_var.tex_on_sln.LoadFromFile(OpenPictureDialog1.Filename);
  except
    on E: Exception do
      MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
  end;
  button_glyph       :=Graphics.TBitmap.Create;
  button_glyph.Width :=50;
  button_glyph.Height:=50;
  button_glyph.PixelFormat:=pf32bit;
  button_glyph.Canvas.StretchDraw(Rect(0,0,
                                       button_glyph.Width,
                                       button_glyph.Height),
                                       sln_var.tex_on_sln.Graphic);
  BB_Load_Bitmap.Glyph:=button_glyph;
  sln_var.tex_on_sln_tmp_bmp:=Graphics.TBitmap.Create;

end; {$endregion}
procedure TF_MainForm.BB_Use_MagicClick     (sender:TObject); {$region -fold}
var
  sprite_rect_arr_ptr: PPtPos;
  useless_arr_ptr    : PByte;
  i,v1,v2,c0,c1,c2,c3: integer;
begin

  {if (useless_fld_arr_<>Nil) then
    //ArrClear(useless_fld_arr_,srf_var.inn_wnd_rct,srf_var.srf_bmp.width);
    FillDWord((@useless_fld_arr_[0])^,srf_var.srf_bmp.width*srf_var.srf_bmp.height,0);}
  SetLength(useless_fld_arr_,srf_var.srf_bmp.width*srf_var.srf_bmp.height);
  ArrClear(useless_fld_arr_,srf_var.inn_wnd_rct,srf_var.srf_bmp.width);

 {if (useless_arr_<>Nil) then
    FillByte ((@useless_arr_[0])^,SE_Count_X.value,0);}
  SetLength  (  useless_arr_     ,SE_Count_X.value  );
  FillByte   ((@useless_arr_[0])^,SE_Count_X.value,0);

  {if (sprite_rect_arr_<>Nil) then
    FillQWord((@sprite_rect_arr_[0])^,SE_Count_X.value,0);}
  SetLength(sprite_rect_arr,SE_Count_X.value);
  FillQWord((@sprite_rect_arr[0])^,SE_Count_X.value,0);

  with fast_actor_set_var.d_icon,fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      v1:=Trunc(tex_var.tex_bmp_rct_pts[0].x)-bmp_ftimg_width >>1;
      v2:=Trunc(tex_var.tex_bmp_rct_pts[0].y)-bmp_ftimg_height>>1;
      sprite_rect_arr_ptr:=@sprite_rect_arr[0];
      for i:=0 to SE_Count_X.Value-1 do
        begin
          sprite_rect_arr_ptr^.x:=v1+Random(Trunc(tex_var.tex_bmp_rct_pts[1].x-tex_var.tex_bmp_rct_pts[0].x));
          sprite_rect_arr_ptr^.y:=v2+Random(Trunc(tex_var.tex_bmp_rct_pts[1].y-tex_var.tex_bmp_rct_pts[0].y));
          Inc(sprite_rect_arr_ptr);
        end;

      c0:=0;
      c1:=0;
      c2:=0;
      c3:=0;
      sprite_rect_arr_ptr:=@sprite_rect_arr[SE_Count_X.value-1];
      useless_arr_ptr    :=@useless_arr_   [SE_Count_X.value-1];
      for i:=SE_Count_X.Value-1 downto 0 do
        begin
          SetRctPos(sprite_rect_arr_ptr^.x,
                    sprite_rect_arr_ptr^.y);
          Dec      (sprite_rect_arr_ptr);
          SetRctDst;
          SetRctSrc;
          NTUselessProc[nt_pix_clp_type](useless_fld_arr_,srf_var.srf_bmp.Width,i);
          PTUselessProc[pt_pix_clp_type](useless_fld_arr_,srf_var.srf_bmp.Width,i);
          useless_arr_ptr^:=Useless;
          case useless_arr_ptr^ of
            0: Inc(c0);
            1: Inc(c1);
            2: Inc(c2);
            3: Inc(c3);
          end;
          Dec(useless_arr_ptr);
        end;
    end;

  {M_Description.Lines.Text:=IntToStr({fast_actor_set_var.d_icon.img_kind}{nt_pix_cnt}c0)+'; '+
                    IntToStr({fast_actor_set_var.d_icon.img_kind}{nt_pix_cnt}c1)+'; '+
                    IntToStr({fast_actor_set_var.d_icon.img_kind}{nt_pix_cnt}c2)+'; '+
                    IntToStr({fast_actor_set_var.d_icon.img_kind}{nt_pix_cnt}c3)+'. ';}

  {anim_play2:=not anim_play2;
  if anim_play2 then
    Application.OnIdle:=@Tic
  else
    Application.OnIdle:=Nil;}

end; {$endregion}
procedure TF_MainForm.I_Frame_ListMouseEnter(sender:TObject); {$region -fold}
begin
  with fast_actor_set_var.d_icon,cmr_var,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      SetBkgnd(img_lst_bmp_ptr,img_lst_bmp.width,img_lst_bmp.height,bmp_rect);
    end;
end; {$endregion}
procedure TF_MainForm.I_Frame_ListMouseDown (sender:TObject; button:TMouseButton; shift:TShiftState; x,y:integer); {$region -fold}
begin
  fast_actor_set_var.AddActor(x,y);
  CnvToCnv(PtBounds(0,0,img_lst_bmp.Width,img_lst_bmp.Height),
           I_Frame_List.Canvas,
           img_lst_bmp.Canvas,
           SRCCOPY);
  I_Frame_List.Invalidate;
end; {$endregion}
{$endregion}

// (Map Editor) Редактор карт:
{LI} {$region -fold}
constructor TTlMap.Create;                                          {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  TileMapSpriteDefaultIconCreate;
  show_tile_map:=True;
end; {$endregion}
destructor  TTlMap.Destroy;                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure  TTlMap.TileMapSpriteDefaultIconCreate;           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // Create Mask Template Sprite Icon:
  SetLength(tilemap_sprite_inds_arr,Length(tilemap_sprite_inds_arr)+1);
  SetLength(sprite_sheet_arr       ,Length(sprite_sheet_arr       )+1);
  with srf_var do
    sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
    (
      srf_bmp_ptr,
      srf_bmp.width,
      srf_bmp.height,
      inn_wnd_rct,
      max_sprite_w_h_rct,
      Application.Location+DEFAULT_TILE_MAP_SPRITE_ICON,
      @F_MainForm.IL_Default_Tile_Map_Sprite_Icon.GetBitmap,
      0
    );
  tilemap_sprite_inds_arr[0]:=Length(sprite_sheet_arr)-1;
  with sprite_sheet_arr[tilemap_sprite_inds_arr[0]],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0{2}:=@fast_image_data;

      SetPPInfo(clRed);
      SetGrad  (0,bmp_ftimg_height,0,255);

      col_trans_arr[01]:=132;
      col_trans_arr[02]:=032;
      col_trans_arr[03]:=132;
      col_trans_arr[04]:=132;
      col_trans_arr[05]:=132;
      col_trans_arr[06]:=132;
      col_trans_arr[07]:=132;
      col_trans_arr[08]:=132;
      col_trans_arr[09]:=132;
      col_trans_arr[10]:=0;
      col_trans_arr[11]:=255;
      col_trans_arr[12]:=0;
      col_trans_arr[13]:=255;
      col_trans_arr[14]:=0;
      col_trans_arr[15]:=255;
      col_trans_arr[16]:=0;

      pix_drw_type             :=00{01}; //must be in range of [0..002]
      nt_pix_cfx_type          :=02{00};
      pt_pix_cfx_type          :=02{00};
      fx_cnt                   :=00{01}; //must be in range of [0..255]

      fx_arr[0].rep_cnt        :=01{02}; //must be in range of [0..255]

      fx_arr[0].nt_pix_srf_type:=01    ; //must be in range of [0..001]
      fx_arr[0].nt_pix_cfx_type:=17    ; //must be in range of [0..255]
      fx_arr[0].nt_pix_cng_type:=00    ; //must be in range of [0..001]

      fx_arr[0].pt_pix_srf_type:=01    ; //must be in range of [0..001]
      fx_arr[0].pt_pix_cfx_type:=17    ; //must be in range of [0..255]
      fx_arr[0].pt_pix_cng_type:=00    ; //must be in range of [0..001]
    end;
end; {$endregion}
procedure  TTlMap.AddTileMapObj;                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  default_tlmap_sprite: string;
begin
  default_tlmap_sprite:=F_MainForm.OPD_Add_TileMap.Filename;
  SetLength(tilemap_inds_arr,Length(tilemap_inds_arr)+1);
  SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
  with srf_var do
    sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
    (
      srf_bmp_ptr,
      srf_bmp.width,
      srf_bmp.height,
      obj_var.obj_arr[obj_var.tlmap_inds_obj_arr[obj_var.tlmap_cnt-1]].rct_clp_ptr^,
      max_sprite_w_h_rct,
      default_tlmap_sprite,
      @F_MainForm.IL_Default_Tile_Map_Icon.GetBitmap,
      0,
      True
    );
  tilemap_inds_arr[Length(tilemap_inds_arr)-1]:=Length(sprite_sheet_arr)-1;
  with sprite_sheet_arr[tilemap_inds_arr[Length(tilemap_inds_arr)-1]],fast_image_data do
    if (Length(tilemap_sprite_inds_arr)=1) then
      begin
        tilemap_sprite_w_h:=PtPos(sprite_sheet_arr[tilemap_sprite_inds_arr[000000000000000000000000000000000]].fast_image_data.bmp_ftimg_width_origin,
                                  sprite_sheet_arr[tilemap_sprite_inds_arr[000000000000000000000000000000000]].fast_image_data.bmp_ftimg_height_origin);
        tilemap_sprite_ind:=                       tilemap_sprite_inds_arr[000000000000000000000000000000000];
      end
    else
      begin
        tilemap_sprite_w_h:=PtPos(sprite_sheet_arr[tilemap_sprite_inds_arr[Length(tilemap_sprite_inds_arr)-1]].fast_image_data.bmp_ftimg_width_origin,
                                  sprite_sheet_arr[tilemap_sprite_inds_arr[Length(tilemap_sprite_inds_arr)-1]].fast_image_data.bmp_ftimg_height_origin);
        tilemap_sprite_ind:=                       tilemap_sprite_inds_arr[Length(tilemap_sprite_inds_arr)-1];
      end;
end; {$endregion}
procedure  TTlMap.AddTileMapSpriteObj;                      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  tlmap_sprite: string;
begin
  tlmap_sprite:=F_MainForm.OPD_Add_TileMap_Sprite.Filename;
  SetLength(tilemap_sprite_inds_arr,Length(tilemap_sprite_inds_arr)+1);
  SetLength(sprite_sheet_arr       ,Length(sprite_sheet_arr       )+1);
  with srf_var do
    sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
    (
      srf_bmp_ptr,
      srf_bmp.width,
      srf_bmp.height,
      inn_wnd_rct{obj_var.obj_arr[obj_var.tlmap_inds_obj_arr[obj_var.tlmap_cnt-1]].rct_clp_ptr^},
      max_sprite_w_h_rct,
      tlmap_sprite,
      Nil,
      0
    );
  tilemap_sprite_inds_arr[Length(tilemap_sprite_inds_arr)-1]:=Length(sprite_sheet_arr)-1;
end; {$endregion}
procedure  TTlMap.AddTileMapPreview;                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct1,rct2: TRect;
begin
  {with srf_var,tlm_var do
    begin
      rct1:=Bounds(0,
                   0,
                   tilemap_arr1[High(tilemap_arr1)].width,
                   tilemap_arr1[High(tilemap_arr1)].height);
      rct2:=Bounds(0,
                   0,
                   100,
                   100);
      F_MainForm.I_Add_Mask_Template_List.Canvas.CopyRect(rct2,tilemap_arr1[High(tilemap_arr1)].Bitmap.Canvas,rct1);
    end;}
end; {$endregion}
procedure  TTlMap.AddTileMapSpritePreview;                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct1,rct2: TRect;
begin
  {with srf_var,tlm_var do
    begin
      rct1:=Bounds(0,
                   0,
                   tilemap_arr1[High(tilemap_arr1)].width,
                   tilemap_arr1[High(tilemap_arr1)].height);
      rct2:=Bounds(0,
                   0,
                   100,
                   100);
      F_MainForm.I_Add_Mask_Template_List.Canvas.CopyRect(rct2,tilemap_arr1[High(tilemap_arr1)].Bitmap.Canvas,rct1);
    end;}
end; {$endregion}
procedure  TTlMap.FilTileMapObj(constref tlmap_ind:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
begin
  if show_tile_map then
    with srf_var,sprite_sheet_arr[tilemap_inds_arr[tlmap_ind]],fast_image_data,fast_image_proc_var do
      begin
        fast_image_data_ptr1:=@fast_image_data;
        fast_image_data_ptr2:=@sprite_sheet_arr[tilemap_sprite_ind].fast_image_data;
        fast_image_data_ptr0:=fast_image_data_ptr1;
        obj_arr_ptr         :=Unaligned(@obj_var.obj_arr[obj_var.tlmap_inds_obj_arr[tlmap_ind]]);
        SetRctPos(world_axis.x-(bmp_ftimg_width_origin *tilemap_sprite_w_h.x)>>1+obj_arr_ptr^.world_axis_shift.x,
                  world_axis.y-(bmp_ftimg_height_origin*tilemap_sprite_w_h.y)>>1+obj_arr_ptr^.world_axis_shift.y);
        SetBkgnd
        (
          obj_arr_ptr^.bkgnd_ptr,
          obj_arr_ptr^.bkgnd_width,
          obj_arr_ptr^.bkgnd_height,
          obj_arr_ptr^.rct_clp_ptr^
        );
        fast_image_data_ptr0:=fast_image_data_ptr2;
        SetBkgnd
        (
          obj_arr_ptr^.bkgnd_ptr,
          obj_arr_ptr^.bkgnd_width,
          obj_arr_ptr^.bkgnd_height,
          obj_arr_ptr^.rct_clp_ptr^
        );
        fast_image_data_ptr0:=fast_image_data_ptr1;
        FilTileMap1;
        bmp_bkgnd_ptr:=@coll_arr[0];
      end;
end; {$endregion}
procedure  TTlMap.MovTileMapObj(constref tlmap_ind:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjInfo;
begin
  if show_tile_map then
    with srf_var,sprite_sheet_arr[tilemap_inds_arr[tlmap_ind]],fast_image_data,fast_image_proc_var do
      begin
        fast_image_data_ptr1:=@fast_image_data;
        fast_image_data_ptr2:=@sprite_sheet_arr[tilemap_sprite_ind].fast_image_data;
        fast_image_data_ptr0:=fast_image_data_ptr1;
        obj_arr_ptr         :=Unaligned(@obj_var.obj_arr[obj_var.tlmap_inds_obj_arr[tlmap_ind]]);
        SetRctPos(world_axis.x-(bmp_ftimg_width_origin *tilemap_sprite_w_h.x)>>1+obj_arr_ptr^.world_axis_shift.x,
                  world_axis.y-(bmp_ftimg_height_origin*tilemap_sprite_w_h.y)>>1+obj_arr_ptr^.world_axis_shift.y);
        SetBkgnd
        (
          obj_arr_ptr^.bkgnd_ptr,
          obj_arr_ptr^.bkgnd_width,
          obj_arr_ptr^.bkgnd_height,
          obj_arr_ptr^.rct_dst_ptr^
        );
        fast_image_data_ptr0:=fast_image_data_ptr2;
        SetBkgnd
        (
          obj_arr_ptr^.bkgnd_ptr,
          obj_arr_ptr^.bkgnd_width,
          obj_arr_ptr^.bkgnd_height,
          obj_arr_ptr^.rct_dst_ptr^
        );
        fast_image_data_ptr0:=fast_image_data_ptr1;
        FilTileMap1;
        bmp_bkgnd_ptr:=@coll_arr[0];
      end;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_Map_EditorClick         (sender:TObject); {$region -fold}
begin
  DrawingPanelsSetVisibility1(down_map_editor_ptr,P_Map_Editor,P_AnimK_Custom_Panel,prev_panel_animk,curr_panel_animk);
end; {$endregion}
procedure TF_MainForm.BB_Add_TileMapClick        (sender:TObject); {$region -fold}
begin
  with srf_var,tlm_var do
    begin
      OPD_Add_TileMap.Options:=OPD_Add_TileMap.Options+[ofFileMustExist];
      if (not OPD_Add_TileMap.Execute) then
        Exit;
      try
        srf_var.EventGroupsCalc(calc_arr,[30,37,39,41,48]);
      except
        on E: Exception do
          MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
      end;
      AddTileMapPreview;
    end;
end; {$endregion}
procedure TF_MainForm.BB_Add_TileMap_SpriteClick(sender:TObject); {$region -fold}
begin
  with srf_var,tlm_var do
    begin
      OPD_Add_TileMap_Sprite.Options:=OPD_Add_TileMap_Sprite.Options+[ofFileMustExist];
      if (not OPD_Add_TileMap_Sprite.Execute) then
        Exit;
      try
        begin
          AddTileMapSpriteObj;
          srf_var.EventGroupsCalc(calc_arr,[30,37,41,48]);
        end;
      except
        on E: Exception do
          MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
      end;
      AddTileMapSpritePreview;
    end;
end; {$endregion}
{$endregion}

// (Add Actor) Добавить персонажа:
{LI} {$region -fold}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_Add_ActorClick(sender:TObject); {$region -fold}
begin
  DrawingPanelsSetVisibility1(down_add_actor_ptr,P_Add_Actor,P_AnimK_Custom_Panel,prev_panel_animk,curr_panel_animk);
end; {$endregion}
{$endregion}

// (F_MainForm) Основные функции формы:
{LI} {$region -fold}
procedure SpeedButtonRepaint;                                                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  F_MainForm.TB_Speed.width:=137;
  F_MainForm.TB_Speed.width:=136;
end; {$endregion}
procedure FormChangeSize;                                                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SplittersPosCalc;
  with srf_var do
    begin
      EventGroupsCalc(calc_arr,[0,1,2,3,4,17,18,30,31,32,37,41,48]);
      SetLength(useless_fld_arr_,srf_bmp.width*srf_bmp.height);
      ArrClear (useless_fld_arr_,inn_wnd_rct,  srf_bmp.width );
    end;
  if down_select_items_ptr^ then
    sel_var.MinimizeCircleSelection;
  F_MainForm.KeysEnable0;
end; {$endregion}
procedure ButtonKeyPress(sp_btn:TSpeedButton; btn_pnl1,btn_pnl2,btn_pnl3:TPanel; down_btn_ptr:PByteBool; b:byte; cur1:integer; cur2:integer=crDefault); {$region -fold}
begin
  sp_btn.Down:=not sp_btn.Down;
  case b of
    0:
      begin
        DrawingPanelsSetVisibility1(down_btn_ptr,btn_pnl1,btn_pnl2,prev_panel_draw,curr_panel_draw);
        DrawingPanelsSetVisibility2;
      end;
    1:
      begin
        DrawingPanelsSetVisibility1(down_btn_ptr,btn_pnl1,btn_pnl2,prev_panel_animk,curr_panel_animk);
      //DrawingPanelsSetVisibility2;
      end;
  end;
  btn_pnl3.Repaint;
  InvalidateInnerWindow;
  if down_btn_ptr^ then
    Screen.Cursor:=cur1
  else
    Screen.Cursor:=cur2;
end; {$endregion}
{$ifdef Windows}
procedure TF_MainForm.OnMove(var message:TWMMove);                                                                                                                 {$region -fold}
begin
  if move_with_child_form then
    begin
      F_Hot_Keys.Left:=F_MainForm.Left+11;
      F_Hot_Keys.Top :=F_MainForm.Top +80;
    end;
  inherited;
end; {$endregion}
{$endif}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.TB_SpeedChange    (sender:TObject);                                                          {$region -fold}
begin
  cmr_var.speed_mul.x:=TB_Speed.Position;
  cmr_var.speed_mul.y:=TB_Speed.Position;
  obj_var.SetParallaxShift(cmr_var.parallax_shift,cmr_var.speed_mul);
end; {$endregion}
procedure TF_MainForm.TB_SpeedClick     (sender:TObject);                                                          {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.KeysEnable0;                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  if (sel_var.sel_pts_cnt>0) or sln_var.draw_spline or is_scene_tree_editing then
    Exit;
  for i:=0 to P_Drawing_Buttons.ControlCount-1 do
    begin
      (P_Drawing_Buttons.Controls[i] as TSpeedButton).OnClick:=P_Drawing_Buttons_ClickArr[i];
      (P_Drawing_Buttons.Controls[i] as TSpeedButton).Enabled:=True;
    end;
  for i:=0 to P_Animation_Buttons.ControlCount-1 do
    begin
      (P_Animation_Buttons.Controls[i] as TSpeedButton).OnClick:=P_Animation_Buttons_ClickArr[i];
      (P_Animation_Buttons.Controls[i] as TSpeedButton).Enabled:=True;
    end;
end; {$endregion}
procedure TF_MainForm.KeysEnable1;                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  OnKeyPress:=@FormKeyPress;
  OnKeyDown :=@FormKeyDown;
  OnKeyUp   :=@FormKeyUp;
end; {$endregion}
procedure TF_MainForm.KeysDisable0;                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  if (sel_var.sel_pts_cnt>0) or sln_var.draw_spline or is_scene_tree_editing then
    begin
      for i:=0 to P_Drawing_Buttons.ControlCount-1 do
        begin
          (P_Drawing_Buttons.Controls[i] as TSpeedButton).OnClick:=Nil;
          (P_Drawing_Buttons.Controls[i] as TSpeedButton).Enabled:=False;
        end;
      for i:=0 to P_Animation_Buttons.ControlCount-1 do
        begin
          (P_Animation_Buttons.Controls[i] as TSpeedButton).OnClick:=Nil;
          (P_Animation_Buttons.Controls[i] as TSpeedButton).Enabled:=False;
        end;
    end;
end; {$endregion}
procedure TF_MainForm.KeysDisable1;                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  OnKeyPress:=Nil;
  OnKeyDown :=Nil;
  OnKeyUp   :=Nil;
end; {$endregion}
procedure TF_MainForm.FormResize        (sender:TObject);                                                          {$region -fold}
begin
  FormChangeSize;
end; {$endregion}
procedure TF_MainForm.FormMouseMove     (sender:TObject; shift:TShiftState; x,y:integer);                          {$region -fold}
var
  color_info: TColorInfo;
  rct_prop  : TCurveProp;
  rct       : TPtRect;
begin

  if down_play_anim_ptr^ then
    begin
      ////
      Exit;
    end;

  {Selection} {$region -fold}
  if down_select_items_ptr^ then
    begin

      {Pivot Moving---------} {$region -fold}
      if pvt_var.move_pvt then
        with srf_var,sln_var,sel_var,pvt_var do
          begin
            need_repaint:=True;
            LowerBmpToMainBmp;

            {Drawing of Selected Edges, Points and Objects and Pivot} {$region -fold}
            snap_mode.snap_event:=(shift=[ssAlt]);
            case pvt_var.pvt_mode of
              (pmPivotMove  ): {$region -fold}
                begin
                  {Align Pivot on Axis X}
                  AlignPivotOnX(x,y,shift);
                  {Align Pivot on Axis Y}
                  AlignPivotOnY(x,y,shift);
                  {Align Pivot on Points}
                  AlignPivotOnP(x,y,shift);
                end; {$endregion}
              (pmPivotScale ): {$region -fold}
                begin
                  SclSettings  (x,y);
                end; {$endregion}
              (pmPivotRotate): {$region -fold}
                begin
                end; {$endregion}
            end;
            SelPtsCalcProc   [Byte(pvt_var.pvt_mode)](x,y);
            WholeSubgraphProc[Byte(pvt_var.pvt_mode)](x,y,pvt_pos,sln_pts,srf_bmp_ptr,inn_wnd_rct,ClippedRct(inn_wnd_rct,sel_pts_rct));
            SelPtsRctCalcProc[Byte(pvt_var.pvt_mode)](x,y,sel_pts_rct);
            PivotDraw(Ptpos(0,0),x,y); {$endregion}

            CnvToCnv     (srf_bmp_rct,Canvas,srf_bmp.Canvas,SRCCOPY{NOTSRCCOPY});
            {$ifdef Windows}
            Sleep(32);
            {$else}
            USleep(32000000);
            {$endif}
            need_repaint:=False;
            Exit;
          end; {$endregion}

      {Circle Selection Mode} {$region -fold}
      if crc_sel_var.draw_crc_sel then
        with srf_var,sln_var,sel_var,crc_sel_var,brs_sel_var,pvt_var do
          begin
            need_repaint:=True;
            LowerBmp2ToMainBmp;
            {if show_world_axis and (not exp0) then
              WorldAxisDraw;}
            VisibilityChange(False);
            ResizeCircleSelectionModeDraw;
            if (not only_fill) then
              begin
                AddCircleSelection;
                CrtCircleSelection;
                only_fill:=True;
              end;
            FilSelPtsObj(crc_sel_rct.left,crc_sel_rct.top); //CircleSelectionModeDraw(x,y,srf_var);
            if (sel_pts_cnt>0) then
              if (sqr(pvt_pos.x-x)+
                  sqr(pvt_pos.y-y)<=crc_rad_sqr) then
                LocalAxisHighLight(Trunc(pvt_pos.x),
                                   Trunc(pvt_pos.y));
            if sel_var.sel_pts then
              case CB_Select_Items_Selection_Drawing_Mode.ItemIndex of
                0: CircleSelection(x,y,srf_var,sel_var,sln_pts,sln_pts_cnt,True);
                1:
                  begin
                    SetColorInfo   (clGreen,color_info);
                    CircleFloodFill(x,y,low_bmp2_ptr,inn_wnd_rct,low_bmp2.width,color_info,crc_rad<<1,120);
                    CircleSelection(x,y,srf_var,sel_var,sln_pts,sln_pts_cnt,False);
                  end;
              end;
            CnvToCnv(srf_bmp_rct,Canvas,srf_bmp.Canvas,SRCCOPY);
            {$ifdef Windows}
            Sleep(1);
            {$else}
            USleep(1000000);
            {$endif}
            need_repaint:=False;
            Exit;
          end; {$endregion}

      {Pivot To Point-------} {$region -fold}
      if pvt_var.pvt_to_pt then
        with srf_var,sln_var,sel_var,crc_sel_var,pvt_var do
          begin
            //VisibilityChange(False);
            need_repaint:=True;
            LowerBmp2ToMainBmp;
            if sel_pts_big_img.local_prop.eds_show then
              begin
                SelectdPointsCalc(x,y,pvt_pos,sln_pts,srf_bmp_ptr,inn_wnd_rct);
                SelectdPointsDraw(x,y,pvt_pos,sln_pts,srf_bmp_ptr,inn_wnd_rct);
              end;
            PivotToPoint  (x,y,1,srf_var,sln_var,sel_var,crc_sel_var);
            PivotModeDraw (srf_bmp.Canvas);
            PivotAxisDraw0(srf_bmp.Canvas,pvt_axis_rect,PtPos(0,0));
            PivotAxisDraw1(srf_bmp.Canvas,pvt_axis_rect,PtPos(0,0),Trunc(pvt_pos.x),Trunc(pvt_pos.y));
            if pvt_to_pt_draw_pt then
              PivotToPointDraw(srf_bmp.Canvas)
            else
              LocalAxisDraw(Trunc(pvt_pos.x),Trunc(pvt_pos.y));
            CnvToCnv
            (
              srf_bmp_rct,
              Canvas,
              srf_bmp.Canvas,
              SRCCOPY
            );
            {$ifdef Windows}
            Sleep(6);
            {$else}
            USleep(6000000);
            {$endif}
            need_repaint:=False;
            Exit;
          end; {$endregion}

    end; {$endregion}

  {Spline---} {$region -fold}
  with srf_var,sln_var do
    if draw_spline                   and
      ((CB_Spline_Mode.ItemIndex=0)  or
       (CB_Spline_Mode.ItemIndex=2)) then
      begin
        if down_play_anim_ptr^ then
          AddPoint
          (
            x,
            y,
            srf_bmp_ptr,
            srf_bmp.width,
            color_info,
            inn_wnd_rct,
            add_spline_calc,
            True
          )
        else
          begin
            AddPoint
            (
              x,
              y,
              srf_bmp_ptr,
              srf_bmp.width,
              color_info,
              inn_wnd_rct,
              add_spline_calc,
              True
            );
            CnvToCnv
            (
              srf_bmp_rct,
              Canvas,
              srf_bmp.Canvas,
              SRCCOPY
            );
          end;
      end; {$endregion}

end; {$endregion}
procedure TF_MainForm.FormMouseDown     (sender:TObject; button:TMouseButton; shift:TShiftState; x,y:integer);     {$region -fold}
var
  color_info: TColorInfo;
begin
  case Button of

    (mbLeft):
      begin

        {Animation}
        if down_play_anim_ptr^ then
          begin
            vec_x:=x{+35};
            vec_y:=y{-69};
            projectile_var:=projectile_default;
            with projectile_var do
              begin
                pt_0:=PtPosF(x-srf_var.world_axis_shift.x,
                             y-srf_var.world_axis_shift.y);
                pt_p:=pt_0;
                pt_n:=pt_0;
                pt_c:=pt_n;
              end;
            //Exit;
          end;

        {Add Actor}
        if down_add_actor_ptr^ then
          begin
            fast_actor_set_var.AddActor(x,y);
            {with main_canvas_var,tex_canvas_var do
              PPFloodFill(main_bmp_handle,
                          ClippedRect(inner_window_rect,tex_bmp_rect),
                          main_bmp.Width,
                          clGreen);}
              {PPHighLight(main_bmp_handle,
                          ClippedRect(inner_window_rect,tex_bmp_rect),
                          main_bmp.Width);}
              {PPColorCorrection0(@ColorizeRM,
                                 @ColorizeRP,
                                 main_bmp_handle,
                                 ClippedRect(inner_window_rect,tex_bmp_rect),
                                 main_bmp.Width,
                                 sprite_count);} ///////
            with srf_var do
              CnvToCnv(srf_bmp_rct,
                       Canvas,
                       srf_bmp.Canvas,SRCCOPY);
            Exit;
          end;

        {Brush}
        if down_brush_ptr^ then
          begin
            draw_brush:=True;
            PrevX     :=x;
            PrevY     :=y;
          end;

        {Spray}
        if down_spray_ptr^ then
          begin
            draw_spray:=True;
            SprayDraw(x,y,40,CD_Select_Color.Color);
          end;

        if show_spline then
          begin

            {Spline}
            if down_spline_ptr^ then
              with Canvas,srf_var,sln_var do
                if (CB_Spline_Type.ItemIndex=0) then
                  begin
                    draw_spline:=not draw_spline;
                    KeysDisable0;
                    VisibilityChange(False);
                    case CB_Spline_Mode.ItemIndex of
                      0,2:
                        MoveTo(x,y);
                      1:
                        begin
                          AddPoint
                          (
                            x,
                            y,
                            srf_bmp_ptr,
                            srf_bmp.width,
                            color_info,
                            inn_wnd_rct,
                            add_spline_calc
                          );
                          CnvToCnv
                          (
                            srf_bmp_rct,
                            Canvas,
                            srf_bmp.Canvas,
                            SRCCOPY
                          );
                        end;
                    end;
                  end;

            if down_select_items_ptr^ then
              with sln_var,sel_var,pvt_var,crc_sel_var,brs_sel_var do
                begin

                  resize_crc_sel:=False;
                  draw_brs_sel  :=False;
                  pvt_to_pt     :=False;

                  {Select Pivot}
                  if need_align_pivot_x then
                    y:=align_pivot.y;
                  if need_align_pivot_y then
                    x:=align_pivot.x;
                  if need_align_pivot_p then
                    begin
                      x:=align_pivot.x;
                      y:=align_pivot.y;
                    end;
                  if (sqr(pvt_pos.x-x)+
                      sqr(pvt_pos.y-y)<=crc_rad_sqr) then
                    begin
                      move_pvt:=(not move_pvt);
                      if show_visibility_panel then
                        VisibilityChange(not move_pvt);
                      if move_pvt then
                        begin
                          if (pvt_mode<>pmPivotMove) then
                            Screen.Cursor:=crDefault;
                          with srf_var do
                            begin
                              need_repaint:=True;
                              LowerBmp2ToMainBmp;
                              CnvToCnv(srf_bmp_rct,Canvas,srf_bmp.Canvas,SRCCOPY);
                              need_repaint:=False;
                            end;
                          //if (outer_subgraph_img.local_prop.eds_show and inner_subgraph_img.local_prop.eds_show) then
                          pvt_origin    :=pvt_pos;
                          pvt_to_pt     :=False;
                          draw_crc_sel  :=False;
                          resize_crc_sel:=False;
                          crc_sel_rct   :=Default(TRect);

                        end
                      else
                        begin
                          if exp0 then
                            begin
                              Screen.Cursor:=crNone;
                              with srf_var do
                                begin
                                  need_repaint:=True;
                                  MainBmpToLowerBmp2;
                                  fill_bmp_only:=True;
                                  FillSelBmpAndSelPtsBRectDraw;
                                  fill_bmp_only:=False;
                                  PivotDraw(PtPos(0,0),Trunc(pvt_pos.x),Trunc(pvt_pos.y));
                                  CnvToCnv(srf_bmp_rct,Canvas,srf_bmp.Canvas,SRCCOPY);
                                  need_repaint:=False;
                                end;
                            end;
                          ChangeSelectionMode(CB_Select_Items_Selection_Drawing_Mode.ItemIndex);
                        end;
                      Exit;
                    end

                  {Unselect Pivot}
                  else
                    begin
                      Screen.Cursor:=crNone;
                      if exp0 then
                        srf_var.EventGroupsCalc(calc_arr,[16,27,30,31,32]);
                      sel_var.sel_pts:=True;
                      ChangeSelectionMode(CB_Select_Items_Selection_Drawing_Mode.ItemIndex);
                      KeysEnable0;
                      TV_Scene_Tree.Items.ClearMultiSelection(True);
                      UnsPnlsCalc;
                    end;

                  L_Object_Info.Visible:=(not move_pvt) and show_obj_info;

                end;

          end;

      end;

    (mbMiddle):
      begin

        {Minimize Circle Selection}
        if down_select_items_ptr^ then
          with sel_var,srf_var,crc_sel_var do
            begin
              LowerBmpToMainBmp;
              need_repaint:=True;
              MinimizeCircleSelection;
              CnvToCnv(srf_bmp_rct,Canvas,srf_bmp.Canvas,SRCCOPY);
              need_repaint:=False;
            end;

      end;

    (mbRight):
      begin

        {Pivot To Point Begin}
        with srf_var,sln_var,pvt_var do
          if down_select_items_ptr^ and
             move_pvt_to_pt_button   and
             (sqr(pvt_pos.x-x)+
              sqr(pvt_pos.y-y)<=crc_sel_var.crc_rad_sqr) then
            begin
              pvt_to_pt:=not pvt_to_pt;
              case CB_Select_Items_Selection_Drawing_Mode.ItemIndex of
                0,1:
                  with crc_sel_var do
                    begin
                      draw_crc_sel:=not pvt_to_pt;
                      crc_sel_rct :=Default(TRect);
                    end;
                2:rct_sel_var.rct_sel:=Default(TRect);
              end;
              ArrClear(dup_pts_arr,inn_wnd_rct,srf_bmp.width);
              AddSplineDupPtsAll(0,sln_obj_cnt-1);
              L_Object_Info.Visible:=not pvt_to_pt;
              if I_Visibility_Panel.Visible then
                 I_Visibility_Panel.Visible:=False;
            end;

      end;

  end;

end; {$endregion}
procedure TF_MainForm.FormMouseUp       (sender:TObject; button:TMouseButton; shift:TShiftState; x,y:integer);     {$region -fold}
begin

  {if down_play_anim_ptr^ then
    begin
      ////
      Exit;
    end;}

  {Brush------------------} {$region -fold}
  draw_brush:=False; {$endregion}

  {Spray------------------} {$region -fold}
  draw_spray:=False; {$endregion}

  {Add Spline-------------} {$region -fold}
  if show_spline                   and
     down_spline_ptr^              and
    ((CB_Spline_Mode.ItemIndex=0)  or
     (CB_Spline_Mode.ItemIndex=2)) and
     (CB_Spline_Type.ItemIndex=0)  and
     add_spline_calc               then
    with srf_var,sln_var do
      begin
        draw_spline:=False;
        KeysEnable0;
        EventGroupsCalc(calc_arr,[12,30,31,33,40,41]);
        VisibilityChange(srf_var.inner_window_ui_visible);
        SpeedButtonRepaint;
      end; {$endregion}

  {Finish Points Selection} {$region -fold}
  if show_spline            and
     down_select_items_ptr^ and
     sel_var.sel_pts        and
     (not pvt_var.move_pvt) then
    with srf_var,sln_var,sel_var,crc_sel_var,pvt_var do
      begin
        EventGroupsCalc(calc_arr,[6,20,30,41,48]+[41+Byte(sel_pts_cnt>0)]);
        pvt_draw_sel_eds_off:=pvt_pos;
        sel_pts             :=False;
        need_align_pivot_p2 :=True;
        SpeedButtonRepaint;
        KeysDisable0;
      end; {$endregion}

end; {$endregion}
procedure TF_MainForm.FormDblClick      (sender:TObject);                                                          {$region -fold}
begin

  {Add Spline} {$region -fold}
  if show_spline and down_spline_ptr^ and
     (CB_Spline_Mode.ItemIndex=1)     and
     (CB_Spline_Type.ItemIndex=0)    then
    with srf_var,sln_var do
      begin
        Dec(sln_pts_cnt);
        Dec(sln_pts_cnt_add);
        draw_spline:=False;
        KeysEnable0;
        EventGroupsCalc(calc_arr,[12,30,31,33,40,41]);
        VisibilityChange(show_visibility_panel);
        SpeedButtonRepaint;
      end; {$endregion}

end; {$endregion}
procedure TF_MainForm.FormPaint         (sender:TObject);                                                          {$region -fold}
begin
  with srf_var do
    if (not need_repaint) then
      CnvToCnv(srf_bmp_rct,
               F_MainForm.Canvas,
               srf_bmp.Canvas,
               SRCCOPY);
end; {$endregion}
procedure TF_MainForm.FormMouseWheelDown(sender:TObject; shift:TShiftState; mousePos:TPoint; var handled:boolean); {$region -fold}
begin
  if drawing_area_enter_calc then
    begin
      {Check Exit-----} {$region -fold}
      if  sln_var.draw_spline            or
         (srf_var.inn_wnd_rct.width <=0) or
         (srf_var.inn_wnd_rct.height<=0) or
        ((sel_var.sel_pts_cnt        >0) and
         (Shift<>[ssCtrl]))              then
        Exit; {$endregion}
      if (Shift<>[ssCtrl]) then
        begin
          with obj_var,cmr_var,srf_var,rgr_var,sgr_var,crc_sel_var do
            begin
              if (scl_dif<-17{20}) then
                Exit;
              Dec(scl_dif);
              scl_dir:=sdDown;
              if down_select_items_ptr^ then
                crc_sel_rct:=Default(TRect);
              if down_play_anim_ptr^ then
                SetObjBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct,0,obj_cnt-1);
              EventGroupsCalc(calc_arr,[8,9,18,19,23,24,29,30,31,32,41]+[41+7*Byte(down_select_items_ptr^)]);
            end;
        end
      else
        {Resize And Draw Circle Selection}
        if down_select_items_ptr^ then
          with sel_var,crc_sel_var,brs_sel_var do
            begin
              if (crc_rad<11) then
                Exit;
              crc_rad       -=10;
              crc_rad_sqr   :=crc_rad*crc_rad;
              resize_crc_sel:=False;
              draw_crc_sel  :=False;
              draw_brs_sel  :=False;
              case CB_Select_Items_Selection_Drawing_Mode.ItemIndex of
                0,1:
                  with srf_var do
                    begin
                      need_repaint:=True;
                      LowerBmp2ToMainBmp;
                      ResizeCircleSelectionModeDraw;
                      AddCircleSelection;
                      CrtCircleSelection;
                      with crc_sel_rct do
                        FilSelPtsObj(left,top);
                      CnvToCnv(srf_bmp_rct,Canvas,srf_bmp.Canvas,SRCCOPY);
                      need_repaint      :=False;
                      crc_rad_invalidate:=crc_rad;
                      draw_crc_sel      :=True;
                      resize_crc_sel    :=True;
                    end;
              end;
            end;
    end;
  SpeedButtonRepaint;
end; {$endregion}
procedure TF_MainForm.FormMouseWheelUp  (sender:TObject; shift:TShiftState; mousePos:TPoint; var handled:boolean); {$region -fold}
var
  max_sqr,min_sqr: integer;
begin
  if drawing_area_enter_calc then
    begin
      {Check Exit-----} {$region -fold}
      if  sln_var.draw_spline            or
         (srf_var.inn_wnd_rct.width <=0) or
         (srf_var.inn_wnd_rct.height<=0) or
        ((sel_var.sel_pts_cnt        >0) and
         (Shift<>[ssCtrl]))              then
        Exit; {$endregion}
      if (Shift<>[ssCtrl]) then
        begin
          with obj_var,cmr_var,srf_var,tex_var,rgr_var,sgr_var,crc_sel_var do
            begin
              if (Trunc(Math.Max(tex_bmp_rct_pts[1].x-tex_bmp_rct_pts[0].x,tex_bmp_rct_pts[1].y-tex_bmp_rct_pts[0].y)/50)>Math.Min(inn_wnd_rct.width,inn_wnd_rct.height)) then
                Exit;
              Inc(scl_dif);
              scl_dir:=sdUp;
              if down_select_items_ptr^ then
                crc_sel_rct:=Default(TRect);
              if down_play_anim_ptr^ then
                SetObjBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct,0,obj_cnt-1);
              EventGroupsCalc(calc_arr,[8,9,18,19,23,24,29,30,31,32,41]+[41+7*Byte(down_select_items_ptr^)]);
            end;
        end
      else
        {Resize And Draw Circle Selection}
        if down_select_items_ptr^ then
          with sel_var,srf_var,crc_sel_var,brs_sel_var do
            begin
              if (crc_rad<<1+20>=Min(inn_wnd_rct.width,inn_wnd_rct.height)) or
                 (crc_rad<<1+20>=00000000000000000000000000000000000004096) then
                Exit;
              crc_rad       +=10;
              crc_rad_sqr   :=crc_rad*crc_rad;
              resize_crc_sel:=False;
              draw_crc_sel  :=False;
              draw_brs_sel  :=False;
              case CB_Select_Items_Selection_Drawing_Mode.ItemIndex of
                0,1:
                  begin
                    need_repaint:=True;
                    LowerBmp2ToMainBmp;
                    ResizeCircleSelectionModeDraw;
                    AddCircleSelection;
                    CrtCircleSelection;
                    with crc_sel_rct do
                      FilSelPtsObj(left,top);
                    CnvToCnv(srf_bmp_rct,Canvas,srf_bmp.Canvas,SRCCOPY);
                    need_repaint      :=False;
                    crc_rad_invalidate:=crc_rad;
                    draw_crc_sel      :=True;
                    resize_crc_sel    :=True;
                  end;
              end;
            end;
    end;
  SpeedButtonRepaint;
end; {$endregion}
procedure TF_MainForm.FormKeyPress      (sender:TObject; var key:char);                                            {$region -fold}
begin

  {Change Pivot Mode-} {$region -fold}
  if (key=#32{'space'}) then
    if down_select_items_ptr^ then
      with srf_var,sel_var do
        begin
          need_repaint:=True;
          if (sel_pts_cnt>0) then
            with pvt_var do
              begin
                LowerBmpToMainBmp;
                case pvt_mode of
                  (pmPivotMove  ): pvt_mode:=(pmPivotScale );
                  (pmPivotScale ): pvt_mode:=(pmPivotRotate);
                  (pmPivotRotate): pvt_mode:=(pmPivotMove  );
                end;
                Screen.Cursor:=crNone;
                fill_bmp_only:=True;
                FillSelBmpAndSelPtsBRectDraw;
                fill_bmp_only:=False;
                PivotDraw(Ptpos(0,0),Trunc(pvt_pos.x),Trunc(pvt_pos.y));
              end
          else
            begin
              LowerBmp2ToMainBmp;
              if (CB_Select_Items_Selection_Drawing_Mode.ItemIndex=CB_Select_Items_Selection_Drawing_Mode.Items.Count-1) then
                CB_Select_Items_Selection_Drawing_Mode.ItemIndex:=0
              else
                CB_Select_Items_Selection_Drawing_Mode.ItemIndex:=CB_Select_Items_Selection_Drawing_Mode.ItemIndex+1;
              ChangeSelectionMode(CB_Select_Items_Selection_Drawing_Mode.ItemIndex);
            end;
          CnvToCnv(srf_bmp_rct,Canvas,srf_bmp.Canvas,SRCCOPY);
          need_repaint:=False;
        end; {$endregion}

  {Change Spline Mode} {$region -fold}
  if (key=#32{'space'}) then
    if down_spline_ptr^ then
      with sln_var do
        if (global_prop.sln_type=stFreeHand) then
          begin
            if (CB_Spline_Mode.ItemIndex=CB_Spline_Mode.Items.Count-1) then
              CB_Spline_Mode.ItemIndex:=0
            else
              CB_Spline_Mode.ItemIndex:=CB_Spline_Mode.ItemIndex+1;
            SplineModeSelect;
          end; {$endregion}

  {Check Exit--------} {$region -fold}
  if (sel_var.sel_pts_cnt        >0) or
     (sln_var.draw_spline          ) or
     (is_scene_tree_editing        ) or
     (srf_var.inn_wnd_rct.width <=0) or
     (srf_var.inn_wnd_rct.height<=0) then
    Exit;
  if down_play_anim_ptr^ then
     begin
       {if (key=#32{'space'}) then
         time_interval:=-1;}
       Exit;
     end; {$endregion}

  {Switch Buttons----} {$region -fold}
  RM_Description.Lines.Text:='';
  if (key=Char(key_arr[04]{#49})) or (key=Char(key_alt_arr[04]{' '})) then
    begin
      ButtonKeyPress(SB_Text                 ,P_Text                 ,P_Draw_Custom_Panel,P_Drawing_Buttons,down_text_ptr                 ,0,000001);
      if (not down_text_ptr^) then
        Exit;
    end;
  // button 'Brush':
  if (key=Char(key_arr[05]{#50})) or (key=Char(key_alt_arr[05]{' '})) then
    begin
      ButtonKeyPress(SB_Brush                ,P_Brush                ,P_Draw_Custom_Panel,P_Drawing_Buttons,down_brush_ptr                ,0,000002);
      if (not down_brush_ptr^) then
        Exit;
    end;
  // button 'Spray':
  if (key=Char(key_arr[06]{#51})) or (key=Char(key_alt_arr[06]{' '})) then
    begin
      ButtonKeyPress(SB_Spray                ,P_Spray                ,P_Draw_Custom_Panel,P_Drawing_Buttons,down_spray_ptr                ,0,000003);
      if (not down_spray_ptr^) then
        Exit;
    end;
  // button 'Spline':
  if (key=Char(key_arr[07]{#52})) or (key=Char(key_alt_arr[07]{'q'})) then
    begin
      ButtonKeyPress(SB_Spline               ,P_Spline               ,P_Draw_Custom_Panel,P_Drawing_Buttons,down_spline_ptr               ,0,000004);
      if (not down_spline_ptr^) then
        Exit;
      AddDocContent(RM_Description,curve_doc_str_arr,curve_doc_font_arr,0);
    end;
  // button 'Select Items/Points':
  if (key=Char(key_arr[08]{#53})) or (key=Char(key_alt_arr[08]{'e'})) then
    begin
      ButtonKeyPress(SB_Select_Items         ,P_Select_Items         ,P_Draw_Custom_Panel,P_Drawing_Buttons,down_select_items_ptr         ,0,crNone);
      if (not down_select_items_ptr^) then
        Exit;
    end;
  // button 'Select Texture Region':
  if (key=Char(key_arr[09]{#54})) or (key=Char(key_alt_arr[09]{' '})) then
    begin
      ButtonKeyPress(SB_Select_Texture_Region,P_Select_Texture_Region,P_Draw_Custom_Panel,P_Drawing_Buttons,down_select_texture_region_ptr,0,000006);
      if (not down_select_texture_region_ptr^) then
        Exit;
    end;
  // button 'Regular Grid':
  if (key=Char(key_arr[10]{#54})) or (key=Char(key_alt_arr[10]{' '})) then
    begin
      ButtonKeyPress(SB_RGrid                ,P_RGrid                ,P_Draw_Custom_Panel,P_Drawing_Buttons,down_rgrid_ptr                ,0,000007);
      if (not down_rgrid_ptr^) then
        Exit;
    end;
  // button 'Snap Grid':
  if (key=Char(key_arr[11]{#54})) or (key=Char(key_alt_arr[11]{' '})) then
    begin
      ButtonKeyPress(SB_SGrid                ,P_SGrid                ,P_Draw_Custom_Panel,P_Drawing_Buttons,down_sgrid_ptr                ,0,000008);
      if (not down_sgrid_ptr^) then
        Exit;
    end; {$endregion}

end; {$endregion}
procedure TF_MainForm.FormKeyDown       (sender:TObject; var key:word; shift:TShiftState);                         {$region -fold}
begin

  is_active:=True;

  with obj_var,srf_var,sln_var,tex_var,sel_var,pvt_var do
    begin

      case Key of
        {VK_LEFT,VK_RIGHT,VK_UP,VK_DOWN: Key:=0;}
        {#9  } VK_TAB : {$region -fold}
          if (not down_play_anim_ptr^) then
            begin
              VisibilityChange(True);
              srf_var.inner_window_ui_visible:=True;
              show_visibility_panel          :=True;
            end; {$endregion}
      end;

      {Check Exit-----} {$region -fold}
      if (sel_pts_cnt        >0) or
         (draw_spline          ) or
         (is_scene_tree_editing) or
         (inn_wnd_rct.width <=0) or
         (inn_wnd_rct.height<=0) then
        Exit; {$endregion}

      {if T_Menu.Enabled then
        begin
          case Key of
            65,68,87,83: PlaySound(PChar(SELECT_ITEM),0,SND_ASYNC);
          end;
          case Key of
            {'Enter'}13:
              if (menu_img_arr_cnt=0) then
                begin
                  mciSendString(PChar('stop "'+MENU_THEME+'"'),nil,0,0);
                  T_Menu.Enabled:=False;
                  T_Game.Enabled:=True;
                end;
            {'a'}65:
              begin

              end;
            {'d'}68:
              begin

              end;
            {'w'}87:
              begin
                menu_img_arr_cnt-=1;
                if (menu_img_arr_cnt=-1) then
                  menu_img_arr_cnt:=2;
              end;
            {'s'}83:
              begin
                menu_img_arr_cnt+=1;
                if (menu_img_arr_cnt=3) then
                  menu_img_arr_cnt:=0;
              end;
          end;
          Exit;
        end;}

      if T_Game.Enabled or T_Game_Loop.Enabled then
        begin
          case Key of
            {'a'}65:
              cmr_var.dir_a:=True;
            {'d'}68:
              cmr_var.dir_d:=True;
            {'w'}87:
              cmr_var.dir_w:=True;
            {'s'}83:
              cmr_var.dir_s:=True;
          end;
          Exit;
        end;

      if down_play_anim_ptr^ then
        Exit;

      case Key of
        65,68,87,83:
          begin
            draw_spline:=False;
            sel_pts    :=False;
          end;
      end;

      case Key of
        65,68,87,83:
          begin
            SetObjBkgnd
            (
              low_bmp_ptr,
              low_bmp.width,
              low_bmp.height,
              @inn_wnd_rct,
              0,
              low_lr_obj_cnt-1
            );
          end;
      end;

      case Key of
        {
        {   }{'Alt'}18:
        if need_align_pivot_p2 then
          begin
            ArrClear(dup_pts_arr,inn_wnd_rct,srf_bmp.width);
            AddSplineDupPtsAll(0,sln_obj_cnt-1);
            pvt_prev.x         :=pvt_pos.x;
            pvt_prev.y         :=pvt_pos.y;
            need_align_pivot_p2:=False;
          end;}

        {#97 }{'a'} 65: {$region -fold}
          begin
            MovLeft;
            FilLeft
            (
              low_bmp_ptr,
              low_bmp.width,
              low_bmp.height,
              inn_wnd_rct
            );
            MovScene(0,low_lr_obj_cnt-1);
          end; {$endregion}

        {#100}{'d'} 68: {$region -fold}
          begin
            MovRight;
            FilRight
            (
              low_bmp_ptr,
              low_bmp.width,
              low_bmp.height,
              inn_wnd_rct
            );
            MovScene(0,low_lr_obj_cnt-1);
          end; {$endregion}

        {#119}{'w'} 87: {$region -fold}
          begin
            MovUp;
            FilUp
            (
              low_bmp_ptr,
              low_bmp.width,
              low_bmp.height,
              inn_wnd_rct
            );
            MovScene(0,low_lr_obj_cnt-1);
          end; {$endregion}

        {#115}{'s'} 83: {$region -fold}
          begin
            MovDown;
            FilDown
            (
              low_bmp_ptr,
              low_bmp.width,
              low_bmp.height,
              inn_wnd_rct
            );
            MovScene(0,low_lr_obj_cnt-1);
          end; {$endregion}

      end;

      case Key of

        65,68,87,83   : {$region -fold}
          with obj_var,srf_var,sgr_var,sel_var,pvt_var do
            begin
              {Background Drawing1--------} {$region -fold}
              LowerBmpToMainBmp; {$endregion}
              {Draw Objects of Upper Layer} {$region -fold}
              if (upp_lr_obj_cnt>0) then
                begin
                  SetObjBkgnd
                  (
                    srf_bmp_ptr,
                    srf_bmp.width,
                    srf_bmp.height,
                    @inn_wnd_rct,
                    low_lr_obj_cnt,
                    obj_cnt-1
                  );
                  SetRctDstPtr(@inn_wnd_rct,low_lr_obj_cnt,obj_cnt-1);
                  MovScene    (             low_lr_obj_cnt,obj_cnt-1);
              end; {$endregion}
              {Hide Panels----------------} {$region -fold}
              VisibilityChange(False);
              {$endregion}
              {Pivot Drawing--------------} {$region -fold}
              if (sel_pts_cnt>0) then
                begin
                  PivotDraw(srf_var.world_axis_shift,Trunc(pvt_pos.x),Trunc(pvt_pos.y));
                  IsPivotOutOfInnerWindow(pvt_axis_rect,pvt_pos);
                end; {$endregion}
              {World Axis Drawing---------} {$region -fold}
              if show_world_axis then
                WorldAxisDraw; {$endregion}
              {Inner Window Rectangle-----} {$region -fold}
              if (inn_wnd_mrg>0) then
                InnerWindowDraw($00FF9F66); {$endregion}
              {Reset Some Var.------------} {$region -fold}
              srf_bmp.Canvas.CopyMode:=cmSrcCopy;
              crc_sel_var.crc_sel_rct:=Default(TRect); {$endregion}
              {Background Drawing2--------} {$region -fold}
              CnvToCnv
              (
                srf_bmp_rct,
                Canvas,
                srf_bmp.Canvas,
                SRCCOPY
              ); {$endregion}
            end; {$endregion}

      end;

    end;

end; {$endregion}
procedure TF_MainForm.FormKeyUp         (sender:TObject; var key:word; shift:TShiftState);                         {$region -fold}
begin

  with obj_var,srf_var,sln_var,tex_var,sel_var,pvt_var do
    begin

      case Key of
        {VK_LEFT,VK_RIGHT,VK_UP,VK_DOWN: Key:=0;}
        {#9} VK_TAB: {$region -fold}
          begin
            VisibilityChange(False);
            srf_var.inner_window_ui_visible:=False;
            show_visibility_panel          :=False;
            F_Hot_Keys.Visible             :=False;
            InvalidateInnerWindow;
            crc_sel_var.crc_sel_rct:=Default(TRect);
          end; {$endregion}
      end;

      {Check Exit-----} {$region -fold}
      if (sel_pts_cnt        >0) or
         (draw_spline          ) or
         (is_scene_tree_editing) or
         (inn_wnd_rct.width <=0) or
         (inn_wnd_rct.height<=0) then
        Exit; {$endregion}

      is_active       :=False;
      downtime_counter:=0;

      if T_Game.Enabled or T_Game_Loop.Enabled then
        begin
          case Key of
            65,68,87,83: cmr_var.mov_dir:=mdNone;
          end;
          case Key of
            {'a'}65:
              cmr_var.dir_a:=False;
            {'d'}68:
              cmr_var.dir_d:=False;
            {'w'}87:
              cmr_var.dir_w:=False;
            {'s'}83:
              cmr_var.dir_s:=False;
          end;
          //Exit;
        end;

      {if T_Menu.Enabled then
        Exit;}

      {if T_Game.Enabled then
        Exit;}

      {if down_play_anim_ptr^ then
        Exit;}

      case Key of

        65,68,87,83:
          begin
            if (not down_play_anim_ptr^) then
              begin
                VisibilityChange(srf_var.inner_window_ui_visible);
                show_visibility_panel:=True;
              end;
            with obj_var,srf_var do
              SetObjBkgnd
              (
                srf_bmp_ptr,
                srf_bmp.width,
                srf_bmp.height,
                @inn_wnd_rct,
                0,
                obj_cnt-1
              );
            srf_var.EventGroupsCalc(calc_arr,[{6,9,}18,{20,23,}30,{31,}32,41]+[41+7*Byte(down_select_items_ptr^)]);
            if down_play_anim_ptr^ then
              with obj_var,srf_var do
                begin
                  SetObjBkgnd
                  (
                    low_bmp_ptr,
                    low_bmp.width,
                    low_bmp.height,
                    @inn_wnd_rct,
                    0,
                    low_lr_obj_cnt-1
                  );
                  {if (upp_lr_obj_cnt>0) then
                    SetObjBkgnd
                    (
                      srf_bmp_ptr,
                      srf_bmp.width,
                      srf_bmp.height,
                      @inn_wnd_rct,
                      low_lr_obj_cnt,
                      obj_cnt-1
                    );}
                end;
          end;

      end;

      SpeedButtonRepaint;

  end;

end; {$endregion}
procedure TF_MainForm.FormMouseEnter    (sender:TObject);                                                          {$region -fold}
begin
  {Add Actor} {$region -fold}
  //if down_add_actor_ptr^ then
    with srf_var,fast_actor_set_var.d_icon,fast_image_proc_var do
      begin
        fast_image_data_ptr0:=@fast_image_data;
        SetBkgnd (srf_bmp_ptr,
                  srf_bmp.width,
                  srf_bmp.height,
                  inn_wnd_rct);
      end; {$endregion}
  {if anim_play then
    OnMouseMove:=Nil;}
  drawing_area_enter_calc:=True;
  DefocusControl(ActiveControl,True);
  KeysEnable0;
  {Play Anim} {$region -fold}
  if down_play_anim_ptr^ then
    begin
      Screen.Cursor:=crNone;
      Exit;
    end
  else
    Screen.Cursor:=crDefault; {$endregion}
  if down_text_ptr^ then
    Screen.Cursor:=1;
  if down_brush_ptr^ then
    Screen.Cursor:=2;
  if down_spray_ptr^ then
    Screen.Cursor:=3;
  if down_spline_ptr^ then
    Screen.Cursor:=4;
  if down_select_items_ptr^ then
    begin
      Screen.Cursor:=crNone;
      if (CB_Select_Items_Selection_Drawing_Mode.ItemIndex=1) then
        brs_sel_var.draw_brs_sel:=True;
      crc_sel_var.crc_sel_rct   :=Default(TRect);
      rct_sel_var.rct_sel       :=Default(TRect);
    end;
  if down_select_texture_region_ptr^ then
    Screen.Cursor:=6;
  if down_rgrid_ptr^ then
    Screen.Cursor:=7;
  if down_sgrid_ptr^ then
    Screen.Cursor:=8;
end; {$endregion}
procedure TF_MainForm.FormMouseLeave    (sender:TObject);                                                          {$region -fold}
begin
  drawing_area_enter_calc:=False;
  if down_select_items_ptr^ then
    case CB_Select_Items_Selection_Drawing_Mode.ItemIndex of
      0,1:
        with crc_sel_var,brs_sel_var do
          begin
            resize_crc_sel:=False;
            draw_brs_sel  :=False;
            crc_sel_rct   :=Default(TRect);
            InvalidateInnerWindow;
          end;
    end;
  Screen.Cursor:=crDefault;
end; {$endregion}
procedure TF_MainForm.FormCreate        (sender:TObject);                                                          {$region -fold}
var
  color_info      : TColorInfo;
  world_axis_shift: TPtPos;
  i               : integer;
begin

  exec_timer:=TPerformanceTime.Create;

  {Documentation-------------} {$region -fold}
  RM_Description.Transparent:=True;
  HintsFontArrInit; {$endregion}

  {Fast Image Proc. Var Init.} {$region -fold}
  fast_image_proc_var:=TFastImageProc.Create; {$endregion}

  {Post-Process Init.--------} {$region -fold}
  PPDec2ProcInit;
  ArrFillProcInit;
  PPBlurProcInit; {$endregion}

  {Scene Tree----------------} {$region -fold}
  obj_var:=TSceneTree.Create;
  if (srf_var<>Nil) then
    world_axis_shift:=srf_var.world_axis_shift
  else
    world_axis_shift:=Default(TPtPos);
  obj_var.Add(kooEmpty,world_axis_shift);
  CreateNode('','0',True);
  ObjIndsCalc;
  ScTIndsCalc;
  CngPnVsCalc; {$endregion}

  {General-------------------} {$region -fold}

    {Window Splitters} {$region -fold}
    S_Splitter0.height     :=splitter_thickness;
    S_Splitter1.left       :=0;
    S_Splitter1.width      :=splitter_thickness;
    S_Splitter2.height     :=splitter_thickness;
    S_Splitter3.left       :=F_MainForm.width;
    S_Splitter3.width      :=splitter_thickness;
    S_Splitter4.height     :=splitter_thickness;
    P_Splitter5.height     :=splitter_thickness;
    S_Splitter6.height     :=splitter_thickness;
    S_Splitter7.top        :=(F_MainForm.height+S_Splitter6.top)>>1;
    S_Splitter7.height     :=splitter_thickness;
    splitters_arr[0]       :=Unaligned(@S_Splitter0.top );
    splitters_arr[1]       :=Unaligned(@S_Splitter1.left);
    splitters_arr[2]       :=Unaligned(@S_Splitter2.top );
    splitters_arr[3]       :=Unaligned(@S_Splitter3.left);
    splitters_arr[4]       :=Unaligned(@S_Splitter4.top );
    splitters_arr[5]       :=Unaligned(@P_Splitter5.top );
    splitters_arr[6]       :=Unaligned(@S_Splitter6.top );
    splitters_arr[7]       :=Unaligned(@S_Splitter7.top );
    treeview_splitter_shift:=S_TreeView_Splitter.Left-S_Splitter3.left; {$endregion}

    {Misc. Settings--} {$region -fold}
    MaxSpriteWHRctInit(max_sprite_w_h_rct);
    AutoScale;
    bkg_pp_calc              :=False;
    show_spline_pts_b_rect_1 :=False;
    show_spline_pts_b_rect_2 :=False;
    show_selected_pts_b_rect :=False;
    Application.HintPause    :=250;
    Application.HintHidePause:=3000;
    for i:=0 to ComponentCount-1 do
      if (Components[i] is TWinControl) then
         (Components[i] as TWinControl).TabStop:=False;
    F_MainForm.Menu  :=Nil;
    //F_MainForm.Menu:=MainMenu1;
    MouseMoveProcInit(P_Drawing_Buttons  ,@P_Drawing_ButtonsMouseMove   );
    MouseMoveProcInit(P_Animation_Buttons,@P_Animation_ButtonsMouseMove );
    ini_var:=TIniFile.Create(ExtractFilePath(ParamStr(0))+'settings.ini');
    TrayIcon1.Show; {$endregion}

    {Buttons:File----} {$region -fold}
    for i:=0 to SB_Image_List.ControlCount-1 do
      SB_Image_List.Controls[i].Anchors:=[akLeft,akTop,akRight,akBottom]; {$endregion}

    {Buttons:Draw----} {$region -fold}
    SetLength(P_Drawing_Buttons_ClickArr,P_Drawing_Buttons.ControlCount);
    for i:=0 to P_Drawing_Buttons.ControlCount-1 do
      P_Drawing_Buttons_ClickArr[i]:=(P_Drawing_Buttons.Controls[i] as TSpeedButton).OnClick;
    for i:=0 to SB_Drawing.ControlCount-1 do
      SB_Drawing.Controls[i].Anchors:=[akLeft,akTop,akRight,akBottom];
    prev_panel_draw                 :=P_Draw_Custom_Panel;
    curr_panel_draw                 :=P_Spline;
    P_Draw_Custom_Panel.Visible     :=False; {$endregion}

    {Buttons:AnimK---} {$region -fold}
    SetLength(P_Animation_Buttons_ClickArr,P_Animation_Buttons.ControlCount);
    for i:=0 to P_Animation_Buttons.ControlCount-1 do
      P_Animation_Buttons_ClickArr[i]:=(P_Animation_Buttons.Controls[i] as TSpeedButton).OnClick;
    for i:=0 to SB_AnimK.ControlCount-1 do
      SB_AnimK.Controls[i].Anchors:=[akLeft,akTop,akRight,akBottom];
    prev_panel_animk              :=P_AnimK_Custom_Panel;
    curr_panel_animk              :=P_Map_Editor;
    P_AnimK_Custom_Panel.Visible  :=False; {$endregion}

  {$endregion}

  {Visibility Panel----------} {$region -fold}
  visibility_panel_picture                          :=Graphics.TBitmap.Create;
  visibility_panel_picture         .width           :=I_Visibility_Panel.width;
  visibility_panel_picture         .height          :=I_Visibility_Panel.height;
  I_Visibility_Panel.Picture.Bitmap.width           :=I_Visibility_Panel.width;
  I_Visibility_Panel.Picture.Bitmap.height          :=I_Visibility_Panel.height;
  I_Visibility_Panel.Picture.Bitmap.TransparentColor:=clBlack;
  SelectionBoundsRepaint; {$endregion}

  {Buttons Icons-------------} {$region -fold}
  BB_Reset_Pivot        .Glyph:=SB_Move_Pivot_To_Point.Glyph;
  SB_Visibility_Show_All.Glyph:=SB_Spline_Points_Show .Glyph; {$endregion}

  {Camera--------------------} {$region -fold}
  cmr_var:=TCamera.Create(I_Frame_List.width,
                          I_Frame_List.height); {$endregion}

  {Main Layer----------------} {$region -fold}
  srf_var:=TSurface.Create(width,height); {$endregion}

  {Texture-------------------} {$region -fold}
  tex_var:=TTex.Create(512,512); {$endregion}

  {Snap Grid-----------------} {$region -fold}
  sgr_var       :=TSGrid.Create(width,height);
  down_sgrid_ptr:=Unaligned(@SB_SGrid.Down); {$endregion}

  {Grid----------------------} {$region -fold}
  rgr_var             :=TRGrid.Create(width,height);
  SB_RGrid_Color.Color:=rgr_var.rgrid_color;
  down_rgrid_ptr      :=Unaligned(@SB_RGrid.Down); {$endregion}

  {Text----------------------} {$region -fold}
  txt_var      :=TFText.Create(width,height);
  down_text_ptr:=Unaligned(@SB_Text.Down); {$endregion}

  {Brush---------------------} {$region -fold}
  CB_Brush_Mode.ItemIndex:=00;
  SE_Brush_Radius.Value  :=10;
  SE_Brush_Hardness.Value:=10;
  down_brush_ptr         :=Unaligned(@SB_Brush.Down); {$endregion}

  {Spray---------------------} {$region -fold}
  down_spray_ptr:=Unaligned(@SB_Spray.Down); {$endregion}

  {Spline--------------------} {$region -fold}
  CB_Spline_Mode.ItemIndex:=0;
  down_spline_ptr         :=Unaligned(@SB_Spline.Down);
  sln_var                 :=TCurve.Create(width,height);
  SplinesTemplatesNamesInit(sln_var); {$endregion}

  {Colliders-----------------} {$region -fold}
  show_collider:=True; {$endregion}

  {Select Items--------------} {$region -fold}
  sel_var:=TSelIts.Create(width,height);
  down_select_items_ptr:=Unaligned(@SB_Select_Items.Down); {$endregion}

  {Select Texture Region-----} {$region -fold}
  down_select_texture_region_ptr:=Unaligned(@SB_Select_Texture_Region.Down); {$endregion}

  {UV------------------------} {$region -fold}
  uv_var:=TUV.Create(width,height); {$endregion}

  {Intersection Graph--------} {$region -fold}
  isg_var:=TISGraph.Create(width,height); {$endregion}

  {Pivot---------------------} {$region -fold}
  pvt_var:=TPivot.Create(25,25); {$endregion}

  {Circle Selection----------} {$region -fold}
  crc_sel_var:=TCrcSel.Create; {$endregion}

  {Brush Selection-----------} {$region -fold}
  brs_sel_var:=TBrsSel.Create; {$endregion}

  {Rectangle Selection-------} {$region -fold}
  rct_sel_var:=TRctSel.Create; {$endregion}

  {Play Animation------------} {$region -fold}
  down_play_anim_ptr :=Unaligned(@SB_Play_Anim.Down);
  obj_var.res_var_ptr:=down_play_anim_ptr; {$endregion}

  {Tile Map -----------------} {$region -fold}
  tlm_var              :=TTlMap.Create;
  SB_Map_Editor.Down   :=True;
  P_Map_Editor .Visible:=True;
  down_map_editor_ptr  :=Unaligned(@SB_Map_Editor.Down); {$endregion}

  {Add Actor-----------------} {$region -fold}
  with srf_var do
    fast_actor_set_var:=TFastActorSet.Create(srf_bmp_ptr,
                                             srf_bmp.width,
                                             srf_bmp.height,
                                             inn_wnd_rct,
                                             max_sprite_w_h_rct,
                                             Application.Location+DEFAULT_ACTOR_ICON,
                                             @IL_Add_Actor_Default_Icon.GetBitmap);
  img_lst_bmp:=CrtTBmpInst(I_Frame_List.width,
                           I_Frame_List.height,
                           img_lst_bmp_ptr);
  SetColorInfo($00957787,color_info);
  PPFloodFill(img_lst_bmp_ptr,
              PtBounds(0,0,img_lst_bmp.Width,img_lst_bmp.height),
              img_lst_bmp.Width,
              color_info.pix_col);
  with img_lst_bmp do
    begin
      SetTextInfo   (Canvas);
      Canvas.TextOut(width >>1-80,
                     height>>1-16,
                     'Frame List is Empty');
    end;
  with img_lst_bmp.Canvas do
    begin
      Brush.Style:=bsClear;
      Pen.Mode   :=pmCopy;
      Pen.Color  :=clBlue;
    end;
  img_lst_bmp.Canvas.Rectangle(0,0,
                               img_lst_bmp.width,
                               img_lst_bmp.height);
  CnvToCnv(PtBounds(0,0,
                    img_lst_bmp.width,
                    img_lst_bmp.height),
           I_Frame_List.Canvas,
           img_lst_bmp .Canvas,
           SRCCOPY);
  down_add_actor_ptr:=@SB_Add_Actor.Down;
  show_actor        :=True; {$endregion}

  {TimeLine------------------} {$region -fold}
  TimeLineButtonsCreate; {$endregion}

  {Cursors-------------------} {$region -fold}
  CursorsCreate;
  // 'Text' button cursor init.:
  CursorInit(1,0,Application.Location+TEXT_BUTTON_ICON                 ,@IL_Drawing_Buttons.GetBitmap);
  // 'Brush' button cursor init.:
  CursorInit(2,6,Application.Location+BRUSH_CURSOR_ICON                ,@IL_Drawing_Buttons.GetBitmap);
  // 'Spray' button cursor init.:
  CursorInit(3,2,Application.Location+SPRAY_BUTTON_ICON                ,@IL_Drawing_Buttons.GetBitmap);
  // 'Spline' button cursor init.:
  CursorInit(4,3,Application.Location+SPLINE_BUTTON_ICON               ,@IL_Drawing_Buttons.GetBitmap);
  // 'Select Points' button cursor init.:
  CursorInit(5,4,Application.Location+SELECT_POINTS_BUTTON_ICON        ,@IL_Drawing_Buttons.GetBitmap);
  // 'Select Texture Region' button cursor init.:
  CursorInit(6,5,Application.Location+SELECT_TEXTURE_REGION_BUTTON_ICON,@IL_Drawing_Buttons.GetBitmap);
  // 'Select Texture Region' button cursor init.:
  CursorInit(7,7,Application.Location+REGULAR_GRID_BUTTON_ICON         ,@IL_Drawing_Buttons.GetBitmap);
  // 'Select Texture Region' button cursor init.:
  CursorInit(8,8,Application.Location+SNAP_GRID_BUTTON_ICON            ,@IL_Drawing_Buttons.GetBitmap); {$endregion}

  {Physics-------------------} {$region -fold}
  fast_physics_var:=TCollider.Create(width,height);
  fast_fluid_var  :=TFluid   .Create(0,0); {$endregion}

  {Align Canvas--------------} {$region -fold}
  tex_var.AlignPictureToCenter;
  SB_Change_LayoutClick(F_MainForm);
  S_Splitter2.top :=F_MainForm.height-045{540};
  S_Splitter8.left:=232; {$endregion}

  with srf_var do
    begin
      SetLength(useless_fld_arr_,srf_bmp.width*srf_bmp.height);
      ArrClear (useless_fld_arr_,inn_wnd_rct,  srf_bmp.width );
    end;
  SetLength(useless_arr_,1);
  useless_arr_[0]:=1;

  {Game----------------------} {$region -fold}
  {with srf_var do
    logo1_img:=TFastImage.Create(srf_bmp_ptr,
                                 srf_bmp.width,
                                 srf_bmp.height,
                                 inn_wnd_rct,
                                 max_sprite_w_h_rct,
                                 Application.Location+LOGO1);
  with logo1_img do
    begin
      col_trans_arr[02]:=255;
      nt_pix_cng_type  :=001;
      pt_pix_cng_type  :=001;
      nt_pix_cfx_type  :=002;
      pt_pix_cfx_type  :=002;
    end;

  with srf_var do
    logo2_img:=TFastImage.Create(srf_bmp_ptr,
                                 srf_bmp.width,
                                 srf_bmp.height,
                                 inn_wnd_rct,
                                 max_sprite_w_h_rct,
                                 Application.Location+LOGO2);
  with logo2_img do
    begin
      col_trans_arr[02]:=255;
      nt_pix_cng_type  :=001;
      pt_pix_cng_type  :=001;
      nt_pix_cfx_type  :=002;
      pt_pix_cfx_type  :=002;
    end;

  with srf_var do
    start_game_img:=TFastImage.Create(srf_bmp_ptr,
                                      srf_bmp.width,
                                      srf_bmp.height,
                                      inn_wnd_rct,
                                      max_sprite_w_h_rct,
                                      Application.Location+START_GAME);
  with start_game_img do
    begin
      col_trans_arr[02]:=000;
      nt_pix_cng_type  :=001;
      pt_pix_cng_type  :=001;
      nt_pix_cfx_type  :=002;
      pt_pix_cfx_type  :=002;
    end;

  with srf_var do
    settings_img:=TFastImage.Create(srf_bmp_ptr,
                                    srf_bmp.width,
                                    srf_bmp.height,
                                    inn_wnd_rct,
                                    max_sprite_w_h_rct,
                                    Application.Location+SETTINGS);
  with settings_img do
    begin
      col_trans_arr[02]:=000;
      nt_pix_cng_type  :=001;
      pt_pix_cng_type  :=001;
      nt_pix_cfx_type  :=002;
      pt_pix_cfx_type  :=002;
    end;

  with srf_var do
    save_and_exit_img:=TFastImage.Create(srf_bmp_ptr,
                                         srf_bmp.width,
                                         srf_bmp.height,
                                         inn_wnd_rct,
                                         max_sprite_w_h_rct,
                                         Application.Location+SAVE_AND_EXIT);
  with save_and_exit_img do
    begin
      col_trans_arr[02]:=000;
      nt_pix_cng_type  :=001;
      pt_pix_cng_type  :=001;
      nt_pix_cfx_type  :=002;
      pt_pix_cfx_type  :=002;
    end;

  with srf_var do
    selection_border_img:=TFastImage.Create(srf_bmp_ptr,
                                            srf_bmp.width,
                                            srf_bmp.height,
                                            inn_wnd_rct,
                                            max_sprite_w_h_rct,
                                            Application.Location+SELECTION_BORDER);
  with selection_border_img do
    begin
      col_trans_arr[02]:=200;
      nt_pix_cng_type  :=001;
      pt_pix_cng_type  :=001;
      nt_pix_cfx_type  :=002;
      pt_pix_cfx_type  :=002;
    end;

  with srf_var do
    military_head_img:=TFastImage.Create(srf_bmp_ptr,
                                            srf_bmp.width,
                                            srf_bmp.height,
                                            inn_wnd_rct,
                                            max_sprite_w_h_rct,
                                            Application.Location+MILITARY_HEAD);
  with military_head_img do
    begin
      col_trans_arr[02]:=000;
      nt_pix_cng_type  :=001;
      pt_pix_cng_type  :=001;
      nt_pix_cfx_type  :=002;
      pt_pix_cfx_type  :=002;
    end;} {$endregion}

end; {$endregion}
procedure TF_MainForm.FormActivate      (sender:TObject);                                                          {$region -fold}
var
  i  : integer;
  key: char;
begin
  {AlphaBlend:=True;
  for i:=0 to 63 do
    begin
      AlphaBlendValue:=i*4;
      {$ifdef Windows}
      Sleep(2);
      {$else}
      USleep(1000000);
      {$endif}
    end;
  AlphaBlend:=False;}
  OnActivate:=Nil;
  fill_scene_calc:=True;
  show_world_axis:=True;
  with srf_var,inn_wnd_rct do
    world_axis:=PtPos((left+right )>>1,
                      (top +bottom)>>1);
  key:=Char(key_arr[07]);
  FormKeyPress(Self,key);
  SB_Spline_Edges_ShowClick               (Self);
  SB_Spline_Points_ShowClick              (Self);
  SB_Select_Items_Outer_Subgraph_ShowClick(Self);
  SB_Select_Items_Inner_Subgraph_ShowClick(Self);
  S_TreeView_Splitter.left:=F_MainForm.width;
  SB_Centrify_PictureClick                (Self);
  RM_Description.Perform(EM_SCROLLCARET,0,0);

  {Hot Keys Panel-----} {$region -fold}
  F_Hot_Keys.Left   :=F_MainForm.left+11;
  F_Hot_Keys.Top    :=F_MainForm.top +81;
  F_Hot_Keys.Visible:=True; {$endregion}

  {OpenGL Window------} {$region -fold}
  OpenGLControl2.Visible:=False;
  OpenGLControl2.Enabled:=False; {$endregion}

  {Game Mode} {$region -fold}
  {SB_Unfold_Image_WindowClick  (Self);
  SB_Unfold_Image_WindowClick  (Self);
  SB_Original_Texture_SizeClick(Self);
  VisibilityChange             (False);
  S_Splitter0.height    :=splitter_thickness;
  S_Splitter1.left      :=0;
  S_Splitter1.width     :=splitter_thickness;
  S_Splitter2.height    :=splitter_thickness;
  S_Splitter3.left      :=F_MainForm.width;
  S_Splitter3.width     :=splitter_thickness;
  S_Splitter4.height    :=splitter_thickness;
  P_Splitter5.height    :=splitter_thickness;
  S_Splitter6.height    :=splitter_thickness;
  S_Splitter7.top       :=(F_MainForm.height+S_Splitter6.top)>>1;
  S_Splitter7.height    :=splitter_thickness;
  F_Hot_Keys.Visible    :=False;
  F_Hot_Keys.Enabled    :=False;
  Screen.Cursor         :=crNone;
  OnMouseEnter          :=Nil;
  down_play_anim_ptr^   :=True;
  {OpenGLControl2.Visible:=down_play_anim_ptr^;
  OpenGLControl2.Enabled:=down_play_anim_ptr^;}
  tlm_var.AddTileMap;
  with srf_var do
    begin
      // Get Target Render For OpenGL Output:
      GLBitmapToRect(texture_id,srf_bmp,down_play_anim_ptr^);
      //if down_play_anim_ptr^ then
      GetObject(srf_bmp.Handle,SizeOf(buffer),@buffer);
      if down_play_anim_ptr^ then
        SetBckgd
        (
          low_bmp_ptr,
          low_bmp.width,
          low_bmp.height,
          inn_wnd_rct
        )
      else
        SetBckgd
        (
          srf_bmp_ptr,
          srf_bmp.width,
          srf_bmp.height,
          inn_wnd_rct
        );
      SB_Play_AnimClick(Self);
      //T_Logo1.Enabled:=down_play_anim_ptr^; //T_Game_Loop.Enabled:=down_play_anim_ptr^;
    end;} {$endregion}

end; {$endregion}
procedure TF_MainForm.FormDestroy       (sender:TObject);                                                          {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.FormDropFiles     (sender:TObject; const file_names:array of string);                        {$region -fold}
var
  file_name: string;
begin
  for file_name in file_names do
    try
      tex_var.loaded_picture.LoadFromFile(file_name);
    except
      on E: Exception do
        MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
    end;
  tex_var.LoadTexture;
end; {$endregion}
{$endregion}

// (Scene Tree) Иерархия обьектов:
{LI} {$region -fold}
procedure ObjIndsCalc;                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  with F_MainForm.TV_Scene_Tree,obj_var do
    begin
      Items.BeginUpdate;
      for i:=0 to Items.Count-1 do
        begin
          obj_inds_arr[i]:=PNodeData(Items[i].Data)^.g_ind;
          obj_arr[obj_inds_arr[i]].t_ind:=i;
        end;
      LowLrObjCntCalc1;
      Items.EndUpdate;
    end;
end; {$endregion}
procedure ScTIndsCalc;                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i  : integer;
  i00: integer=-1;
  i01: integer=-1;
  i02: integer=-1;
  i03: integer=-1;
  i04: integer=-1;
  i05: integer=-1;
  i06: integer=-1;
  i07: integer=-1;
  i08: integer=-1;
  i09: integer=-1;
  i10: integer=-1;

  procedure SetIndsSctArrVal(var obj_inds_sct_arr:TColorArr; var ind1:integer; constref ind2:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    Inc(ind1);
    obj_inds_sct_arr[ind1]:=ind2;
  end; {$endregion}

begin
  with F_MainForm.TV_Scene_Tree do
    begin
      Items.BeginUpdate;
      for i:=0 to Items.Count-1 do
        with obj_var do
          case obj_arr[PNodeData(Items[i].Data)^.g_ind].koo of
            TKindOfObject(00){kooEmpty}: SetIndsSctArrVal(empty_inds_sct_arr,i00,i);
            TKindOfObject(01){kooBkgnd}: SetIndsSctArrVal(bkgnd_inds_sct_arr,i01,i);
            TKindOfObject(02){kooBkTex}: SetIndsSctArrVal(bktex_inds_sct_arr,i02,i);
            TKindOfObject(03){kooRGrid}: SetIndsSctArrVal(rgrid_inds_sct_arr,i03,i);
            TKindOfObject(04){kooSGrid}: SetIndsSctArrVal(sgrid_inds_sct_arr,i04,i);
            TKindOfObject(05){kooGroup}: SetIndsSctArrVal(group_inds_sct_arr,i05,i);
            TKindOfObject(06){kooTlMap}: SetIndsSctArrVal(tlmap_inds_sct_arr,i06,i);
            TKindOfObject(07){kooActor}: SetIndsSctArrVal(actor_inds_sct_arr,i07,i);
            TKindOfObject(08){kooPrtcl}: SetIndsSctArrVal(prtcl_inds_sct_arr,i08,i);
            TKindOfObject(09){kooCurve}: SetIndsSctArrVal(curve_inds_sct_arr,i09,i);
            TKindOfObject(10){kooFtext}: SetIndsSctArrVal(ftext_inds_sct_arr,i10,i);
          end;
      Items.EndUpdate;
    end;
end; {$endregion}
procedure CngPnVsCalc;                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,v: integer;

  function HasNotExpandedParent(ind:integer): boolean; {$ifdef Linux}[local];{$endif} {$region -fold}
  var
    j: integer;
  begin
    j:=0;
    Result:=False;
    with F_MainForm,TV_Scene_Tree,SB_TreeView_Object_Tags do
      begin
        Items.BeginUpdate;
        while (Items[ind].GetParentNodeOfAbsoluteLevel(j)<>Items[ind]) do
          begin
            if (not Items[ind].GetParentNodeOfAbsoluteLevel(j).Expanded) then
              begin
                Result:=True;
                Break;
              end;
            Inc(j);
          end;
        Items.EndUpdate;
      end;
  end; {$endregion}

begin
  with F_MainForm,TV_Scene_Tree,SB_TreeView_Object_Tags do
    begin
      for i:=0 to ControlCount-1 do
        (Controls[i] as TPanel).Visible:=not HasNotExpandedParent(obj_var.obj_arr[i].t_ind);
      v:=0;
      for i:=0 to ControlCount-1 do
        begin
          if (Controls[obj_var.obj_inds_arr[i]] as TPanel).Visible then
            begin
             (Controls[obj_var.obj_inds_arr[i]] as TPanel).Top:=v*(P_TreeView_Attributes_Cells.Height-1)-P_TreeView_Attributes_Cells.Height;
             Inc(v);
            end;
        end;
    end;
end; {$endregion}
procedure SelPnlsCalc;                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  with F_MainForm,TV_Scene_Tree,SB_TreeView_Object_Tags,obj_var do
    for i:=0 to ControlCount-1 do
      if (Controls[obj_inds_arr[i]] {as TPanel}).Visible and Items[i].Selected then
         (Controls[obj_inds_arr[i]] {as TPanel}).Color:=$0082804D;
end; {$endregion}
procedure UnsPnlsCalc;                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  with F_MainForm,TV_Scene_Tree,SB_TreeView_Object_Tags do
    for i:=0 to ControlCount-1 do
      (Controls[obj_var.obj_inds_arr[i]] {as TPanel}).Color:=$00ABAFA3;
end; {$endregion}
procedure SelIndsCalc;                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  with F_MainForm,TV_Scene_Tree,obj_var do
    begin
      if (SelectionCount=0) then
        Exit;
      j:=-1;
      for i:=0 to Items.Count-1 do
        if Items[i].Selected then
          begin
            Inc(j);
            sel_inds_arr[j]:=i;
          end;
      sel_cnt:=SelectionCount;
    end;
end; {$endregion}
procedure SelObjsPosRecalc0;                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  {if (F_MainForm.TV_Scene_Tree.SelectionCount=0) then
    Exit;
  with F_MainForm.TV_Scene_Tree,obj_var do
    for i:=0 to SelectionCount-1 do
      if obj_arr[obj_inds_arr[sel_inds_arr[i]]].recalc_pos then
        begin
          obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift.x:=Trunc((obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift.x-obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift_centrify.x)/obj_arr[obj_inds_arr[sel_inds_arr[i]]].parallax_shift.x);
          obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift.y:=Trunc((obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift.y-obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift_centrify.y)/obj_arr[obj_inds_arr[sel_inds_arr[i]]].parallax_shift.y);
        end;}
end; {$endregion}
procedure SelObjsPosRecalc1;                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  {if (F_MainForm.TV_Scene_Tree.SelectionCount=0) then
    Exit;
  with F_MainForm.TV_Scene_Tree,obj_var do
    for i:=0 to SelectionCount-1 do
      if obj_arr[obj_inds_arr[sel_inds_arr[i]]].recalc_pos then
        begin
          obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift.x:=obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift.x*Trunc(obj_arr[obj_inds_arr[sel_inds_arr[i]]].parallax_shift.x)+obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift_centrify.x;
          obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift.y:=obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift.y*Trunc(obj_arr[obj_inds_arr[sel_inds_arr[i]]].parallax_shift.y)+obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift_centrify.y;
        end;}
end; {$endregion}
function  AreAllObjKindEqual: TKindOfObject;                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  next_selected_node: TTreeNode;
  curr_selected_node: TTreeNode;
  i                 : integer;
  s                 : string;
begin
  with F_MainForm.TV_Scene_Tree do
    begin
      Result                    :=TKindOfObject(11);
      obj_var.first_sel_node_ind:=0;
      if (SelectionCount=0) then
        begin
          F_MainForm.L_Object_Name.Caption:='';
          Result                          :=kooEmpty;
          Exit;
        end;
      for i:=0 to Items.Count-1 do
        if Items[i].Selected then
          begin
            Result                    :=obj_var.obj_arr[PNodeData(Items[i].Data)^.g_ind].koo;
            obj_var.first_sel_node_ind:=i;
            single_selected_node_ind  :=obj_var.first_sel_node_ind;
            Break;
          end;
      if (SelectionCount=1) then
        begin
          s:=GetEnumName(TypeInfo(TKindOfObject),Ord(Result));
          if (s='kooCurve') then
            s:='Spline'
          else
            Delete(s,1,3);
          F_MainForm.L_Object_Name.Caption:=s;
          Exit;
        end;
      next_selected_node:=Items[obj_var.first_sel_node_ind];
      curr_selected_node:=next_selected_node;
      while (next_selected_node<>Nil) do
        begin
          curr_selected_node:=next_selected_node;
          if (obj_var.obj_arr[PNodeData(next_selected_node.Data)^.g_ind].koo=Result) then
            next_selected_node:=next_selected_node.GetNextMultiSelected
          else
            Break;
        end;
      if (SelectionCount>1) and (obj_var.obj_arr[PNodeData(curr_selected_node.Data)^.g_ind].koo<>Result) then
        Result:=TKindOfObject(11);
      s:=GetEnumName(TypeInfo(TKindOfObject),Ord(Result));
      Delete(s,1,3);
      F_MainForm.L_Object_Name.Caption:=s;
    end;
end; {$endregion}
function  AreAllObjPrlxEqual: TPtPosF;                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  next_selected_node: TTreeNode;
  curr_selected_node: TTreeNode;
begin
  with F_MainForm.TV_Scene_Tree do
    begin
      Result:=Default(TPtPosF);
      if (SelectionCount=0) then
        begin
          F_MainForm.SE_Object_Properties_Parallax_Shift.Color:=DEFAULT_MISCELLANEOUS_VALUES_COLOR;
          Exit;
        end;
      Result:=obj_var.obj_arr[PNodeData(Items[obj_var.first_sel_node_ind].Data)^.g_ind].parallax_shift;
      if (SelectionCount=1) then
        begin
          F_MainForm.SE_Object_Properties_Parallax_Shift.Color:=DEFAULT_MISCELLANEOUS_VALUES_COLOR;
          Exit;
        end;
      next_selected_node:=Items[obj_var.first_sel_node_ind];
      curr_selected_node:=next_selected_node;
      while (next_selected_node<>Nil) do
        begin
          curr_selected_node:=next_selected_node;
          if (obj_var.obj_arr[PNodeData(next_selected_node.Data)^.g_ind].parallax_shift=Result) then
            next_selected_node:=next_selected_node.GetNextMultiSelected
          else
            Break;
        end;
      if (SelectionCount>1) then
        begin
          if (obj_var.obj_arr[PNodeData(curr_selected_node.Data)^.g_ind].parallax_shift<>Result) then
            F_MainForm.SE_Object_Properties_Parallax_Shift.Color:=clGray
          else
            F_MainForm.SE_Object_Properties_Parallax_Shift.Color:=DEFAULT_MISCELLANEOUS_VALUES_COLOR;
        end;
    end;
end; {$endregion}
function  AreAllObjShowEqual: byte;                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  next_selected_node: TTreeNode;
  curr_selected_node: TTreeNode;
begin
  with F_MainForm,TV_Scene_Tree do
    begin
      Result:=Default(TByte);
      if (SelectionCount=0) then
        begin
          CB_Object_Properties_Show_In_Editor.State:=cbChecked;
          CB_Object_Properties_Show_In_Game  .State:=cbChecked;
          Exit;
        end;
      Result:=obj_var.obj_arr[PNodeData(Items[obj_var.first_sel_node_ind].Data)^.g_ind].obj_show;
      if (SelectionCount=1) then
        begin

          Exit;
        end;
      next_selected_node:=Items[obj_var.first_sel_node_ind];
      curr_selected_node:=next_selected_node;
      while (next_selected_node<>Nil) do
        begin
          curr_selected_node:=next_selected_node;
          if (obj_var.obj_arr[PNodeData(next_selected_node.Data)^.g_ind].obj_show=Result) then
            next_selected_node:=next_selected_node.GetNextMultiSelected
          else
            Break;
        end;
      if (SelectionCount>1) then
        begin
          if (obj_var.obj_arr[PNodeData(curr_selected_node.Data)^.g_ind].obj_show<>Result) then
            begin
              CB_Object_Properties_Show_In_Editor.State:=cbGrayed;
              CB_Object_Properties_Show_In_Game  .State:=cbGrayed;
            end
          else
            begin

            end;
        end;
    end;
end; {$endregion}
function  AreAllObjRPosEqual: boolean;                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  next_selected_node: TTreeNode;
  curr_selected_node: TTreeNode;
begin
  with F_MainForm,TV_Scene_Tree do
    begin
      Result:=Default(boolean);
      if (SelectionCount=0) then
        begin
          CB_Object_Properties_Recalculate_Position.State:=cbChecked;
          Exit;
        end;
      Result:=obj_var.obj_arr[PNodeData(Items[obj_var.first_sel_node_ind].Data)^.g_ind].recalc_pos;
      if (SelectionCount=1) then
        begin

          Exit;
        end;
      next_selected_node:=Items[obj_var.first_sel_node_ind];
      curr_selected_node:=next_selected_node;
      while (next_selected_node<>Nil) do
        begin
          curr_selected_node:=next_selected_node;
          if (obj_var.obj_arr[PNodeData(next_selected_node.Data)^.g_ind].recalc_pos=Result) then
            next_selected_node:=next_selected_node.GetNextMultiSelected
          else
            Break;
        end;
      if (SelectionCount>1) then
        begin
          if (obj_var.obj_arr[PNodeData(curr_selected_node.Data)^.g_ind].recalc_pos<>Result) then
            CB_Object_Properties_Recalculate_Position.State:=cbGrayed
          else
            begin

            end;
        end;
    end;
end; {$endregion}
procedure AreAllObjPropEqual;                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  obj_var.sel_koo:=AreAllObjKindEqual;
  AreAllObjPrlxEqual;
  AreAllObjRPosEqual;
  AreAllObjShowEqual;
end; {$endregion}
procedure ParallaxShiftChange;                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with F_MainForm,obj_var do
    begin
      global_prop.parallax_shift.x:=SE_Object_Properties_Parallax_Shift.Value;
      global_prop.parallax_shift.y:=SE_Object_Properties_Parallax_Shift.Value;
    end;
end; {$endregion}
procedure RecalcPosChange;                                                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with F_MainForm,obj_var do
    global_prop.recalc_pos:=CB_Object_Properties_Recalculate_Position.Checked;
end; {$endregion}
procedure ObjectShowChange;                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with F_MainForm,obj_var do
    if CB_Object_Properties_Show_In_Editor.Checked then
      begin
        if CB_Object_Properties_Show_In_Game.Checked then
          global_prop.obj_show:=0
        else
          global_prop.obj_show:=1;
      end
    else
      begin
        if CB_Object_Properties_Show_In_Game.Checked then
          global_prop.obj_show:=2
        else
          global_prop.obj_show:=3;
      end;
end; {$endregion}
procedure CrtNodeData(node_with_data:TTreeNode; g_ind:TColor);                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  node_data_pointer: PNodeData;
begin
  New(node_data_pointer);
  node_data_pointer^.g_ind:=g_ind;
  case obj_var.obj_arr[g_ind].koo of
    kooEmpty: ;
    kooBkgnd: ;
    kooBkTex: node_with_data.ImageIndex:=15;
    kooRGrid: node_with_data.ImageIndex:=06;
    kooSGrid: node_with_data.ImageIndex:=07;
    kooGroup: node_with_data.ImageIndex:=14;
    kooTlMap: ;
    kooActor: node_with_data.ImageIndex:=08;
    kooPrtcl: ;
    kooCurve: node_with_data.ImageIndex:=03;
  end;
  node_with_data.Data:=PNodeData(node_data_pointer);
end; {$endregion}
procedure WrtNodeData(data_start_ptr:PPtPosF;  data_write:TPtPosF; size_of_data:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  if (F_MainForm.TV_Scene_Tree.SelectionCount=0) then
    Exit;
  with F_MainForm.TV_Scene_Tree,obj_var do
    begin
      for i:=0 to SelectionCount-1 do
        (data_start_ptr+obj_inds_arr[sel_inds_arr[i]]*size_of_data)^:=data_write;
      (data_start_ptr+0*size_of_data)^:=(data_start_ptr+obj_inds_arr[1]*size_of_data)^;
    end;
end; {$endregion}
procedure WrtNodeData(data_start_ptr:PByte;    data_write:byte;    size_of_data:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  if (F_MainForm.TV_Scene_Tree.SelectionCount=0) then
    Exit;
  with F_MainForm.TV_Scene_Tree,obj_var do
    begin
      for i:=0 to SelectionCount-1 do
        (data_start_ptr+obj_inds_arr[sel_inds_arr[i]]*size_of_data)^:=data_write;
      (data_start_ptr+0*size_of_data)^:=(data_start_ptr+obj_inds_arr[1]*size_of_data)^;
    end;
end; {$endregion}
procedure WrtNodeData(data_start_ptr:PBoolean; data_write:boolean; size_of_data:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  if (F_MainForm.TV_Scene_Tree.SelectionCount=0) then
    Exit;
  with F_MainForm.TV_Scene_Tree,obj_var do
    begin
      for i:=0 to SelectionCount-1 do
        (data_start_ptr+obj_inds_arr[sel_inds_arr[i]]*size_of_data)^:=data_write;
      (data_start_ptr+0*size_of_data)^:=(data_start_ptr+obj_inds_arr[1]*size_of_data)^;
    end;
end; {$endregion}
procedure ClrNodeData(node_with_data:TTreeNode);                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (node_with_data.data<>Nil) then
    Dispose(PNodeData(node_with_data.data));
end; {$endregion}
procedure DeleteSelectedNodes(TV:TTreeView);                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  List: TList;
  i,j : integer;
  f   : boolean;

  function HasAsParent(node,PotentialParent:TTreeNode): boolean;
  begin
    node:=node.Parent;
    while(node<>Nil) and (node<>PotentialParent) do
      node:=node.Parent;
    Result:=node=PotentialParent;
  end;

begin
  List:=TList.Create;
  try
    List.Capacity:=TV.SelectionCount;
    for i:=0 to TV.SelectionCount-1 do
      begin
        // Ищем, может кого из родителей уже занесли в список на выбывание ;)
        f:=False;
        for j:=0 to List.Count-1 do
          begin
            f:=HasAsParent(TV.Selections[i],TTreeNode(List[j]));
            if f then
              Break;
          end;
        if f then // Родителя удалят, так что текущий узел удалять не нужно
          Continue;
        // Теперь нужно удалить всех детей, которые уже были записаны в список
        for j:=List.Count-1 downto 0 do
          if HasAsParent(TTreeNode(List[j]),TV.Selections[i]) then
            List.Delete(j);
        // Вот теперь можно со спокойной душей добавлять узел в список..
        List.Add(TV.Selections[i])
      end;
      for i:=0 to List.Count-1 do
        TTreeNode(List[i]).Delete;
  finally
    List.Free;
  end;
end; {$endregion}
procedure AddTagPanel(constref ind:integer);                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  P_TreeView_Attributes_Cells:=TPanel.Create(Nil);
  with F_MainForm,TV_Scene_Tree,P_TreeView_Attributes_Cells do
    begin
      AnchorParallel(akRight,0,SB_TreeView_Object_Tags);
      BevelColor:=clGray;
      Parent    :=SB_TreeView_Object_Tags;
      Width     :=62;
      Height    :=DefaultItemHeight+1;
      Left      :=1;
      Top       :=Items[ind].Top-Height;
      Color     :=$00ABAFA3;
      Caption   :=IntToStr(ind);
      Font.Color:=clBlue;
      //Tag       :=ind;
    end;
end; {$endregion}
procedure CreateNode(item_text1,item_text2:ansistring; is_first_node:boolean=False);      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  item_text: ansistring;
  ind       : integer;
begin
  with F_MainForm,TV_Scene_Tree,obj_var do
    begin
      Items.BeginUpdate;
      item_text:=item_text1+item_text2;
      if (not is_first_node) then
        begin
          if (Selected=Nil) then
            ind:=Items.AddChild(Items[0],item_text).AbsoluteIndex
          else
            ind:=Items.AddChild(Selected,item_text).AbsoluteIndex;
        end
      else
        begin
          Items.AddFirst(Nil,item_text).Expanded:=True;
          ind                                   :=0;
        end;
      CrtNodeData(Items[ind],obj_cnt-1);
      if (SelectionCount<>0) then
        AddTagPanel(obj_cnt-1)
      else
        AddTagPanel(ind);
      Items.EndUpdate;
    end;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
constructor TF_MainForm.Create                                       (TheOwner:TComponent);                                                      {$region -fold}
begin
  inherited Create(TheOwner);
end; {$endregion}
procedure TF_MainForm.SB_TreeView_Object_TagsMouseWheelDown          (sender:TObject; shift:TShiftState; mousepos:TPoint; var handled:boolean);  {$region -fold}
begin
  TV_Scene_Tree.Perform(WM_VSCROLL,MakeWParam(SB_LINEDOWN,0),0);
end; {$endregion}
procedure TF_MainForm.SB_TreeView_Object_TagsMouseWheelUp            (sender:TObject; shift:TShiftState; mousepos:TPoint; var handled:boolean);  {$region -fold}
begin
  TV_Scene_Tree.Perform(WM_VSCROLL,MakeWParam(SB_LINEUP,0),0);
end; {$endregion}
procedure TF_MainForm.MI_Add_GroupClick                              (sender:TObject);                                                           {$region -fold}
var
  world_axis_shift: TPtPos;
  //items_text      : ansistring;
begin
  with TV_Scene_Tree,obj_var do
    begin
      if (srf_var<>Nil) then
        world_axis_shift:=srf_var.world_axis_shift
      else
        world_axis_shift:=Default(TPtPos);
      Add(kooGroup,world_axis_shift);
      CreateNode('Group',IntToStr(group_cnt));
      ObjIndsCalc;
      ScTIndsCalc;
      //Items.AddChild(Items[0],items_text).MakeVisible;
    end;
  DrawObjectInfo0;
end; {$endregion}
procedure TF_MainForm.MI_Remove_ObjectClick                          (sender:TObject);                                                           {$region -fold}
begin
  if (TV_Scene_Tree.Selected=Nil) then
    begin
      ShowMessage('Nothing selected');
      Exit;
    end;
  if (TV_Scene_Tree.Selected.Level=0) then
    begin
      ShowMessage('Cant delete the root node');
      Exit;
    end;
  DeleteSelectedNodes(TV_Scene_Tree);
end; {$endregion}
procedure TF_MainForm.MI_Group_ObjectsClick                          (sender:TObject);                                                           {$region -fold}
var
  j,m: integer;

  function FirstSelectedNode: integer; {$region -fold}
    var
      i,m: integer;
  begin
    Randomize;
    m:=0;
    with TV_Scene_Tree do
      if Items.IsMultiSelection then
        for i:=1 to Items.Count-1 do
          case Items[i].Selected of
            False: Inc(m);
            True : Break;
          end;
    Result:=m;
  end; {$endregion}

begin
  m:=FirstSelectedNode;
  with TV_Scene_Tree,obj_var do
    begin
      Items.BeginUpdate;
      Items.Insert(Items[m+1],'Group'+IntToStr(group_cnt+1));
      Add(kooGroup,srf_var.world_axis_shift);
      CrtNodeData(Items[m+1],obj_cnt-1);
      AddTagPanel(obj_cnt-1);
      for j:=1 to Items.Count-1 do
        if Items[j].MultiSelected then
           Items[j].MoveTo(Items[m+1],naAddChild);
      Items[m+1].Expanded:=True;
      if (Selected<>Nil) then
        Items.ClearMultiSelection(True);
      ObjIndsCalc;
      ScTIndsCalc;
      CngPnVsCalc;
      SelPnlsCalc;
      SelIndsCalc;
      cmr_var.parallax_shift:=obj_var.obj_arr[0].parallax_shift;
      srf_var.EventGroupsCalc(calc_arr,[30,41,48]);
      Items.EndUpdate;
    end;
end; {$endregion}
procedure TF_MainForm.MI_Delete_Without_ChildrenClick                (sender:TObject);                                                           {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.MI_Delete_All_GroupsClick                      (sender:TObject);                                                           {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.MI_Select_AllClick                             (sender:TObject);                                                           {$region -fold}
var
  i: integer;
begin
  with TV_Scene_Tree do
    for i:=1 to Items.Count-1 do
      Items[i].Selected:=True;
  SelPnlsCalc;
  SelIndsCalc;
  AreAllObjPropEqual;
end; {$endregion}
procedure TF_MainForm.MI_Unselect_AllClick                           (sender:TObject);                                                           {$region -fold}
begin
  with TV_Scene_Tree do
    if (SelectionCount<>0) then
      Items.ClearMultiSelection(True);
  UnsPnlsCalc;
  AreAllObjPropEqual;
end; {$endregion}
procedure TF_MainForm.MI_Fold_AllClick                               (sender:TObject);                                                           {$region -fold}
var
  i: integer;
begin
  for i:=1 to TV_Scene_Tree.Items.Count-1 do
    TV_Scene_Tree.Items[i].Expanded:=False;
  CngPnVsCalc;
end; {$endregion}
procedure TF_MainForm.MI_Unfold_AllClick                             (sender:TObject);                                                           {$region -fold}
begin
  TV_Scene_Tree.FullExpand;
  CngPnVsCalc;
end; {$endregion}
procedure TF_MainForm.MI_Fold_SelectedClick                          (sender:TObject);                                                           {$region -fold}
var
  i: integer;
begin
  for i:=1 to TV_Scene_Tree.Items.Count-1 do
    if TV_Scene_Tree.Items[i].Selected then
      TV_Scene_Tree.Items[i].Expanded:=False;
  CngPnVsCalc;
end; {$endregion}
procedure TF_MainForm.MI_Unfold_SelectedClick                        (sender:TObject);                                                           {$region -fold}
var
  i: integer;
begin
  for i:=1 to TV_Scene_Tree.Items.Count-1 do
    if TV_Scene_Tree.Items[i].{Multi}Selected then
      TV_Scene_Tree.Items[i].Expanded:=True;
  CngPnVsCalc;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeExpanded                          (sender:TObject; node:TTreeNode);                                           {$region -fold}
begin
  CngPnVsCalc;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeExpanding                         (sender:TObject; node:TTreeNode; var allowexpansion:boolean);               {$region -fold}
begin
  CngPnVsCalc;
end; {$endregion}
procedure TF_MainForm.MI_Goto_First_ObjectClick                      (sender:TObject);                                                           {$region -fold}
begin
  TV_Scene_Tree.Items[1].Selected:=True;
  TV_Scene_Tree.Perform(WM_VSCROLL,MakeWParam(SB_LINEUP,0),0);
  SB_TreeView_Object_Tags.VertScrollBar.Position:=0;
  SelPnlsCalc;
  SelIndsCalc;
  AreAllObjPropEqual;
end; {$endregion}
procedure TF_MainForm.MI_Goto_Last_ObjectClick                       (sender:TObject);                                                           {$region -fold}
begin
  TV_Scene_Tree.Items[TV_Scene_Tree.Items.Count-1].Selected:=True;
  SB_TreeView_Object_Tags.VertScrollBar.Position:=3*TV_Scene_Tree.DefaultItemHeight*(TV_Scene_Tree.Items.Count-1);
  SelPnlsCalc;
  SelIndsCalc;
  AreAllObjPropEqual;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeDragOver                          (sender,source:TObject; x,y:integer; state:TDragState; var accept:boolean); {$region -fold}
begin
  SelPnlsCalc;
  SelIndsCalc;
  AreAllObjPropEqual;
  accept:=True and (sel_var.sel_pts_cnt=0); // If TRUE then accept the draged item
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeMouseDown                         (sender:TObject; button:TMouseButton; shift:TShiftState; x,y:integer);      {$region -fold}
var
  target_node: TTreeNode;
  shift_name : string;
begin
  with TV_Scene_Tree,obj_var do
    if (button=mbLeft) then
      begin
        ReadOnly             :=False;
        scene_tree_mouse_down:=True;
        source_node_x        :=x;
        source_node_y        :=y;
        target_node          :=GetNodeAt(x,y);
        if (target_node<>Nil) then
          begin
            SE_Object_Properties_Parallax_Shift      .Value  := obj_arr[PNodeData(target_node.Data)^.g_ind].parallax_shift.x;
            ParallaxShiftChange;
            CB_Object_Properties_Recalculate_Position.Checked:= obj_arr[PNodeData(target_node.Data)^.g_ind].recalc_pos;
            RecalcPosChange;
            CB_Object_Properties_Show_In_Editor      .Checked:=(obj_arr[PNodeData(target_node.Data)^.g_ind].obj_show=0) or
                                                               (obj_arr[PNodeData(target_node.Data)^.g_ind].obj_show=1);
            CB_Object_Properties_Show_In_Game        .Checked:=(obj_arr[PNodeData(target_node.Data)^.g_ind].obj_show=0) or
                                                               (obj_arr[PNodeData(target_node.Data)^.g_ind].obj_show=2);
            ObjectShowChange;
            single_selected_node_ind                         :=target_node.AbsoluteIndex;
            shift_name                                       :=GetEnumName(TypeInfo(TShiftStateEnum),Ord(TShiftStateEnum(shift)));
            if (shift_name='ssSuper') then
              begin
                Items.ClearMultiSelection(True);
                target_node.Selected:=True;
              end
            else
            if (shift_name='ssNum') then
              target_node.Selected:=False;
            BeginDrag(True);
          end
        else
        if (SelectionCount<>0) then
          begin
            Items.ClearMultiSelection(True);
            FormKeyPress(F_MainForm,prev_key);
            L_Object_Name                            .Caption:='';
            SE_Object_Properties_Parallax_Shift      .Color  :=DEFAULT_MISCELLANEOUS_VALUES_COLOR;
            CB_Object_Properties_Recalculate_Position.State  :=TCheckBoxState(Byte(global_prop.recalc_pos));
            CB_Object_Properties_Show_In_Editor      .State  :=TCheckBoxState(Byte(global_prop.obj_show in [0,1]));
            CB_Object_Properties_Show_In_Game        .State  :=TCheckBoxState(Byte(global_prop.obj_show in [0,2]));
            EndDrag(False);
          end;
        ReadOnly             :=True;
        scene_tree_mouse_down:=False;
        UnsPnlsCalc;
      end;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeMouseMove                         (sender:TObject; shift:TShiftState; x,y:integer);                           {$region -fold}
var
  target_node: TTreeNode;
  i          : integer;
begin
  with TV_Scene_Tree do
    begin
      target_node:=GetNodeAt(x,y);
      if (target_node<>Nil) then
        begin
          if (target_node.GetPrev<>Nil) then
            begin
              target_node.GetPrev.NodeEffect:=gdeNormal;
              if (not target_node.GetPrev.Selected) then
                (SB_TreeView_Object_Tags.Controls[obj_var.obj_inds_arr[target_node.GetPrev.AbsoluteIndex]] as TPanel).Color:=$00ABAFA3;
            end;
          target_node.NodeEffect:=gdeHighlighted;
          if (not target_node.Selected) then
            (SB_TreeView_Object_Tags.Controls[obj_var.obj_inds_arr[target_node.AbsoluteIndex]] as TPanel).Color:=$00ABC0B4;
          if (target_node.GetNext<>Nil) then
            begin
              target_node.GetNext.NodeEffect:=gdeNormal;
              if (not target_node.GetNext.Selected) then
                (SB_TreeView_Object_Tags.Controls[obj_var.obj_inds_arr[target_node.GetNext.AbsoluteIndex]] as TPanel).Color:=$00ABAFA3;
            end;
        end
      else
        for i:=0 to Items.Count-1 do
          begin
            Items[i].NodeEffect:=gdeNormal;
            if (not Items[i].Selected) then
              (SB_TreeView_Object_Tags.Controls[obj_var.obj_inds_arr[i]] as TPanel).Color:=$00ABAFA3;
          end;
    end;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeMouseWheelDown                    (sender:TObject; shift:TShiftState; mousepos:TPoint; var handled:boolean);  {$region -fold}
begin
  SB_TreeView_Object_Tags.VertScrollBar.Position:=SB_TreeView_Object_Tags.VertScrollBar.Position+3*TV_Scene_Tree.DefaultItemHeight;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeMouseWheelUp                      (sender:TObject; shift:TShiftState; mousepos:TPoint; var handled:boolean);  {$region -fold}
begin
  SB_TreeView_Object_Tags.VertScrollBar.Position:=SB_TreeView_Object_Tags.VertScrollBar.Position-3*TV_Scene_Tree.DefaultItemHeight;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeMouseEnter                        (sender:TObject);                                                           {$region -fold}
begin
  TV_Scene_Tree.Color:=HighLight(TV_Scene_Tree.Color,0,0,0,0,0,16);
  is_mouse_in_scene_tree:=True;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeMouseLeave                        (sender:TObject);                                                           {$region -fold}
var
  i: integer;
begin
  TV_Scene_Tree.Color:=Darken(TV_Scene_Tree.Color,0,0,0,0,0,16);
  with TV_Scene_Tree do
    for i:=0 to Items.Count-1 do
      begin
        Items[i].NodeEffect:=gdeNormal;
        if (not Items[i].Selected) then
          (SB_TreeView_Object_Tags.Controls[obj_var.obj_inds_arr[i]] as TPanel).Color:=$00ABAFA3;
      end;
  is_mouse_in_scene_tree:=False;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeDblClick                          (sender:TObject);                                                           {$region -fold}
begin

end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeEditing                           (sender:TObject; node:TTreeNode; var allowedit:boolean);                    {$region -fold}
begin
  is_scene_tree_editing:=True;
  KeysDisable0;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeEditingEnd                        (sender:TObject; node:TTreeNode; cancel:boolean);                           {$region -fold}
begin
  is_scene_tree_editing:=False;
  KeysEnable0;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeKeyDown                           (sender:TObject; var key:word; shift:TShiftState);                          {$region -fold}
var
  s: string;
begin
  with TV_Scene_Tree do
    begin
      case key of
        38:
          if (SelectionCount=1) then
            begin
              if (single_selected_node_ind<>0) then
                begin
                  Dec(single_selected_node_ind);
                  (SB_TreeView_Object_Tags.Controls[obj_var.obj_inds_arr[single_selected_node_ind+1]] as TPanel).Color:=$00ABAFA3;
                  (SB_TreeView_Object_Tags.Controls[obj_var.obj_inds_arr[single_selected_node_ind+0]] as TPanel).Color:=$0082804D;
                end
              else
                begin
                  //
                end;
            end;
        40:
          if (SelectionCount=1) then
            begin
              if (single_selected_node_ind<>Items.Count-1) then
                begin
                  Inc(single_selected_node_ind);
                  (SB_TreeView_Object_Tags.Controls[obj_var.obj_inds_arr[single_selected_node_ind-1]] as TPanel).Color:=$00ABAFA3;
                  (SB_TreeView_Object_Tags.Controls[obj_var.obj_inds_arr[single_selected_node_ind-0]] as TPanel).Color:=$0082804D;
                end
              else
                begin
                  single_selected_node_ind:=1;
                  Items.ClearMultiSelection(True);
                  Items[0].Selected:=True;
                  (SB_TreeView_Object_Tags.Controls[obj_var.obj_inds_arr[Items.Count-000000000001]] as TPanel).Color:=$00ABAFA3;
                  (SB_TreeView_Object_Tags.Controls[obj_var.obj_inds_arr[single_selected_node_ind]] as TPanel).Color:=$0082804D;
                end;
            end;
      end;
      case key of
        38,40:
          if (SelectionCount=1) then
            begin
              with obj_var do
                begin
                  SE_Object_Properties_Parallax_Shift .Value  := obj_arr[PNodeData(Items[single_selected_node_ind].Data)^.g_ind].parallax_shift.x;
                  CB_Object_Properties_Show_In_Editor.Checked:=(obj_arr[PNodeData(Items[single_selected_node_ind].Data)^.g_ind].obj_show=0) or
                                                                (obj_arr[PNodeData(Items[single_selected_node_ind].Data)^.g_ind].obj_show=1);
                  CB_Object_Properties_Show_In_Game  .Checked:=(obj_arr[PNodeData(Items[single_selected_node_ind].Data)^.g_ind].obj_show=0) or
                                                                (obj_arr[PNodeData(Items[single_selected_node_ind].Data)^.g_ind].obj_show=2);
                  s:=GetEnumName(TypeInfo(TKindOfObject),Ord    (obj_arr[PNodeData(Items[single_selected_node_ind].Data)^.g_ind].koo));
                end;
              Delete(s,1,3);
              if (s='Empty') then
                L_Object_Name.Caption:=''
              else
                L_Object_Name.Caption:=s;
            end;
      end;
    end;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeKeyPress                          (sender:TObject; var key:char);                                             {$region -fold}
begin
  with TV_Scene_Tree do
    case key of
      #13:
        if (Selected<>Nil) then
            Selected.EditText;
      {#40: Items[Selected.Index+1].Selected;
      #38:
        begin
          if (Selected.Index>2) then
            Items[Selected.Index-1].Selected
          else
            Items[Selected.Index+1].Selected;
        end;}
    end;
  //Mouse_Event
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeDragDrop                          (sender,source:TObject; x,y:integer);                                       {$region -fold}
var
  source_node,target_node: TTreeNode;
begin
  with TV_Scene_Tree do
    begin
      source_node:=GetNodeAt(source_node_x,source_node_y);
      target_node:=GetNodeAt(x,y);
      if (target_node=Nil) then
        begin
          EndDrag(False);
          {if (Selected<>Nil) then
            Items.ClearMultiSelection(True);}
          target_node:=Items[0];
        end;
      source_node.MoveTo(target_node,naAddChild);
    end;
  ObjIndsCalc;
  ScTIndsCalc;
  CngPnVsCalc;
  SelPnlsCalc;
  SelIndsCalc;
  //obj_var.LowLrObjCntCalc3;
  cmr_var.parallax_shift:=obj_var.obj_arr[0].parallax_shift;
  srf_var.EventGroupsCalc(calc_arr,[30,41,48]);
end; {$endregion}
procedure TF_MainForm.S_TreeView_SplitterChangeBounds                (sender:TObject);                                                           {$region -fold}
begin
  {$ifdef Windows}
  Application.ProcessMessages;
  {$else}
  P_TreeView_Attributes.Update;
  {$endif}
  if (S_TreeView_Splitter.left<F_MainForm.width-TV_Scene_Tree.width+4) then
    S_TreeView_Splitter.left:=F_MainForm.width-TV_Scene_Tree.width+4;
  treeview_splitter_shift:=S_TreeView_Splitter.left-S_Splitter3.left;
end; {$endregion}
// (Object Properties) Свойства обьекта:
procedure TF_MainForm.SB_Object_PropertiesMouseEnter                 (sender:TObject);                                                           {$region -fold}
begin
  SB_Object_Properties.Color:=HighLight(SB_Object_Properties.Color,0,0,0,0,0,16);
  P_Object_Properties .Color:=HighLight(P_Object_Properties .Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.SB_Object_PropertiesMouseLeave                 (sender:TObject);                                                           {$region -fold}
begin
  SB_Object_Properties.Color:=Darken(SB_Object_Properties.Color,0,0,0,0,0,16);
  P_Object_Properties .Color:=Darken(P_Object_Properties .Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.SE_Object_Properties_Parallax_ShiftChange      (sender:TObject);                                                           {$region -fold}
begin
  ParallaxShiftChange;
  if (TV_Scene_Tree.SelectionCount=0) or (is_mouse_in_scene_tree) then
    Exit;
  //SelObjsPosRecalc0;
  WrtNodeData(PPtPosF   (@obj_var.obj_arr[0] .parallax_shift),
              PtPosF    ( obj_var.global_prop.parallax_shift.x,
                          obj_var.global_prop.parallax_shift.y),
              PPtPosF   (@obj_var.obj_arr[1] .parallax_shift)-
              PPtPosF   (@obj_var.obj_arr[0] .parallax_shift));
  cmr_var.parallax_shift:=obj_var.obj_arr[0] .parallax_shift;
  //SelObjsPosRecalc1;
  obj_var.LowLrObjCntCalc1;
  srf_var.EventGroupsCalc(calc_arr,[30]+[30+11*Byte(not down_play_anim_ptr^)]+[30+18*Byte(down_select_items_ptr^)]);
end; {$endregion}
procedure TF_MainForm.CB_Object_Properties_Recalculate_PositionChange(sender:TObject);                                                           {$region -fold}
begin
  RecalcPosChange;
  if (TV_Scene_Tree.SelectionCount=0) or (is_mouse_in_scene_tree) then
    Exit;
  WrtNodeData(PBoolean(@obj_var.obj_arr[0] .recalc_pos),
                        obj_var.global_prop.recalc_pos,
              PBoolean(@obj_var.obj_arr[1] .recalc_pos)-
              PBoolean(@obj_var.obj_arr[0] .recalc_pos));
  //obj_var.LowLrObjCntCalc1;
  //srf_var.EventGroupsCalc(calc_arr,[30]+[30+11*Byte(not down_play_anim_ptr^)]+[30+18*Byte(down_select_points_ptr^)]);
end; {$endregion}
procedure TF_MainForm.CB_Object_Properties_Show_In_EditorChange      (sender:TObject);                                                           {$region -fold}
begin
  ObjectShowChange;
  if (TV_Scene_Tree.SelectionCount=0) or (is_mouse_in_scene_tree) then
    Exit;
  WrtNodeData(PByte   (@obj_var.obj_arr[0] .obj_show),
                        obj_var.global_prop.obj_show,
              PByte   (@obj_var.obj_arr[1] .obj_show)-
              PByte   (@obj_var.obj_arr[0] .obj_show));
  WrtNodeData(PBoolean(@obj_var.obj_arr[0] .forced_repaint),
              True,
              PBoolean(@obj_var.obj_arr[1] .forced_repaint)-
              PBoolean(@obj_var.obj_arr[0] .forced_repaint));
  obj_var.LowLrObjCntCalc1;
  srf_var.EventGroupsCalc(calc_arr,[18,30]+[30+11*Byte(not down_play_anim_ptr^)]+[30+18*Byte(down_select_items_ptr^)]);
  WrtNodeData(PBoolean(@obj_var.obj_arr[0] .forced_repaint),
              False,
              PBoolean(@obj_var.obj_arr[1] .forced_repaint)-
              PBoolean(@obj_var.obj_arr[0] .forced_repaint));
end; {$endregion}
// (Tag    Properties) Свойства тега:
procedure TF_MainForm.SB_Tag_PropertiesMouseEnter                    (sender:TObject);                                                           {$region -fold}
begin
  SB_Tag_Properties.Color:=HighLight(SB_Tag_Properties.Color,0,0,0,0,0,16);
  P_Tag_Properties .Color:=HighLight(P_Tag_Properties .Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.SB_Tag_PropertiesMouseLeave                    (sender:TObject);                                                           {$region -fold}
begin
  SB_Tag_Properties.Color:=Darken(SB_Tag_Properties.Color,0,0,0,0,0,16);
  P_Tag_Properties .Color:=Darken(P_Tag_Properties .Color,0,0,0,0,0,16);
end; {$endregion}
// (Clear Scene) Очистить сцену:
{UI} {$region -fold}
procedure TF_MainForm.SB_Clear_SceneClick    (sender:TObject); {$region -fold}
begin
  {P_Selective_Deletion.Visible:=SB_Clear_Scene.Down;
  P_Load_Save_Clear.Repaint;}
end; {$endregion}
procedure TF_MainForm.BB_Delete_SelectedClick(sender:TObject); {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.BB_Delete_AllClick     (sender:TObject); {$region -fold}
var
  i: integer;
begin
  {with srf_var,tex_var,sln_var,sel_var do
    begin

      {Clear Layer Canvas}
      srf_bmp.Canvas.Clear;
      low_bmp.Canvas.Clear;

      {Clear Texture List}
      for i:=FP_Image_List.ControlCount-1 downto 0 do
        FP_Image_List.Controls[i].Destroy;

      {Clear Scene Tree Nodes}
      with TV_Scene_Tree do
        begin
          Items[0].DeleteChildren;
          if Items.Count>1 then
            for i:=1 to Items.Count-1 do
              ClrNodeData(Items[i]);
        end;

      {Reset Layer Bounding Rectangles}
      srf_bmp_rct:=Default(TPtRect);

      {Reset Texture}
      is_tex_enabled :=False;
      loaded_picture.Clear;
      loaded_picture :=Graphics.TPicture.Create;
      tex_bmp_rct_pts:=tex_bmp_rct_origin_pts;

      {Reset Miscellaneous Parameters}
      SB_StatusBar1.Panels.Items[2].Text:='';
      L_Object_Info.Caption             :='';
      FP_Image_List.Caption             :='Texture List is Empty';
      L_Object_Info.Visible             :=False;
    //MI_Antialiasing.Checked           :=False;
    //srf_bmp.Canvas.Antialiasingmode   :=amOff;
      AlignPictureToCenter;
      EventGroupsCalc(calc_arr,[0,1,2,8,9]);

    end;}
end; {$endregion}
{$endregion}
{$endregion}

// (Game Loop) Игровой цикл:
{LI} {$region -fold}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.Tic             (sender:TObject; var done:boolean); {$region -fold}
var
  d                  : TPoint;
  i{,j,x,y}            : integer;
  color_info         : TColorInfo;
  t                  : integer;
  {vec_x_dist_sht     : integer;
  velocity           : integer=4;
  distance           : integer=4;
  r_x,r_y            : longword;
  sprite_rect_arr_ptr: PPtPos;
  useless_arr_ptr    : PByte;}
begin

  Sleep(12);

  with srf_var,sln_var,tex_var,fast_physics_var,fast_fluid_var do
    begin

      if (not is_active) then
        begin
          Inc(downtime_counter);
          if (downtime_counter>downtime) then
            Exit;
        end
      else
        downtime_counter:=0;

      LowerBmpToMainBmp;
      Randomize;
      t:=200;
      GetCursorPos(d);
      d:=ScreenToClient(d);

      with fast_actor_set_var.d_icon,fast_image_data do
        begin

          begin
            col_trans_arr[00]+=4;
            col_trans_arr[01]+=4;
            col_trans_arr[02]+=4;
            col_trans_arr[03]+=4;
            col_trans_arr[04]+=4;
            col_trans_arr[05]+=4;
            col_trans_arr[06]+=4;
            col_trans_arr[07]+=4;
            col_trans_arr[08]+=4;
            col_trans_arr[09]+=4;
            col_trans_arr[10]+=4;
            col_trans_arr[11]+=4;
            col_trans_arr[12]+=4;
            col_trans_arr[13]+=4;
            col_trans_arr[14]+=4;
            col_trans_arr[15]+=4;
          end;

          SetColorInfo(clRed,color_info);
          {for i:=0 to 1000 do
            CircleHighlight(tex_bmp_rect.left+Random(tex_bmp_rect.width-1),
                            tex_bmp_rect.top+Random(tex_bmp_rect.height-1),
                            surf_bmp_handle,
                            inner_window_rect,
                            surf_bmp.width,
                            color_info,
                            Random(032),
                            Random(256));}

          if (sln_obj_cnt>0) then
            for i:=0 to sln_obj_cnt-1 do
              begin
                if (sln_obj_pts_cnt[i]=1) then
                  begin
                    CircleHighlight(Trunc(sln_pts[partial_pts_sum[i]].x),
                                    Trunc(sln_pts[partial_pts_sum[i]].y),
                                    srf_bmp_ptr,
                                    inn_wnd_rct,
                                    srf_bmp.width,
                                    color_info,
                                    sln_sprite_counter_rad_arr[i],
                                    sln_sprite_counter_pow_arr[i]);
                    Continue;
                  end;
                if (sln_obj_pts_cnt[i]>1) then
                  begin
                    CircleHighlight(Trunc(sln_pts[partial_pts_sum[i]+sln_sprite_counter_pos_arr[i]].x),
                                    Trunc(sln_pts[partial_pts_sum[i]+sln_sprite_counter_pos_arr[i]].y),
                                    srf_bmp_ptr,
                                    inn_wnd_rct,
                                    srf_bmp.width,
                                    color_info,
                                    sln_sprite_counter_rad_arr[i],
                                    sln_sprite_counter_pow_arr[i]);
                    if (sln_sprite_counter_pos_arr[i]=sln_obj_pts_cnt[i]-1) then
                        sln_sprite_counter_pos_arr[i]:=0
                    else
                      Inc(sln_sprite_counter_pos_arr[i]);
                    Continue;
                  end;
              end;

          //for i:=0 to SE_Count_X.Value-1 do
            {PPBlur(surf_bmp_handle,
                   ClippedRect(inner_window_rect,tex_bmp_rect),
                   surf_bmp.width,SE_Count_Y.Value-1);}
          //fx_arr[0].fx_id:=SE_Count_Y.Value;
          srf_bmp.Canvas.TextOut(100,100,'Start Demo');
          srf_bmp.Canvas.TextOut(100,140,'Settings'  );
          srf_bmp.Canvas.TextOut(100,180,'Credits'   );
          srf_bmp.Canvas.TextOut(100,220,'Exit'      );

          {fx_arr[1].nt_pix_cfx_type:=SE_Count_X.Value-1;
          fx_arr[1].pt_pix_cfx_type:=SE_Count_X.Value-1;}

          {fast_actor_set_var.act_pos_arr[fast_actor_set_var.act_cnt-1].x:=d.x{-bmp_ftimg_width >>1};
          fast_actor_set_var.act_pos_arr[fast_actor_set_var.act_cnt-1].y:=d.y{-bmp_ftimg_height>>1};
          bmp_ftimg_left  :=Trunc(fast_actor_set_var.act_pos_arr[fast_actor_set_var.act_cnt-1].x);
          bmp_ftimg_top   :=Trunc(fast_actor_set_var.act_pos_arr[fast_actor_set_var.act_cnt-1].y);
          bmp_ftimg_right :=bmp_ftimg_left+bmp_ftimg_width ;
          bmp_ftimg_bottom:=bmp_ftimg_top +bmp_ftimg_height;}

          {bmp_ftimg_left  :=d.x-bmp_ftimg_width >>1;
          bmp_ftimg_top   :=d.y-bmp_ftimg_height>>1;
          bmp_ftimg_right :=bmp_ftimg_left+bmp_ftimg_width ;
          bmp_ftimg_bottom:=bmp_ftimg_top +bmp_ftimg_height;}


          {sprite_rect_arr_ptr:=@sprite_rect_arr[0];
          useless_arr_ptr    :=@useless_arr_   [0];
          for i:=0 to SE_Count_X.Value-1 do
            begin
              SetRctPos((sprite_rect_arr_ptr+i)^.x,
                        (sprite_rect_arr_ptr+i)^.y);
              SdrProc[(useless_arr_ptr+i)^];
            end;}

          //for i:=0 to SE_Count_X.Value-1 do
            {PPHighLight(srf_bmp_ptr,
                        ClippedRect(inner_window_rect,PtBounds(d.x-64,d.y-64,128,128)),
                        surf_bmp.width);}
          {CircleHighlight(d.x,d.y,
                          surf_bmp_ptr,
                          inn_wnd_rect,
                          surf_bmp.width,
                          color_info,
                          128,
                          045);}

          {PPBlur(surf_bmp_ptr,
                 inn_wnd_rect,
                 surf_bmp.width,
                 10);}

          //////////////// ----- max sprites count without lags
          //////////////// ----- col     val
          {Monochrome } // ----- 266;    278;    340;   1233; 1227;
          {Additive   } // ----- 047;    070;    086;
          {Alphablend } // ----- 089;    108;    120;
          {Inverse    } // ----- 103;    167;    194;
          {Highlighted} // ----- 048;    068;    081;
          {Darkened   } // ----- 052;    072;    085;
          {GrayscaleR } // ----- 085;    128;    135;
          ////////////////

          {Points Cloud--} {$region -fold}
          {SetColorInfo(clRed,color_info);
          for i:=0 to 1000-1 do
            Point(tex_bmp_rect.left+Random(tex_bmp_rect.width-1),
                  tex_bmp_rect.top+Random(tex_bmp_rect.height-1),
                  surf_bmp_ptr,
                  surf_bmp.width,
                  color_info,
                  inn_wnd_rect);} {$endregion}

          {Actor Blur----} {$region -fold}
          {clip_mrg:=1;
          SetRectDst;
          SetRectSrc;
          arr_src_sht:=ClippedArr(rect_src,
                                  rect_dst,
                                  bmp_ftimg_width);
          for i:=0 to 0{sprite_count-1} do
            PPBlur(bmp_color,
                   arr_src_sht,
                   rect_src,
                   rect_dst,
                   surf_bmp.width,
                   bmp_ftimg_width,
                   surf_bmp_handle);} {$endregion}

          {Actor Colorize} {$region -fold}
          {clip_mrg:=0;
          SetRectDst;
          SetRectSrc;
          arr_src_sht:=ClippedArr(rect_src,
                                  rect_dst,
                                  bmp_ftimg_width);
          PPColorCorrection1(@ColorizeRMDec,
                             @ColorizeRPDec,
                             bmp_color,
                             arr_src_sht,
                             rect_src,
                             rect_dst,
                             surf_bmp.width,
                             bmp_ftimg_width,
                             surf_bmp_handle,
                             col_trans_var.grayscale_r_val);} {$endregion}

          {Bullets-------} {$region -fold}
          {begin
            SetColorInfo(clBlue,color_info);
            for i:=0 to 10 do
              begin
                if PointCollDraw(vec_x,
                                 vec_y,
                                 width,
                                 coll_box_arr,
                                 inner_window_rect,
                                 0) then
                  begin
                    vec_x         -=0{velocity}{d.x-t+Random(t<<1)};
                    vec_x_dist_sht:=vec_x-i*distance;
                  end
                else
                  begin
                    vec_x         +=velocity{d.x-t+Random(t<<1)};
                    vec_x_dist_sht:=vec_x+i*distance;
                  end;
                Point(vec_x_dist_sht,
                      vec_y,
                      surf_bmp_handle,
                      surf_bmp.width,
                      color_info,
                      inner_window_rect);
              end;
            ArrClear(coll_box_arr,inner_window_rect,width);
          end;} {$endregion}

          {Fluid Simul.--} {$region -fold}
          {if (spline_pts_cnt>0) then
            begin
              r_x            :=tex_bmp_rect.left;
              r_y            :=tex_bmp_rect.top;
              pts_dist_acc   :=r_x;
              for i:=0 to spline_obj_pts_cnt[spline_obj_cnt-1]-1 do
                begin
                  spline_pts[i].x:=pts_dist_acc;
                  Inc(pts_dist_acc,pts_dist);
                end;
              for i:=0 to spline_obj_pts_cnt[spline_obj_cnt-1]-1 do
                spline_pts[i].y:=(a0/a1)*exp((r_x-spline_pts[i].x)/a2)*sin(a3-a4*(r_x-spline_pts[i].x))+r_y;
              SetColorInfo(clRed{clRed},color_info);
              for i:=0 to spline_obj_pts_cnt[spline_obj_cnt-1]-2 do
                Line(Trunc(spline_pts[i+0].x),
                     Trunc(spline_pts[i+0].y),
                     Trunc(spline_pts[i+1].x),
                     Trunc(spline_pts[i+1].y),
                     surf_bmp_handle,
                     surf_bmp.width,
                     color_info,
                     inner_window_rect);
              SetColorInfo(clRed{clWhite},color_info);
              for i:=0 to spline_obj_pts_cnt[spline_obj_cnt-1]-1 do
                Point(Trunc(spline_pts[i].x),
                      Trunc(spline_pts[i].y),
                      surf_bmp_handle,
                      surf_bmp.width,
                      color_info,
                      inner_window_rect);
              Dec(a3,1);
              if (a3<=0) then
                a3:=80;
              Dec(a0,1);
              if (a0<=0) then
                a0:=0;
            end;} {$endregion}

          {Fluid Colorize} {$region -fold}
          {PPColorCorrectionP0(@ColorizeBP,
                              surf_bmp_ptr,
                              ClippedRect(inn_wnd_rect,
                                          tex_bmp_rect),
                              surf_bmp.width,
                              SE_Count_X.Value-1);} {$endregion}

          {Fluid Blur----} {$region -fold}
          {for i:=0 to 0 do
            PPBlur(surf_bmp_handle,
                   ClippedRect(inner_window_rect,tex_bmp_rect),
                   surf_bmp.width);} {$endregion}

        end;

        CnvToCnv(srf_bmp_rct,Canvas,srf_bmp.Canvas,SRCCOPY);

    end;

  Done:=false;

end; {$endregion}
procedure TF_MainForm.T_Game_LoopTimer(sender:TObject);                   {$region -fold}
var
  {sln_eds_var_ptr      : PFastLine;
  sln_pts_ptr          : PPtPosF;
  sln_pts_ptr2         : PPtPosF;
  pt                   : TPtPos;
  rct                  : TPtRect;
  sln_obj_pts_cnt_ptr  : PInteger;
  partial_pts_sum_ptr  : PInteger;
  i,j,x,y              : integer;}
  color_info           : TColorInfo;
  {t                    : integer;
  vec_x_dist_sht       : integer;
  velocity             : integer=4;
  distance             : integer=4;
  sprite_rect_arr_ptr  : PPtPos;
  useless_arr_ptr      : PByte;
  m                    : byte;
  f                    : TPtPos;
  n                    : integer;
  x0,y0,x1,y1,v1,w1,k,b: double;
  str                  : string;
  projectile_arr_ptr   : PProjectile;}
  execution_time       : double;
begin

  {if (frame_skip<>frame_step) then
    begin
      Inc(frame_skip);
      Exit;
    end
  else
    frame_skip:=0;}

  if (WindowState=wsMinimized) then
    Exit;

  exec_timer.Start;

  with obj_var,cmr_var,srf_var,sln_var,tex_var,srf_var,tex_var,sln_var,sel_var,crc_sel_var,pvt_var,fast_physics_var,fast_fluid_var do
    begin

      //Randomize;
      //t:=200;

      GetCursorPos(cur_pos);
      cur_pos:=ScreenToClient(cur_pos);

      if (CB_Spline_Mode.ItemIndex=0) then
        if draw_spline then
          begin
            AddPoint
            (
              cur_pos.x,
              cur_pos.y,
              low_bmp_ptr,
              low_bmp.width,
              color_info,
              inn_wnd_rct,
              add_spline_calc,
              True
            );
            CnvToCnv
            (
              srf_bmp_rct,
              Canvas,
              low_bmp.Canvas,
              SRCCOPY
            );
          end;

      {Draw Objects of Lower Layer} {$region -fold}
      if dir_a then
        begin
          MovLeft;
          if low_bmp_draw then
            begin
              FilLeft
              (
                low_bmp_ptr,
                low_bmp.width,
                low_bmp.height,
                inn_wnd_rct
              );
              MovScene(0,low_lr_obj_cnt-1);
            end;
        end;
      if dir_d then
        begin
          MovRight;
          if low_bmp_draw then
            begin
              FilRight
              (
                low_bmp_ptr,
                low_bmp.width,
                low_bmp.height,
                inn_wnd_rct
              );
              MovScene(0,low_lr_obj_cnt-1);
            end;
        end;
      if dir_w then
        begin
          MovUp;
          if low_bmp_draw then
            begin
              FilUp
              (
                low_bmp_ptr,
                low_bmp.width,
                low_bmp.height,
                inn_wnd_rct
              );
              MovScene(0,low_lr_obj_cnt-1);
            end;
        end;
      if dir_s then
        begin
          MovDown;
          if low_bmp_draw then
            begin
              FilDown
              (
                low_bmp_ptr,
                low_bmp.width,
                low_bmp.height,
                inn_wnd_rct
              );
              MovScene(0,low_lr_obj_cnt-1);
            end;
        end;

      if low_bmp_draw then
        LowerBmpToMainBmp
      else
        PPFloodFill(srf_bmp_ptr,inn_wnd_rct,srf_bmp.width,bg_color,flood_fill_inc);
      flood_fill_inc:=not flood_fill_inc; {$endregion}

      {Draw Objects of Upper Layer} {$region -fold}
      if (upp_lr_obj_cnt>0) then
        begin
          if dir_a then
            begin
              if dir_w then
                cmr_var.mov_dir:=mdLeftUp
              else
              if dir_s then
                cmr_var.mov_dir:=mdLeftDown
              else
                cmr_var.mov_dir:=mdLeft;
            end;
          if dir_d then
            begin
              if dir_w then
                cmr_var.mov_dir:=mdRightUp
              else
              if dir_s then
                cmr_var.mov_dir:=mdRightDown
              else
                cmr_var.mov_dir:=mdRight;
            end;
          if dir_w then
            begin
              if dir_a then
                cmr_var.mov_dir:=mdLeftUp
              else
              if dir_d then
                cmr_var.mov_dir:=mdRightUp
              else
                cmr_var.mov_dir:=mdUp;
            end;
          if dir_s then
            begin
              if dir_a then
                cmr_var.mov_dir:=mdLeftDown
              else
              if dir_d then
                cmr_var.mov_dir:=mdRightDown
              else
                cmr_var.mov_dir:=mdDown;
            end;
          {SetObjBkgnd
          (
            srf_bmp_ptr,
            srf_bmp.width,
            srf_bmp.height,
            @inn_wnd_rct,
            low_lr_obj_cnt,
            obj_cnt-1
          );}
          SetRctDstPtr(@inn_wnd_rct,low_lr_obj_cnt,obj_cnt-1);
          MovScene    (             low_lr_obj_cnt,obj_cnt-1);
        end; {$endregion}

      with fast_actor_set_var.d_icon,fast_image_data do
        begin

          begin
            col_trans_arr[04]:=128;
            {col_trans_arr[00]+=4;
            col_trans_arr[01]+=4;
            col_trans_arr[02]+=4;
            col_trans_arr[03]+=4;
            col_trans_arr[04]+=4;
            col_trans_arr[05]+=4;
            col_trans_arr[06]+=4;
            col_trans_arr[07]+=4;
            col_trans_arr[08]+=4;
            col_trans_arr[09]+=4;
            col_trans_arr[10]+=4;
            col_trans_arr[11]+=4;
            col_trans_arr[12]+=4;
            col_trans_arr[13]+=4;
            col_trans_arr[14]+=4;
            col_trans_arr[15]+=4;}
          end;

          SetColorInfo(clRed,color_info);

         { if (sln_obj_cnt>0) then
            begin
              for i:=0 to sln_obj_cnt-1 do
                begin
                  if (sln_obj_pts_cnt[i]=1) then
                    begin
                      CircleHighlight(Trunc(sln_pts[partial_pts_sum[i]].x)+world_axis_shift.x,
                                      Trunc(sln_pts[partial_pts_sum[i]].y)+world_axis_shift.y,
                                      srf_bmp_ptr,
                                      inn_wnd_rct,
                                      srf_bmp.width,
                                      color_info,
                                      sln_sprite_counter_rad_arr[i],
                                      sln_sprite_counter_pow_arr[i]);
                      Continue;
                    end;
                  if (sln_obj_pts_cnt[i]>1) then
                    begin
                      {for j:=0 to sln_obj_pts_cnt[i]-1 do
                        CircleHighlight(Trunc(sln_pts[partial_pts_sum[i]+j].x),
                                        Trunc(sln_pts[partial_pts_sum[i]+j].y),
                                        srf_bmp_ptr,
                                        inn_wnd_rct,
                                        srf_bmp.width,
                                        color_info,
                                        sln_sprite_counter_rad_arr[i],
                                        sln_sprite_counter_pow_arr[i]);}
                      CircleHighlight(Trunc(sln_pts[partial_pts_sum[i]+sln_sprite_counter_pos_arr[i]].x)+world_axis_shift.x,
                                      Trunc(sln_pts[partial_pts_sum[i]+sln_sprite_counter_pos_arr[i]].y)+world_axis_shift.y,
                                      srf_bmp_ptr,
                                      inn_wnd_rct,
                                      srf_bmp.width,
                                      color_info,
                                      sln_sprite_counter_rad_arr[i],
                                      sln_sprite_counter_pow_arr[i]);
                      if (sln_sprite_counter_pos_arr[i]=sln_obj_pts_cnt[i]-1) then
                          sln_sprite_counter_pos_arr[i]:=0
                      else
                        Inc(sln_sprite_counter_pos_arr[i]);
                      Continue;
                    end;
                end;


              {with inn_wnd_rct do
                rct:=PtRct(left,top,right-1,bottom-1);
              for i:=0 to sln_obj_cnt-1 do
                begin
                  SetColorInfo(SetColorInv(clRed),color_info,False);
                  LineABCG
                  (
                    sln_pts,
                    partial_pts_sum[i],
                    partial_pts_sum[i]+sln_obj_pts_cnt[i]-1,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    color_info,
                    rct,
                    world_axis_shift
                  );
                end;}

            end;}

      {srf_bmp.Canvas.TextOut(100,100,'Start Demo');
      srf_bmp.Canvas.TextOut(100,140,'Settings'  );
      srf_bmp.Canvas.TextOut(100,180,'Credits'   );
      srf_bmp.Canvas.TextOut(100,220,'Exit'      );}

     {fx_arr[1].nt_pix_cfx_type:=SE_Count_X.Value-1;
      fx_arr[1].pt_pix_cfx_type:=SE_Count_X.Value-1;}

     {fast_actor_set_var.act_pos_arr[fast_actor_set_var.act_cnt-1].x:=cur_pos.x{-bmp_ftimg_width >>1};
      fast_actor_set_var.act_pos_arr[fast_actor_set_var.act_cnt-1].y:=cur_pos.y{-bmp_ftimg_height>>1};
      bmp_ftimg_left  :=Trunc(fast_actor_set_var.act_pos_arr[fast_actor_set_var.act_cnt-1].x);
      bmp_ftimg_top   :=Trunc(fast_actor_set_var.act_pos_arr[fast_actor_set_var.act_cnt-1].y);
      bmp_ftimg_right :=bmp_ftimg_left+bmp_ftimg_width ;
      bmp_ftimg_bottom:=bmp_ftimg_top +bmp_ftimg_height;}

     {bmp_ftimg_left  :=cur_pos.x-bmp_ftimg_width >>1;
      bmp_ftimg_top   :=cur_pos.y-bmp_ftimg_height>>1;
      bmp_ftimg_right :=bmp_ftimg_left+bmp_ftimg_width ;
      bmp_ftimg_bottom:=bmp_ftimg_top +bmp_ftimg_height;}

      (*sprite_rect_arr_ptr:=@sprite_rect_arr[0];
      useless_arr_ptr    :=@useless_arr_   [0];
      for i:=0 to SE_Count_X.Value-1 do
        begin
          SetRctPos((sprite_rect_arr_ptr+i)^.x,
                    (sprite_rect_arr_ptr+i)^.y);
          SdrProc[(useless_arr_ptr+i)^];
        end;*)

      {for i:=0 to SE_Count_X.Value-1 do
        begin
          sln_var.eds_var[i].fst_img.SetRectPos(cur_pos.x-sln_var.eds_var[i].fst_img.bmp_ftimg_width>>1,
                                                cur_pos.y-sln_var.eds_var[i].fst_img.bmp_ftimg_width>>1);
          sln_var.eds_var[i].fst_img.SdrProc[1];
          sln_var.pts_var[i].fst_img.SetRectPos(cur_pos.x-sln_var.pts_var[i].fst_img.bmp_ftimg_width>>1,
                                                cur_pos.y-sln_var.pts_var[i].fst_img.bmp_ftimg_width>>1);
          sln_var.pts_var[i].fst_img.SdrProc[1];
        end;}

      //for i:=0 to SE_Count_X.Value-1 do
        {PPHighLight(surf_bmp_handle,
                    ClippedRect(inner_window_rect,PtBounds(d.x-64,d.y-64,128,128)),
                    surf_bmp.width);}
     {CircleHighlight(d.x,d.y,
                      surf_bmp_ptr,
                      inn_wnd_rct,
                      surf_bmp.width,
                      color_info,
                      128,
                      045);}

      {PPBlur(surf_bmp_ptr,
             inn_wnd_rct,
             surf_bmp.width,
             10);}

      {Points Cloud----------} {$region -fold}
      {SetColorInfo(clGreen,color_info);
      for i:=0 to 1000 do
        Point(Trunc(tex_bmp_rct_pts[0].x)+Random(Trunc(tex_bmp_rct_pts[1].x-tex_bmp_rct_pts[0].x)-1)+1,
              Trunc(tex_bmp_rct_pts[0].y)+Random(Trunc(tex_bmp_rct_pts[1].y-tex_bmp_rct_pts[0].y)-1)+1,
              srf_bmp_ptr,
              srf_bmp.width,
              color_info,
              inn_wnd_rct);} {$endregion}

      {Actor Blur------------} {$region -fold}
      {clip_mrg:=1;
      SetRectDst;
      SetRectSrc;
      arr_src_sht:=ClippedArr(rect_src,
                              rect_dst,
                              bmp_ftimg_width);
      for i:=0 to 0{sprite_count-1} do
        PPBlur(bmp_color,
               arr_src_sht,
               rect_src,
               rect_dst,
               surf_bmp.width,
               bmp_ftimg_width,
               surf_bmp_handle);} {$endregion}

      {Actor Colorize--------} {$region -fold}
      {clip_mrg:=0;
      SetRectDst;
      SetRectSrc;
      arr_src_sht:=ClippedArr(rect_src,
                              rect_dst,
                              bmp_ftimg_width);
      PPColorCorrection1(@ColorizeRMDec,
                         @ColorizeRPDec,
                         bmp_color,
                         arr_src_sht,
                         rect_src,
                         rect_dst,
                         surf_bmp.width,
                         bmp_ftimg_width,
                         surf_bmp_handle,
                         col_trans_var.grayscale_r_val);} {$endregion}

      {Bullets---------------} {$region -fold}
      {begin
        SetColorInfo(clBlue,color_info);
        for i:=0 to 10 do
          begin
            if PointCollDraw(vec_x,
                             vec_y,
                             width,
                             coll_box_arr,
                             inn_wnd_rct,
                             0) then
              begin
                vec_x         -=0{velocity}{d.x-t+Random(t<<1)};
                vec_x_dist_sht:=vec_x-i*distance;
              end
            else
              begin
                vec_x         +=velocity{d.x-t+Random(t<<1)};
                vec_x_dist_sht:=vec_x+i*distance;
              end;
            Point(vec_x_dist_sht,
                  vec_y,
                  srf_bmp_ptr,
                  srf_bmp.width,
                  color_info,
                  inn_wnd_rct);
          end;
        ArrClear(coll_box_arr,inn_wnd_rct,width);
      end;} {$endregion}

      {Fluid Simul.----------} {$region -fold}
      {SetColorInfo({clDkGray}clRed,color_info);
      if (sln_pts_cnt>0) then
        begin
          for i:=0 to sln_obj_pts_cnt[0]-1 do
            begin
              WaterWaveInit3(PtPosF(sln_pts[i].x,
                                    sln_pts[i].y));
              WaterWave3(PtPosF(sln_pts[i].x,
                                sln_pts[i].y),
                         PtPosF(obj_var.obj_arr[5].world_axis_shift.x,
                                obj_var.obj_arr[5].world_axis_shift.y),
                         3,
                         90,
                         8,
                         srf_bmp_ptr,
                         srf_bmp.width,
                         color_info,
                         inn_wnd_rct);
            end;
          //WaterWaveParamChg(a0,001,00,00);
          //WaterWaveParamChg(a3,0.5,00,80);
        end;
      SetColorInfo({clBlack}{clAqua}clYellow,color_info);
      if (sln_pts_cnt>0) then
        begin
          for i:=0 to sln_obj_pts_cnt[0]-1 do
            begin
              WaterWaveInit3(PtPosF(sln_pts[i].x,
                                    sln_pts[i].y));
              WaterWave3(PtPosF(sln_pts[i].x,
                                sln_pts[i].y),
                         PtPosF(obj_var.obj_arr[5].world_axis_shift.x,
                                obj_var.obj_arr[5].world_axis_shift.y),
                         3,
                         90,
                         8,
                         srf_bmp_ptr,
                         srf_bmp.width,
                         color_info,
                         inn_wnd_rct);
            end;
          //WaterWaveParamChg(a0,001,00,00);
          WaterWaveParamChg(a3,0.5,00,80);
        end;}

      {WaterWave2(PtPosF(world_axis.x,
                         world_axis.y),
                  PtPosF(world_axis_shift.x,
                         world_axis_shift.y),
                  4,
                  -90,
                  64,
                  srf_bmp_ptr,
                  srf_bmp.width,
                  color_info,
                  inn_wnd_rct);}
      {if (sln_pts_cnt>0) then
        begin
          WaterWaveArea(sln_pts,
                        sln_pts_cnt-sln_obj_pts_cnt[sln_obj_cnt-1],
                        sln_pts_cnt);
          SetColorInfo(clRed{clRed},color_info);
          for i:=sln_pts_cnt-sln_obj_pts_cnt[sln_obj_cnt-1] to sln_pts_cnt-2 do
            Line(Trunc(sln_pts[i+0].x),
                 Trunc(sln_pts[i+0].y),
                 Trunc(sln_pts[i+1].x),
                 Trunc(sln_pts[i+1].y),
                 srf_bmp_ptr,
                 srf_bmp.width,
                 color_info,
                 inn_wnd_rct);
          SetColorInfo(clRed{clWhite},color_info);
          for i:=sln_pts_cnt-sln_obj_pts_cnt[sln_obj_cnt-1] to sln_pts_cnt-1 do
            Point(Trunc(sln_pts[i].x),
                  Trunc(sln_pts[i].y),
                  srf_bmp_ptr,
                  srf_bmp.width,
                  color_info,
                  inn_wnd_rct);
        end;} {$endregion}

      {Fluid Colorize--------} {$region -fold}
      {PPColorCorrectionP0(@ColorizeBP,
                          srf_bmp_ptr,
                          ClippedRect(inn_wnd_rct,
                                      PtRect(tex_bmp_rct_pts)),
                          srf_bmp.width,
                          SE_Count_X.Value-1);} {$endregion}

      {Fluid Blur------------} {$region -fold}
      {for i:=0 to 0 do
        PPBlur(srf_bmp_ptr,
               inn_wnd_rct,
               srf_bmp.width);}
        {PPMonoNoise(srf_bmp_ptr,
                    inn_wnd_rct,
                    srf_bmp.width,
                    clBlue);} {$endregion}

      {Select Sprites--------} {$region -fold}
          (*if IsPointInRect(cur_pos.x,cur_pos.y,inn_wnd_rct) then // if (cur_pos.x>0) and (cur_pos.y>0) then
            begin
              SetRctPos(sprite_rect_arr[useless_fld_arr_[cur_pos.x+cur_pos.y*srf_var.srf_bmp.width]].x,
                        sprite_rect_arr[useless_fld_arr_[cur_pos.x+cur_pos.y*srf_var.srf_bmp.width]].y);

              pix_drw_type:=1;      hdc
              fx_cnt      :=1;

              fx_arr[0].rep_cnt        :=1;

              fx_arr[0].nt_pix_srf_type:=1;
              fx_arr[0].nt_pix_cfx_type:=4;
              fx_arr[0].nt_pix_cng_type:=1;

              fx_arr[0].pt_pix_srf_type:=1;
              fx_arr[0].pt_pix_cfx_type:=4;
              fx_arr[0].pt_pix_cng_type:=1;

              SetRctDst;
              SetRctSrc;
              ShaderType;

              NTValueProc[fx_arr[0].nt_value_proc_ind];
              PTValueProc[fx_arr[0].pt_value_proc_ind];

              pix_drw_type   :=0;

              fx_cnt         :=0;

              nt_pix_srf_type:=1;
              nt_pix_cfx_type:=0;
              nt_pix_cng_type:=0;

              pt_pix_srf_type:=1;
              pt_pix_cfx_type:=0;
              pt_pix_cng_type:=0;
            end;*)

        end; {$endregion}

      {TimeLine Buttons------} {$region -fold}
      {TimeLineButtonsDraw(F_MainForm.S_Splitter2.Top-40,F_MainForm.S_Splitter2.Width>>1-16+4);} {$endregion}

      {Equidistant Curves----} {$region -fold}
      {with inn_wnd_rct do
        begin
          //ArrClear(coll_arr,PtRct(left,top,right-1,bottom-1),srf_bmp.width);
          LineBCE3
          (
            sln_pts,
            0,
            sln_pts_cnt-1,
            @coll_arr[0],
            srf_bmp.width,
            PtRct(left,top,right-1,bottom-1),
            PtPos(0,0){world_axis_shift},
            projectile_arr[0].c_rad,
            {True}False
          );
          {ArrFill(coll_arr,
                  srf_bmp_ptr,
                  srf_bmp.width,
                  srf_bmp.height,
                  PtRct(left,top,right-1,bottom-1),
                  clGreen);}
          LineBCE{LineABCE}
          (
            sln_pts,
            0,
            sln_pts_cnt-1,
            srf_bmp_ptr,
            srf_bmp.width,
            color_info,
            PtRct(left,top,right-1,bottom-1),
            world_axis_shift,
            projectile_arr[0].c_rad,
            {True}False
          ); //
        end;} {$endregion}

      {Projectile------------} {$region -fold}
      {projectile_arr_ptr:=Unaligned(@projectile_arr[0]);
      for i:=0 to 0{9999} do
        with projectile_arr_ptr^ do
          begin

            {Proj. Collision Calc.} {$region -fold}
            Projectile(projectile_arr_ptr^,@coll_arr[0],srf_bmp.width,inn_wnd_rct,sln_pts); {$endregion}

            {Proj. Shape Drawing--} {$region -fold}
            CircleHighlight(Trunc(pt_n.x)+world_axis_shift.x,
                            Trunc(pt_n.y)+world_axis_shift.y,
                            low_bmp_ptr,
                            inn_wnd_rct,
                            srf_bmp.width,
                            Default(TColorInfo),
                            c_rad,
                            255);
            CircleC(Trunc(pt_n.x)+world_axis_shift.x,
                    Trunc(pt_n.y)+world_axis_shift.y,
                    c_rad,
                    srf_bmp_ptr,
                    inn_wnd_rct,
                    srf_bmp.width,
                    clBlue);
            {x0:=pt_p.x;
            y0:=pt_p.y;
            x1:=pt_n.x;
            y1:=pt_n.y;
            if LineC(Trunc(x0),
                     Trunc(y0),
                     Trunc(x1),
                     Trunc(y1),
                     inn_wnd_rct) then
              begin

                {n :=8;
                v1:=x1+n*(x1-x0);
                k :=(y1-y0)/(x1-x0);
                b :=(x1*y0-x0*y1)/(x1-x0);
                w1:=k*v1+b;
                SetColorInfo(clPurple,color_info);
                LineAC(Trunc(x0)+world_axis_shift.x,
                       Trunc(y0)+world_axis_shift.y,
                       Trunc(v1)+world_axis_shift.x,
                       Trunc(w1)+world_axis_shift.y,
                       srf_bmp_ptr,
                       srf_bmp.width,
                       color_info,
                       inn_wnd_rct);}
                {SetColorInfo(clBlue,color_info);
                Point(Trunc(pt_p.x)+world_axis_shift.x,
                      Trunc(pt_p.y)+world_axis_shift.y,
                      srf_bmp_ptr,
                      srf_bmp.width,
                      color_info);
                SetColorInfo(clGreen,color_info);
                Point(Trunc(pt_n.x)+world_axis_shift.x,
                      Trunc(pt_n.y)+world_axis_shift.y,
                      srf_bmp_ptr,
                      srf_bmp.width,
                      color_info);
                SetColorInfo(clYellow,color_info);
                Point(Trunc(pt_c.x)+world_axis_shift.x,
                      Trunc(pt_c.y)+world_axis_shift.y,
                      srf_bmp_ptr,
                      srf_bmp.width,
                      color_info);}
              end;} {$endregion}

            Inc(projectile_arr_ptr);
          end;
      with inn_wnd_rct do
        ArrClear(coll_arr,PtRct(left,top,right-1,bottom-1),srf_bmp.width);} {$endregion}

      {World Axis------------} {$region -fold}
      {Inc(drs);
      with world_axis_bmp do
        begin
          if (drs in [0..127]) then
            begin
              pix_drw_type:=02;
              fx_cnt      :=01;
            end
          else
            begin
              pix_drw_type:=00;
              fx_cnt      :=00;
            end;
        end;}

      {WorldAxisDraw;} {$endregion}

      {with local_axis_bmp,fast_image_data,fast_image_proc_var do
        begin
          fast_image_data_ptr:=@fast_image_data;
          SetRctPos(10+bmp_ftimg_width_origin >>1,
                    10+bmp_ftimg_height_origin>>1);
          SetRctDst;
          SetRctSrc;
          SetGrad(0,bmp_ftimg_height-1,grad_rng.x,grad_rng.y);
          for i:=0 to 1000-1 do
            begin
              GrdNTValueProc0;
              GrdPTValueProc0;
            end;
        end;}

      {Inner Window Rectangle} {$region -fold}
      if (inn_wnd_mrg>0) then
        InnerWindowDraw($00FF9F66); {$endregion}

      //if (sln_pts_cnt<>0) and IsRct1InRct2(pts_img_arr[sln_obj_cnt-1].rct_ent,inn_wnd_rct) then
        {begin
          //for i:=0 to 100 do
            {ImgRot2
            (
              PtPos
              (
                pts_img_arr[sln_obj_cnt-1].rct_ent.left{pts_img_arr[sln_obj_cnt-1].rct_ent.left+pts_img_arr[sln_obj_cnt-1].rct_ent.width >>1},
                pts_img_arr[sln_obj_cnt-1].rct_ent.top {pts_img_arr[sln_obj_cnt-1].rct_ent.top +pts_img_arr[sln_obj_cnt-1].rct_ent.height>>1}
              ),
              low_bmp_ptr,
              srf_bmp_ptr,
              low_bmp.width,
              srf_bmp.width,
              PtRct(pts_img_arr[sln_obj_cnt-1].rct_ent),
              inn_wnd_rct,
              angle,
              pts_img_arr[sln_obj_cnt-1].rct_ent.left{200}{-500+{Random}(inn_wnd_rct.width )-pts_img_arr[sln_obj_cnt-1].rct_ent.width >>1}, //Random(2000)-1000,
              pts_img_arr[sln_obj_cnt-1].rct_ent.top {200}{-500+{Random}(inn_wnd_rct.height)-pts_img_arr[sln_obj_cnt-1].rct_ent.height>>1}, //Random(2000)-1000,
              1,
              low_bmp.height
            );}
          for i:=0 to 0{1300} do
          {ImgRot2
            (
              PtPos
              (
                tex_bmp.width >>1,
                tex_bmp.height>>1
              ),
              tex_bmp_ptr,
              srf_bmp_ptr,
              tex_bmp.width,
              srf_bmp.width,
              PtRct(0,0,tex_bmp.width,tex_bmp.height),
              inn_wnd_rct,
              angle,
              cur_pos.x,
              cur_pos.y,
              1,
              tex_bmp.height
            );}
          ImgRot1
            (
              PtPos
              (
                tex_bmp.width >>1,
                tex_bmp.height>>1
              ),
              tex_bmp_ptr,  //
              srf_bmp_ptr,
              tex_bmp.width,
              srf_bmp.width,
              PtRct(0,0,tex_bmp.width,tex_bmp.height),
              inn_wnd_rct,
              angle,
              cur_pos.x-tex_bmp.width >>1,
              cur_pos.y-tex_bmp.height>>1,
              False,

            );
          //angle:=37;
          angle+=1{1};
          if (angle>=360) then
            angle:=0;
        end;}

      {SetColorInfo(clBlue,color_info);
      Point(main_char_pos.x,
            main_char_pos.y,
            srf_bmp_ptr,
            srf_bmp.width,
            color_info,
            inn_wnd_rct);}

      {SetColorInfo($001D88FE,color_info);
      if (sln_pts_cnt>0) then
        begin
          for i:=0 to sln_obj_pts_cnt[0]-1 do
            begin
              WaterWaveInit3(PtPosF(sln_pts[i].x,
                                    sln_pts[i].y));
              WaterWave3(PtPosF(sln_pts[i].x,
                                sln_pts[i].y),
                         PtPosF(obj_var.obj_arr[5].world_axis_shift.x,
                                obj_var.obj_arr[5].world_axis_shift.y),
                         3,
                         90{0},
                         8{81},
                         srf_bmp_ptr,
                         srf_bmp.width,
                         color_info,
                         inn_wnd_rct);
            end;
          //WaterWaveParamChg(a0,001,000,000);
          WaterWaveParamChg(a3,001,000,020);
        end;}

      {Cursor----------------} {$region -fold}
      //CircleC(cur_pos.x,cur_pos.y,crc_rad,srf_bmp_ptr,inn_wnd_rct,srf_bmp.width,clBlue);
      CursorDraw(cur_pos.x,cur_pos.y);
      CircleHighlight(cur_pos.x,
                      cur_pos.y,
                      srf_bmp_ptr,
                      inn_wnd_rct,
                      srf_bmp.width,
                      Default(TColorInfo),
                      128,
                      045); {$endregion}

      {Minimap---------------} {$region -fold}
      {ImgScl(srf_bmp_ptr,srf_bmp_ptr,low_bmp.width,low_bmp.height,8,8);} {$endregion}

      {Full Scene Drawing----} {$region -fold}

      exec_timer.Stop;
      execution_time:=Trunc(exec_timer.Delay*1000);

      SetTextInfo(srf_var.srf_bmp.Canvas,22,$006C4411);
      srf_var.srf_bmp.Canvas.TextOut(L_Exec_Time_Info.left,
                                     L_Exec_Time_Info.top,
                                     'Execution time: '+FloatToStr(execution_time)+' ms.');

      //CnvToCnv(srf_bmp_rct,Canvas,srf_bmp.Canvas,SRCCOPY);

      //glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
      //glLoadIdentity;
      with srf_var do
        begin
          //glDrawPixels(srf_bmp.Width,srf_bmp.Height,32993{swap channels: GL_RGBA=$1908 to GL_BGRA=32993},GL_UNSIGNED_BYTE,{srf_bmp_ptr}buffer.bmBits);
          //glEnable       (GL_TEXTURE_2D);
          glTexImage2D   (GL_TEXTURE_2D,0,3,srf_bmp.Width,srf_bmp.Height,0,32993{swap channels: GL_RGBA=$1908 to GL_BGRA=32993},GL_UNSIGNED_BYTE,srf_bmp_ptr{buffer.bmBits});
          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST{GL_LINEAR});
          {glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST{GL_LINEAR});
          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S    ,GL_CLAMP  {GL_REPEAT});
          glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T    ,GL_CLAMP  {GL_REPEAT});}
          {glEnable       (GL_COLOR_LOGIC_OP);
          glLogicOp      (GL_COPY_INVERTED);}
          {glEnable       (GL_BLEND);
          glBlendFunc    (GL_ONE_MINUS_DST_COLOR,GL_ZERO);}
          glBegin        (GL_QUADS);
            glTexCoord2f ( 0, 0  );
            glVertex3f   (-1, 1,0);
            glTexCoord2f ( 1, 0  );
            glVertex3f   ( 1, 1,0);
            glTexCoord2f ( 1, 1  );
            glVertex3f   ( 1,-1,0);
            glTexCoord2f ( 0, 1  );
            glVertex3f   (-1,-1,0);
          glEnd;

          {glBegin(GL_QUADS);
            glColor3f (1 , 1, 1);
            glVertex3f(-0.5, 0.5, 0);
            glColor3f (1 , 1, 1);
            glVertex3f( 0.5, 0.5, 0);
            glColor3f (1 , 1, 1);
            glVertex3f( 0.5,-0.5, 0);
            glColor3f (1 , 1, 1);
            glVertex3f(-0.5,-0.5, 0);
          glEnd;}

        end;
      OpenGLControl2.SwapBuffers; {$endregion}

    end;

end; {$endregion}
procedure TF_MainForm.T_Logo1Timer    (sender:TObject);                   {$region -fold}
begin
  with srf_var do
    begin
      PPFloodFill(srf_bmp_ptr,inn_wnd_rct,srf_bmp.width,bg_color);
      {with logo1_img do
        begin
          FadeTemplate0(100,100,100,col_trans_arr[02],time_interval);
          if (time_interval=0) then
            begin
              T_Logo1.Enabled:=False;
              T_Logo2.Enabled:=True;
              mciSendString(PChar('play "'+LOGO2_MUSIC+'"'),nil,0,0);
            end;
          SetBkgnd (srf_bmp_ptr,
                    srf_bmp.width,
                    srf_bmp.height,
                    inn_wnd_rct);
          SetRctPos(world_axis.x+world_axis_shift.x-logo1_img.bmp_ftimg_width >>1,
                    world_axis.y+world_axis_shift.y-logo1_img.bmp_ftimg_height>>1);
          SdrProc[3];
        end;}
      //GetCursorPos(cur_pos);
      //cur_pos:=ScreenToClient(cur_pos);
      //CursorDraw(cur_pos.x,cur_pos.y);
      glEnable       (GL_TEXTURE_2D);
      glTexImage2D   (GL_TEXTURE_2D,0,3,srf_bmp.Width,srf_bmp.Height,0,32993,GL_UNSIGNED_BYTE,buffer.bmBits);
      glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
      glBegin        (GL_QUADS);
        glTexCoord2f ( 0, 0  );
        glVertex3f   (-1, 1,0);
        glTexCoord2f ( 1, 0  );
        glVertex3f   ( 1, 1,0);
        glTexCoord2f ( 1, 1  );
        glVertex3f   ( 1,-1,0);
        glTexCoord2f ( 0, 1  );
        glVertex3f   (-1,-1,0);
      glEnd;
    end;
  OpenGLControl2.SwapBuffers;
end; {$endregion}
procedure TF_MainForm.T_Logo2Timer    (sender:TObject);                   {$region -fold}
begin
  with srf_var do
    begin
      PPFloodFill(srf_bmp_ptr,inn_wnd_rct,srf_bmp.width,bg_color);
      {with logo2_img do
        begin
          FadeTemplate1(100,100,100,col_trans_arr[02],time_interval);
          if (time_interval=0) then
            begin
              T_Logo2.Enabled       :=False;
              T_Logo3.Enabled       :=True;
              mciSendString(PChar('stop "'+LOGO2_MUSIC+'"'),nil,0,0);
              LCLVLCPlayer_Intro.PlayFile(Application.Location+INTRO_MOVIE);
            end;
          SetBkgnd (srf_bmp_ptr,
                    srf_bmp.width,
                    srf_bmp.height,
                    inn_wnd_rct);
          SetRctPos(world_axis.x+world_axis_shift.x-logo2_img.bmp_ftimg_width >>1,
                    world_axis.y+world_axis_shift.y-logo2_img.bmp_ftimg_height>>1);
          SdrProc[3];
        end;}
      //GetCursorPos(cur_pos);
      //cur_pos:=ScreenToClient(cur_pos);
      //CursorDraw(cur_pos.x,cur_pos.y);
      glEnable       (GL_TEXTURE_2D);
      glTexImage2D   (GL_TEXTURE_2D,0,3,srf_bmp.Width,srf_bmp.Height,0,32993,GL_UNSIGNED_BYTE,buffer.bmBits);
      glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
      glBegin        (GL_QUADS);
        glTexCoord2f ( 0, 0  );
        glVertex3f   (-1, 1,0);
        glTexCoord2f ( 1, 0  );
        glVertex3f   ( 1, 1,0);
        glTexCoord2f ( 1, 1  );
        glVertex3f   ( 1,-1,0);
        glTexCoord2f ( 0, 1  );
        glVertex3f   (-1,-1,0);
      glEnd;
    end;
  OpenGLControl2.SwapBuffers;
end; {$endregion}
procedure TF_MainForm.T_Logo3Timer    (sender:TObject);                   {$region -fold}
begin
  {time_interval+=1;
  case time_interval of
    0          :
      begin
        T_Logo3.Enabled:=False;
        T_Menu.Enabled :=True;
        LCLVLCPlayer_Intro.Stop;
        mciSendString(PChar('stop "'+DUCK_VOICE1+'"'),nil,0,0);
        mciSendString(PChar('play "'+MENU_THEME +'"'),nil,0,0);
      end;
    1,10,50,060: PlaySound    (PChar(EGG_SHAKE               ),0,SND_ASYNC);
            080: mciSendString(PChar('play "'+DUCK_VOICE1+'"'),nil,0,0    );
            090: PlaySound    (PChar(EGG_EXPLOSION           ),0,SND_ASYNC);
            210: PlaySound    (PChar(LETTERS_DROP            ),0,SND_ASYNC);
            380: time_interval:=-1;
  end;}
end; {$endregion}
procedure TF_MainForm.T_MenuTimer     (sender:TObject);                   {$region -fold}
begin
  {with srf_var do
    begin
      PPFloodFill(srf_bmp_ptr,inn_wnd_rct,srf_bmp.width,bg_color,flood_fill_inc);
      flood_fill_inc:=not flood_fill_inc;
      with start_game_img do
        begin
          SetBkgnd (srf_bmp_ptr,
                    srf_bmp.width,
                    srf_bmp.height,
                    inn_wnd_rct);
          SetRctPos(world_axis.x+world_axis_shift.x-start_game_img.bmp_ftimg_width >>1,
                    world_axis.y+world_axis_shift.y-start_game_img.bmp_ftimg_height>>1-70);
          SdrProc[3];
        end;
      with settings_img do
        begin
          SetBkgnd (srf_bmp_ptr,
                    srf_bmp.width,
                    srf_bmp.height,
                    inn_wnd_rct);
          SetRctPos(world_axis.x+world_axis_shift.x-settings_img.bmp_ftimg_width >>1,
                    world_axis.y+world_axis_shift.y-settings_img.bmp_ftimg_height>>1-70+60);
          SdrProc[3];
        end;
      with save_and_exit_img do
        begin
          SetBkgnd (srf_bmp_ptr,
                    srf_bmp.width,
                    srf_bmp.height,
                    inn_wnd_rct);
          SetRctPos(world_axis.x+world_axis_shift.x-save_and_exit_img.bmp_ftimg_width >>1,
                    world_axis.y+world_axis_shift.y-save_and_exit_img.bmp_ftimg_height>>1-70+120);
          SdrProc[3];
        end;
      with selection_border_img do
        begin
          SetBkgnd (srf_bmp_ptr,
                    srf_bmp.width,
                    srf_bmp.height,
                    inn_wnd_rct);
          SetRctPos(world_axis.x+world_axis_shift.x-selection_border_img.bmp_ftimg_width >>1,
                    world_axis.y+world_axis_shift.y-selection_border_img.bmp_ftimg_height>>1-70+60*menu_img_arr_cnt);
          SdrProc[3];
        end;
      with military_head_img do
        begin
          SetBkgnd (srf_bmp_ptr,
                    srf_bmp.width,
                    srf_bmp.height,
                    inn_wnd_rct);
          SetRctPos(world_axis.x+world_axis_shift.x-selection_border_img.bmp_ftimg_width >>1-military_head_img.bmp_ftimg_width-20,
                    world_axis.y+world_axis_shift.y-military_head_img   .bmp_ftimg_height>>1-70+60*menu_img_arr_cnt);
          SdrProc[3];
        end;
      with menu_img_arr[menu_img_arr_cnt] do
        begin
          begin
            pix_drw_type     :=001;
            col_trans_arr[04]:=032;
            fx_cnt           :=001;
            fx_arr[0].rep_cnt        :=01;
            fx_arr[0].nt_pix_srf_type:=01;
            fx_arr[0].nt_pix_cfx_type:=04;
            fx_arr[0].nt_pix_cng_type:=00;
            fx_arr[0].pt_pix_srf_type:=01;
            fx_arr[0].pt_pix_cfx_type:=04;
            fx_arr[0].pt_pix_cng_type:=00;
          end;
          SetBkgnd (srf_bmp_ptr,
                    srf_bmp.width,
                    srf_bmp.height,
                    inn_wnd_rct);
          SetRctPos(world_axis.x+world_axis_shift.x-menu_img_arr[menu_img_arr_cnt].bmp_ftimg_width >>1,
                    world_axis.y+world_axis_shift.y-menu_img_arr[menu_img_arr_cnt].bmp_ftimg_height>>1-70+60*menu_img_arr_cnt);
          SdrProc[3];
          begin
            pix_drw_type:=000;
            fx_cnt      :=000;
          end;
        end;
      //GetCursorPos(cur_pos);
      //cur_pos:=ScreenToClient(cur_pos);
      //CursorDraw(cur_pos.x,cur_pos.y);
      glEnable       (GL_TEXTURE_2D);
      glTexImage2D   (GL_TEXTURE_2D,0,3,srf_bmp.Width,srf_bmp.Height,0,32993,GL_UNSIGNED_BYTE,buffer.bmBits);
      glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
      glBegin        (GL_QUADS);
        glTexCoord2f ( 0, 0  );
        glVertex3f   (-1, 1,0);
        glTexCoord2f ( 1, 0  );
        glVertex3f   ( 1, 1,0);
        glTexCoord2f ( 1, 1  );
        glVertex3f   ( 1,-1,0);
        glTexCoord2f ( 0, 1  );
        glVertex3f   (-1,-1,0);
      glEnd;
    end;
  OpenGLControl2.SwapBuffers;}
end; {$endregion}
procedure TF_MainForm.T_GameTimer     (sender:TObject);                   {$region -fold}
{var
  color_info: TColorInfo;
  i         : integer;}
begin
  {with srf_var do
    begin
      PPFloodFill(srf_bmp_ptr,inn_wnd_rct,srf_bmp.width,bg_color,flood_fill_inc);
      flood_fill_inc:=not flood_fill_inc;
      //WorldAxisDraw;
      with tlm_var do
        for i:=0 to High(tilemap_arr2) do
          with tilemap_arr2[i{High(mask_template_arr2)}] do
            begin
              SetRctPos(world_axis.x-(bmp_ftimg_width_origin *tilemap_sprite_w_h.x)>>1+srf_var.world_axis_shift.x,
                        world_axis.y-(bmp_ftimg_height_origin*tilemap_sprite_w_h.y)>>1+srf_var.world_axis_shift.y);
              SetBkgnd
              (
                srf_bmp_ptr,
                srf_bmp.width,
                srf_bmp.height,
                inn_wnd_rct
              );
              with tilemap_sprite_ptr^ do
                SetBkgnd
                (
                  srf_bmp_ptr,
                  srf_bmp.width,
                  srf_bmp.height,
                  inn_wnd_rct
                );
              FilTileMap1;
              FilTileMap2;
              bmp_bkgnd_ptr:=@coll_arr[0];
            end;
      SetColorInfo(clBlue,color_info);
      Point(main_char_pos.x,
            main_char_pos.y,
            srf_bmp_ptr,
            srf_bmp.width,
            color_info,
            inn_wnd_rct);
      GetCursorPos(cur_pos);
      cur_pos:=ScreenToClient(cur_pos);
      CursorDraw(cur_pos.x,cur_pos.y);
      glEnable       (GL_TEXTURE_2D);
      glTexImage2D   (GL_TEXTURE_2D,0,3,srf_bmp.Width,srf_bmp.Height,0,32993,GL_UNSIGNED_BYTE,buffer.bmBits);
      glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
      glBegin        (GL_QUADS);
        glTexCoord2f ( 0, 0  );
        glVertex3f   (-1, 1,0);
        glTexCoord2f ( 1, 0  );
        glVertex3f   ( 1, 1,0);
        glTexCoord2f ( 1, 1  );
        glVertex3f   ( 1,-1,0);
        glTexCoord2f ( 0, 1  );
        glVertex3f   (-1,-1,0);
      glEnd;
    end;
  OpenGLControl2.SwapBuffers;}
end; {$endregion}
{$endregion}

// (Test) Тест:
{UI} {$region -fold}
procedure TF_MainForm.Button1Click(sender:TObject); {$region -fold}
var
  args_            : TFunc0Args;

  c,s,v,w          : double;
  execution_time   : double;
  i,j,k,i_         : integer;
  color_info       : TColorInfo;
  b                : boolean;
  rot_img          : TFastImageItem;
  tex_img          : TFastImageItem;
  bmp_ptr0,bmp_ptr1: PInteger;
  col              : TColor;
  n                : integer=256;

  x0      : integer;
  y0      : integer;
  x1      : integer;
  y1      : integer;
  crc     : TCrPosF;
  lnint   : boolean;
  col_info: TColorInfo;

  procedure BakeRot(var rot_img_:TFastImageItem; constref angle_:double);
  begin
    with srf_var,tex_var do
      begin
        if (Trunc(angle_)=0) then
          begin
            rot_img_:=Nil;
            Exit;
          end;
        ImgRot1
        (
          PtPos
          (
            tex_bmp.width >>1,
            tex_bmp.height>>1
          ),
          PtRct(0,0,tex_bmp.width,tex_bmp.height),
          inn_wnd_rct,
          tex_bmp_ptr,
          rot_arr_ptr,
          tex_bmp.width,
          srf_bmp.width,
          angle_,
          world_axis.x+world_axis_shift.x-tex_bmp.width >>1,
          world_axis.y+world_axis_shift.y-tex_bmp.height>>1,
          1,
          bounding_rct,
          NT_BIT_MASK_ALPHA
        );
        BorderBlur(rot_arr_ptr,srf_bmp.width,inn_wnd_rct,0,NT_BIT_MASK_ALPHA);
        ImgRot1
        (
          PtPos
          (
            tex_bmp.width >>1,
            tex_bmp.height>>1
          ),
          PtRct(0,0,tex_bmp.width,tex_bmp.height),
          inn_wnd_rct,
          tex_bmp_ptr,
          rot_arr_ptr,
          tex_bmp.width,
          srf_bmp.width,
          angle_,
          world_axis.x+world_axis_shift.x-tex_bmp.width >>1,
          world_axis.y+world_axis_shift.y-tex_bmp.height>>1,
          1,
          bounding_rct,
          0
        );
        if (Trunc(angle_) mod 360=0) then
          begin
            rot_img_:=Nil;
            Exit;
          end;
        rot_img_:=TFastImageItem.Create
        (
          rot_arr_ptr,
          srf_bmp.width,
          srf_bmp.height,
          inn_wnd_rct,
          bounding_rct,
          0
        );
        with rot_img_,fast_image_data,fast_image_proc_var do
          begin
            fast_image_data_ptr0:=@fast_image_data;
            SetRctPos (bounding_rct.left,bounding_rct.top);
            SetValInfo(rot_arr_ptr,Nil,Nil,srf_bmp.width,srf_bmp.height);
            bmp_src_rct_clp:=bounding_rct;
            img_kind       :=1;
            pix_drw_type   :=0;   //must be in range of [0..002]
            fx_cnt         :=0;   //must be in range of [0..255]
            alpha_max      :=$FF; //$7F;
            CmpProc[img_kind];    //ImgToCImg;
            SetRctPos(bmp_src_rct_clp);
            SetSdrType;
            ShaderType;
          end;
        ArrClear(rot_arr_ptr,inn_wnd_rct,rot_arr_width,0,False);
      end;
  end;

  procedure DrawRot(    rot_img_:TFastImageItem; constref angle_:double);
  begin
    with srf_var,tex_var do
      ImgRot1
      (
        PtPos
        (
          tex_bmp.width >>1,
          tex_bmp.height>>1
        ),
        PtRct(0,0,tex_bmp.width,tex_bmp.height),
        inn_wnd_rct,
        tex_bmp_ptr,
        srf_bmp_ptr,
        tex_bmp.width,
        srf_bmp.width,
        angle_,
        world_axis.x+world_axis_shift.x-tex_bmp.width >>1,
        world_axis.y+world_axis_shift.y-tex_bmp.height>>1,
        0,
        bounding_rct,
        0
      );
    if (rot_img_<>Nil) then
      with rot_img_,fast_image_data,fast_image_proc_var do
        begin
          fast_image_data_ptr0:=@fast_image_data;
          SetBkgnd
          (
            srf_var.srf_bmp_ptr,
            srf_var.srf_bmp.width,
            srf_var.srf_bmp.height,
            srf_var.inn_wnd_rct
          );
          SetRctPos(bounding_rct.left,bounding_rct.top);
          SdrProc[3];
        end;
  end;

  function CalcPix: integer;
  var
    i: integer;
  begin
    Result:=0;
    for i:=0 to angle_cnt-1 do
      if (rot_img_arr[i]<>Nil) then
        Result+=rot_img_arr[i].fast_image_data.nt_pix_cnt;
  end;

  procedure AlphaBlur0(    pixel_ptr0:PInteger;                               bmp_dst_width:TColor; d_alpha:byte);
  var
    pixel_ptr2: TColor;
    v0,v1,v2  : TColor;
  begin
    v0        :=(pixel_ptr0-1            )^;
    v1        :=(pixel_ptr0+1            )^;
    v2        :=(pixel_ptr0+bmp_dst_width)^;
    pixel_ptr2:=RGB(Trunc((Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00))/3),
                    Trunc((Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08))/3),
                    Trunc((Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16))/3));
    AlphaBlend0(pixel_ptr0,Blue(pixel_ptr2),Green(pixel_ptr2),Red(pixel_ptr2),d_alpha);
  end;
  procedure AlphaBlur0(var pixel_ptr0:PInteger; constref pixel_ptr1:PInteger; bmp_dst_width:TColor; d_alpha:byte);
  var
    pixel_ptr2 : TColor;
    v0,v1,v2,v3: TColor;
  begin
    v0        :=(pixel_ptr1-1            )^;
    v1        :=(pixel_ptr1+bmp_dst_width)^;
    v2        :=(pixel_ptr1              )^;
    pixel_ptr2:=RGB(Trunc((Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00))/3),
                    Trunc((Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08))/3),
                    Trunc((Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16))/3));
    AlphaBlend0(pixel_ptr0,Blue(pixel_ptr2),Green(pixel_ptr2),Red(pixel_ptr2),d_alpha);
  end;
  procedure AlphaBlur1(    pixel_ptr0:PInteger;                               bmp_dst_width:TColor; d_alpha:byte);
  var
    pixel_ptr2: TColor;
    v0,v1,v2  : TColor;
  begin
    v0        :=(pixel_ptr0-1            )^;
    v1        :=(pixel_ptr0+1            )^;
    v2        :=(pixel_ptr0-bmp_dst_width)^;
    pixel_ptr2:=RGB(Trunc((Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00))/3),
                    Trunc((Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08))/3),
                    Trunc((Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16))/3));
    AlphaBlend0(pixel_ptr0,Blue(pixel_ptr2),Green(pixel_ptr2),Red(pixel_ptr2),d_alpha);
  end;
  procedure AlphaBlur1(var pixel_ptr0:PInteger; constref pixel_ptr1:PInteger; bmp_dst_width:TColor; d_alpha:byte);
  var
    pixel_ptr2 : TColor;
    v0,v1,v2,v3: TColor;
  begin
    v0        :=(pixel_ptr1+1            )^;
    v1        :=(pixel_ptr1-bmp_dst_width)^;
    v2        :=(pixel_ptr1              )^;
    pixel_ptr2:=RGB(Trunc((Byte(    (v0)>>00)+Byte(    (v1)>>00)+Byte(    (v2)>>00))/3),
                    Trunc((Byte(Word(v0)>>08)+Byte(Word(v1)>>08)+Byte(Word(v2)>>08))/3),
                    Trunc((Byte(    (v0)>>16)+Byte(    (v1)>>16)+Byte(    (v2)>>16))/3));
    AlphaBlend0(pixel_ptr0,Blue(pixel_ptr2),Green(pixel_ptr2),Red(pixel_ptr2),d_alpha);
  end;
  procedure AlphaBlur2(    pixel_ptr0,                   pixel_ptr1:PInteger; bmp_dst_width:TColor; d_alpha:byte);
  var
    pixel_ptr2: TColor;
  begin
    pixel_ptr2:=BlurRGB4(pixel_ptr1-bmp_dst_width-1,bmp_dst_width);
    AlphaBlend0(pixel_ptr0,Blue(pixel_ptr2),Green(pixel_ptr2),Red(pixel_ptr2),d_alpha);
  end;

label
  l1;

begin
  {
  {angle    :=0{45};
  angle_cnt:=361{0};
  loop_cnt :=1{000}{00000};
  SetLength(rot_img_arr,angle_cnt);

  with tex_var do
    if show_tex then
      begin
        tex_bmp_ptr:=GetBmpHandle(tex_bmp );
        tex_bmp.Canvas.Draw(0,0,loaded_picture.Bitmap);
      end;

  PPFloodFill(srf_var.srf_bmp_ptr,bounding_rct,srf_var.srf_bmp.width,srf_var.bg_color);
  exec_timer:=TPerformanceTime.Create;
  exec_timer.Start;

  with srf_var do
    tex_img:=TFastImage.Create
    (
      rot_arr_ptr,
      srf_bmp.width,
      srf_bmp.height,
      inn_wnd_rct,
      bounding_rct,
      0
    );

  with tex_var,tex_img do
    begin
      SetValInfo (tex_bmp_ptr,Nil,Nil,tex_bmp.width,tex_bmp.height);
      //CrtTBmpInst(loaded_picture.Bitmap,bmp_color_ptr);
      bmp_src_rct_clp:=PtRct(0,0,tex_bmp.width,tex_bmp.height);
      ImgToCImg;
    end;

  for i:=0 to angle_cnt-1 do
    BakeRot(rot_img_arr[i],angle+i);

  exec_timer.Stop;
  execution_time:=Trunc(exec_timer.Delay*1000);

  Sleep(1000);}
  //for i:=0 to (angle_cnt-1)*2{-1} do
    begin
      {Sleep(10);
      PPFloodFill(srf_var.srf_bmp_ptr,srf_var.inn_wnd_rct{bounding_rct},srf_var.srf_bmp.width,srf_var.bg_color);
      with tex_img do
        begin
          SetBckgd
          (
            srf_var.srf_bmp_ptr,
            srf_var.srf_bmp.width,
            srf_var.srf_bmp.height
          );
          SetRctPos(100,100);
          SdrProc[3];
        end;
      i_:=i mod 360;
      DrawRot(rot_img_arr[i_],angle+i_);}

      EdgeAATest(srf_var.srf_bmp_ptr,srf_var.inn_wnd_rct,srf_var.srf_bmp.width,100,10{StrToInt(M_Description.Lines.Text)});

      CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
      InvalidateInnerWindow;
      Application.ProcessMessages;
    end;

  {with srf_var do
    begin
      //Sleep(10);
      EdgeAATest(srf_bmp_ptr,inn_wnd_rct,srf_bmp.width,StrToInt(M_Description.Lines.Text));
      CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
      InvalidateInnerWindow;
    end;}

  {with srf_var,tex_var,tex_img do
    M_Description.Lines.Text:='pix count         :'+IntToStr  (CalcPix         )+' px.'+#13+
                      'Execution time    :'+FloatToStr(execution_time  )+' ms.'+#13+
                      'img kind          :'+IntToStr  ((bmp_color_ptr+54)^>>24)+' px.';
                     {'loop count        :'+IntToStr  (loop_cnt      )       +#13+
                      'destination width :'+IntToStr  (srf_bmp.width )+' px.'+#13+
                      'destination height:'+IntToStr  (srf_bmp.height)+' px.'+#13+
                      'image width       :'+IntToStr  (tex_bmp.width )+' px.'+#13+
                      'image height      :'+IntToStr  (tex_bmp.height)+' px.'+#13};}


  {
  with srf_var do
    begin

      SetColorInfo(clBlue,color_info);
      Point(world_axis.x,
            world_axis.y,
            srf_bmp_ptr,
            srf_bmp.width,
            color_info); // pivot;

      SetColorInfo(clGreen,color_info);
      for i:=0 to 360 do
        begin
          GetRotNotRound(PtPos(10,10),i,c,s,v,w,100,100);
          Point(Trunc(v+world_axis.x),
                Trunc(w+world_axis.y),
                srf_bmp_ptr,
                srf_bmp.width,
                color_info,
                inn_wnd_rct); // turned points cloud;
        end;

      SetColorInfo(clRed,color_info);
      for i:=0 to 360 do
        begin
          GetRotRound(PtPos(10,10),i,c,s,v,w,100,100);
          Point(Trunc(v+world_axis.x),
                Trunc(w+world_axis.y),
                srf_bmp_ptr,
                srf_bmp.width,
                color_info,
                inn_wnd_rct); // turned points cloud;
        end;

      SetColorInfo(clBlack,color_info);
      for i:=0 to 360 do
        begin
          GetRotNotRound2(PtPos(10,10),i,c2,s2,v2,w2,100,100);
          Point(v2+world_axis.x,
                w2+world_axis.y,
                srf_bmp_ptr,
                srf_bmp.width,
                color_info,
                inn_wnd_rct); // turned points cloud;
        end;

      CnvToCnv(srf_bmp_rct,Canvas,srf_bmp.Canvas,SRCCOPY);
      InvalidateInnerWindow;

    end;
  }

  }
  //
  {M_Description.Lines.Text:='';
  SetLength(arr_test,10000000);
  for i:=0 to 10000000-1 do
    arr_test[i]:=Random(2);

  {for i:=0 to 5000000-1 do
    arr_test[i]:=1;
  for i:=5000000 to 10000000-1 do
    arr_test[i]:=0;}
  {for i:=0 to 5000000-1 do
    arr_test[2*i]:=0;
  for i:=0 to 5000000-1 do
    arr_test[2*i+1]:=1;}

  exec_timer:=TPerformanceTime.Create;
  exec_timer.Start;

  ArrNzItCnt(arr_test);

  exec_timer.Stop;
  execution_time:=Trunc(exec_timer.Delay*1000);
  M_Description.Lines.Text:=FloatToStr(execution_time);}

  {col:=Random($00FFFFFF);

  for k:=0 to n-1 do
    begin
      col:={clBlue}{col-64*k}Random($00FFFFFF);
      bmp_ptr0:=srf_var.srf_bmp_ptr+100+(100+k)*srf_var.srf_bmp.width;
      bmp_ptr1:=srf_var.low_bmp_ptr+100+(100+k)*srf_var.srf_bmp.width;
      for i:=0 to 39-1 do
        begin
          for j:=0 to 9-1 do
            begin
              col:={clBlue}{col-64*k}Random($00FFFFFF);
              col:={clBlue}{col-64*k}RGB(col,col,col);
              bmp_ptr0^:=col;
              bmp_ptr1^:=col;
              Inc(bmp_ptr0);
              Inc(bmp_ptr1);
            end;
          Inc(bmp_ptr0,srf_var.srf_bmp.width);
          Inc(bmp_ptr1,srf_var.srf_bmp.width);
        end;
    end;

  for k:=0 to n-1 do
    begin
      bmp_ptr0:=srf_var.srf_bmp_ptr+100+(99+k)*srf_var.srf_bmp.width;                   //000
      bmp_ptr1:=srf_var.low_bmp_ptr+100+(99+k)*srf_var.srf_bmp.width;                   //111000
      for i:=0 to 39-1 do                                                               //   111
        begin
          for j:=0 to 9-1 do
            begin
              AlphaBlur0(bmp_ptr0,bmp_ptr1,srf_var.srf_bmp.width,28*j);
              Inc(bmp_ptr0);
              Inc(bmp_ptr1);
            end;
          Inc(bmp_ptr0,srf_var.srf_bmp.width);
          Inc(bmp_ptr1,srf_var.srf_bmp.width);
        end;
    end;

  for k:=0 to n-1 do
    begin
      bmp_ptr0:=srf_var.srf_bmp_ptr+100+(100+k)*srf_var.srf_bmp.width;
      bmp_ptr1:=srf_var.low_bmp_ptr+100+(100+k)*srf_var.srf_bmp.width;
      Inc(bmp_ptr0,39*9-1+39*srf_var.srf_bmp.width);
      Inc(bmp_ptr1,39*9-1+39*srf_var.srf_bmp.width);
      for i:=0 to 39-1 do
        begin
          for j:=0 to 9-1 do
            begin
              AlphaBlur1(bmp_ptr0,bmp_ptr1,srf_var.srf_bmp.width,28*j);
              Dec(bmp_ptr0);
              Dec(bmp_ptr1);
            end;
          Dec(bmp_ptr0,srf_var.srf_bmp.width);
          Dec(bmp_ptr1,srf_var.srf_bmp.width);
        end;
    end;}

  with srf_var,pvt_var,sprite_sheet_arr[pvt_var.local_axis_bmp_ind],fast_image_data,fast_image_proc_var do
    begin

      fast_image_data_ptr0:=@fast_image_data;

      {exec_timer.Start;
      for i:=0 to 100 do
        LocalAxisDraw(world_axis.x+world_axis_shift.x,world_axis.y+world_axis_shift.y);
      exec_timer.Stop;
      execution_time:=Trunc(exec_timer.Delay*1000);
      SetTextInfo(srf_var.srf_bmp.Canvas,22);
      srf_var.srf_bmp.Canvas.TextOut(L_Exec_Time_Info.left,
                                     L_Exec_Time_Info.top,
                                     'Execution time: '+FloatToStr(execution_time)+' ms.');}

      {for j:=0 to 4-1 do
        begin
          for i:=0 to 64 do
            begin
              LowerBmpToMainBmp;
              scl_mul:=PtPosF(1.0-i/64,1.0-i/64);
              if (scl_mul=PtPosF(1.0,1.0)) then
                SdrProc[3]
              else
                begin
                  SetRctPos(10+bmp_ftimg_width_origin >>1,
                            10+bmp_ftimg_height_origin>>1);
                  {Sprite Bounding Rectangles}
                  SetRctDst;
                  SetRctSrc;
                  {Sprite Shader Type}
                  SetSdrType;
                  SdrType    [sdr_type_ind];
                  {Sprite Drawing}
                  NTBeginProc[nt_begin_proc_ind];
                  FilNTColorScaleDown;
                  //BlrNTColorScaleDown;
                  PTBeginProc[pt_begin_proc_ind];
                  FilPTColorScaleDown;
                  //BlrPTColorScaleDown;
                end;
              Sleep(64);
              CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
              //InvalidateInnerWindow;
            end;
          for i:=0 to 64 do
            begin
              LowerBmpToMainBmp;
              scl_mul:=PtPosF(0.0+i/64,0.0+i/64);
              if (scl_mul=PtPosF(1.0,1.0)) then
                SdrProc[3]
              else
                begin
                  SetRctPos(10+bmp_ftimg_width_origin >>1,
                            10+bmp_ftimg_height_origin>>1);
                  {Sprite Bounding Rectangles}
                  SetRctDst;
                  SetRctSrc;
                  {Sprite Shader Type}
                  SetSdrType;
                  SdrType    [sdr_type_ind];
                  {Sprite Drawing}
                  NTBeginProc[nt_begin_proc_ind];
                  FilNTColorScaleDown;
                  //BlrNTColorScaleDown;
                  PTBeginProc[pt_begin_proc_ind];
                  FilPTColorScaleDown;
                  //BlrPTColorScaleDown;
                end;
              Sleep(64);
              CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
              //InvalidateInnerWindow;
            end;
        end;}


      LowerBmpToMainBmp;
      SetRctPos(10+bmp_ftimg_width_origin >>1,
                10+bmp_ftimg_height_origin>>1);
      SetRctDst;
      SetRctSrc;
      SetGrad(0,bmp_ftimg_height-1,Random($FFFFFF),Random($FFFFFF));
      exec_timer.Start;
      for i:=0 to 1{2000}-1 do
        begin
          GrdNTValueProc0;
          GrdPTValueProc0;
        end;
      exec_timer.Stop;
      execution_time:=Trunc(exec_timer.Delay*1000);
      SetTextInfo(srf_var.srf_bmp.Canvas,22);
      srf_var.srf_bmp.Canvas.TextOut(L_Exec_Time_Info.left,
                                     L_Exec_Time_Info.top,
                                     'Execution time: '+FloatToStr(execution_time)+' ms.');
      CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);


      {LowerBmpToMainBmp;
      col_info:=Default(TColorInfo);
      Line  (200,200,210,210,srf_bmp_ptr,srf_bmp.width,col_info);
      {lnint.x0:=1000;
      lnint.y0:=1000;
      lnint.x1:=1000;
      lnint.y1:=1000;
      crc.x:=60;
      crc.y:=60;
      crc.r:=32;}
      CircleC(260,200,32,srf_bmp_ptr,inn_wnd_rct,srf_bmp.width,col_info);
      lnint:=LineCrcIntPt(200,200,210,210,260,200,32,0);
      Point(Trunc(lnint.x0),Trunc(lnint.y0),srf_bmp_ptr,srf_bmp.width,col_info,inn_wnd_rct);
      Point(Trunc(lnint.x1),Trunc(lnint.y1),srf_bmp_ptr,srf_bmp.width,col_info,inn_wnd_rct);
      if not lnint.b then
        RM_Description.Lines.Text:='_'
      else
        RM_Description.Lines.Text:=IntToStr(Trunc(lnint.x0))+'; '+IntToStr(Trunc(lnint.y0))+'; '+IntToStr(Trunc(lnint.x1))+'; '+IntToStr(Trunc(lnint.y1))+';';
      CnvToCnv(srf_bmp_rct,Canvas,srf_bmp.Canvas,SRCCOPY);}


      {SetLength(arr_test_byte,1024*768);
      arr_test_byte[63]:=1;
      IndexByte((@arr_test_byte[0])^,64,1);
      exec_timer.Start;
      for i:=0 to 1000000-1 do
        {for j:=0 to 64-1 do
          if (arr_test_byte[j]=1) then
            Break;}
        IndexByte((@arr_test_byte[0])^,64,1);
      exec_timer.Stop;
      execution_time:=Trunc(exec_timer.Delay*1000);
      SetTextInfo(srf_var.srf_bmp.Canvas,22);
      srf_var.srf_bmp.Canvas.TextOut(L_Exec_Time_Info.left+100,
                                     L_Exec_Time_Info.top,
                                     'Execution time: '+FloatToStr(execution_time)+' ms.');
      CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);}

    end;

  {Sleep(100);
  CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
  InvalidateInnerWindow;}

  //RM_Description.Lines.Text:=IntToStr(SizeOf(Byte));

end; {$endregion}
{$endregion}

end.

initialization

{$I main.lrs}

end.

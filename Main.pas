unit Main;

{This file contains main routines for game editor, including logic and user interfaces}

{$mode objfpc}{$H+,M+,R-,I+,Q-,SMARTLINK+,INLINE+}
{$modeswitch nestedprocvars}

interface

uses

  {ZLib,}
  Graphics, Classes, SysUtils, Forms, ComCtrls, GraphType, LResources, Dialogs,
  LMessages, FileUtil, Math, Menus, StdCtrls, ExtCtrls, Buttons, Controls, Spin,
  ExtDlgs, MMSystem, RichMemo, GifAnim, lclvlc, GL, OpenGLContext,
  {$ifdef Windows}
  {JwaWindows,} Windows, WinInet, Mouse,
  {$endif}
  {$ifdef Linux}
  Linux,Unix,
  {$endif}
  ImgList, IniFiles, Types, TypInfo, LCLType, LCLIntf,
  {MTProcs, FPImage, freetype, lazfreetype,}
  {Own Units}
  Fast_AnimK, Fast_GL, Fast_Graphics, Fast_Scene_Tree, Fast_Threads,
  Documentation, Performance_Time;



const

  BTN_CHECKED                       =$008C8CB5;
  DEFAULT_MISCELLANEOUS_VALUES_COLOR=$00F0F4EC;
  NAV_SEL_COL_0                     =$005ABC98;
  NAV_SEL_COL_1                     =$00C8CFA9;
  NAV_SEL_COL_2                     =$009E9E96;
  NAV_SEL_COL_3                     =$0091B53C;
  NAV_SEL_COL_4                     =$009DD7E6;
  PNL_CNV_COL_0                     =$00625651;
  PNL_CNV_COL_1                     =$00998F77;
  PNL_CNV_COL_2                     =$00937D66;
  PNL_CNV_COL_3                     =$00BAB5A3;
  PNL_CNV_COL_4                     =$00A9A48D;



  {Resources Paths}
  SELECTION_TOOLS_MARKER_ICON       ='Pics\Selection_Tools\Selection_Tools_Marker.png';
  DEFAULT_ACTOR_ICON                ='Pics\Actors\Default_Actor_Icon.png';
  DEFAULT_CURSOR_ICON               ='Pics\Cursors\Cursor_0.png';
  DEFAULT_GAME_APP_ICON             ='GameAppIcon.png';
  DEFAULT_TILE_MAP_ICON             ='Pics\Map_Editor\Default_Tile_Map_Icon.png';
  DEFAULT_TILE_MAP_SPRITE_ICON      ='Pics\Map_Editor\Default_Tile_Map_Sprite_Icon0.png';
  TIMELINE_BUTTON_ICON_PREFIX       ='Pics\TimeLine\Timeline_Button_Icon_';
  TEXT_BUTTON_ICON                  ='Pics\Paint_Tools_Icons_List\Text.png';
  BRUSH_BUTTON_ICON                 ='Pics\Paint_Tools_Icons_List\Brush.png';
  SPRAY_BUTTON_ICON                 ='Pics\Paint_Tools_Icons_List\Spray.png';
  SPLINE_BUTTON_ICON                ='Pics\Paint_Tools_Icons_List\Spline.png';
  SELECT_POINTS_BUTTON_ICON         ='Pics\Paint_Tools_Icons_List\Select_Points.png';
  SELECT_TEXTURE_REGION_BUTTON_ICON ='Pics\Paint_Tools_Icons_List\Select_Texture_Region.png';
  BACKGROUND_BUTTON_ICON            ='Pics\Paint_Tools_Icons_List\Background.png';
  POST_PROCESS_BUTTON_ICON          ='Pics\Paint_Tools_Icons_List\PostProcess.png';
  TILE_MAP_BUTTON_ICON              ='Pics\Paint_Tools_Icons_List\TileMap.png';
  REGULAR_GRID_BUTTON_ICON          ='Pics\Paint_Tools_Icons_List\Grid.png';
  SNAP_GRID_BUTTON_ICON             ='Pics\Paint_Tools_Icons_List\Snap_Grid.png';
  BRUSH_CURSOR_ICON                 ='Pics\Cursors\Cursor_3.png';
  WORLD_AXIS_ICON                   ='Pics\World_Axis\World_Axis.png';
  LOCAL_AXIS_ICON                   ='Pics\Local_Axis\Local_Axis.png';
  BKGND_SOUND                       ='Sound\Bkgnd_Sound.wav';
  INTRO_MOVIE                       ='Intro\IntroMovie.avi';



type

  PNotifyEvent   =^TNotifyEvent;

  TEventGroupEnum=set of byte;
  PEventGroupEnum=^TEventGroupEnum;

  {Points}
  TPtsKind       =(pkAll,pkObj,pkSelected);
  {pkAll      - all points of spline;
   pkObj      - points of single spline object;
   pkSelected - selected points of all splines;}
  PPtsKind       =^TPtsKind;

  {Pivot}
  TPivotMode     =(pmPivotMove,pmPivotScale,pmPivotRotate);
  PPivotMode     =^TPivotMode;

  {Snapping Point}
  TSnapMode      =record {$region -fold}
    snap_event     : boolean;
    first_time_snap: byte;
  end; {$endregion}
  PSnapMode      =^TSnapMode;

  PPanelArr      =array of ^TPanel;

  PControl       =^TControl;

  TF_MainForm    =class;
  TSurface       =class;
  TCamera        =class;
  TRGrid         =class;
  TSGrid         =class;
  TCurve         =class;
  TFText         =class;
  TSelIts        =class;
  TPivot         =class;
  TCrcSel        =class;
  TBrsSel        =class;
  TRctSel        =class;
  TTlMap         =class;
  TPProc         =class;

  {ScrollBars Events--}
  TTreeView      =class(ComCtrls.TTreeView) {$region -fold}
    procedure WMHScroll(var message:TLMHScroll); message LM_HScroll;
    procedure WMVScroll(var message:TLMHScroll); message LM_VScroll;
  end; {$endregion}
  PTreeView      =^TTreeView;

  {TF_MainForm--------}
  TF_MainForm    =class(TForm) {$region -fold}
    GifAnim_Content_Library_Sounds_Play              : TGifAnim;
    GifAnim_Content_Library_Sounds_Play2             : TGifAnim;
    GifAnim_Background_Sound                         : TGifAnim;
    T_Editor_Time                                    : TTimer;
    T_Game_Loop                                      : TTimer;
    TrayIcon1                                        : TTrayIcon;
    TV_Scene_Tree                                    : TTreeView;
    LCLVLCPlayer_Intro                               : TLCLVLCPlayer;
    RM_Description                                   : TRichMemo;
    PC_Scene_Editor                                  : TPageControl;
    OGLC_GPU_Canvas                                  : TOpenGLControl;
    CD_Select_Color                                  : TColorDialog;
    OpenDialog1                                      : TOpenDialog;
    SaveDialog1                                      : TSaveDialog;
    FontDialog1                                      : TFontDialog;
    OD_Spline_Load                                   : TOpenDialog;
    OPD_Content_Library_Images_Load                  : TOpenPictureDialog;
    OPD_Add_TileMap_Sprite                           : TOpenPictureDialog;
    OPD_Add_TileMap                                  : TOpenPictureDialog;
    OpenPictureDialog1                               : TOpenPictureDialog;
    SavePictureDialog1                               : TSavePictureDialog;
    BB_Add_TileMap                                   : TBitBtn;
    BB_Add_TileMap_Sprite                            : TBitBtn;
    BB_Post_Processing_Add_FX                        : TBitBtn;
    BB_Apply_Bitmap_To_Spline                        : TBitBtn;
    BB_Delete_All                                    : TBitBtn;
    BB_Load_Bitmap                                   : TBitBtn;
    BB_Load_Frame                                    : TBitBtn;
    BB_Spline_Edges_Post_Processing_Add_Effect       : TBitBtn;
    BB_Spline_Generate                               : TBitBtn;
    BB_Spline_Points_Post_Processing_Add_Effect      : TBitBtn;
    BB_Spline_Templates_Left                         : TBitBtn;
    BB_Spline_Templates_Right                        : TBitBtn;
    BB_Delete_Selected                               : TBitBtn;
    BB_Text_Generate                                 : TBitBtn;
    BB_Text_Set_Font                                 : TBitBtn;
    BB_Use_Magic                                     : TBitBtn;
    B_Test                                           : TButton;
    CB_Game_Settings_Fix_Resolution                  : TCheckBox;
    CB_Game_Settings_Refresh_Lower_Layer             : TCheckBox;
    CB_Game_Settings_Show_World_Axis                 : TCheckBox;
    CB_Object_Properties_Scalable                    : TCheckBox;
    CB_Object_Properties_Recalculate_Position        : TCheckBox;
    CB_Object_Properties_Rotatable                   : TCheckBox;
    CB_Object_Properties_Show_In_Game                : TCheckBox;
    CB_Object_Properties_Movable                     : TCheckBox;
    CB_Physics_Deletion                              : TCheckBox;
    CB_Select_Items_Selected_Points_Show_Bounds      : TCheckBox;
    CB_Select_Items_Outer_Subgraph_Anti_Aliasing     : TCheckBox;
    CB_Select_Items_Inner_Subgraph_Anti_Aliasing     : TCheckBox;
    CB_Select_Items_Selected_Points_Anti_Aliasing    : TCheckBox;
    CB_Select_Items_Selection_Only_Visible           : TCheckBox;
    CB_Sound_Control_Play_Background_Sound           : TCheckBox;
    CB_Splines_Deletion                              : TCheckBox;
    CB_Object_Properties_Show_In_Editor              : TCheckBox;
    CB_Spline_Better_Quality                         : TCheckBox;
    CB_Spline_Byte_Mode                              : TCheckBox;
    CB_Spline_Connect_Ends                           : TCheckBox;
    CB_Spline_Dynamics_Collider                      : TCheckBox;
    CB_Spline_Edges_LOD                              : TCheckBox;
    CB_Spline_Edges_LOD_On_Create                    : TCheckBox;
    CB_Spline_Epicycloid_Hypocycloid                 : TCheckBox;
    CB_Spline_Free_On_Out_Of_Window                  : TCheckBox;
    CB_Spline_Free_On_Scale_Down                     : TCheckBox;
    CB_Spline_Grid_Clipping_Adaptive                 : TCheckBox;
    CB_Spline_Grid_Clipping_Edges                    : TCheckBox;
    CB_Spline_Grid_Clipping_Points                   : TCheckBox;
    CB_Spline_Hidden_Line_Elimination                : TCheckBox;
    CB_Spline_Lazy_Repaint                           : TCheckBox;
    CB_Spline_Reallocate_Memory                      : TCheckBox;
    CB_Spline_Remove_Brunching                       : TCheckBox;
    CB_Spline_Rose_Mobius_Grid                       : TCheckBox;
    CB_Actors_Deletion                               : TCheckBox;
    CB_Text_Background                               : TCheckBox;
    CB_Tilemaps_Deletion                             : TCheckBox;
    CB_Groups_Deletion                               : TCheckBox;
    CB_Particles_Deletion                            : TCheckBox;
    CB_Test                                          : TCheckBox;
    CB_Spline_Edges_Anti_Aliasing                    : TCheckBox;
    CB_Brush_Mode                                    : TComboBox;
    CB_Select_Items_Inner_Subgraph_Clip_Style        : TComboBox;
    CB_Select_Items_Inner_Subgraph_Line_Style        : TComboBox;
    CB_Select_Items_Outer_Subgraph_Clip_Style        : TComboBox;
    CB_Select_Items_Outer_Subgraph_Line_Style        : TComboBox;
    CB_Select_Items_Selected_Points_Line_Style       : TComboBox;
    CB_Select_Items_Selection_Background_Style       : TComboBox;
    CB_Select_Items_Selection_Selection_Mode         : TComboBox;
    CB_Spline_Cycloid_Direction_X                    : TComboBox;
    CB_Spline_Cycloid_Direction_Y                    : TComboBox;
    CB_Spline_Dynamics_Style                         : TComboBox;
    CB_Spline_Edges_Bounds_Style                     : TComboBox;
    CB_Spline_Edges_Post_Processing_Style            : TComboBox;
    CB_Spline_Edges_Post_Processing_Style_Add_Effect : TComboBox;
    CB_Spline_Edges_Shape                            : TComboBox;
    CB_Spline_Mode                                   : TComboBox;
    CB_Spline_Points_Bounds_Style                    : TComboBox;
    CB_Spline_Points_Post_Processing_Style           : TComboBox;
    CB_Spline_Points_Post_Processing_Style_Add_Effect: TComboBox;
    CB_Spline_Points_Shape                           : TComboBox;
    CB_Spline_Type                                   : TComboBox;
    CB_Spline_Type1                                  : TComboBox;
    FP_Image_List                                    : TFlowPanel;
    FSE_Brush_Fall_Off                               : TFloatSpinEdit;
    FSE_Camera_Speed                                 : TFloatSpinEdit;
    FSE_Spline_Cycloid_Curvature                     : TFloatSpinEdit;
    FSE_Spline_Cycloid_Radius                        : TFloatSpinEdit;
    FSE_Spline_Epicycloid_Angle                      : TFloatSpinEdit;
    FSE_Spline_Epicycloid_Petals_Count               : TFloatSpinEdit;
    FSE_Spline_Epicycloid_Radius                     : TFloatSpinEdit;
    FSE_Spline_Epicycloid_Rotation                   : TFloatSpinEdit;
    FSE_Spline_Rose_Angle                            : TFloatSpinEdit;
    FSE_Spline_Rose_Petals_Count                     : TFloatSpinEdit;
    FSE_Spline_Rose_Radius                           : TFloatSpinEdit;
    FSE_Spline_Rose_Rotation                         : TFloatSpinEdit;
    FSE_Spline_Simplification_Angle                  : TFloatSpinEdit;
    FSE_Spline_Spiral_Angle                          : TFloatSpinEdit;
    FSE_Spline_Spiral_Coil_Step                      : TFloatSpinEdit;
    FSE_Spline_Spiral_Radius                         : TFloatSpinEdit;
    FSE_Spline_Spiral_Rotation                       : TFloatSpinEdit;
    FSE_Spline_Superellipse_Curvature0               : TFloatSpinEdit;
    FSE_Spline_Superellipse_Curvature1               : TFloatSpinEdit;
    FSE_Spline_Superellipse_Curvature2               : TFloatSpinEdit;
    FSE_Spline_Superellipse_Curvature3               : TFloatSpinEdit;
    FSE_Spline_Superellipse_Radius                   : TFloatSpinEdit;
    IL_Default_Tile_Map_Icon                         : TImageList;
    IL_Miscellaneous                                 : TImageList;
    IL_Local_Axis                                    : TImageList;
    IL_World_Axis                                    : TImageList;
    IL_Butons_Icons                                  : TImageList;
    IL_Buttons_Background                            : TImageList;
    IL_Cursors_Icons                                 : TImageList;
    IL_Select_Points                                 : TImageList;
    IL_Spline_Templates                              : TImageList;
    IL_Arrow_Up_Down                                 : TImageList;
    IL_Draw                                          : TImageList;
    IL_AnimK                                         : TImageList;
    IL_File                                          : TImageList;
    IL_Default_Tile_Map_Sprite_Icon                  : TImageList;
    IL_Fold_Unfold                                   : TImageList;
    IL_Add_Actor_Default_Icon                        : TImageList;
    Image18                                          : TImage;
    Image22                                          : TImage;
    Image23                                          : TImage;
    Image4                                           : TImage;
    Image8                                           : TImage;
    Image9                                           : TImage;
    I_Visibility_Panel                               : TImage;
    I_Add_Mask_Template_List                         : TImage;
    I_Add_Sprite_List                                : TImage;
    I_Frame_List                                     : TImage;
    I_Content_Library_Images_List                    : TImage;
    I_Content_Library_Sounds_List                    : TImage;
    I_Object_Tags_List                               : TImage;
    LE_Content_Library_Images_Find_Image             : TLabeledEdit;
    LE_Content_Library_Sounds_Find_Sound             : TLabeledEdit;
    Label2                                           : TLabel;
    Label3                                           : TLabel;
    Label4                                           : TLabel;
    Label5                                           : TLabel;
    L_Background_Color                               : TLabel;
    L_Bitmap_Height                                  : TLabel;
    L_Bitmap_Width                                   : TLabel;
    L_Brush_Fall_Off                                 : TLabel;
    L_Brush_Hardness                                 : TLabel;
    L_Brush_Mode                                     : TLabel;
    L_Brush_Size                                     : TLabel;
    L_Count_X                                        : TLabel;
    L_Count_Y                                        : TLabel;
    L_Game_Settings_Canvas_Width                     : TLabel;
    L_Game_Settings_Canvas_Height                    : TLabel;
    L_Game_Settings_Exec_Time_Limit                  : TLabel;
    L_Game_Settings_Exec_Time_Limit_Milliseconds     : TLabel;
    L_Game_Settings_Refresh_Step                     : TLabel;
    L_Game_Settings_Refresh_Step_Frames              : TLabel;
    L_Object_Name                                    : TLabel;
    L_Object_Properties_Parallax_ShiftX              : TLabel;
    L_Object_Properties_Parallax_ShiftY              : TLabel;
    L_RGrid_Color                                    : TLabel;
    L_SGrid_Color                                    : TLabel;
    L_Select_Items_Inner_Subgraph_Clip_Style         : TLabel;
    L_Select_Items_Inner_Subgraph_Color              : TLabel;
    L_Select_Items_Inner_Subgraph_Line_Style         : TLabel;
    L_Select_Items_Outer_Subgraph_Clip_Style         : TLabel;
    L_Select_Items_Outer_Subgraph_Color              : TLabel;
    L_Select_Items_Selected_Points_Color             : TLabel;
    L_Select_Items_Outer_Subgraph_Line_Style         : TLabel;
    L_Select_Items_Selected_Points_Line_Style        : TLabel;
    L_Select_Items_Selection_Background_Style        : TLabel;
    L_Select_Items_Selection_Color                   : TLabel;
    L_Select_Items_Selection_Selection_Mode          : TLabel;
    L_Spline_Cycloid_Curvature                       : TLabel;
    L_Spline_Cycloid_Direction_X                     : TLabel;
    L_Spline_Cycloid_Direction_Y                     : TLabel;
    L_Spline_Cycloid_Loops_Count                     : TLabel;
    L_Spline_Cycloid_Points_Count                    : TLabel;
    L_Spline_Cycloid_Radius                          : TLabel;
    L_Spline_Dynamics                                : TLabel;
    L_Spline_Dynamics_Style                          : TLabel;
    L_Spline_Edges_Bounds_Color                      : TLabel;
    L_Spline_Edges_Bounds_Effect_Strength            : TLabel;
    L_Spline_Edges_Bounds_Style                      : TLabel;
    L_Spline_Edges_Dash_Length                       : TLabel;
    L_Spline_Edges_Points_Radius                     : TLabel;
    L_Spline_Edges_Post_Processing_Add_Effect        : TLabel;
    L_Spline_Edges_Post_Processing_Color             : TLabel;
    L_Spline_Edges_Post_Processing_Effect_Strength   : TLabel;
    L_Spline_Edges_Shape                             : TLabel;
    L_Spline_Edges_Width                             : TLabel;
    L_Spline_Epicycloid_Angle                        : TLabel;
    L_Spline_Epicycloid_Petals_Count                 : TLabel;
    L_Spline_Epicycloid_Points_Count                 : TLabel;
    L_Spline_Epicycloid_Radius                       : TLabel;
    L_Spline_Epicycloid_Rotation                     : TLabel;
    L_Spline_Interpolation                           : TLabel;
    L_Spline_Mode                                    : TLabel;
    L_Spline_Points_Bounds_Color                     : TLabel;
    L_Spline_Points_Bounds_Effect_Strength           : TLabel;
    L_Spline_Points_Bounds_Style                     : TLabel;
    L_Spline_Points_Count                            : TLabel;
    L_Spline_Points_Frequency                        : TLabel;
    L_Spline_Points_Post_Processing_Add_Effect       : TLabel;
    L_Spline_Points_Post_Processing_Color            : TLabel;
    L_Spline_Points_Post_Processing_Effect_Strength  : TLabel;
    L_Spline_Points_Rectangle_Inner_Rectangle        : TLabel;
    L_Spline_Points_Rectangle_Inner_Rectangle_Height : TLabel;
    L_Spline_Points_Rectangle_Inner_Rectangle_Width  : TLabel;
    L_Spline_Points_Rectangle_Thickness              : TLabel;
    L_Spline_Points_Rectangle_Thikness_Bottom        : TLabel;
    L_Spline_Points_Rectangle_Thikness_Left          : TLabel;
    L_Spline_Points_Rectangle_Thikness_Right         : TLabel;
    L_Spline_Points_Rectangle_Thikness_Top           : TLabel;
    L_Spline_Points_Shape                            : TLabel;
    L_Spline_Rose_Angle                              : TLabel;
    L_Spline_Rose_Petals_Count                       : TLabel;
    L_Spline_Rose_Points_Count                       : TLabel;
    L_Spline_Rose_Radius                             : TLabel;
    L_Spline_Rose_Rotation                           : TLabel;
    L_Spline_Save                                    : TLabel;
    L_Spline_Simplification_Angle                    : TLabel;
    L_Spline_Grid_Clipping_Grid_Density              : TLabel;
    L_Spline_Spiral_Angle                            : TLabel;
    L_Spline_Spiral_Coil_Step                        : TLabel;
    L_Spline_Spiral_Points_Count                     : TLabel;
    L_Spline_Spiral_Radius                           : TLabel;
    L_Spline_Spiral_Rotation                         : TLabel;
    L_Spline_Spray_Radius                            : TLabel;
    L_Spline_Superellipse_Curvature0                 : TLabel;
    L_Spline_Superellipse_Curvature1                 : TLabel;
    L_Spline_Superellipse_Curvature2                 : TLabel;
    L_Spline_Superellipse_Curvature3                 : TLabel;
    L_Spline_Superellipse_Points_Count               : TLabel;
    L_Spline_Superellipse_Radius                     : TLabel;
    L_Spline_Templates_Name                          : TLabel;
    L_Spline_Type                                    : TLabel;
    L_Exec_Time_Info                                 : TLabel;
    L_Camera_Speed                                   : TLabel;
    L_Object_Properties_Parallax_Shift               : TLabel;
    L_Object_Properties                              : TLabel;
    L_Selective_Deletion                             : TLabel;
    L_Object_Info                                    : TLabel;
    L_Tag_Properties                                 : TLabel;
    L_Text_Field                                     : TLabel;
    L_Label1                                         : TLabel;
    M_Test_Log                                       : TMemo;
    M_Text_Text_Field                                : TMemo;
    MI_Monochrome                                    : TMenuItem;
    MI_Additive                                      : TMenuItem;
    MI_Alphablend                                    : TMenuItem;
    MI_Inverse                                       : TMenuItem;
    MI_Highlight                                     : TMenuItem;
    MI_Darken                                        : TMenuItem;
    MI_GrayscaleR                                    : TMenuItem;
    MI_GrayscaleG                                    : TMenuItem;
    MI_GrayscaleB                                    : TMenuItem;
    MI_Noise                                         : TMenuItem;
    MI_ColorizeR                                     : TMenuItem;
    MI_ColorizeG                                     : TMenuItem;
    MI_ColorizeB                                     : TMenuItem;
    MI_BlurRGB                                       : TMenuItem;
    MI_BlurRRB                                       : TMenuItem;
    MI_BlurRGR                                       : TMenuItem;
    MI_BlurGGB                                       : TMenuItem;
    MI_BlurRGG                                       : TMenuItem;
    MI_BlurBGB                                       : TMenuItem;
    MI_BlurRBB                                       : TMenuItem;
    MI_BlurRRR                                       : TMenuItem;
    MI_BlurGGG                                       : TMenuItem;
    MI_BlurBBB                                       : TMenuItem;
    MI_Contrast                                      : TMenuItem;
    MI_Separator0                                    : TMenuItem;
    MI_Separator1                                    : TMenuItem;
    MI_Separator2                                    : TMenuItem;
    MI_Separator3                                    : TMenuItem;
    MI_Separator4                                    : TMenuItem;
    MI_Separator5                                    : TMenuItem;
    MI_Separator6                                    : TMenuItem;
    MI_Separator7                                    : TMenuItem;
    MI_Separator8                                    : TMenuItem;
    MI_Allow_MultiRename                             : TMenuItem;
    MI_Reverse_Order                                 : TMenuItem;
    MI_Center_Camera_To_Selected_Object              : TMenuItem;
    MI_Add_Group                                     : TMenuItem;
    MI_Group_Objects                                 : TMenuItem;
    MI_Delete_Without_Children                       : TMenuItem;
    MI_Delete_All_Groups                             : TMenuItem;
    MI_Remove_Object                                 : TMenuItem;
    MI_Select_All                                    : TMenuItem;
    MI_Unselect_All                                  : TMenuItem;
    MI_Fold_All                                      : TMenuItem;
    MI_Unfold_All                                    : TMenuItem;
    MI_Fold_Selected                                 : TMenuItem;
    MI_Unfold_Selected                               : TMenuItem;
    MI_Goto_First_Object                             : TMenuItem;
    MI_Goto_Last_Object                              : TMenuItem;
    MI_Add_Tag                                       : TMenuItem;
    MI_Points_Selection                              : TMenuItem;
    MI_Edges_Selection                               : TMenuItem;
    MI_Animation                                     : TMenuItem;
    MI_Special_Effect                                : TMenuItem;
    MI_Snap_To                                       : TMenuItem;
    MI_Add_Event                                     : TMenuItem;
    MI_Add_Asset                                     : TMenuItem;
    MI_On_Click                                      : TMenuItem;
    MI_On_Double_Click                               : TMenuItem;
    MI_On_Mouse_Down                                 : TMenuItem;
    MI_On_Mouse_Up                                   : TMenuItem;
    MI_On_Mouse_Enter                                : TMenuItem;
    MI_On_Mouse_Leave                                : TMenuItem;
    MI_On_Key_Down                                   : TMenuItem;
    MI_On_Key_Up                                     : TMenuItem;
    MI_On_Key_Press                                  : TMenuItem;
    MI_On_Show                                       : TMenuItem;
    MI_On_Hide                                       : TMenuItem;
    MI_Save_Asset                                    : TMenuItem;
    Separator4                                       : TMenuItem;
    Separator3                                       : TMenuItem;
    MI_Align_Image_On_Inner_Window_Resize            : TMenuItem;
    MenuItem9                                        : TMenuItem;
    MenuItem10                                       : TMenuItem;
    MI_Button_Styles                                 : TMenuItem;
    MI_Button_Style_1                                : TMenuItem;
    MI_Button_Style_2                                : TMenuItem;
    MI_Button_Style_3                                : TMenuItem;
    MI_Button_Styles1                                : TMenuItem;
    MI_Button_Style_4                                : TMenuItem;
    MI_Button_Style_5                                : TMenuItem;
    MI_Button_Style_6                                : TMenuItem;
    P_Content_Library_Images_Header                  : TPanel;
    P_Content_Library_Images_Settings                : TPanel;
    P_Content_Library_Sounds_Header                  : TPanel;
    P_Content_Library_Sounds_Settings                : TPanel;
    P_Object_Tags_Header                             : TPanel;
    P_Object_Tags                                    : TPanel;
    P_Select_Items_Inner_Subgraph_Header             : TPanel;
    P_Select_Items_Outer_Subgraph_Header             : TPanel;
    P_Select_Items_Selection_Header                  : TPanel;
    P_Select_Items_Selected_Points_Settings          : TPanel;
    P_Select_Items_Selected_Points_Header            : TPanel;
    P_Content_Library_Header                         : TPanel;
    P_Library_Settings                               : TPanel;
    P_Inner_Window_Buttons                           : TPanel;
    P_Description                                    : TPanel;
    P_DescriptionHeader                              : TPanel;
    P_Scene_Editor                                   : TPanel;
    P_Load_Save_Clear                                : TPanel;
    P_Selective_Deletion                             : TPanel;
    P_Draw_Buttons                                   : TPanel;
    P_Select_Items_Inner_Subgraph_Settings           : TPanel;
    P_Select_Items_Outer_Subgraph_Settings           : TPanel;
    P_Select_Items_Selection_Settings                : TPanel;
    P_Spline_Cycloid                                 : TPanel;
    P_Spline_Drawing_Formula_Templates               : TPanel;
    P_Spline_Drawing_Freehand                        : TPanel;
    P_Spline_Drawing_Header                          : TPanel;
    P_Spline_Drawing_Settings                        : TPanel;
    P_Spline_Drawing_Settings_Header                 : TPanel;
    P_Spline_Drawing_Spline_Type_Header              : TPanel;
    P_Spline_Drawing_Spline_Type_Settings            : TPanel;
    P_Spline_Dynamics_Prop                           : TPanel;
    P_Spline_Edges_Bounds_Header                     : TPanel;
    P_Spline_Edges_Bounds_Settings                   : TPanel;
    P_Spline_Edges_Header                            : TPanel;
    P_Spline_Edges_Post_Processing_Add_Effect        : TPanel;
    P_Spline_Edges_Post_Processing_Header            : TPanel;
    P_Spline_Edges_Post_Processing_Settings          : TPanel;
    P_Spline_Edges_Settings                          : TPanel;
    P_Spline_Edges_Shape_Header                      : TPanel;
    P_Spline_Edges_Shape_Settings                    : TPanel;
    P_Spline_Epicycloid                              : TPanel;
    P_Spline_Optimization_Compression_Header         : TPanel;
    P_Spline_Optimization_Compression_Settings       : TPanel;
    P_Spline_Optimization_General_Header             : TPanel;
    P_Spline_Optimization_General_Settings           : TPanel;
    P_Spline_Optimization_Grid_Clipping_Header       : TPanel;
    P_Spline_Optimization_Grid_Clipping_Settings     : TPanel;
    P_Spline_Optimization_Header                     : TPanel;
    P_Spline_Optimization_LOD_Header                 : TPanel;
    P_Spline_Optimization_LOD_Settings               : TPanel;
    P_Spline_Optimization_Memory_Management_Header   : TPanel;
    P_Spline_Optimization_Memory_Management_Settings : TPanel;
    P_Spline_Optimization_Settings                   : TPanel;
    P_Spline_Points_Bounds_Header                    : TPanel;
    P_Spline_Points_Bounds_Settings                  : TPanel;
    P_Spline_Points_Header                           : TPanel;
    P_Spline_Points_Post_Processing_Add_Effect       : TPanel;
    P_Spline_Points_Post_Processing_Header           : TPanel;
    P_Spline_Points_Post_Processing_Settings         : TPanel;
    P_Spline_Points_Rectangle_Settings               : TPanel;
    P_Spline_Points_Settings                         : TPanel;
    P_Spline_Points_Shape_Header                     : TPanel;
    P_Spline_Points_Shape_Settings                   : TPanel;
    P_Spline_Rose                                    : TPanel;
    P_Spline_Save_Prop                               : TPanel;
    P_Spline_Spiral                                  : TPanel;
    P_Spline_Superellipse                            : TPanel;
    P_Spline_Templates_Properties                    : TPanel;
    P_Spline_Template_List                           : TPanel;
    P_Spline_Template_List1                          : TPanel;
    P_Text_Settings                                  : TPanel;
    P_Text_Settings_Header                           : TPanel;
    P_Anim_Buttons                                   : TPanel;
    P_Scene_Tree_Header                              : TPanel;
    P_Object_Properties                              : TPanel;
    P_Tag_Properties                                 : TPanel;
    Panel1                                           : TPanel;
    Panel9                                           : TPanel;
    PM_Post_Processing_Add_Effect                    : TPopupMenu;
    PM_Unfold_And_Align_Image                        : TPopupMenu;
    PM_Drawing_Buttons                               : TPopupMenu;
    PM_Animation_Buttons                             : TPopupMenu;
    PM_Scene_Tree                                    : TPopupMenu;
    P_Add_Actor                                      : TScrollBox;
    P_Add_Tilemap                                    : TScrollBox;
    P_Anim_Custom_Panel                              : TScrollBox;
    P_Background                                     : TScrollBox;
    P_Brush                                          : TScrollBox;
    P_Draw_Custom_Panel                              : TScrollBox;
    P_Game_Settings                                  : TScrollBox;
    P_Play_Anim                                      : TScrollBox;
    P_Post_Processing                                : TScrollBox;
    P_RGrid                                          : TScrollBox;
    P_Select_Items                                   : TScrollBox;
    P_Select_Texture_Region                          : TScrollBox;
    P_SGrid                                          : TScrollBox;
    P_Sound_Control                                  : TScrollBox;
    P_Spline                                         : TScrollBox;
    P_Spray                                          : TScrollBox;
    P_Text                                           : TScrollBox;
    SB_Spline_Edges_Post_Processing_Add_Effect       : TScrollBox;
    SB_Spline_Points_Post_Processing_Add_Effect      : TScrollBox;
    SB_Object_Properties                             : TScrollBox;
    SB_Tag_Properties                                : TScrollBox;
    SB_Image_List                                    : TScrollBox;
    SB_Original_Scene_Scale                          : TSpeedButton;
    SB_Content_Library_Images_Load                   : TSpeedButton;
    SB_Content_Library_Images_Save                   : TSpeedButton;
    SB_Content_Library_Images_Edit                   : TSpeedButton;
    SB_Content_Library_Images_Filter                 : TSpeedButton;
    SB_Content_Library_Sounds_Load                   : TSpeedButton;
    SB_Content_Library_Sounds_Save                   : TSpeedButton;
    SB_Content_Library_Sounds_Edit                   : TSpeedButton;
    SB_Content_Library_Sounds_Filter                 : TSpeedButton;
    SB_Select_Items_Inner_Subgraph_Show              : TSpeedButton;
    SB_Select_Items_Selected_Points_Color            : TSpeedButton;
    SB_Select_Items_Outer_Subgraph_Show              : TSpeedButton;
    SB_Select_Items_Selected_Points_Show             : TSpeedButton;
    SB_Add_Tilemap                                   : TSpeedButton;
    SB_Post_Processing                               : TSpeedButton;
    SB_Background                                    : TSpeedButton;
    SB_Background_Color                              : TSpeedButton;
    SB_RGrid_Color                                   : TSpeedButton;
    SB_SGrid_Color                                   : TSpeedButton;
    SB_Select_Items_Inner_Subgraph_Color             : TSpeedButton;
    SB_Select_Items_Outer_Subgraph_Color             : TSpeedButton;
    SB_Select_Items_Selection_Color                  : TSpeedButton;
    SB_Spline_Edges_Bounds_Color                     : TSpeedButton;
    SB_Spline_Edges_Bounds_Color_FallOff             : TSpeedButton;
    SB_Spline_Edges_Bounds_Color_Random              : TSpeedButton;
    SB_Spline_Edges_Post_Processing_Color            : TSpeedButton;
    SB_Spline_Edges_Post_Processing_Color_FallOff    : TSpeedButton;
    SB_Spline_Edges_Post_Processing_Color_Random     : TSpeedButton;
    SB_Spline_Edges_Show                             : TSpeedButton;
    SB_Spline_Edges_Show_Bounds                      : TSpeedButton;
    SB_Spline_Load                                   : TSpeedButton;
    SB_Spline_Save                                   : TSpeedButton;
    SB_Spline_Points_Bounds_Color                    : TSpeedButton;
    SB_Spline_Points_Bounds_Color_FallOff            : TSpeedButton;
    SB_Spline_Points_Bounds_Color_Random             : TSpeedButton;
    SB_Spline_Points_Post_Processing_Color           : TSpeedButton;
    SB_Spline_Points_Post_Processing_Color_FallOff   : TSpeedButton;
    SB_Spline_Points_Post_Processing_Color_Random    : TSpeedButton;
    SB_Spline_Points_Show                            : TSpeedButton;
    SB_Spline_Points_Show_Bounds                     : TSpeedButton;
    SB_Spline_Template_Cycloid                       : TSpeedButton;
    SB_Spline_Template_Epicycloid                    : TSpeedButton;
    SB_Spline_Template_Rose                          : TSpeedButton;
    SB_Spline_Template_Spiral                        : TSpeedButton;
    SB_Spline_Template_Superellipse                  : TSpeedButton;
    SB_Text_Background_Color                         : TSpeedButton;
    SB_Text_Background_Color_Random                  : TSpeedButton;
    SB_Draw_Buttons_Button_Bkgnd                     : TSpeedButton;
    SB_Anim_Buttons_Button_Bkgnd                     : TSpeedButton;
    SB_Sound_Control                                 : TSpeedButton;
    SB_Button_Bounds                                 : TSpeedButton;
    SB_Draw_Buttons_Button_Bounds                    : TSpeedButton;
    SB_Anim_Buttons_Button_Bounds                    : TSpeedButton;
    SB_Game_Settings                                 : TSpeedButton;
    SB_RGrid                                         : TSpeedButton;
    SB_SGrid                                         : TSpeedButton;
    SB_Spline                                        : TSpeedButton;
    SB_Add_Actor                                     : TSpeedButton;
    SB_Brush                                         : TSpeedButton;
    SB_Load_Game_Project                             : TSpeedButton;
    SB_Save_Game_Project                             : TSpeedButton;
    SB_Clear_Scene                                   : TSpeedButton;
    SB_Select_Background_Region                      : TSpeedButton;
    SB_Spray                                         : TSpeedButton;
    SB_Text                                          : TSpeedButton;
    SB_Select_Items                                  : TSpeedButton;
    SB_Play_Anim                                     : TSpeedButton;
    SB_Change_Layout                                 : TSpeedButton;
    SB_Centrify_Picture                              : TSpeedButton;
    SB_Visibility_Regular_Grid                       : TSpeedButton;
    SB_Visibility_Tile_Map                           : TSpeedButton;
    SB_Visibility_Snap_Grid                          : TSpeedButton;
    SB_Visibility_Show_All                           : TSpeedButton;
    SB_Visibility_Spline                             : TSpeedButton;
    SB_Visibility_Background                         : TSpeedButton;
    SB_Visibility_Actor                              : TSpeedButton;
    SE_Brush_Hardness                                : TSpinEdit;
    SE_Brush_Radius                                  : TSpinEdit;
    SE_Count_X                                       : TSpinEdit;
    SE_Count_Y                                       : TSpinEdit;
    SE_Game_Settings_Canvas_Width                    : TSpinEdit;
    SE_Game_Settings_Canvas_Height                   : TSpinEdit;
    SE_Game_Settings_Exec_Time_Limit                 : TSpinEdit;
    SE_Game_Settings_Refresh_Step                    : TSpinEdit;
    SE_Object_Properties_Parallax_ShiftX             : TSpinEdit;
    SE_Object_Properties_Parallax_ShiftY             : TSpinEdit;
    SE_Spline_Bitmap_Height                          : TSpinEdit;
    SE_Spline_Bitmap_Width                           : TSpinEdit;
    SE_Spline_Cycloid_Loops_Count                    : TSpinEdit;
    SE_Spline_Cycloid_Points_Count                   : TSpinEdit;
    SE_Spline_Grid_Clipping_Grid_Density             : TSpinEdit;
    SE_Spline_Edges_Bounds_Effect_Strength           : TSpinEdit;
    SE_Spline_Edges_Dash_Length                      : TSpinEdit;
    SE_Spline_Edges_Points_Radius                    : TSpinEdit;
    SE_Spline_Edges_Post_Processing_Effect_Strength  : TSpinEdit;
    SE_Spline_Edges_Width                            : TSpinEdit;
    SE_Spline_Epicycloid_Points_Count                : TSpinEdit;
    SE_Spline_Points_Bounds_Effect_Strength          : TSpinEdit;
    SE_Spline_Points_Count                           : TSpinEdit;
    SE_Spline_Points_Post_Processing_Effect_Strength : TSpinEdit;
    SE_Spline_Points_Rectangle_Inner_Rectangle_Height: TSpinEdit;
    SE_Spline_Points_Rectangle_Inner_Rectangle_Width : TSpinEdit;
    SE_Spline_Points_Rectangle_Thikness_Bottom       : TSpinEdit;
    SE_Spline_Points_Rectangle_Thikness_Left         : TSpinEdit;
    SE_Spline_Points_Rectangle_Thikness_Right        : TSpinEdit;
    SE_Spline_Points_Rectangle_Thikness_Top          : TSpinEdit;
    SE_Spline_Pts_Freq                               : TSpinEdit;
    SE_Spline_Rose_Points_Count                      : TSpinEdit;
    SE_Spline_Spiral_Points_Count                    : TSpinEdit;
    SE_Spline_Spray_Radius                           : TSpinEdit;
    SE_Spline_Superellipse_Points_Count              : TSpinEdit;
    SE_Test_FX_Fading_Type                           : TSpinEdit;
    SE_Test_FX_Value                                 : TSpinEdit;
    SE_Test_FX_Type                                  : TSpinEdit;
    Shape1                                           : TShape;
    Shape10                                          : TShape;
    Shape11                                          : TShape;
    Shape12                                          : TShape;
    Shape13                                          : TShape;
    Shape14                                          : TShape;
    Shape15                                          : TShape;
    Shape16                                          : TShape;
    Shape17                                          : TShape;
    Shape18                                          : TShape;
    Shape19                                          : TShape;
    Shape2                                           : TShape;
    Shape20                                          : TShape;
    Shape21                                          : TShape;
    Shape22                                          : TShape;
    Shape23                                          : TShape;
    Shape3                                           : TShape;
    Shape4                                           : TShape;
    Shape5                                           : TShape;
    Shape6                                           : TShape;
    Shape7                                           : TShape;
    Shape8                                           : TShape;
    Shape9                                           : TShape;
    S_Splitter1                                      : TSplitter;
    S_Splitter2                                      : TSplitter;
    S_Splitter3                                      : TSplitter;
    S_Splitter4                                      : TPanel;
    S_Splitter5                                      : TSplitter;
    S_Splitter6                                      : TSplitter;
    S_Splitter7                                      : TSplitter;
    S_Splitter8                                      : TSplitter;
    TB_Camera_Speed                                  : TTrackBar;
    TS_File                                          : TTabSheet;
    TS_Draw                                          : TTabSheet;
    TS_Anim                                          : TTabSheet;

    {Test} {$region -fold}
    FSE_Rad0                                         : TFloatSpinEdit;
    FSE_Rad1                                         : TFloatSpinEdit;
    Panel2                                           : TPanel;
    SE_K                                             : TSpinEdit;
    SE_T                                             : TSpinEdit;
    ST_K                                             : TStaticText;
    ST_T                                             : TStaticText;
    ST_Rad0                                          : TStaticText;
    ST_Rad1                                          : TStaticText;
    ST_Sprite_Scale                                  : TStaticText;
    TB_Test0                                         : TTrackBar;
    TB_Test1                                         : TTrackBar;
    TB_Test2                                         : TTrackBar;
    {$endregion}

    {F_MainForm}
    procedure BB_Add_TileMapClick                                     (      sender               :TObject);
    procedure BB_Add_TileMap_SpriteClick                              (      sender               :TObject);
    procedure BB_Post_Processing_Add_FXClick                          (      sender               :TObject);
    procedure BB_Spline_Edges_Post_Processing_Add_EffectClick         (      sender               :TObject);
    procedure BB_Spline_GenerateClick                                 (      sender               :TObject);
    procedure BB_Load_FrameClick                                      (      sender               :TObject);
    procedure BB_Spline_Points_Post_Processing_Add_EffectClick        (      sender               :TObject);
    procedure BB_Spline_Templates_RightClick                          (      sender               :TObject);
    procedure BB_Spline_Templates_LeftClick                           (      sender               :TObject);
    procedure BB_Use_MagicClick                                       (      sender               :TObject);
    procedure B_TestClick                                             (      sender               :TObject);
    procedure OGLC_GPU_CanvasMouseEnter                               (      sender               :TObject);
    procedure OGLC_GPU_CanvasMouseLeave                               (      sender               :TObject);
    procedure CB_Game_Settings_Fix_ResolutionChange                   (      sender               :TObject);
    procedure CB_Game_Settings_Refresh_Lower_LayerChange              (      sender               :TObject);
    procedure CB_Game_Settings_Show_World_AxisChange                  (      sender               :TObject);
    procedure SE_Game_Settings_Canvas_WidthEditingDone                (      sender               :TObject);
    procedure SE_Game_Settings_Canvas_HeightEditingDone               (      sender               :TObject);
    procedure SE_Game_Settings_Canvas_WidthChange                     (      sender               :TObject);
    procedure SE_Game_Settings_Canvas_HeightChange                    (      sender               :TObject);
    procedure CB_Select_Items_Inner_Subgraph_Anti_AliasingChange      (      sender               :TObject);
    procedure CB_Select_Items_Inner_Subgraph_Clip_StyleSelect         (      sender               :TObject);
    procedure CB_Select_Items_Inner_Subgraph_Line_StyleSelect         (      sender               :TObject);
    procedure CB_Select_Items_Outer_Subgraph_Anti_AliasingChange      (      sender               :TObject);
    procedure CB_Select_Items_Selected_Points_Anti_AliasingChange     (      sender               :TObject);
    procedure CB_Select_Items_Selected_Points_Line_StyleSelect        (      sender               :TObject);
    procedure CB_Select_Items_Selected_Points_Show_BoundsChange       (      sender               :TObject);
    procedure CB_Select_Items_Selection_Background_StyleSelect        (      sender               :TObject);
    procedure CB_Select_Items_Selection_Only_VisibleChange            (      sender               :TObject);
    procedure CB_Sound_Control_Play_Background_SoundChange            (      sender               :TObject);
    procedure CB_Spline_Best_Ends_QualityChange                       (      sender               :TObject);
    procedure CB_Spline_Cycloid_Direction_XSelect                     (      sender               :TObject);
    procedure CB_Spline_Cycloid_Direction_YSelect                     (      sender               :TObject);
    procedure CB_Spline_Dynamics_StyleSelect                          (      sender               :TObject);
    procedure CB_Spline_Edges_Bounds_StyleSelect                      (      sender               :TObject);
    procedure CB_Spline_Edges_LOD_On_CreateChange                     (      sender               :TObject);
    procedure CB_Spline_Edges_Post_Processing_StyleSelect             (      sender               :TObject);
    procedure CB_Spline_Epicycloid_HypocycloidChange                  (      sender               :TObject);
    procedure CB_Spline_Best_PrecisionChange                          (      sender               :TObject);
    procedure CB_Spline_Byte_ModeChange                               (      sender               :TObject);
    procedure CB_Spline_Edges_ShapeSelect                             (      sender               :TObject);
    procedure CB_Spline_Better_QualityChange                          (      sender               :TObject);
    procedure CB_Spline_Grid_Clipping_PointsChange                    (      sender               :TObject);
    procedure CB_Spline_Grid_Clipping_AdaptiveChange                  (      sender               :TObject);
    procedure CB_Spline_Hidden_Line_EliminationChange                 (      sender               :TObject);
    procedure CB_Spline_Lazy_RepaintChange                            (      sender               :TObject);
    procedure CB_Spline_Invert_OrderChange                            (      sender               :TObject);
    procedure CB_Spline_Edges_LODChange                               (      sender               :TObject);
    procedure CB_Spline_Free_On_Out_Of_WindowChange                   (      sender               :TObject);
    procedure CB_Spline_Free_On_Scale_DownChange                      (      sender               :TObject);
    procedure CB_Spline_Points_Bounds_StyleSelect                     (      sender               :TObject);
    procedure CB_Spline_Points_ShapeSelect                            (      sender               :TObject);
    procedure CB_Spline_Points_Post_Processing_StyleSelect            (      sender               :TObject);
    procedure CB_Spline_Reallocate_MemoryChange                       (      sender               :TObject);
    procedure CB_Spline_Remove_BrunchingChange                        (      sender               :TObject);
    procedure CB_Spline_Rose_Mobius_GridChange                        (      sender               :TObject);
    procedure CB_Text_BackgroundChange                                (      sender               :TObject);
    procedure FormMouseMove                                           (      sender               :TObject;
                                                                             shift                :TShiftState;
                                                                             x,y                  :integer);
    procedure FormMouseDown                                           (      sender               :TObject;
                                                                             button               :TMouseButton;
                                                                             shift                :TShiftState;
                                                                             x,y                  :integer);
    procedure FormMouseUp                                             (      sender               :TObject;
                                                                             button               :TMouseButton;
                                                                             shift                :TShiftState;
                                                                             x,y                  :integer);
    procedure FormDblClick                                            (      sender               :TObject);
    procedure FormPaint                                               (      sender               :TObject);
    procedure FormMouseWheelDown                                      (      sender               :TObject;
                                                                             shift                :TShiftState;
                                                                             mousepos             :TPoint;
                                                                       var   handled              :boolean);
    procedure FormMouseWheelUp                                        (      sender               :TObject;
                                                                             shift                :TShiftState;
                                                                             mousepos             :TPoint;
                                                                       var   handled              :boolean);
    procedure FormKeyPress                                            (      sender               :TObject;
                                                                       var   key                  :char);
    procedure FormKeyDown                                             (      sender               :TObject;
                                                                       var   key                  :word;
                                                                             shift                :TShiftState);
    procedure FormKeyUp                                               (      sender               :TObject;
                                                                       var   key                  :word;
                                                                             shift                :TShiftState);
    procedure FormMouseEnter                                          (      sender               :TObject);
    procedure FormMouseLeave                                          (      sender               :TObject);
    procedure FormCreate                                              (      sender               :TObject);
    procedure FormActivate                                            (      sender               :TObject);
    procedure FormDestroy                                             (      sender               :TObject);
    procedure FormDropFiles                                           (      sender               :TObject;
                                                                       const file_names           :array of string);
    procedure FormResize                                              (      sender               :TObject);
    procedure PC_Scene_EditorChanging                                 (      sender               :TObject;
                                                                       var   allowchange          :boolean);
    procedure FSE_Spline_Rose_Petals_CountChange                      (      sender               :TObject);
    procedure FSE_Spline_Cycloid_CurvatureChange                      (      sender               :TObject);
    procedure FSE_Camera_SpeedChange                                  (      sender               :TObject);
    procedure FSE_Spline_Simplification_AngleEditingDone              (      sender               :TObject);
    procedure FSE_Spline_Spiral_Coil_StepChange                       (      sender               :TObject);
    procedure FSE_Spline_Superellipse_Curvature0Change                (      sender               :TObject);
    procedure FSE_Spline_Superellipse_Curvature1Change                (      sender               :TObject);
    procedure FSE_Spline_Superellipse_Curvature2Change                (      sender               :TObject);
    procedure FSE_Spline_Superellipse_Curvature3Change                (      sender               :TObject);
    procedure FSE_Spline_Superellipse_RadiusChange                    (      sender               :TObject);
    procedure I_Frame_ListMouseDown                                   (      sender               :TObject;
                                                                             button               :TMouseButton;
                                                                             shift                :TShiftState;
                                                                             x,y                  :integer);
    procedure I_Frame_ListMouseEnter                                  (      sender               :TObject);
    procedure LE_Content_Library_Images_Find_ImageEnter               (      sender               :TObject);
    procedure LE_Content_Library_Images_Find_ImageExit                (      sender               :TObject);
    procedure L_Object_InfoMouseEnter                                 (      sender               :TObject);
    procedure L_Object_InfoMouseLeave                                 (      sender               :TObject);
    procedure L_Spline_Edges_Post_Processing_Add_EffectClick          (      sender               :TObject);
    procedure L_Spline_Points_Post_Processing_Add_EffectClick         (      sender               :TObject);
    procedure MI_MonochromeClick                                      (      sender               :TObject);

    {Menu Items}
    procedure MI_Button_Style_1Click                                  (      sender               :TObject);
    procedure MI_Button_Style_2Click                                  (      sender               :TObject);
    procedure MI_Button_Style_3Click                                  (      sender               :TObject);
    procedure MI_Fold_AllClick                                        (      sender               :TObject);
    procedure MI_Unfold_AllClick                                      (      sender               :TObject);
    procedure MI_Unselect_AllClick                                    (      sender               :TObject);
    procedure PM_Post_Processing_Add_EffectClose                      (      sender               :TObject);
    procedure P_Content_Library_Images_HeaderClick                    (      sender               :TObject);
    procedure P_Content_Library_Images_HeaderMouseEnter               (      sender               :TObject);
    procedure P_Content_Library_Images_HeaderMouseLeave               (      sender               :TObject);
    procedure P_Content_Library_Sounds_HeaderClick                    (      sender               :TObject);
    procedure P_Content_Library_Sounds_HeaderMouseEnter               (      sender               :TObject);
    procedure P_Content_Library_Sounds_HeaderMouseLeave               (      sender               :TObject);
    procedure P_Load_Save_ClearPaint                                  (      sender               :TObject);
    procedure P_Draw_ButtonsPaint                                     (      sender               :TObject);
    procedure P_Anim_ButtonsPaint                                     (      sender               :TObject);
    procedure P_Draw_ButtonsMouseLeave                                (      sender               :TObject);
    procedure P_Anim_ButtonsMouseLeave                                (      sender               :TObject);
    procedure P_Draw_ButtonsMouseMove                                 (      sender               :TObject;
                                                                             shift                :TShiftState;
                                                                             x,y                  :integer);
    procedure P_Anim_ButtonsMouseMove                                 (      sender               :TObject;
                                                                             shift                :TShiftState;
                                                                             x,y                  :integer);
    procedure SB_TextMouseEnter                                       (      sender               :TObject);
    procedure SB_TextMouseLeave                                       (      sender               :TObject);
    procedure SB_BrushMouseEnter                                      (      sender               :TObject);
    procedure SB_BrushMouseLeave                                      (      sender               :TObject);
    procedure SB_SprayMouseEnter                                      (      sender               :TObject);
    procedure SB_SprayMouseLeave                                      (      sender               :TObject);
    procedure SB_SplineMouseEnter                                     (      sender               :TObject);
    procedure SB_SplineMouseLeave                                     (      sender               :TObject);
    procedure SB_Select_ItemsMouseEnter                               (      sender               :TObject);
    procedure SB_Select_ItemsMouseLeave                               (      sender               :TObject);
    procedure SB_Select_Background_RegionMouseEnter                   (      sender               :TObject);
    procedure SB_Select_Background_RegionMouseLeave                   (      sender               :TObject);
    procedure SB_BackgroundMouseEnter                                 (      sender               :TObject);
    procedure SB_BackgroundMouseLeave                                 (      sender               :TObject);
    procedure SB_SGridMouseEnter                                      (      sender               :TObject);
    procedure SB_SGridMouseLeave                                      (      sender               :TObject);
    procedure SB_RGridMouseEnter                                      (      sender               :TObject);
    procedure SB_RGridMouseLeave                                      (      sender               :TObject);
    procedure SB_Add_TilemapMouseEnter                                (      sender               :TObject);
    procedure SB_Add_TilemapMouseLeave                                (      sender               :TObject);
    procedure SB_Post_ProcessingMouseEnter                            (      sender               :TObject);
    procedure SB_Post_ProcessingMouseLeave                            (      sender               :TObject);
    procedure SB_Play_AnimMouseEnter                                  (      sender               :TObject);
    procedure SB_Play_AnimMouseLeave                                  (      sender               :TObject);
    procedure SB_Game_SettingsMouseEnter                              (      sender               :TObject);
    procedure SB_Game_SettingsMouseLeave                              (      sender               :TObject);
    procedure SB_Add_ActorMouseEnter                                  (      sender               :TObject);
    procedure SB_Add_ActorMouseLeave                                  (      sender               :TObject);
    procedure SB_Sound_ControlMouseEnter                              (      sender               :TObject);
    procedure SB_Sound_ControlMouseLeave                              (      sender               :TObject);
    procedure P_Select_Items_Inner_Subgraph_HeaderClick               (      sender               :TObject);
    procedure P_Select_Items_Inner_Subgraph_HeaderMouseEnter          (      sender               :TObject);
    procedure P_Select_Items_Inner_Subgraph_HeaderMouseLeave          (      sender               :TObject);
    procedure P_Select_Items_Inner_Subgraph_SettingsMouseEnter        (      sender               :TObject);
    procedure P_Select_Items_Inner_Subgraph_SettingsMouseLeave        (      sender               :TObject);
    procedure P_Select_Items_Outer_Subgraph_HeaderClick               (      sender               :TObject);
    procedure P_Select_Items_Outer_Subgraph_HeaderMouseEnter          (      sender               :TObject);
    procedure P_Select_Items_Outer_Subgraph_HeaderMouseLeave          (      sender               :TObject);
    procedure P_Select_Items_Outer_Subgraph_SettingsMouseEnter        (      sender               :TObject);
    procedure P_Select_Items_Outer_Subgraph_SettingsMouseLeave        (      sender               :TObject);
    procedure P_Select_Items_Selected_Points_HeaderClick              (      sender               :TObject);
    procedure P_Select_Items_Selected_Points_HeaderMouseEnter         (      sender               :TObject);
    procedure P_Select_Items_Selected_Points_HeaderMouseLeave         (      sender               :TObject);
    procedure P_Select_Items_Selected_Points_SettingsMouseEnter       (      sender               :TObject);
    procedure P_Select_Items_Selected_Points_SettingsMouseLeave       (      sender               :TObject);
    procedure P_Select_Items_Selection_HeaderClick                    (      sender               :TObject);
    procedure P_Select_Items_Selection_HeaderMouseEnter               (      sender               :TObject);
    procedure P_Select_Items_Selection_HeaderMouseLeave               (      sender               :TObject);
    procedure P_Select_Items_Selection_SettingsMouseEnter             (      sender               :TObject);
    procedure P_Select_Items_Selection_SettingsMouseLeave             (      sender               :TObject);
    procedure P_Spline_Drawing_HeaderClick                            (      sender               :TObject);
    procedure P_Spline_Drawing_HeaderMouseEnter                       (      sender               :TObject);
    procedure P_Spline_Drawing_HeaderMouseLeave                       (      sender               :TObject);
    procedure P_Spline_Drawing_Settings_HeaderClick                   (      sender               :TObject);
    procedure P_Spline_Drawing_Settings_HeaderMouseEnter              (      sender               :TObject);
    procedure P_Spline_Drawing_Settings_HeaderMouseLeave              (      sender               :TObject);
    procedure P_Spline_Drawing_Spline_Type_HeaderClick                (      sender               :TObject);
    procedure P_Spline_Drawing_Spline_Type_HeaderMouseEnter           (      sender               :TObject);
    procedure P_Spline_Drawing_Spline_Type_HeaderMouseLeave           (      sender               :TObject);
    procedure P_Spline_Dynamics_PropMouseEnter                        (      sender               :TObject);
    procedure P_Spline_Dynamics_PropMouseLeave                        (      sender               :TObject);
    procedure P_Spline_Edges_Bounds_HeaderClick                       (      sender               :TObject);
    procedure P_Spline_Edges_Bounds_HeaderMouseEnter                  (      sender               :TObject);
    procedure P_Spline_Edges_Bounds_HeaderMouseLeave                  (      sender               :TObject);
    procedure P_Spline_Edges_HeaderClick                              (      sender               :TObject);
    procedure P_Spline_Edges_HeaderMouseEnter                         (      sender               :TObject);
    procedure P_Spline_Edges_HeaderMouseLeave                         (      sender               :TObject);
    procedure P_Spline_Edges_Post_Processing_Add_EffectMouseEnter     (      sender               :TObject);
    procedure P_Spline_Edges_Post_Processing_Add_EffectMouseLeave     (      sender               :TObject);
    procedure P_Spline_Edges_Post_Processing_HeaderClick              (      sender               :TObject);
    procedure P_Spline_Edges_Post_Processing_HeaderMouseEnter         (      sender               :TObject);
    procedure P_Spline_Edges_Post_Processing_HeaderMouseLeave         (      sender               :TObject);
    procedure P_Spline_Edges_Shape_HeaderClick                        (      sender               :TObject);
    procedure P_Spline_Edges_Shape_HeaderMouseEnter                   (      sender               :TObject);
    procedure P_Spline_Edges_Shape_HeaderMouseLeave                   (      sender               :TObject);
    procedure P_Spline_Optimization_Compression_HeaderClick           (      sender               :TObject);
    procedure P_Spline_Optimization_Compression_HeaderMouseEnter      (      sender               :TObject);
    procedure P_Spline_Optimization_Compression_HeaderMouseLeave      (      sender               :TObject);
    procedure P_Spline_Optimization_General_HeaderClick               (      sender               :TObject);
    procedure P_Spline_Optimization_General_HeaderMouseEnter          (      sender               :TObject);
    procedure P_Spline_Optimization_General_HeaderMouseLeave          (      sender               :TObject);
    procedure P_Spline_Optimization_Grid_Clipping_HeaderClick         (      sender               :TObject);
    procedure P_Spline_Optimization_Grid_Clipping_HeaderMouseEnter    (      sender               :TObject);
    procedure P_Spline_Optimization_Grid_Clipping_HeaderMouseLeave    (      sender               :TObject);
    procedure P_Spline_Optimization_HeaderClick                       (      sender               :TObject);
    procedure P_Spline_Optimization_HeaderMouseEnter                  (      sender               :TObject);
    procedure P_Spline_Optimization_HeaderMouseLeave                  (      sender               :TObject);
    procedure P_Spline_Optimization_LOD_HeaderClick                   (      sender               :TObject);
    procedure P_Spline_Optimization_LOD_HeaderMouseEnter              (      sender               :TObject);
    procedure P_Spline_Optimization_LOD_HeaderMouseLeave              (      sender               :TObject);
    procedure P_Spline_Optimization_Memory_Management_HeaderClick     (      sender               :TObject);
    procedure P_Spline_Optimization_Memory_Management_HeaderMouseEnter(      sender               :TObject);
    procedure P_Spline_Optimization_Memory_Management_HeaderMouseLeave(      sender               :TObject);
    procedure P_Spline_Optimization_SettingsMouseEnter                (      sender               :TObject);
    procedure P_Spline_Optimization_SettingsMouseLeave                (      sender               :TObject);
    procedure P_Spline_Points_Bounds_HeaderClick                      (      sender               :TObject);
    procedure P_Spline_Points_Bounds_HeaderMouseEnter                 (      sender               :TObject);
    procedure P_Spline_Points_Bounds_HeaderMouseLeave                 (      sender               :TObject);
    procedure P_Spline_Points_HeaderClick                             (      sender               :TObject);
    procedure P_Spline_Points_HeaderMouseEnter                        (      sender               :TObject);
    procedure P_Spline_Points_HeaderMouseLeave                        (      sender               :TObject);
    procedure P_Spline_Points_Post_Processing_Add_EffectMouseEnter    (      sender               :TObject);
    procedure P_Spline_Points_Post_Processing_Add_EffectMouseLeave    (      sender               :TObject);
    procedure P_Spline_Points_Post_Processing_HeaderClick             (      sender               :TObject);
    procedure P_Spline_Points_Post_Processing_HeaderMouseEnter        (      sender               :TObject);
    procedure P_Spline_Points_Post_Processing_HeaderMouseLeave        (      sender               :TObject);
    procedure P_Spline_Points_Shape_HeaderClick                       (      sender               :TObject);
    procedure P_Spline_Points_Shape_HeaderMouseEnter                  (      sender               :TObject);
    procedure P_Spline_Points_Shape_HeaderMouseLeave                  (      sender               :TObject);
    procedure P_Spline_Save_PropMouseEnter                            (      sender               :TObject);
    procedure P_Spline_Save_PropMouseLeave                            (      sender               :TObject);
    procedure P_Spline_FreehandMouseEnter                             (      sender               :TObject);
    procedure P_Spline_FreehandMouseLeave                             (      sender               :TObject);
    procedure P_Spline_Templates_PropertiesMouseEnter                 (      sender               :TObject);
    procedure P_Spline_Templates_PropertiesMouseLeave                 (      sender               :TObject);
    procedure P_Spline_Template_ListMouseEnter                        (      sender               :TObject);
    procedure P_Spline_Template_ListMouseLeave                        (      sender               :TObject);
    procedure P_Spline_Template_ListMouseWheelDown                    (      sender               :TObject;
                                                                             shift                :TShiftState;
                                                                             mousepos             :TPoint;
                                                                       var   handled              :boolean);
    procedure P_Spline_Template_ListMouseWheelUp                      (      sender               :TObject;
                                                                             shift                :TShiftState;
                                                                             mousepos             :TPoint;
                                                                       var   handled              :boolean);
    procedure P_Spline_Template_ListPaint                             (      sender               :TObject);
    procedure P_Text_Drawing_PropMouseEnter                           (      sender               :TObject);
    procedure P_Text_Drawing_PropMouseLeave                           (      sender               :TObject);
    procedure P_Text_SettingsMouseEnter                               (      sender               :TObject);
    procedure P_Text_SettingsMouseLeave                               (      sender               :TObject);
    procedure SB_Add_ActorClick                                       (      sender               :TObject);
    procedure SB_Add_TilemapClick                                     (      sender               :TObject);
    procedure SB_Post_ProcessingClick                                 (      sender               :TObject);
    procedure SB_BackgroundClick                                      (      sender               :TObject);
    procedure SB_Centrify_PictureMouseEnter                           (      sender               :TObject);
    procedure SB_Change_LayoutMouseEnter                              (      sender               :TObject);
    procedure SB_Content_Library_Images_LoadClick                     (      sender               :TObject);
    procedure SB_Content_Library_Images_EditClick                     (      sender               :TObject);
    procedure SB_Game_SettingsClick                                   (      sender               :TObject);
    procedure SB_Original_Scene_ScaleClick                            (      sender               :TObject);
    procedure SB_Original_Scene_ScaleMouseEnter                       (      sender               :TObject);
    procedure SB_Original_Scene_ScaleMouseLeave                       (      sender               :TObject);
    procedure SB_RGridClick                                           (      sender               :TObject);
    procedure SB_RGrid_ColorClick                                     (      sender               :TObject);
    procedure SB_Select_Items_Inner_Subgraph_ColorClick               (      sender               :TObject);
    procedure SB_Select_Items_Inner_Subgraph_ShowClick                (      sender               :TObject);
    procedure SB_Select_Items_Outer_Subgraph_ColorClick               (      sender               :TObject);
    procedure SB_Select_Items_Outer_Subgraph_ShowClick                (      sender               :TObject);
    procedure SB_Select_Items_Selected_Points_ColorClick              (      sender               :TObject);
    procedure SB_Select_Items_Selected_Points_ShowClick               (      sender               :TObject);
    procedure SB_Select_Items_Selection_ColorClick                    (      sender               :TObject);
    procedure SB_SGridClick                                           (      sender               :TObject);
    procedure SB_SGrid_ColorClick                                     (      sender               :TObject);
    procedure SB_Sound_ControlClick                                   (      sender               :TObject);
    procedure SB_SplineClick                                          (      sender               :TObject);
    procedure SB_Spline_Edges_Bounds_ColorClick                       (      sender               :TObject);
    procedure SB_Spline_Edges_Bounds_Color_FallOffClick               (      sender               :TObject);
    procedure SB_Spline_Edges_Bounds_Color_RandomClick                (      sender               :TObject);
    procedure SB_Spline_Edges_Post_Processing_ColorClick              (      sender               :TObject);
    procedure SB_Spline_Edges_Post_Processing_Color_FallOffClick      (      sender               :TObject);
    procedure SB_Spline_Edges_Post_Processing_Color_RandomClick       (      sender               :TObject);
    procedure SB_Spline_Edges_ShowClick                               (      sender               :TObject);
    procedure SB_Spline_Edges_Show_BoundsClick                        (      sender               :TObject);
    procedure SB_Spline_LoadClick                                     (      sender               :TObject);
    procedure SB_Spline_Points_Bounds_ColorClick                      (      sender               :TObject);
    procedure SB_Spline_Points_Bounds_Color_FallOffClick              (      sender               :TObject);
    procedure SB_Spline_Points_Bounds_Color_RandomClick               (      sender               :TObject);
    procedure SB_Spline_Points_Show_BoundsClick                       (      sender               :TObject);
    procedure SB_Spline_SaveClick                                     (      sender               :TObject);
    procedure SB_Spline_TemplateClick                                 (      sender               :TObject);
    procedure SB_Play_AnimClick                                       (      sender               :TObject);
    procedure SB_Select_Background_RegionClick                        (      sender               :TObject);
    procedure SB_Spline_Points_Post_Processing_ColorClick             (      sender               :TObject);
    procedure SB_Spline_Points_Post_Processing_Color_FallOffClick     (      sender               :TObject);
    procedure SB_Spline_Points_Post_Processing_Color_RandomClick      (      sender               :TObject);
    procedure SB_Spline_Points_ShowClick                              (      sender               :TObject);
    procedure SB_Tag_PropertiesMouseEnter                             (      sender               :TObject);
    procedure SB_Tag_PropertiesMouseLeave                             (      sender               :TObject);
    procedure SB_Text_Select_FontClick                                (      sender               :TObject);
    procedure SE_Game_Settings_Exec_Time_LimitChange                  (      sender               :TObject);
    procedure SE_Game_Settings_Refresh_StepChange                     (      sender               :TObject);
    procedure SE_Spline_Cycloid_Loops_CountChange                     (      sender               :TObject);
    procedure SE_Spline_Cycloid_Points_CountChange                    (      sender               :TObject);
    procedure FSE_Spline_Cycloid_RadiusChange                         (      sender               :TObject);
    procedure FSE_Spline_Epicycloid_AngleChange                       (      sender               :TObject);
    procedure FSE_Spline_Epicycloid_Petals_CountChange                (      sender               :TObject);
    procedure SE_Spline_Edges_Bounds_Effect_StrengthChange            (      sender               :TObject);
    procedure SE_Spline_Edges_Post_Processing_Effect_StrengthChange   (      sender               :TObject);
    procedure SE_Spline_Epicycloid_Points_CountChange                 (      sender               :TObject);
    procedure FSE_Spline_Epicycloid_RadiusChange                      (      sender               :TObject);
    procedure FSE_Spline_Epicycloid_RotationChange                    (      sender               :TObject);
    procedure SE_Spline_Grid_Clipping_Grid_DensityChange              (      sender               :TObject);
    procedure SE_Spline_Grid_Clipping_Grid_DensityEnter               (      sender               :TObject);
    procedure SE_Spline_Grid_Clipping_Grid_DensityExit                (      sender               :TObject);
    procedure SE_Spline_Grid_Clipping_Grid_DensityMouseDown           (      sender               :TObject;
                                                                             button               :TMouseButton;
                                                                             shift                :TShiftState;
                                                                             x,y                  :integer);
    procedure SE_Spline_Points_Bounds_Effect_StrengthChange           (      sender               :TObject);
    procedure SE_Spline_Pts_FreqEnter                                 (      sender               :TObject);
    procedure SE_Spline_Pts_FreqExit                                  (      sender               :TObject);
    procedure SE_Spline_Pts_FreqMouseDown                             (      sender               :TObject;
                                                                             button               :TMouseButton;
                                                                             shift                :TShiftState;
                                                                             x,y                  :integer);
    procedure FSE_Spline_Rose_AngleChange                             (      sender               :TObject);
    procedure SE_Spline_Rose_Points_CountChange                       (      sender               :TObject);
    procedure FSE_Spline_Rose_RadiusChange                            (      sender               :TObject);
    procedure FSE_Spline_Rose_RotationChange                          (      sender               :TObject);
    procedure FSE_Spline_Spiral_AngleChange                           (      sender               :TObject);
    procedure SE_Spline_Spiral_Points_CountChange                     (      sender               :TObject);
    procedure FSE_Spline_Spiral_RadiusChange                          (      sender               :TObject);
    procedure FSE_Spline_Spiral_RotationChange                        (      sender               :TObject);
    procedure SE_Spline_Edges_WidthChange                             (      sender               :TObject);
    procedure SE_Spline_Points_CountChange                            (      sender               :TObject);
    procedure SE_Spline_Points_Rectangle_Inner_Rectangle_HeightChange (      sender               :TObject);
    procedure SE_Spline_Points_Rectangle_Inner_Rectangle_WidthChange  (      sender               :TObject);
    procedure SE_Spline_Points_Rectangle_Thikness_BottomChange        (      sender               :TObject);
    procedure SE_Spline_Points_Rectangle_Thikness_LeftChange          (      sender               :TObject);
    procedure SE_Spline_Points_Rectangle_Thikness_RightChange         (      sender               :TObject);
    procedure SE_Spline_Points_Rectangle_Thikness_TopChange           (      sender               :TObject);
    procedure SE_Spline_Spray_RadiusChange                            (      sender               :TObject);
    procedure SE_Spline_Superellipse_Points_CountChange               (      sender               :TObject);

    {Buttons}
    procedure S_Splitter0ChangeBounds                                 (      sender               :TObject);
    procedure S_Splitter1ChangeBounds                                 (      sender               :TObject);
    procedure S_Splitter2ChangeBounds                                 (      sender               :TObject);
    procedure S_Splitter3ChangeBounds                                 (      sender               :TObject);
    procedure S_Splitter6ChangeBounds                                 (      sender               :TObject);
    procedure S_Splitter7ChangeBounds                                 (      sender               :TObject);
    procedure S_Splitter8ChangeBounds                                 (      sender               :TObject);
    procedure S_Splitter1Moved                                        (      sender               :TObject);
    procedure S_Splitter2Moved                                        (      sender               :TObject);
    procedure S_Splitter3Moved                                        (      sender               :TObject);
    procedure S_Splitter5Moved                                        (      sender               :TObject);
    procedure S_Splitter6Moved                                        (      sender               :TObject);
    procedure S_Splitter8Moved                                        (      sender               :TObject);
    procedure TB_Camera_SpeedChange                                   (      sender               :TObject);
    procedure TextureListItemMouseDown                                (      sender               :TObject;
                                                                             button               :TMouseButton;
                                                                             shift                :TShiftState;
                                                                             x,y                  :integer);
    procedure SB_Load_Game_ProjectClick                               (      sender               :TObject);
    procedure SB_Save_Game_ProjectClick                               (      sender               :TObject);
    procedure SB_Clear_SceneClick                                     (      sender               :TObject);
    procedure BB_Delete_SelectedClick                                 (      sender               :TObject);
    procedure BB_Delete_AllClick                                      (      sender               :TObject);
    procedure SB_Change_LayoutClick                                   (      sender               :TObject);
    procedure SB_Change_LayoutMouseLeave                              (      sender               :TObject);
    procedure SB_Centrify_PictureClick                                (      sender               :TObject);
    procedure SB_Centrify_PictureMouseLeave                           (      sender               :TObject);
    procedure SB_Background_ColorClick                                (      sender               :TObject);
    procedure I_Visibility_PanelMouseLeave                            (      sender               :TObject);
    procedure I_Visibility_PanelPaint                                 (      sender               :TObject);
    procedure SB_Visibility_Show_AllMouseEnter                        (      sender               :TObject);
    procedure SB_Visibility_BackgroundMouseEnter                      (      sender               :TObject);
    procedure SB_Visibility_Snap_GridMouseEnter                       (      sender               :TObject);
    procedure SB_Visibility_Regular_GridMouseEnter                    (      sender               :TObject);
    procedure SB_Visibility_SplineMouseEnter                          (      sender               :TObject);
    procedure SB_Visibility_ActorMouseEnter                           (      sender               :TObject);
    procedure SB_Visibility_Tile_MapMouseEnter                        (      sender               :TObject);
    procedure SB_Visibility_BackgroundClick                           (      sender               :TObject);
    procedure SB_Visibility_Regular_GridClick                         (      sender               :TObject);
    procedure SB_Visibility_SplineClick                               (      sender               :TObject);
    procedure SB_Visibility_Tile_MapClick                             (      sender               :TObject);
    procedure SB_Visibility_ActorClick                                (      sender               :TObject);
    procedure SB_Visibility_Snap_GridClick                            (      sender               :TObject);
    procedure SB_Visibility_Show_AllClick                             (      sender               :TObject);
    procedure TS_DrawMouseWheelDown                                   (      sender               :TObject;
                                                                             shift                :TShiftState;
                                                                             mousepos             :TPoint;
                                                                       var   handled              :boolean);
    procedure TS_DrawMouseWheelUp                                     (      sender               :TObject;
                                                                             shift                :TShiftState;
                                                                             mousepos             :TPoint;
                                                                       var   handled              :boolean);
    procedure SB_BrushClick                                           (      sender               :TObject);
    procedure SB_SprayClick                                           (      sender               :TObject);
    procedure SB_TextClick                                            (      sender               :TObject);
    procedure CB_Spline_ModeSelect                                    (      sender               :TObject);
    procedure SE_Spline_Pts_FreqChange                                (      sender               :TObject);
    procedure CB_Spline_TypeSelect                                    (      sender               :TObject);
    procedure CB_Spline_Connect_EndsChange                            (      sender               :TObject);
    procedure FSE_Spline_Simplification_AngleChange                   (      sender               :TObject);
    procedure CB_Spline_Edges_Anti_AliasingChange                     (      sender               :TObject);
    procedure SB_Select_ItemsClick                                    (      sender               :TObject);
    procedure CB_Select_Items_Selection_Selection_ModeSelect          (      sender               :TObject);
    procedure CB_Select_Items_Outer_Subgraph_Line_StyleSelect         (      sender               :TObject);
    procedure CB_Select_Items_Outer_Subgraph_Clip_StyleSelect         (      sender               :TObject);
    procedure TV_Scene_TreeCustomDrawItem                             (      sender               :TCustomTreeView;
                                                                             node                 :TTreeNode;
                                                                             state                :TCustomDrawState;
                                                                       var   DefaultDraw          :boolean);
    procedure TV_Scene_TreeDblClick                                   (      sender               :TObject);
    procedure TV_Scene_TreeEditing                                    (      sender               :TObject;
                                                                             node                 :TTreeNode;
                                                                       var   allowedit            :boolean);
    procedure TV_Scene_TreeEditingEnd                                 (      sender               :TObject;
                                                                             node                 :TTreeNode;
                                                                             cancel               :boolean);
    procedure TV_Scene_TreeEndDrag                                    (      sender,target        :TObject;
                                                                             x,y                  :integer);
    procedure TV_Scene_TreeExpanded                                   (      sender               :TObject;
                                                                             node                 :TTreeNode);
    procedure TV_Scene_TreeExpanding                                  (      sender               :TObject;
                                                                             node                 :TTreeNode;
                                                                       var   allowexpansion       :boolean);
    procedure TV_Scene_TreeKeyDown                                    (      sender               :TObject;
                                                                       var   key                  :word;
                                                                             shift                :TShiftState);
    procedure TV_Scene_TreeKeyPress                                   (      sender               :TObject;
                                                                       var   key                  :char);
    procedure TV_Scene_TreeMouseEnter                                 (      sender               :TObject);
    procedure TV_Scene_TreeMouseLeave                                 (      sender               :TObject);
    procedure TV_Scene_TreeMouseMove                                  (      sender               :TObject;
                                                                             shift                :TShiftState;
                                                                             x,y                  :integer);
    procedure TV_Scene_TreeMouseWheelDown                             (      sender               :TObject;
                                                                             shift                :TShiftState;
                                                                             mousepos             :TPoint;
                                                                       var   handled              :boolean);
    procedure TV_Scene_TreeMouseWheelUp                               (      sender               :TObject;
                                                                             shift                :TShiftState;
                                                                             mousepos             :TPoint;
                                                                       var   handled              :boolean);
    procedure T_Editor_TimeTimer                                      (      sender               :TObject);
    procedure T_Game_LoopTimer                                        (      sender               :TObject);

    {TrayIcon}
    procedure TrayIcon1Click                                          (      sender               :TObject);

    {Scene Tree}
    constructor Create                                                (      theowner             :TComponent); override;
    procedure MI_Center_Camera_To_Selected_ObjectClick                (      sender               :TObject);
    procedure MI_Add_GroupClick                                       (      sender               :TObject);
    procedure MI_Remove_ObjectClick                                   (      sender               :TObject);
    procedure MI_Group_ObjectsClick                                   (      sender               :TObject);
    procedure MI_Delete_Without_ChildrenClick                         (      sender               :TObject);
    procedure MI_Delete_All_GroupsClick                               (      sender               :TObject);
    procedure MI_Select_AllClick                                      (      sender               :TObject);
    procedure MI_Fold_SelectedClick                                   (      sender               :TObject);
    procedure MI_Unfold_SelectedClick                                 (      sender               :TObject);
    procedure MI_Goto_First_ObjectClick                               (      sender               :TObject);
    procedure MI_Goto_Last_ObjectClick                                (      sender               :TObject);
    procedure P_Scene_Tree_HeaderClick                                (      sender               :TObject);
    procedure P_Object_TagsMouseWheelDown                             (      sender               :TObject;
                                                                             shift                :TShiftState;
                                                                             mousepos             :TPoint;
                                                                       var   handled              :boolean);
    procedure P_Object_TagsMouseWheelUp                               (      sender               :TObject;
                                                                             shift                :TShiftState;
                                                                             mousepos             :TPoint;
                                                                       var   handled              :boolean);
    procedure TV_Scene_TreeDragOver                                   (      sender,
                                                                             source               :TObject;
                                                                             x,y                  :integer;
                                                                             state                :TDragState;
                                                                       var   accept               :boolean);
    procedure TV_Scene_TreeMouseDown                                  (      sender               :TObject;
                                                                             button               :TMouseButton;
                                                                             shift                :TShiftState;
                                                                             x,y                  :integer);
    procedure TV_Scene_TreeDragDrop                                   (      sender,
                                                                             source               :TObject;
                                                                             x,y                  :integer);
    procedure S_Splitter5ChangeBounds                                 (      sender               :TObject);

    {Object Properties}
    procedure SB_Object_PropertiesMouseEnter                          (      sender               :TObject);
    procedure SB_Object_PropertiesMouseLeave                          (      sender               :TObject);
    procedure SE_Object_Properties_Parallax_ShiftXChange              (      sender               :TObject);
    procedure SE_Object_Properties_Parallax_ShiftYChange              (      sender               :TObject);
    procedure CB_Object_Properties_Show_In_EditorChange               (      sender               :TObject);
    procedure CB_Object_Properties_Show_In_GameChange                 (      sender               :TObject);
    procedure CB_Object_Properties_Recalculate_PositionChange         (      sender               :TObject);
    procedure CB_Object_Properties_MovableChange                      (      sender               :TObject);
    procedure CB_Object_Properties_ScalableChange                     (      sender               :TObject);
    procedure CB_Object_Properties_RotatableChange                    (      sender               :TObject);

    {Cursors}
    procedure LockCursorToWindow; inline;
    procedure UnLockCursor;       inline;

    {Misc.}
    procedure VisibilityChange                                        (      set_visibility       :boolean); inline; {$ifdef Linux}[local];{$endif}
    procedure KeysEnableA                                             (const enabled_var          :boolean); inline; {$ifdef Linux}[local];{$endif}
    procedure KeysEnableB                                             (const pnl                  :TPanel;
                                                                             onclick_arr_ptr      :PNotifyEvent;
                                                                       const enabled_var          :boolean); inline; {$ifdef Linux}[local];{$endif}
    procedure KeysEnableC                                             (const pnl                  :TPanel;
                                                                             onclick_arr_ptr      :PNotifyEvent;
                                                                       const enabled_var          :boolean); inline; {$ifdef Linux}[local];{$endif}
    procedure KeysEnable0;                                                                                   inline; {$ifdef Linux}[local];{$endif}
    procedure KeysEnable1;                                                                                   inline; {$ifdef Linux}[local];{$endif}
    procedure KeysEnable2;                                                                                   inline; {$ifdef Linux}[local];{$endif}
    procedure KeysEnable3;                                                                                   inline; {$ifdef Linux}[local];{$endif}
    procedure KeysEnable4;                                                                                   inline; {$ifdef Linux}[local];{$endif}
    procedure KeysDisable0;                                                                                  inline; {$ifdef Linux}[local];{$endif}
    procedure KeysDisable1;                                                                                  inline; {$ifdef Linux}[local];{$endif}
    procedure KeysDisable2;                                                                                  inline; {$ifdef Linux}[local];{$endif}
    procedure KeysDisable3;                                                                                  inline; {$ifdef Linux}[local];{$endif}
    procedure SplinesTemplatesNamesInit                               (      sln_var_             :TCurve);
    procedure AddFX                                                   (      sb_add_fx            :TScrollBox;
                                                                             cb_fx_stl_src        :TComboBox;
                                                                       var   cb_fx_stl_dst        :TComboBox;
                                                                             fx_name              :TLabel;
                                                                             fx_val               :TSpinEdit;
                                                                             HeaderMouseEnter,
                                                                             HeaderMouseLeave,
                                                                             SplineFXComboBoxClick:TProc14;
                                                                       var   sln_fx_pnls_cnt      :TColor;
                                                                       var   sln_fx_pnls          :PPanelArr;
                                                                       var   sln_fx_arr           :TFX2Arr);
    procedure SplineEdsFXComboBoxClick                                (      sender               :TObject);
    procedure SplinePtsFXComboBoxClick                                (      sender               :TObject);
    procedure SplineEdsFXComboBoxSelect                               (      sender               :TObject);
    procedure SplinePtsFXComboBoxSelect                               (      sender               :TObject);
    procedure WMHScroll                                               (var   message              :TLMHScroll); message LM_HScroll;
    procedure WMVScroll                                               (var   message              :TLMHScroll); message LM_VScroll;

    private
      procedure OnExitResize                                          (var   message              :TMessage);   message WM_CAPTURECHANGED{EXITSIZEMOVE};  // Обработчик завершения изменения размеров формы
      procedure OnMove                                                (var   message              :TWMMove );   message WM_MOVE;                          // Обработчик перемещения формы

    strict private

    protected

    strict protected

    public

    published

  end; {$endregion}
  PF_MainForm    =^TF_MainForm;

  {Drawing Surface----}
  TSurface       =class {$region -fold}
    public
      {Main  layer-----------------------} {$region -fold}
        // main bitmap:
        srf_bmp                : Graphics.TBitmap;
        //
        test_bmp               : Graphics.TBitmap;
        // main bitmap handle:
        srf_bmp_ptr            : PInteger;
        //
        test_bmp_ptr           : PInteger;
        // main bitmap bounding rectangle:
        srf_bmp_rct            : TPtRect;
        canvas_rct_width       : integer;
        canvas_rct_height      : integer;
        // background color:
        bg_col                 : TColor;
        // background post-process effect:
        bg_style               : TBackgroundStyle; {$endregion}
      {Lower layer(before selection)-----} {$region -fold}
        // lower layer(before selection) bitmap:
        low_bmp                : Graphics.TBitmap;
        // lower layer(before selection) bitmap handle:
        low_bmp_ptr            : PInteger;
        // drawing of lower layer(before selection):
        low_bmp_draw           : boolean; {$endregion}
      {Lower layer(after  selection)-----} {$region -fold}
        // lower layer(after selection):
        low_bmp2               : Graphics.TBitmap;
        // lower layer(after selection) bitmap handle:
        low_bmp2_ptr           : PInteger;
        // drawing of lower layer(after selection):
        low_bmp2_draw          : boolean; {$endregion}
      {Resized inner window--------------} {$region -fold}
        // TODO:
        res_wnd_ind            : integer;
        // TODO:
        low_bmp3               : Graphics.TBitmap;
        // TODO:
        low_bmp3_ptr           : PInteger; {$endregion}
      {Buffer for baking scalable sprites} {$region -fold}
        //
        scl_arr                : TColorArr;
        //
        scl_arr_ptr            : PInteger;
        //
        scl_arr_width          : TColor;
        //
        scl_arr_height         : TColor; {$endregion}
      {Inner window----------------------} {$region -fold}
      // TODO:
      inn_wnd_cmr_shake_mrg    : integer;
      /// TODO:
      inn_wnd_mrg              : integer;
      // Inner window bitmap bounding rectangles:
      inn_wnd_rct              : TPtRect;
      inn_wnd_rct1             : TPtRect;
      inn_wnd_rct2             : TPtRect;
      iwr_is_iwr2              : boolean;
      // TODO:
      tex_bmp_rct_pts          : TPtPosFArr;
      // TODO:
      tex_bmp_rct_origin_pts   : TPtPosFArr;
      // UI:
      inner_window_ui_visible  : boolean;
      // TODO:
      need_repaint             : boolean; {$endregion}
      {World axis position---------------} {$region -fold}
      world_axis               : TPtPosF;
      world_axis_shift         : TPtPosF;
      world_axis_shift_centrify: TPtPosF;
      err                      : TPtPos; {$endregion}
      // Count of repetitions of the post-process effect:
      pp_rep_cnt               : integer;
      // Original window resolution:
      orgn_wnd_res             : TPtPos;
      // Resized  window resolution:
      rszd_wnd_res             : TPtPos;
      rszd_wnd_res2            : TPtPos;
      // Array of stored drawing styles(blending effects):
      drawing_style            : array[0..4] of TDrawingStyle;
      // Index inside spritesheet array:
      world_axis_bmp_ind       : integer;
      // TODO:
      form_resize              : boolean;
      form_resized             : boolean;
      // Create class instance:
      constructor Create              (      w,h         :TColor);            {$ifdef Linux}[local];{$endif}
      // Destroy class instance:
      destructor  Destroy;                                          override; {$ifdef Linux}[local];{$endif}
      // Fill background texture:
      procedure FilBkTexObj           (const bktex_ind   :TColor);  inline;   {$ifdef Linux}[local];{$endif}
      // Resized inner window:
      procedure ResInnWndCreate;                                    inline;   {$ifdef Linux}[local];{$endif}
      procedure ResInnWndToBmp;                                     inline;   {$ifdef Linux}[local];{$endif}
      procedure SetPtPosToResInnWndPos(var   x,y         :integer); inline;   {$ifdef Linux}[local];{$endif}
      // World axis:
      procedure WorldAxisCreate;                                    inline;   {$ifdef Linux}[local];{$endif}
      procedure WorldAxisToBmp        (const x,y         :integer); inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure InnerWindowDraw       (      color       :TColor);  inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure MainBmpToLowerBmp;                                  inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure MainBmpToLowerBmp2;                                 inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure LowerBmpToMainBmp;                                  inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure LowerBmp2ToMainBmp;                                 inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure RefreshLowerLayer;                                  inline;   {$ifdef Linux}[local];{$endif}
      // Main drawing procedure:
      procedure BkgndDraw             (const bkgnd_ind   :TColor;
                                             rct_clp_ptr_:PPtRect); inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure FilBkgndObj           (const bkgnd_ind   :TColor);  inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure MovBkgndObj           (const bkgnd_ind   :TColor);  inline;   {$ifdef Linux}[local];{$endif}
      {Lower layer movement-------------------} {$region -fold}
        procedure MovLeft;                                          inline;   {$ifdef Linux}[local];{$endif}
        procedure FilLeft;                                          inline;   {$ifdef Linux}[local];{$endif}
        procedure MovRight;                                         inline;   {$ifdef Linux}[local];{$endif}
        procedure FilRight;                                         inline;   {$ifdef Linux}[local];{$endif}
        procedure MovUp;                                            inline;   {$ifdef Linux}[local];{$endif}
        procedure FilUp;                                            inline;   {$ifdef Linux}[local];{$endif}
        procedure MovDown;                                          inline;   {$ifdef Linux}[local];{$endif}
        procedure FilDown;                                          inline;   {$ifdef Linux}[local];{$endif} {$endregion}
      {Events queue}
      {}
      procedure SetSurfParam0;                                      inline;   {$ifdef Linux}[local];{$endif}
      procedure SetSurfParam1;                                      inline;   {$ifdef Linux}[local];{$endif}
      procedure SetSurfParam2;                                      inline;   {$ifdef Linux}[local];{$endif}
      procedure SetSurfParam3;                                      inline;   {$ifdef Linux}[local];{$endif}
      {Scene scaling--------------------------}
      procedure SceneSclPowCalc;                                    inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure MainBmpRectCalc0;                                   inline;   {$ifdef Linux}[local];{$endif}
      procedure MainBmpRectCalc1;                                   inline;   {$ifdef Linux}[local];{$endif}
      procedure MainBmpRectCalc2;                                   inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure MainBmpSizeCalc;                                    inline;   {$ifdef Linux}[local];{$endif}
      // Set new sizes of bitmaps and arrays:
      procedure MainBmpArrsCalc;                                    inline;   {$ifdef Linux}[local];{$endif}
      // Get handles:
      procedure GetHandles;                                         inline;   {$ifdef Linux}[local];{$endif}
      // World axis: drawing:
      procedure WorldAxisDraw;                                      inline;   {$ifdef Linux}[local];{$endif}
      {Align spline: calculation--------------}
      procedure AlnSplineCalc;                                                {$ifdef Linux}[local];{$endif}
      {Select   pivot: calculation------------}
      procedure SelectPivotCalc;                                              {$ifdef Linux}[local];{$endif}
      {Select   pivot: drawing----------------}
      procedure SelectPivotDraw;                                              {$ifdef Linux}[local];{$endif}
      {Unselect pivot: drawing----------------}
      procedure UnselectPivotDraw;                                            {$ifdef Linux}[local];{$endif}
      {Add spline: calculation----------------}
      procedure AddSplineCalc;                                                {$ifdef Linux}[local];{$endif}
      {Add spline: hidden lines---------------}
      procedure AddSplineHdLn;                                                {$ifdef Linux}[local];{$endif}
      {Add spline: has edge(lines) calculation}
      procedure AddSplineHsLn;                                                {$ifdef Linux}[local];{$endif}
      {Add spline: drawing--------------------}
      procedure AddSplineDraw;                                                {$ifdef Linux}[local];{$endif}
      {Add tilemap: calculation---------------}
      procedure AddTileMapCalc;                                               {$ifdef Linux}[local];{$endif}
      {Add Post-Process FX: Calculation-------}
      procedure AddPProcFXCalc;                                               {$ifdef Linux}[local];{$endif}
      {Scale spline: calculation--------------}
      procedure SclSplineCalc;                                                {$ifdef Linux}[local];{$endif}
      {Repaint splines with Hidden Lines------}
      procedure RepSplineHdLn;                                                {$ifdef Linux}[local];{$endif}
      {Repaint Splines: Points Grid Clipping--}
      procedure RepSplinePtsGrd;                                              {$ifdef Linux}[local];{$endif}
      {Repaint spline: drawing----------------}
      procedure RepSplineDraw0;                                               {$ifdef Linux}[local];{$endif}
      procedure RepSplineDraw1;                                               {$ifdef Linux}[local];{$endif}
      procedure RepSplineDraw2;                                               {$ifdef Linux}[local];{$endif}
      procedure RepSplineDraw3;                                               {$ifdef Linux}[local];{$endif}
      procedure RepSplineDraw4;                                               {$ifdef Linux}[local];{$endif}
      {Duplicated points: drawing-------------}
      procedure DupPtsDraw;                                                   {$ifdef Linux}[local];{$endif}
      {SpriteSheet: reset background settings-}
      procedure SpriteSheetSetBckgd;                                          {$ifdef Linux}[local];{$endif}
      {Actors: reset background settings------}
      procedure ActSetBckgd;                                                  {$ifdef Linux}[local];{$endif}
      {Selected subgraph: drawing-------------}
      procedure SelectedSubgrtaphDraw;                                        {$ifdef Linux}[local];{$endif}
      {Background post-processing-------------}
      procedure BkgPP;                                                        {$ifdef Linux}[local];{$endif}
      {Main render procedure}
      procedure MainDraw;                                                     {$ifdef Linux}[local];{$endif}
      procedure EventGroupsCalc       (var   arr         :TBool2Arr;
                                             event_group :TEventGroupEnum);   {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PSurface       =^TSurface;

  {Camera-------------}
  TCamera        =class {$region -fold}
    public
      // Drawing surface pointer:
      srf_var_ptr       : PSurface;
      {Speed multiplier} {$region -fold}
        // TODO:
        parallax_shift  : TPtPosF;
        // TODO:
        spd_mul         : TPtPosF;
        spd_mul_prev    : TPtPosF;
        // TODO:
        mov_dir         : TMovingDirection; {$endregion}
      {Scale multiplier} {$region -fold}
        scl_mul         : TPtPosF;
        // TODO:
        scl_mul_pow     : double;
        // TODO:
        scl_dif         : integer;
        // TODO:
        scl_min         : integer;
        // TODO:
        scl_max         : integer;
        // scale direction:
        scl_dir         : TSclDir; {$endregion}
      {Camera movement-} {$region -fold}
        // centrify camera:
        centrify_camera : boolean;
        // is camera moving:
        is_camera_moving: boolean;
        // TODO:
        dir_a           : boolean;
        // TODO:
        dir_d           : boolean;
        // TODO:
        dir_w           : boolean;
        // TODO:
        dir_s           : boolean; {$endregion}
      {Camera shake----} {$region -fold}
      shake_mrg         : TPtPosF;
      shake_type        : TCameraShake; {$endregion}
      // TODO:
      bmp_rect          : TPtRect;
      // Create class instance:
      constructor Create  (w,h    :TColor);                     {$ifdef Linux}[local];{$endif}
      // Destroy class instance:
      destructor  Destroy;                            override; {$ifdef Linux}[local];{$endif}
      // Camera movement:
      procedure CameraMove(dir1,
                           dir2   :boolean;
                           movdir1,
                           movdir2,
                           movdir3:TMovingDirection); inline;   {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PCamera        =^TCamera;

  {Grid---------------}
  TRGrid         =class {$region -fold}
    public
      // Drawing surface pointer:
      srf_var_ptr: PSurface;
      class var
        // TODO:
        rgrid_col: TColor;
        // Grid density:
        rgrid_dnt: integer;
      // Create class instance:
      constructor Create   (      w,h         :TColor);            {$ifdef Linux}[local];{$endif}
      // Destroy class instance:
      destructor  Destroy;                               override; {$ifdef Linux}[local];{$endif}
      procedure RGridDraw  (const rgrid_ind   :TColor;
                                  rct_clp_ptr_:PPtRect); inline;   {$ifdef Linux}[local];{$endif}
      procedure FilRGridObj(const rgrid_ind   :TColor);  inline;   {$ifdef Linux}[local];{$endif}
      procedure MovRGridObj(const rgrid_ind   :TColor);  inline;   {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PRGrid         =^TRGrid;

  {Snap Grid----------}
  TSGrid         =class {$region -fold}
    public
      // Drawing surface pointer:
      srf_var_ptr: PSurface;
      class var
        // Snap grid color:
        sgrid_col: TColor;
        // Grid density:
        sgrid_dnt: integer;
        // TODO:
        align_pts: boolean;
      // Create class instance:
      constructor Create   (      w,h                :TColor);            {$ifdef Linux}[local];{$endif}
      // Destroy class instance:
      destructor  Destroy;                                      override; {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SGridToBmp (const pvt                :TPtPosF;
                            const bmp_dst_ptr        :PInteger;
                            const bmp_dst_width      :TColor;
                                  rct_clp_ptr        :PPtRect); inline;   {$ifdef Linux}[local];{$endif}
      procedure SGridDraw  (const sgrid_ind          :TColor;
                                  rct_clp_ptr_       :PPtRect); inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure FilSGridObj(const sgrid_ind          :TColor);  inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure MovSGridObj(const sgrid_ind          :TColor);  inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure AlignPts   (var   pts                :TPtPosFArr;
                            const sel_pts_inds       :TColorArr;
                            const pts_cnt,sel_pts_cnt:TColor);            {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PSGrid         =^TSGrid;

  {Spline-------------}
  TCurve         =class {$region -fold}
    public
      // Drawing surface pointer:
      srf_var_ptr            : PSurface;
      {Spline edges  bounding Rectangles buffers------------------------------} {$region -fold}
        // Indices inside spritesheet array:
        rct_eds_ind_arr        : TIntrArr;
        // TODO:
        rct_eds_img_arr        : TFLnArr;
        // TODO:
        rct_eds_big_img        : TFastLine;
        // TODO:
        rct_eds_useless_fld_arr: TColorArr;
      {$endregion}
      {Spline points bounding Rectangles buffers------------------------------} {$region -fold}
        // Indices inside spritesheet array:
        rct_pts_ind_arr        : TIntrArr;
        // TODO:
        rct_pts_img_arr        : TFLnArr;
        // TODO:
        rct_pts_big_img        : TFastLine;
        // TODO:
        rct_pts_useless_fld_arr: TColorArr;
      {$endregion}
      {Spline edges                      buffers------------------------------} {$region -fold}
        // Indices inside spritesheet array:
        eds_ind_arr            : TIntrArr;
        // TODO:
        eds_img_arr            : TFLnArr;
        // TODO:
        eds_big_img            : TFastLine;
        // TODO:
        eds_useless_fld_arr    : TColorArr;
      {$endregion}
      {Spline points                     buffers------------------------------} {$region -fold}
        // Indices inside spritesheet array:
        pts_ind_arr            : TIntrArr;
        // TODO:
        pts_img_arr            : TFLnArr;
        // TODO:
        pts_big_img            : TFastLine;
        // TODO:
        pts_useless_fld_arr    : TColorArr;
      {$endregion}
      {Global properties------------------------------------------------------} {$region -fold}
        {spline global properties which will be shown on panel of spline properties in editor} {$region -fold}
          global_prop            : TCurveProp;
          current_prop           : TCurveProp;
        {$endregion}
        {fx global properties----------------------------------------------------------------} {$region -fold}
          // effects array:
         {fx_arr                 : TFXArr;
          // count of effects:
          fx_cnt                 : byte;}
        {$endregion}
      {$endregion}
      {Spline template list---------------------------------------------------} {$region -fold}
        // TODO:
        FmlSplineObj           : array[byte] of TProc7;
        // TODO:
        sln_tlt_name_arr1      : array[byte] of string;
        // TODO:
        sln_tlt_name_arr2      : array[byte] of PByteBool;
        // Index of minimal parameter(left/top) of "Spline Teamplates"(spline type:formula) buttons:
        sln_tlt_fst_it_ind     : byte;
        // Index of current button down:
        cur_tlt_dwn_btn_ind    : smallint;
      {$endregion}
      {(Grid clipping: points) отсечение по сетке: точки----------------------} {$region -fold}
        // ...:
        scl_mul_dif              : TPtPosFArr;
        // ...:
        pts_srt_pos_y_min_max    : array of TPtPosFArr;
        // (X-sorted array)отсортированный по оси x массив точек сплайна:
        pts_srt_pos_x            : array of TDublArr;
        // (Y-sorted array)отсортированный по оси x массив точек сплайна:
        pts_srt_pos_y            : array of TDublArr;
        // array of indices of sorted points:
        pts_srt_inds             : array of TColorArr;
        // array of points sorted along one of the axes, which contains the values of the minimum and maximum index in each cluster:
        min_max_inds             : array of TRGBA2Arr;
        // does a points claster have points:
        // 0 - has no points;
        // 1 - has a single point;
        // 2 - has more then 1 point;
        has_pts                  : array of T1Byte1Arr;
      {$endregion}
      {Misc. variables--------------------------------------------------------} {$region -fold}
        // Duplicated points:
        dup_pts_arr              : TPtPos3Arr;
        // Array of ponts for intermediate calculations(when points are added):
        sln_pts_add              : TPtPosFArr;
        // (Partial points sums) частичные суммы точек сплайнов:
        partial_pts_sum          : TColorArr;
        // (Array of counts of spline objects points) массив числа точек сплайнов:
        sln_obj_pts_cnt          : TColorArr;
        {Does spline have selected points:
        0 - no points selected;
        1 - there are selected points in outer subgraph;
        2 - there are selected points in inner subgraph;
        3 - there are selected points in outer and inner subgraphs;
        4 - there is a single selected point}
        has_sel_pts              : T1Byte1Arr;
        {Array of indices of splines with selected points witch has been modified} {$region -fold}
        // Grid Clipping:
        has_mod_pts0             : T1Byte1Arr;
        // Hidden Lines:
        has_mod_pts1             : T1Byte1Arr;
        {$endregion}
        // Spline points:
        sln_pts                  : TPtPosFArr;
        // Spline points(reserved):
        sln_pts_res              : TPtPosFArr;
        // Formula spline points (dummy preview in editor):
        fml_pts                  : TPtPosFArr;
        // (Array of spline objects indices) массив индексов сплайнов:
        sln_obj_ind              : TWordArr{TColorArr};
        // (Array of spline visible edges indices) массив индексов видимых ребер:
        sln_vis_eds_ind          : TColor2Arr;
        // Selected points count of splines:
        sln_sel_pts_cnt          : TColorArr;
        {Set value to point:
        0 - inner spline object point;
        1 - first spline object point;
        2 - last  spline object point;
        3 - spline object has single point}
        fst_lst_sln_obj_pts      : TEnum0Arr;
        {Does point have an edge:
        -1 - point doesnt have edge;
        0  - point has         edge}
        has_edge                 : TShIntArr;
        // TODO:
        rct_bnd_ind_arr          : array of TEnum2Arr;
        // All splines bounding rectangle intersected with inner window:
        sln_obj_all_rct_vis      : TRect;
        // Spline objects count:
        sln_obj_cnt              : word{TColor};
        // Spline points count:
        sln_pts_cnt              : TColor;
        // Spline points count on addition:
        sln_pts_cnt_add          : TColor;
        // Spline edges count:
        sln_eds_cnt              : TColor;
        // ...
        sln_pts_skip_counter     : TColor;
        // Detect, if spline drawing is happening:
        draw_spline              : boolean;
        // Detect, if there is at least one spline with property local_prop.hid_ln_elim in True:
        has_hid_ln_elim_sln      : boolean;
        // Detect, if there is at least one spline with property local_prop.byte_mode in True:
        has_byte_mode_sln        : boolean;
        //
        sln_3_pts                : array[0..2] of TPtPosF;
        //
        eds_simpl_angle_sum      : double;
        // Linked list for "Add Point":
        first_item,p1,p2         : PFList;
      {$endregion}
      {Spline Init.-----------------------------------------------------------} {$region -fold}
        // Create class instance:
        constructor Create                 (const w,h              :TColor);                   {$ifdef Linux}[local];{$endif}
        // Destroy class instance:
        destructor  Destroy;                                                         override; {$ifdef Linux}[local];{$endif}
        // Compress primitive surface:
        procedure PrimitiveComp            (const spline_ind       :TColor;
                                            const pmt_var_ptr,
                                                  pmt_big_var_ptr  :PFastLine;
                                                  pmt_bld_stl      :TDrawingStyle;
                                                  fast_image_ptr   :PFastImageItem);           {$ifdef Linux}[local];{$endif} {$endregion}
      {Calculation of spline rectangle----------------------------------------} {$region -fold}
        procedure RctSplineRct0            (const spline_ind       :TColor;
                                            var   rct_out_         :TRect;
                                            var   rct_ent_         :TPtRectF);                 {$ifdef Linux}[local];{$endif}
        procedure RctSplineRct1            (const spline_ind       :TColor;
                                            var   rct_out_         :TRect;
                                            var   rct_ent_         :TPtRectF);                 {$ifdef Linux}[local];{$endif}
        procedure RctSplineRct2            (const spline_ind       :TColor;
                                            var   rct_out_         :TRect;
                                            var   rct_ent_         :TPtRectF);                 {$ifdef Linux}[local];{$endif}
        procedure RctSplineRctEds          (const spline_ind       :TColor;
                                            const rct_out_         :TRect;
                                            const rct_ent_         :TPtRectF);                 {$ifdef Linux}[local];{$endif}
        procedure RctSplineRctPts          (const spline_ind       :TColor;
                                            const rct_out_         :TRect;
                                            const rct_ent_         :TPtRectF);                 {$ifdef Linux}[local];{$endif}
        procedure RctSplineEds             (const spline_ind       :TColor;
                                            const rct_out_         :TRect;
                                            const rct_ent_         :TPtRectF);                 {$ifdef Linux}[local];{$endif}
        procedure RctSplinePts             (const spline_ind       :TColor;
                                            const rct_out_         :TRect;
                                            const rct_ent_         :TPtRectF);                 {$ifdef Linux}[local];{$endif}
        procedure RctSplineEntAndVis       (const w_a_s_x,
                                                  w_a_s_y          :integer;
                                            const f_ln_arr_item_ptr:PFastLine);                {$ifdef Linux}[local];{$endif}
        procedure RctSplineObj0            (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure RctSplineObj1            (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif} {$endregion}
      {Calculation of all splines rectangles----------------------------------} {$region -fold}
        procedure RctSplineAll0            (const start_ind,
                                                  end_ind          :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure RctSplineAll1            (const start_ind,
                                                  end_ind          :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure RctSplineAll2            (const start_ind,
                                                  end_ind          :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure RctSplineAll3            (const start_ind,
                                                  end_ind          :TColor);                   {$ifdef Linux}[local];{$endif} {$endregion}
      {Misc. routines---------------------------------------------------------} {$region -fold}

        // Calculation of spline on addition:
        procedure AddSplineObj;                                                                {$ifdef Linux}[local];{$endif}
        // add spline bounding rectangle to spline edges buffer into clipped region:
        procedure AddSplineRctEds          (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        // add spline bounding rectangle to spline points buffer into clipped region:
        procedure AddSplineRctPts          (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        // Add point: drawing:
        procedure AddPoint                 (const x,y              :integer;
                                            const bmp_dst_ptr      :PInteger;
                                            const bmp_dst_width    :TColor;
                                            var   color_info       :TColorInfo;
                                            const rct_clp          :TPtRect;
                                            var   add_spline_calc_ :boolean;
                                                  sleep_           :boolean=False);            {$ifdef Linux}[local];{$endif}
        // Grid clipping: points:
        procedure GrdSplineCalc            (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        // ...:
        procedure SclMulDifCalc            (const scl_mul          :TPtPosF;
                                            const scl_dir          :TSclDir);                  {$ifdef Linux}[local];{$endif} {$endregion}
      {Add    spline edges  to spline edges  buffer into clipped region-------} {$region -fold}
        procedure ClippedLineW2            (      x0,y0,x1,y1      :double;
                                            const rct_clp          :TPtRect;
                                            const proc1            :TProc20;
                                            const proc2,
                                                  proc3,
                                                  proc4,
                                                  proc5            :TProc0);                   {$ifdef Linux}[local];{$endif}
        procedure ClippedLineW3            (      x0,y0,x1,y1      :double;
                                            const rct_clp          :TPtRect;
                                            const proc1            :TProc20;
                                            const proc2,
                                                  proc3,
                                                  proc4,
                                                  proc5            :TProc0);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds00           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds01           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds02           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds03           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds04           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds05           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds06           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds07           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds08           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds09           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds10           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds11           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds12           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds13           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds14           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds15           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds16           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds17           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds18           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds19           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds20           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineEds21           (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif} {$endregion}
      {Add    spline points to spline points buffer into clipped region-------} {$region -fold}
        procedure AddSplinePts0            (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplinePts1            (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplinePts2            (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplinePts3            (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplinePts4            (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplinePts5            (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplinePts6            (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplinePts7            (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif} {$endregion}
      {Add    spline duplicated points on specified buffer(dup_pts_arr)-------} {$region -fold}
        procedure AddSplineDupPts0         (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineDupPts1         (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineDupPts2         (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineDupPts3         (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure AddSplineDupPtsAll       (const start_ind,
                                                  end_ind          :TColor);                   {$ifdef Linux}[local];{$endif} {$endregion}
      {Clear  spline duplicated points on specified buffer(dup_pts_arr)-------} {$region -fold}
        procedure ClrSplineDupPts0         (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure ClrSplineDupPts1         (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure ClrSplineDupPts2         (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure ClrSplineDupPts3         (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif} {$endregion}
      {Сlear  sprite on canvas after points are selected----------------------} {$region -fold}
        // Clear all spline edges on spline edges  bounding rectangles buffer:
        procedure ClrSplineRctEds          (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        // Clear all spline edges on spline points bounding rectangles buffer:
        procedure ClrSplineRctPts          (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        // Clear all spline edges on spline edges buffers:
        procedure ClrSplineEds             (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        // Clear all spline points on spline points buffers:
        procedure ClrSplinePts             (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        // Clear all splines from start_ind to end_ind:
        procedure ClrSplineAll             (const start_ind,
                                                  end_ind          :TColor);                   {$ifdef Linux}[local];{$endif} {$endregion}
      {Create sprites for spline elements(edges, points, ...)-----------------} {$region -fold}
        // Create sprite of all spline edges and points bounding rectangles on spline edges  bounding rectangles buffer into clipped region:
        procedure CrtSplineRctEds          (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        // Create sprite of all spline edges and points bounding rectangles on spline points bounding rectangles buffer into clipped region:
        procedure CrtSplineRctPts          (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        // Create sprite of all spline edges on spline edges buffer into clipped region:
        procedure CrtSplineEds             (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        // Create sprite of all spline points on spline points buffer into clipped region:
        procedure CrtSplinePts             (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif} {$endregion}
      {Create sprites of all spline edges and points from start_ind to end_ind} {$region -fold}
        procedure CrtSplineAll0            (const start_ind,
                                                  end_ind          :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure CrtSplineAll1            (const start_ind,
                                                  end_ind          :TColor);                   {$ifdef Linux}[local];{$endif} {$endregion}
      {Draw   sprites for spline elements(edges, points, ...)-----------------} {$region -fold}
        // TODO:
        procedure FilSplineLazy            (const spline_ind       :TColor;
                                            const obj_arr_ptr      :PObjProp;
                                            const b2,b3            :boolean);                  {$ifdef Linux}[local];{$endif}
        // TODO:
        procedure HasSplineEds             (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        {Main drawing routines}
        procedure SplineRctEdsDraw         (const spline_ind       :TColor;
                                                  rct_clp_ptr_     :PPtRect);                  {$ifdef Linux}[local];{$endif}
        procedure SplineRctPtsDraw         (const spline_ind       :TColor;
                                                  rct_clp_ptr_     :PPtRect);                  {$ifdef Linux}[local];{$endif}
        procedure SplineEds0Draw           (const spline_ind       :TColor;
                                                  rct_clp_ptr_     :PPtRect);                  {$ifdef Linux}[local];{$endif}
        procedure SplineEds1Draw           (const spline_ind       :TColor;
                                                  rct_clp_ptr_     :PPtRect);                  {$ifdef Linux}[local];{$endif}
        procedure SplineEds2Draw           (const spline_ind       :TColor;
                                                  rct_clp_ptr_     :PPtRect);                  {$ifdef Linux}[local];{$endif}
        procedure SplinePts0Draw           (const spline_ind       :TColor;
                                                  rct_clp_ptr_     :PPtRect);                  {$ifdef Linux}[local];{$endif}
        procedure SplinePts1Draw           (const spline_ind       :TColor;
                                                  rct_clp_ptr_     :PPtRect);                  {$ifdef Linux}[local];{$endif}
        //Fill all spline edges and points bounding rectangles on spline edges  bounding rectangles buffer into clipped region:
        procedure FilSplineRctEds          (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        //Fill all spline edges and points bounding rectangles on spline points bounding rectangles buffer into clipped region:
        procedure FilSplineRctPts          (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        //Fill all spline edges on spline edges buffer into clipped region:
        procedure FilSplineEds             (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        //Fill all spline points on spline points buffer into clipped region:
        procedure FilSplinePts             (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        //Fill spline object:
        procedure FilSplineObj             (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        //Fill all spline objects:
        procedure FilSplineAll             (const start_ind,
                                                  end_ind          :TColor);                   {$ifdef Linux}[local];{$endif}
        {Move spline edges bounding rectangles}
        procedure MovSplineRctEds          (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        {Move spline points bounding rectangles}
        procedure MovSplineRctPts          (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        {Move spline edges}
        procedure MovSplineEds0            (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure MovSplineEds1            (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure MovSplineEds2            (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        {Move spline points}
        procedure MovSplinePts0            (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        procedure MovSplinePts1            (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        {Move spline object}
        procedure MovSplineObj             (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        {Move all spline objects}
        procedure MovSplineAll             (const start_ind,
                                                  end_ind          :TColor);                   {$ifdef Linux}[local];{$endif}
        {Repaint spline edges  bounding rectangles on spline edges and points bounding rectangles buffer into clipped region}
        procedure RepSplineRctEds          (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        {Repaint spline points bounding rectangles on spline edges and points bounding rectangles buffer into clipped region}
        procedure RepSplineRctPts          (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        {Repaint spline edges}
        procedure RepSplineEds             (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        {Repaint spline points}
        procedure RepSplinePts             (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif}
        {Set random color info.}
        procedure RndSplineCol             (var   local_prop       :TCurveProp;
                                            var   col,col_inv      :TColor;
                                            var   col_ptr          :PInteger;
                                            const btn              :TSpeedButton);             {$ifdef Linux}[local];{$endif}
        {Generate random spline into specified area}
        procedure RndSplineObj             (const pt               :TPtPos;
                                            const w,h              :TColor);                   {$ifdef Linux}[local];{$endif}
        {Drawing simplified spline points on spline points buffer into clipped region}
        procedure SmpSplinePts             (const spline_ind       :TColor);                   {$ifdef Linux}[local];{$endif} {$endregion}
      {Generate formula spline into specified area----------------------------} {$region -fold}
        // TODO:
        procedure FmlSplineInit;                                                               {$ifdef Linux}[local];{$endif}
        // TODO:
        procedure FmlSplinePrev            (const fml_pts_cnt      :TColor;
                                            const ln_arr2_clear    :boolean=False);            {$ifdef Linux}[local];{$endif}
        // TODO:
        procedure Cycloid                  (const x,y              :integer);                  {$ifdef Linux}[local];{$endif}
        // TODO:
        procedure Epicycloid               (const x,y              :integer);                  {$ifdef Linux}[local];{$endif}
        // TODO:
        procedure Rose                     (const x,y              :integer);                  {$ifdef Linux}[local];{$endif}
        // TODO:
        procedure Spiral                   (const x,y              :integer);                  {$ifdef Linux}[local];{$endif}
        // TODO:
        procedure Superellipse             (const x,y              :integer);                  {$ifdef Linux}[local];{$endif} {$endregion}
  end; {$endregion}
  PCurve         =^TCurve;

  {Text---------------}
  TFText         =class {$region -fold}
    public
      // Drawing surface pointer:
      srf_var_ptr: PSurface;
      // Array of text sprites:
      txt_img_arr: TFTxArr;
      // Spline global properties which will be shown on panel of spline properties in editor:
      global_prop: TFTextProp;
      // Create class instance:
      constructor Create(w,h:TColor);           {$ifdef Linux}[local];{$endif}
      // Destroy class instance:
      destructor  Destroy;            override; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PFText         =^TFText;

  {Select Items-------}
  TSelIts        =class {$region -fold}
    public
      // Drawing surface pointer:
      srf_var_ptr                : PSurface;
      // Outer subgraph edges:
      outer_subgraph_img         : TFastLine;
      // Inner subgraph edges:
      inner_subgraph_img         : TFastLine;
      // Selected points:
      sel_pts_img                : TFastLine;
      // Selection image:circle,rectangle etc.:
      selection_img              : TFastLine;
      // Selection properties:
      selection_prop             : TSelItProp;
      selection_bounds_prop      : TCurveProp;
      {Subgraph indices arrays} {$region -fold}
        // TODO:
        outer_subgraph1          : TEdgeArr;
        outer_subgraph1_eds_cnt  : TColor;
        // TODO:
        outer_subgraph2          : TEdgeArr;
        outer_subgraph2_eds_cnt  : TColor;
        // TODO:
        outer_subgraph3          : TEdgeArr;
        outer_subgraph3_eds_cnt  : TColor;
        // TODO:
        inner_subgraph_          : TEdgeArr;
        inner_subgraph__eds_cnt  : TColor;
        // TODO:
        sl_pt_subgraph_          : TSlPtArr;
        sl_pt_subgraph__eds_cnt  : TColor;
      {$endregion}
      {Is point of outer or inner subgraph:
      0 - point is not selected;
      1 - point is of outer subgraph;
      2 - point is of inner subgraph}
      out_or_inn_subgraph_pts    : T1Byte1Arr;
      // Selected points indices:
      sel_pts_inds               : TColorArr;
      // Is point selected:
      is_point_selected          : TBool1Arr;
      // Is point duplicated:
      is_point_duplicated        : TBool1Arr;
      // Is point in circle:
      is_point_in_circle         : TBool1Arr;
      // Is point position calculated:
      is_point_pos_calc          : TBool1Arr;
      // selected points bitmap:
      // TODO:
      // Selected points bitmap handle:
      // TODO:
      // Selected points bounding rectangle:
      sel_pts_rct                : TPtRectF;
      // TODO:
      sel_pts_rct_mrgn           : TColor;
      // TODO:
      not_sel_pts_rct            : TPtRect;
      // TODO:
      ncs_adv_clip_rect          : TPtRectF;
      // TODO:
      bucket_rct                 : TPtRect;
      // TODO:
      bucket_rct_color           : TColor;
      // Count of splines with selected points:
      sln_with_sel_pts_cnt       : TColor;
      // Count of selected points:
      sel_pts_cnt                : TColor;
      // Count of duplicated points:
      dup_pts_cnt                : TColor;
      // Minimal index of selected object(spline):
      sel_obj_min_ind            : TColor;
      // Is an abstract object kind after spline which has selected points and minimal index:
      is_not_abst_obj_kind_after : boolean;
      // Select points:expression:
      sel_pts                    : boolean;
      // Fill bmp only without full repaint:
      fill_bmp_only              : boolean;
      // Select only points of visible (in the scene tree) splines:
      sel_only_pts_vis_sln       : boolean;
      // Select only points of selected(in the scene tree) splines:
      sel_only_pts_sel_sln       : boolean;
      // TODO:
      OuterSubgraphProc          : array[0..2] of TProc10;
      // TODO:
      InnerSubgraphProc          : array[0..2] of TProc10;
      // TODO:
      WholeSubgraphProc          : array[0..2] of TProc11;
      // create class instance:
      constructor Create                     (const w,h                :TColor);                   {$ifdef Linux}[local];{$endif}
      // Destroy class instance:
      destructor  Destroy;                                                               override; {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure BucketSizeChange             (      chng_val           :integer);        inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure IsObjColorAMaskColor;                                                    inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure FillSelBmpAndSelPtsBRectDraw;                                            inline;   {$ifdef linux}[local];{$endif}
      // TODO:
      procedure ChangeSelectionMode          (      item_ind           :TColor);         inline;   {$ifdef Linux}[local];{$endif}
      // Add circle:
      procedure AddCircleSelection;                                                      inline;   {$ifdef Linux}[local];{$endif}
      // Compression of primitive's surface:
      procedure PrimitiveComp                (const pmt_img_ptr        :PFastLine;
                                                    pmt_bld_stl        :TDrawingStyle;
                                                    fast_image_ptr     :PFastImageItem); inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure CrtCircleSelection;                                                      inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure FilSelPtsObj                 (const x,y                :integer);        inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure MinimizeCircleSelection;                                                 inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SelectAllPts                 (const pts_cnt,
                                                    eds_cnt            :TColor);         inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SubgraphCalc                 (var   has_sel_pts        :T1Byte1Arr;
                                              const pts                :TPtPosFArr;
                                              const fst_lst_sln_obj_pts:TEnum0Arr;
                                              const obj_ind            :TWordArr;
                                              const sln_obj_cnt        :TColor;
                                              const sln_pts_cnt        :TColor);                   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure UnselectedPtsCalc0           (const fst_lst_sln_obj_pts:TEnum0Arr;
                                              var   pts                :TPtPosFArr;
                                              const pvt_pos_curr,
                                                    pvt_pos_prev       :TPtPosF);        inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure UnselectedPtsCalc1           (const fst_lst_sln_obj_pts:TEnum0Arr;
                                              var   pts                :TPtPosFArr;
                                              const pvt_pos_curr,
                                                    pvt_pos_prev       :TPtPosF);        inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SelPtsIndsToFalse1;                                                      inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SelPtsIndsToFalse2;                                                      inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure DuplicatedPtsCalc;                                                       inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure AdvancedClipCalc             (      pts                :TPtPosFArr;
                                                    pts_cnt            :TColor;
                                                    is_pt_marked       :TBool1Arr);      inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure DuplicatedPtsToBmp;                                                      inline;   {$ifdef Linux}[local];{$endif}
      {Outer subgraph----} {$region -fold}
        procedure OuterSubgraphCalc0         (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct_clp            :TPtRect);                  {$ifdef Linux}[local];{$endif}
        procedure OuterSubgraphCalc1         (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct_clp            :TPtRect);                  {$ifdef Linux}[local];{$endif}
        procedure OuterSubgraphCalc2         (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct_clp            :TPtRect);                  {$ifdef Linux}[local];{$endif}
        procedure OuterSubgraphDraw          (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct_clp            :TPtRect);                  {$ifdef Linux}[local];{$endif}
      {$endregion}
      {Inner subgraph----} {$region -fold}
        procedure InnerSubgraphCalc0         (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct_clp            :TPtRect);                  {$ifdef Linux}[local];{$endif}
        procedure InnerSubgraphCalc1         (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct_clp            :TPtRect);                  {$ifdef Linux}[local];{$endif}
        procedure InnerSubgraphCalc2         (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct_clp            :TPtRect);                  {$ifdef Linux}[local];{$endif}
        procedure InnerSubgraphDraw          (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct_clp            :TPtRect);                  {$ifdef Linux}[local];{$endif}
      {$endregion}
      {Single point graph} {$region -fold}
        procedure SinglePtGraphCalc0         (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct_clp            :TPtRect);                  {$ifdef Linux}[local];{$endif}
        procedure SinglePtGraphCalc1         (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct_clp            :TPtRect);                  {$ifdef Linux}[local];{$endif}
        procedure SinglePtGraphCalc2         (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct_clp            :TPtRect);                  {$ifdef Linux}[local];{$endif}
      {$endregion}
      // TODO:
      procedure SelPtsCalc                   (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct_clp            :TPtRect);                  {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SelPtsDraw                   (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct_clp            :TPtRect);                  {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SelPtsBnds                   (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct_clp            :TPtRect);                  {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure WholeSubgraphDraw0           (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct1,rct2          :TPtRect);        inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure WholeSubgraphDraw1           (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct1,rct2          :TPtRect);        inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure WholeSubgraphDraw2           (      x,y                :integer;
                                              const pvt                :TPtPosF;
                                              var   pts                :TPtPosFArr;
                                              const bmp_dst_ptr        :PInteger;
                                              const rct1,rct2          :TPtRect);        inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SelPvtAndSplineEdsToBmp;                                                 inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SelPtsIndsToBmp              (var   pts                :TPtPosFArr);     inline;   {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PSelIts        =^TSelIts;

  {Pivot--------------}
  TPivot         =class {$region -fold}
    public
      // Drawing surface pointer:
      srf_var_ptr          : PSurface;
      // Indices inside spritesheet array:
      local_axis_bmp_ind   : integer;
      sel_tls_mrk_ind      : integer;
      // Points transform:
      pos_dif              : TPtPosF;
      scl_dif              : TPtPosF;
      rot_dif              : TPtPosF;
      // TODO:
      pvt_pos              : TPtPosF;
      // TODO:
      pvt_scl              : TPtPosF;
      // TODO:
      pvt_origin           : TPtPosF;
      // Pivot position after finishing point selection:
      pvt_pos_first        : TPtPosF;
      // Pivot position before unselecting points:
      pvt_pos_last         : TPtPosF;
      // TODO:
      pvt_mode             : TPivotMode;
      // TODO:
      pvt_marker_arr       : array[0..3] of Graphics.TBitmap;
      // TODO:
      pvt_marker_bmp       : TPortableNetworkGraphic;
      // Scale direction:
      scl_dir              : TSclDir;
      prev_mouse_pos       : TPtPosF;
      curr_mouse_pos       : TPtPosF;
      // TODO:
      pvt_marker           : TPtPos;
      // Previous pivot:
      pvt_prev             : TPtPosF;
      // Mouse motion vector:
      mos_mot_vec          : TLnPos;
      // TODO:
      pvt_axis_rect        : TPtRect;
      // TODO:
      align_pivot          : TPtPos;
      // TODO:
      weighted_pvt_shift   : TPtPosF;
      // TODO:
      need_align_pivot_x   : boolean;
      // TODO:
      need_align_pivot_y   : boolean;
      // TODO:
      need_align_pivot_p   : boolean;
      // TODO:
      need_align_pivot_p2  : boolean;
      // TODO:
      pvt_marker_draw      : boolean;
      // TODO:
      pvt_marker_left      : boolean;
      // TODO:
      pvt_marker_top       : boolean;
      // TODO:
      pvt_marker_right     : boolean;
      // TODO:
      pvt_marker_bottom    : boolean;
      // TODO:
      pvt_to_pt            : boolean;
      // Event of snapping:
      snap_mode            : TSnapMode;
      snap_to_pt           : boolean;
      // TODO:
      pvt_to_pt_draw_pt    : boolean;
      // TODO:
      move_pvt             : boolean;
      // TODO:
      scale_pvt            : boolean;
      // TODO:
      move_pvt_to_pt_button: boolean;
      // TODO:
      pvt_exists           : byte;
      // TODO:
      SelPtsCalcProc       : array[0..2] of TProc13;
      // TODO:
      SelPtsRctCalcProc    : array[0..2] of TProc12;
      // Create class instance:
      constructor Create                  (      w,h         :TColor);                {$ifdef Linux}[local];{$endif}
      // Destroy class instance:
      destructor  Destroy;                                                  override; {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure LocalAxisCreate;                                            inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure LocalAxisDraw             (const x,y         :integer);     inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure LocalAxisHighlight        (const x,y         :integer);     inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SelectionToolsMarkerCreate;                                 inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SelectionToolsMarkerDraw  (const x,y         :integer);     inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SetPivotAxisRect          (const pt_rct      :TPtRect;
                                           const margin      :TColor=10);   inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure PivotCalc                 (const pts         :TPtPosFArr;
                                           const sel_pts_inds:TColorArr;
                                           const sel_pts_cnt :TColor);                {$ifdef Linux}[local];{$endif}
      // Align pivot on axis X:
      procedure AlignPivotOnX             (var   x,y         :integer;
                                                 shift       :TShiftState); inline;   {$ifdef Linux}[local];{$endif}
      // Align pivot on axis Y:
      procedure AlignPivotOnY             (var   x,y         :integer;
                                                 shift       :TShiftState); inline;   {$ifdef Linux}[local];{$endif}
      // Align pivot on points:
      procedure AlignPivotOnP             (var   x,y         :integer;
                                                 shift       :TShiftState); inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure PivotToPoint              (      x,y         :integer);               {$ifdef Linux}[local];{$endif}
      procedure PivotToPoint              (      x,y         :integer;
                                                 b           :boolean);               {$ifdef Linux}[local];{$endif}
      procedure PivotToPoint              (      x,y         :integer;
                                                 density     :TColor);                {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SclSettings               (      x,y         :integer);     inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SelPtsPosCalc             (      x,y         :integer);     inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SelPtsSclCalc             (      x,y         :integer);     inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SelPtsRotCalc             (      x,y         :integer);     inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SelPtsRctPosCalc          (      x,y         :integer;
                                           var   sel_pts_rect:TPtRectF);    inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SelPtsRctSclCalc          (      x,y         :integer;
                                           var   sel_pts_rect:TPtRectF);    inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure SelPtsRctRotCalc          (      x,y         :integer;
                                           var   sel_pts_rect:TPtRectF);    inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure IsPivotOutOfInnerWindow   (var   custom_rect :TPtRect;
                                           const pvt_        :TPtPosF);     inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure PivotToPointDraw          (      cnv_dst     :TCanvas);     inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure PivotAxisDraw0            (      cnv_dst     :TCanvas;
                                           const custom_rct  :TPtRect;
                                           const shift       :TPtPos);      inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure PivotAxisDraw1            (      cnv_dst     :TCanvas;
                                           const custom_rct  :TPtRect;
                                           const shift       :TPtPos;
                                                 x,y         :integer);     inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure PivotBoundsDraw;                                            inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure PivotAngleDraw;                                             inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure PivotModeDraw             (      cnv_dst     :TCanvas);     inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure PivotDraw                 (const shift       :TPtPos;
                                                 x,y         :integer);     inline;   {$ifdef Linux}[local];{$endif}
    end; {$endregion}
  PPivot         =^TPivot;

  {Circle Selection---}
  TCrcSel        =class {$region -fold}
    public
      // TODO:
      srf_var_ptr       : PSurface;
      // Index inside spritesheet array:
      crc_sel_ind       : integer;
      // TODO:
      crc_sel_col       : TColor;
      // TODO:
      crc_sel_rct       : TRect;
      // TODO:
      crc_rad_invalidate: integer;
      // TODO:
      crc_rad           : integer;
      // TODO:
      crc_rad_sqr       : integer;
      // TODO:
      draw_crc_sel      : boolean;
      // TODO:
      resize_crc_sel    : boolean;
      // TODO:
      minimize_crc_sel  : boolean;
      // TODO:
      only_fill         : boolean;
      // Create class instance:
      constructor Create;                                                       {$ifdef Linux}[local];{$endif}
      // Destroy class instance:
      destructor  Destroy;                                            override; {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure CircleSelection        (      x,y     :integer;
                                        const sel_draw:boolean=True);           {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure CircleSelectionModeDraw(      x,y     :integer);      inline;   {$ifdef Linux}[local];{$endif}
      // TODO:
      procedure ResizeCircleSelectionModeDraw;                        inline;   {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PCrcSel        =^TCrcSel;

  {Brush Selection----}
  TBrsSel        =class {$region -fold}
    public
      // Drawing surface pointer:
      srf_var_ptr : PSurface;
      // TODO:
      draw_brs_sel: boolean;
      // Create class instance:
      constructor Create;            {$ifdef Linux}[local];{$endif}
      // Destroy class instance:
      destructor  Destroy; override; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PBrsSel        =^TBrsSel;

  {Rectangle Selection}
  TRctSel        =class {$region -fold}
    public
      // Drawing surface pointer:
      srf_var_ptr: PSurface;
      // TODO:
      rct_sel    : TRect;
      // TODO:
      rct_width  : integer;
      // Create class instance:
      constructor Create;            {$ifdef Linux}[local];{$endif}
      // Destroy class instance:
      destructor  Destroy; override; {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PRctSel        =^TRctSel;

  {TileMap Editor-----}
  TTlMap         =class {$region -fold}
    public
      // Drawing surface pointer:
      srf_var_ptr: PSurface;
      {Indices inside spritesheet array} {$region -fold}
        tilemap_inds_arr       : TIntrArr;
        tilemap_sprite_inds_arr: TIntrArr;
      {$endregion}
      // Create class instance:
      constructor Create;                                                               {$ifdef Linux}[local];{$endif}
      // Destroy class instance:
      destructor  Destroy;                                                    override; {$ifdef Linux}[local];{$endif}
      // Create default icon for tile map sprite:
      procedure TileMapSpriteDefaultIconCreate;                               inline;   {$ifdef Linux}[local];{$endif}
      // Add tile map:
      procedure AddTileMapObj;                                                inline;   {$ifdef Linux}[local];{$endif}
      // Add tile map sprite:
      procedure AddTileMapSpriteObj;                                          inline;   {$ifdef Linux}[local];{$endif}
      // Add tile map preview:
      procedure AddTileMapPreview;                                            inline;   {$ifdef Linux}[local];{$endif}
      // Add tile map sprite preview:
      procedure AddTileMapSpritePreview;                                      inline;   {$ifdef Linux}[local];{$endif}
      //
      procedure TileMapDraw                     (const tlmap_ind   :TColor;
                                                       rct_clp_ptr_:PPtRect); inline;   {$ifdef Linux}[local];{$endif}
      //
      procedure FilTileMapObj                   (const tlmap_ind   :TColor);  inline;   {$ifdef Linux}[local];{$endif}
      //
      procedure MovTileMapObj                   (const tlmap_ind   :TColor);  inline;   {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PTlMap         =^TTlMap;

  {Post-Processing----}
  TPProc         =class {$region -fold}
    public
      // Drawing surface pointer:
      srf_var_ptr: PSurface;
      // Create class instance:
      constructor Create;                                            {$ifdef Linux}[local];{$endif}
      // Destroy class instance:
      destructor  Destroy;                                 override; {$ifdef Linux}[local];{$endif}
      //
      procedure AddPProcObj;                               inline;   {$ifdef Linux}[local];{$endif}
      //
      procedure PProcDraw    (const pproc_ind   :TColor;
                                    rct_clp_ptr_:PPtRect); inline;   {$ifdef Linux}[local];{$endif}
      //
      procedure FilPProcObj  (const pproc_ind   :TColor);  inline;   {$ifdef Linux}[local];{$endif}
      //
      procedure MovPProcObj  (const pproc_ind   :TColor);  inline;   {$ifdef Linux}[local];{$endif}
  end; {$endregion}
  PPProc         =^TPProc;



var

  {Type info}
  obj_prop_helper             : TRecInfo;
  curve_prop_helper           : TRecInfo;

  {General}
  F_MainForm                  : TF_MainForm;
  max_sprite_w_h_rct          : TPtRect;
  ini_var                     : TIniFile;
  move_with_child_form        : boolean;
  splitters_arr               : array[1..8] of PInteger;
  splitter_thickness          : integer=04{02}{01};

  {Select Tools(checking of speed buttons down)} {$region -fold}
  // down buttons array
  down_arr                       : array[0..14] of boolean;
  // down button "Text"
  down_text_ptr                  : PByteBool;
  // down button "Brush"
  down_brush_ptr                 : PByteBool;
  // down button "Spray"
  down_spray_ptr                 : PByteBool;
  // down button "Spline"
  down_spline_ptr                : PByteBool;
  // down button "Select Items"
  down_select_items_ptr          : PByteBool;
  // down button "Select Texture Region"
  down_select_texture_region_ptr : PByteBool;
  // down button "Snap Grid"
  down_bkgnd_ptr                 : PByteBool;
  // down button "Post-Processing"
  down_pproc_ptr                 : PByteBool;
  // down button "Add Tilemap"
  down_tlmap_ptr                 : PByteBool;
  // down button "Snap Grid"
  down_sgrid_ptr                 : PByteBool;
  // down button "Regular Grid"
  down_rgrid_ptr                 : PByteBool;
  // down button "Play"
  down_play_anim_ptr             : PByteBool;
  // down button "Game Settings"
  down_game_settings_ptr         : PByteBool;
  // down button "Add Actor"
  down_add_actor_ptr             : PByteBool;
  // down button "Sound Control"
  down_sound_control_ptr         : PByteBool; {$endregion}

  {Calculation Flags---------------------------} {$region -fold}
  // calculation flags array
  calc_arr                    : array[0..100] of boolean;
  // do all layers bounding rectangles need to be calculated:
  main_bmp_rect_calc          : boolean absolute calc_arr[00];
  // do all layers bitmaps sizes need to be calculated?:
  main_bmp_size_calc          : boolean absolute calc_arr[01];
  // do specified arrays sizes need to be calculated(probably with calculation of appropriate bitmaps sizes):
  main_bmp_arrs_calc          : boolean absolute calc_arr[02];
  // get handles of all main buffers:
  main_bmp_hndl_calc          : boolean absolute calc_arr[03];
  // resize form:
  form_resize_calc            : boolean absolute calc_arr[04];
  // resize scene:
  scene_resize_calc           : boolean absolute calc_arr[05];
  // background post-processing:
  bkg_pp_calc                 : boolean absolute calc_arr[06];
  // is cursor in inner window:
  drawing_area_enter_calc     : boolean absolute calc_arr[07];
  // does grid need to be calculated:
  grid_calc                   : boolean absolute calc_arr[08];
  // does snap grid need to be calculated:
  snap_grid_calc              : boolean absolute calc_arr[09];
  // reserved:
  repaint_spline_forced_calc  : boolean absolute calc_arr[10];
  // reserved:
  add_pproc_calc              : boolean absolute calc_arr[11];
  // add spline:
  add_spline_calc             : boolean absolute calc_arr[12];
  // reserved:
  reserved_3_calc             : boolean absolute calc_arr[13];
  // reserved:
  reserved_4_calc             : boolean absolute calc_arr[14];
  // reserved:
  reserved_5_calc             : boolean absolute calc_arr[15];
  // reserved:
  reserved_6_calc             : boolean absolute calc_arr[16];
  // reset background settings for actors:
  actor_set_bckgd             : boolean absolute calc_arr[17];
  // repaint all splines:
  repaint_spline_calc         : boolean absolute calc_arr[18];
  // scale all splines:
  spline_scale_calc           : boolean absolute calc_arr[19];
  // draw selected edges:
  sel_eds_draw_calc           : boolean absolute calc_arr[20];
  // reserved:
  lower_bmp_to_main_bmp_calc  : boolean absolute calc_arr[21];
  // reserved:
  reserved_8_calc             : boolean absolute calc_arr[22];
  // timeline drawing:
  timeline_draw               : boolean absolute calc_arr[23];
  // cursor drawing:
  cursor_draw                 : boolean absolute calc_arr[24];
  // does pivot need to be unselected:
  unselect_pivot_calc         : boolean absolute calc_arr[27];
  // is spliter position changed:
  splitter_pos_moved_calc     : boolean absolute calc_arr[28];
  // scale background:
  scale_scene_calc            : boolean absolute calc_arr[29];
  // scene drawing:
  fill_scene_calc             : boolean absolute calc_arr[30];
  // align points:
  align_pts_calc              : boolean absolute calc_arr[31];
  // calculate bounding rectangles:
  rectangles_calc             : boolean absolute calc_arr[32];
  // add spline               : hidden lines:
  add_hid_ln_calc             : boolean absolute calc_arr[33];
  // repaint all splines: hidden lines:
  repaint_spline_hid_ln_calc0 : boolean absolute calc_arr[34];
  repaint_spline_hid_ln_calc1 : boolean absolute calc_arr[35];
  repaint_spline_hid_ln_calc2 : boolean absolute calc_arr[36];
  // reset background settings for world axis:
  sprite_sheet_set_bckgd      : boolean absolute calc_arr[37];
  // lazy repaint:
  lazy_repaint_calc           : boolean absolute calc_arr[38];
  // add tile map:
  add_tlmap_calc              : boolean absolute calc_arr[39];
  // ...:
  has_edge_calc               : boolean absolute calc_arr[40];
  // ...:
  copy1_calc                  : boolean absolute calc_arr[41];
  // ...:
  copy2_calc                  : boolean absolute calc_arr[42];
  // ...:
  copy3_calc                  : boolean absolute calc_arr[43];
  // ...:
  copy4_calc                  : boolean absolute calc_arr[44];
  // ...:
  copy5_calc                  : boolean absolute calc_arr[45];
  // ...:
  copy6_calc                  : boolean absolute calc_arr[46];
  // ...:
  copy7_calc                  : boolean absolute calc_arr[47];
  // ...:
  copy8_calc                  : boolean absolute calc_arr[48];
  // points has been modified:
  pts_mod_calc                : boolean absolute calc_arr[49];
  // points grid calculate:
  pts_grd_calc                : boolean absolute calc_arr[50];
  // ...:
  set_surf_param00            : boolean absolute calc_arr[51];
  // ...:
  set_surf_param01            : boolean absolute calc_arr[52];
  // ...:
  set_surf_param02            : boolean absolute calc_arr[53];
  // ...:
  set_surf_param03            : boolean absolute calc_arr[54];
  // ...:
  set_surf_param10            : boolean absolute calc_arr[55];
  // ...:
  set_surf_param11            : boolean absolute calc_arr[56];
  // ...:
  set_surf_param12            : boolean absolute calc_arr[57];
  // ...:
  set_surf_param13            : boolean absolute calc_arr[58];
  {$endregion}

  {Miscellaneous Expressions-------------------} {$region -fold}
  // expressions array
  exp_arr                     : array[0..1] of boolean;
  // selected_pts_count>0
  exp0                        : boolean absolute exp_arr[0];
  //
  exp1                        : boolean absolute exp_arr[1];
  {$endregion}

  {Visibility Panel----------------------------} {$region -fold}
  // show objects array
  show_obj_arr                : array[0..9] of boolean;
  // show all objects
  show_all                    : boolean absolute show_obj_arr[00];
  // show background texture
  show_tex                    : boolean absolute show_obj_arr[01];
  // show snap    grid
  show_sgrid                  : boolean absolute show_obj_arr[02];
  // show regular grid
  show_rgrid                  : boolean absolute show_obj_arr[03];
  // show splines
  show_spline                 : boolean absolute show_obj_arr[04];
  // show tile maps
  show_tile_map               : boolean absolute show_obj_arr[05];
  // show actors
  show_actor                  : boolean absolute show_obj_arr[06];
  // show textures on splines
  show_tex_on_spline          : boolean absolute show_obj_arr[07];
  // show colliders
  show_collider               : boolean absolute show_obj_arr[08];
  // show world axis
  show_world_axis             : boolean absolute show_obj_arr[09];

  visibility_panel_picture    : Graphics.TBitmap;
  show_visibility_panel       : boolean=True;
  show_obj_info               : boolean=True;
  {$endregion}

  {Buttons:Draw--------------------------------} {$region -fold}
  P_Draw_Buttons_ClickArr     : array of TNotifyEvent;
  prev_panel_draw             : TScrollBox;
  curr_panel_draw             : TScrollBox;
  {$endregion}

  {Buttons:Anim--------------------------------} {$region -fold}
  P_Anim_Buttons_ClickArr     : array of TNotifyEvent;
  prev_panel_animk            : TScrollBox;
  curr_panel_animk            : TScrollBox;
  {$endregion}

  {Camera}
  cmr_var                     : TCamera;

  {Sprite Sheet}
  sprite_sheet_arr            : TFastImageItemArr;

  {Content Library - Images}
  library_images_bmp          : Graphics.TBitmap;
  library_images_bmp_ptr      : PInteger;
  library_images_inds_arr     : TWordArr;

  {Content Library - Sounds}
  library_sounds_bmp          : Graphics.TBitmap;
  library_sounds_bmp_ptr      : PInteger;
  library_sounds_inds_arr     : TWordArr;

  {Main Layer}
  srf_var                     : TSurface;
  k_blur_shift                : integer;

  {Regular Grid}
  rgr_var                     : TRGrid;

  {Snap Grid}
  sgr_var                     : TSGrid;

  {Spline}
  sln_var                     : TCurve;
  sln_eds_fx_pnls_cnt         : TColor =1;
  sln_pts_fx_pnls_cnt         : TColor =1;
  sln_eds_fx_arr              : TFX2Arr;
  sln_pts_fx_arr              : TFX2Arr;
  sln_eds_fx_pnls             : PPanelArr;
  sln_pts_fx_pnls             : PPanelArr;

  {Text}
  txt_var                     : TFText;

  {Selected Points}
  sel_var                     : TSelIts;

  {Pivot}
  pvt_var                     : TPivot;

  {Circle Selection}
  crc_sel_var                 : TCrcSel;

  {Brush Selection}
  brs_sel_var                 : TBrsSel;

  {Rectangle Selection}
  rct_sel_var                 : TRctSel;

  {Tile Map}
  tlm_var                     : TTlMap;

  {Screen Space Post-processing}
  ppr_var                     : TPProc;

  {Game Settings}
  fix_resolution              : boolean=True;
  refresh_lower_layer         : boolean=True;
  refresh_skip                : integer;
  refresh_step                : integer=256;
  exec_time_sup               : integer=8;
  exec_time0                  : integer=0;
  exec_time1                  : integer=0;

  {Actors}
  fast_actor_set_var          : TFastActorSet;
  img_lst_bmp                 : Graphics.TBitmap;
  img_lst_bmp_ptr             : PInteger;

  {Physics}
  fast_physics_var            : TCollider;

  {Fluid}
  fast_fluid_var              : TFluid;

  {Sound}
  play_bkgnd_sound            : boolean;

  {Background Movie}
  play_bkgnd_movie            : boolean=True;

  {Scene Tree}
  obj_var                     : TSceneTree;
  P_TreeView_Attributes_Cells : TPanel;
  scene_tree_font_size_counter: double;
  single_selected_node_ind    : integer;
  source_node_x,source_node_y : integer;
  obj_tags_repaint_counter    : integer;
  tree_inactive               : TColor =$008D8B8B;
  tree___active               : TColor;
  is_mouse_in_scene_tree      : boolean;
  is_scene_tree_editing       : boolean;
  node_text_field_not_changed : boolean;
  prev_key                    : char   ='_';
  current_node_text_field     : string ='';


  {Object Tags}
  object_tags_bmp             : Graphics.TBitmap;
  object_tags_bmp_ptr         : PInteger;

  {Brush}
  draw_brush                  : boolean;

  {Spray}
  draw_spray                  : boolean;

  mouse_pos_x,mouse_pos_y     : integer;
  treeview_splitter_shift     : integer;

  {Execution Time}
  exec_timer                  : TPerformanceTime;

  vec_x,vec_y                 : integer;

  sln_sprite_counter_pos_arr  : TColorArr;
  sln_sprite_counter_rad_arr  : TColorArr;
  sln_sprite_counter_pow_arr  : TColorArr;

  sprite_rect_arr             : TPtPosArr;
  useless_arr_                : T1Byte1Arr;
  useless_fld_arr_            : TColorArr;

  is_active                   : boolean=True;

  downtime_counter            : integer;
  downtime                    : integer=320;

  {TimeLine}
  // cursors:
  cursors_inds_arr            : TIntrArr;
  // buttons_background:
  bckgd_btn_inds_arr          : TIntrArr;
  // buttons icons:
  tmln_btn_inds_arr           : TIntrArr;
  // buttons positions:
  btn_pos_arr                 : TPtPosArr;

  {Cursors}
  cur_pos                     : TPoint;
  cur_pos_                    : TPoint;
  cur_pos_prev                : TPoint;
  cur_pos_speed               : double;

  {OpenGL Context}
  texture_id                  : TColor;
  buffer                      : Windows.BITMAP;

  {Physics Test}
  coll_arr                    : TColorArr;
  projectile_var              : TProjectile;
  projectile_arr              : array of TProjectile;

  {Test}
  arr_test_byte               : T1Byte1Arr;
  angle                       : double=0;
  flood_fill_inc              : boolean;
  loop_cnt,angle_cnt          : TColor;
  rot_img_arr                 : TFastImageItemArr;
  bounding_rct                : TPtRect;
  arr_test                    : TColorArr;
  fx                          : double;
  fx_inc_check                : boolean;
  tf1                         : TColor=1;
  c1_                         : TColor=clRed;
  c2_                         : TColor=clBlue;
  test_pos_arr                : TPtPosArr;
  rct_src_mrg_inc_            : double;
  rct_src_mrg_inc             : integer;
  anim_inc                    : integer;

  frame_counter               : integer=01;
  dy0                         : double =05;
  dir_                        : TMovingDirection=mdDown;

  frame_skip_counter          : integer=0;
  frame_skip_val              : integer=2;

  br_vec_projectile_arr       : array of TBrVec;
  projectile_curr_pos         : TPtPosF=(x :200; y :200);
  projectile_mov_vec          : TLnPosF=(x0:200; y0:200; x1:400; y1:400);
  projectile_mov_vec2         : TLnPosF=(x0:200; y0:200; x1:400; y1:400);
  projectile_rnd0             : integer;
  projectile_rnd1             : integer;
  projectile_speed            : integer=010;
  projectile_dir              : shortint;
  projectile_dir_switch       : boolean=False;
  projectile_dir_tick_c_lim   : double =128.0{255.0};
  projectile_dir_tick_counter0: double =000.0;
  projectile_dir_tick_counter1: double =000.0;
  projectile_dir_tick_inc0    : double =004.0{002.0};
  projectile_dir_tick_inc1    : double =004.0{002.0};
  collision_detect            : TProjectile;

  collision_grid_density      : TPtPos =(x:064; y:032);
  grid_ln_arr                 : TColorArr;
  grid_pt_arr                 : TColorArr;
  grid_ln_prop                : TGrid;
  grid_pt_prop                : TGrid;
  pt_ind_arr                  : TColorArr;
  d0__,d1__                   : double;
  target_node_selected_ctrl   : boolean=False;
  target_node_selected        : boolean=False;
  session_time                : TColor;

  vec0                        : TLnPosF=(x0:100; y0:100; x1:500; y1:420);
  vec1                        : TLnPosF=(x0:500; y0:150; x1:200; y1:450);
  vec2                        : TLnPosF;
  crc_crc_int                 : byte=0;

  tstposx,tstposy             : double;

  rct_clp_test                : TPtRect;
  rct_src_test0               : TPtRect;
  rct_dst_test1               : TPtRect;
  rct_dst_test2               : TPtRect;
  rct_dst_test3               : TPtRect;

  rrrrrrr                     : boolean;

  sln_pt_ind                  : integer=0;

  test_nt_fx_prop_cfx_pow0    : byte=0;
  test_pt_fx_prop_cfx_pow0    : byte=0;

  vat_test_f0                 : double=0.0;
  vat_test_g0                 : int64 absolute vat_test_f0;
  vat_test_f1                 : double=0.1;
  vat_test_g1                 : int64 absolute vat_test_f1;
  vat_test_f2                 : double=0.2;
  vat_test_g2                 : int64 absolute vat_test_f2;
  vat_test_f3                 : double=0.3;
  vat_test_g3                 : int64 absolute vat_test_f3;
  vat_test_f4                 : double=0.4;
  vat_test_g4                 : int64 absolute vat_test_f4;
  vat_test_f5                 : double=0.5;
  vat_test_g5                 : int64 absolute vat_test_f5;
  vat_test_f6                 : double=0.6;
  vat_test_g6                 : int64 absolute vat_test_f6;
  vat_test_f7                 : double=0.6;
  vat_test_g7                 : int64 absolute vat_test_f7;

  {
  //threadvar
  test_arr       : TColorArr;
  test_arr_ptr   : PInteger;
  test_arr_width : integer=4000{1560};
  test_arr_height: integer=4000{865};
  }

{Forward Declarations}(********************************************************)

{Misc. Routines--} {$region -fold}
procedure SpeedButtonRepaint; inline; {$ifdef Linux}[local];{$endif}
procedure FormChangeSize;     inline; {$ifdef Linux}[local];{$endif}
procedure ButtonKeyPress(sp_btn,bkgnd_btn:TSpeedButton; btn_pnl1,btn_pnl2:TScrollBox; btn_pnl3:TPanel; down_btn_ptr:PByteBool; b:byte; cur1:integer; cur2:integer=crDefault); inline; {$ifdef Linux}[local];{$endif}
procedure BtnColAndDown(const spd_btn:TSpeedButton; var down_flag:boolean; color_down:TColor=NAV_SEL_COL_0; color_up:TColor=BTN_CHECKED); inline; {$ifdef Linux}[local];{$endif}
procedure SelectionBounds(custom_bitmap:Graphics.TBitmap; custom_rect:TPtRect; custom_color:TColor; custom_width:integer);
procedure SelectionBoundsRepaint; inline; {$ifdef Linux}[local];{$endif}
procedure PanelDropDownSettings(panel:TPanel; shape:TShape); inline; {$ifdef Linux}[local];{$endif}
function  DwmIsCompositionEnabled(out pfEnabled:longbool): HRESULT; external 'Dwmapi.dll';
function  EnumDisplaySettingsA(lpszDeviceName:LPCSTR; iModeNum:DWORD; var lpDevMode:TDeviceModeA): BOOL; external 'user32';
procedure InvalidateInnerWindow; inline; {$ifdef Linux}[local];{$endif}
procedure InvalidateRegion(rct_dst:TRect); inline; {$ifdef Linux}[local];{$endif}
procedure MoveBorders; inline; {$ifdef Linux}[local];{$endif}
procedure SplittersPosCalc; inline; {$ifdef Linux}[local]{$endif}
function  ObjectInfo0: string; inline; {$ifdef Linux}[local];{$endif}
procedure CheckDIB; inline; {$ifdef Linux}[local];{$endif}
{$endregion}

{ContentLibrary--} {$region -fold}
procedure ContentLibraryImagesListRepaint; inline; {$ifdef Linux}[local];{$endif}
procedure AddLibrarySpriteObj;             inline; {$ifdef Linux}[local];{$endif}
{$endregion}

{Scene Tree------} {$region -fold}
// calculate objects indices in object array:
procedure ObjIndsCalc;                                                   inline; {$ifdef Linux}[local];{$endif}
// calculate objects indices in scene tree:
procedure ScTIndsCalc;                                                   inline; {$ifdef Linux}[local];{$endif}
// change panels visibility after folding/unfolding or draging items in scene tree :
procedure CngPnVsCalc;                                                   inline; {$ifdef Linux}[local];{$endif}
// select panels after selection in scene tree :
procedure SelPnlsCalc;                                                   inline; {$ifdef Linux}[local];{$endif}
// unselect panels after clearing selection in scene tree :
procedure UnsPnlsCalc;                                                   inline; {$ifdef Linux}[local];{$endif}
// calculate selected objects indices in scene tree:
procedure SelIndsCalc;                                                   inline; {$ifdef Linux}[local];{$endif}
//
procedure ChsDataCalc;                                                   inline; {$ifdef Linux}[local];{$endif}
// recalculate positions of selected objects:
procedure SelObjsPosRecalc0;                                             inline; {$ifdef Linux}[local];{$endif}
procedure SelObjsPosRecalc1;                                             inline; {$ifdef Linux}[local];{$endif}
// (Check Equality Of All Objects By Properties          ) Проверка на равенство всех обьектов по свойствам:
procedure AreAllObjPropEqual;                                            inline; {$ifdef Linux}[local];{$endif}
//
procedure ParallaxShiftChange;                                           inline; {$ifdef Linux}[local];{$endif}
//
procedure RecalcPosChange;                                               inline; {$ifdef Linux}[local];{$endif}
//
procedure ObjectShowChange;                                              inline; {$ifdef Linux}[local];{$endif}
//
procedure SpatialStateChange;                                            inline; {$ifdef Linux}[local];{$endif}
//
procedure DeleteSelectedNodes   (         TV            :TTreeView);     inline; {$ifdef Linux}[local];{$endif}
//
procedure CreateNode            (         item_text1,
                                          item_text2    :ansistring;
                                          is_first_node :boolean=False); inline; {$ifdef Linux}[local];{$endif}
{Object Tags}
//
procedure AddTagPanel           (constref ind           :integer);       inline; {$ifdef Linux}[local];{$endif}
procedure ObjectTagsListRepaint;                                         inline; {$ifdef Linux}[local];{$endif}
{$endregion}

{Brush-----------} {$region -fold}
procedure BrushDraw(X,Y:integer); inline; {$ifdef Linux}[local];{$endif}
{$endregion}

{Spray-----------} {$region -fold}
procedure SprayDraw(X,Y,r:integer; custom_color:TColor); inline; {$ifdef Linux}[local];{$endif}
{$endregion}

{TimeLine--------} {$region -fold}
procedure TimeLineButtonsCreate;                  inline; {$ifdef Linux}[local];{$endif}
procedure TimeLineButtonsDraw(const x,y:integer); inline; {$ifdef Linux}[local];{$endif}
{$endregion}

{Cursors---------} {$region -fold}
procedure CursorsCreate;                                          inline; {$ifdef Linux}[local];{$endif}
procedure CursorDraw(const x,y:integer; const cur_ind:integer=0); inline; {$ifdef Linux}[local];{$endif}
procedure CursorDraw;                                             inline; {$ifdef Linux}[local];{$endif}
{$endregion}

{Camera----------} {$region -fold}
procedure SnapGLCanvas;                                           inline; {$ifdef Linux}[local];{$endif}
{$endregion}

{Collision System} {$region -fold}
function  CollisionTest0(const x,y        :integer): boolean;     inline; {$ifdef Linux}[local];{$endif}
function  CollisionTest1(const x0,y0,x1,y1:integer): TProjectile; inline; {$ifdef Linux}[local];{$endif}
function  CollisionTest2(const x0,y0,x1,y1:double ): TProjectile; inline; {$ifdef Linux}[local];{$endif}
function  CollisionTest3(const x0,y0,x1,y1:double ): TProjectile; inline; {$ifdef Linux}[local];{$endif}
{$endregion}

(******************************************************************************)



implementation

uses
  Hot_Keys, Image_Editor;

{$R *.lfm}

{LI = Logic Interface;
 UI = User  Interface.}

// (Miscellaneous Routines) Разные процедуры:
{LI} {$region -fold}
{$endregion}

// (Object Info) Информация об обьекте:
{LI} {$region -fold}
function  ObjectInfo0: string;                                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  info_arr  : array[0..20] of string;
  i         : integer;
  hid_ln_cnt: integer;
begin

  Result    :='';
  hid_ln_cnt:=0;
  if (sln_var<>Nil) then
    for i:=0 to sln_var.sln_obj_cnt-1 do
      Inc(hid_ln_cnt,sln_var.eds_img_arr[i].hid_ln_cnt);

  if (obj_var<>Nil) then
    info_arr[00]:='Objects: '                                                               +IntToStr(obj_var.obj_cnt               )+';';
  info_arr[01]:=#13+'  • Lower layer: '                                                     +IntToStr(obj_var.low_lr_obj_cnt        )+';';
  info_arr[02]:=#13+'  • Upper layer: '                                                     +IntToStr(obj_var.upp_lr_obj_cnt        )+';';
  info_arr[03]:=#13+'  • Splines: '                                                         +IntToStr(obj_var.curve_cnt             )+';';
  if (sln_var<>Nil) then
    info_arr[04]:=#13+'    • Points: '                                                      +IntToStr(sln_var.sln_pts_cnt           )+';';
  if (sel_var<>Nil) then
    begin
      info_arr[05]:=#13+'      • Count of splines'       +#13+'      with selected points: '+IntToStr(sel_var.sln_with_sel_pts_cnt  )+';';
    //info_arr[06]:=#13+'      • Minimal index of spline'+#13+'      with selected points: '+IntToStr(sel_var.sel_obj_min_ind       )+';';
      info_arr[07]:=#13+'      • Selected: '                                                +IntToStr(sel_var.sel_pts_cnt           )+';';
    //if (sel_var.sel_pts_cnt=0) then
    //  info_arr[08]:=#13+'        • Is not abstract object'+#13+'        kind after: No;'
    //else
    //  begin
    //    if sel_var.is_not_abst_obj_kind_after then
    //      info_arr[08]:=#13+'        • Is not abstract object'+#13+'        kind after: ' +'Yes;'
    //    else
    //      info_arr[08]:=#13+'        • Is not abstract object'+#13+'        kind after: ' +'No;'
    //  end;
    //info_arr[09]:=#13+'      • Duplicated: '                                              +IntToStr(sel_var.dup_pts_cnt           )+';';
    end;
  if (sln_var<>Nil) then
    begin
      info_arr[10]:=#13+'    • Lines: '                                                     +IntToStr(sln_var.sln_eds_cnt           )+';';
      info_arr[11]:=#13+'      • Visible: '                                                 +IntToStr(sln_var.sln_eds_cnt-hid_ln_cnt)+';';
      info_arr[12]:=#13+'      • Hidden: '                                                  +IntToStr(hid_ln_cnt                    )+';';
    end;
  info_arr[13]:=#13+'  • Actors: '                                                          +IntToStr(obj_var.actor_cnt             )+';';
  info_arr[14]:=#13+'    • Static: 0'                                                                                                +';';
  info_arr[15]:=#13+'    • Dynamic: 0'                                                                                               +';';
  info_arr[16]:=#13+'    • Physical: 0'                                                                                              +';';
  info_arr[17]:=#13+'  • Post-process: '                                                    +IntToStr(obj_var.pproc_cnt             )+';';
  info_arr[18]:=#13+'  • Tile maps: '                                                       +IntToStr(obj_var.tlmap_cnt             )+';';
  info_arr[19]:=#13+'  • Groups: '                                                          +IntToStr(obj_var.group_cnt             )+';';
  info_arr[20]:=#13+'  • Text fields: '                                                     +IntToStr(obj_var.ftext_cnt             )+' ';

  for i:=0 to Length(info_arr)-1 do
    Result+=info_arr[i];

end; {$endregion}
procedure DrawObjectInfo0;                                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  F_MainForm.L_Object_Info.Caption:=ObjectInfo0;
end; {$endregion}
procedure DrawObjectInfo1(constref x,y:integer; bmp_dst:Graphics.TBitmap; constref text_:string); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  F_MainForm.L_Exec_Time_Info.Caption:=text_;
end; {$endregion}
procedure CheckDIB;                                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  h_d_c: HDC;}
begin
  {h_d_c:=F_MainForm.Canvas.Handle;}
  {F_MainForm.L_Log.Caption:=IntToStr(GetDeviceCaps(h_d_c,RC_STRETCHBLT));}
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.L_Object_InfoMouseEnter(sender:TObject); {$region -fold}
begin
  L_Object_Info.Font.Color:=Integer(Abs($FFFFFFFF-srf_var.bg_col)>>1);
end; {$endregion}
procedure TF_MainForm.L_Object_InfoMouseLeave(sender:TObject); {$region -fold}
begin
  L_Object_Info.Font.Color:=Integer(Abs($FFFFFFFF-srf_var.bg_col)>>1);
end; {$endregion}
{$endregion}

// (Documentation) Документация:
{LI} {$region -fold}
procedure AddDocContent(var rich_memo:TRichMemo; str_arr:TStringArr; font_arr:TFontArr; char_pos_start:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i  : integer;
  str: string;
begin
  with rich_memo do
    begin
      if (Length(str_arr)=1) then
        begin
          Lines.Add(str_arr[0]);
          SetTextAttributes(char_pos_start,Length(str_arr[0])+char_pos_start,font_arr[0]);
        end
      else
        begin
          str:='';
          for i:=0 to Length(str_arr)-1 do
            str+=str_arr[i];
          Lines.Add(str);
          SetTextAttributes(char_pos_start,Length(str_arr[0])+char_pos_start,font_arr[0]);
          for i:=1 to Length(str_arr)-1 do
            SetTextAttributes(Length(str_arr[i-1]){+1}+char_pos_start,Length(str_arr[i])+char_pos_start,font_arr[i]);
        end;
    end;
end; {$endregion}
{$endregion}

// (Tray Icon) Системный трей:
{UI} {$region -fold}
procedure TF_MainForm.TrayIcon1Click(sender:TObject); {$region -fold}
begin
  ShowOnTop;
end; {$endregion}
{$endregion}

// (Open) Импорт файла:
{UI} {$region -fold}
{procedure TF_MainForm.MI_OpenClick(sender:TObject);} {$region -fold}
{var
  node_first: TTreeNode;
  exec_time : double;
  fcs_cnt,    {количество UV-островов, символов 'f' в импортируемом файле}
  eds_cnt,    {количество ребер, символов '/' в импортируемом файле}
  vts_cnt,    {количество вершин, символов 'v' в импортируемом файле}
  tex_vts_cnt,{количество текстурных вершин, строк 'vt' в импортируемом файле}
  i,j,k,m1,m2,m3,m4: integer;
  file_import: text;
  file_path,file_line,s: string;}
//begin
  {begin
    k                       :=-1;
    fcs_cnt                 :=0;
    vts_cnt                 :=0;
    tex_vts_cnt             :=0;
    PB_ProgressBar1.Position:=0;
    SetLength(uv_var.uv_pts,1000000);
  end;
  OpenDialog1.Options:=OpenDialog1.Options+[ofFileMustExist];
  if (not OpenDialog1.Execute) then
    Exit;
  file_path:=OpenDialog1.Filename;
  Text:='MorphoEngine'+'('+file_path+')';
  exec_timer:=TPerformanceTime.Create;
  exec_timer.Start;
  AssignFile(file_import,file_path);
  Reset(file_import);

  while (not EOF(file_import)) do
    begin
      readln(file_import,file_line);
      for i:=0 to length(file_line)-1 do
        case file_line[i+1] of
          #32:
            case file_line[i] of
              'v': Inc(vts_cnt);
              'f': Inc(fcs_cnt);
            end;
          't':
            begin
              Inc(k);
              Inc(tex_vts_cnt);
              if file_line[i]='v' then
                begin
                  j:=i+2;
                  s:='';
                  while (not (file_line[j+1]=#32)) do
                    begin
                      Inc(j);
                      if file_line[j]='-' then
                        file_line[j]:='0';
                      if file_line[j]='.' then
                        file_line[j]:=',';
                      s:=s+file_line[j];
                      uv_var.uv_pts[k].x:=StrToFloat(s);
                    end;
                  Inc(j);
                  s:='';
                  while (not (file_line[j+1]=#32)) do
                    begin
                      Inc(j);
                      if file_line[j]='-' then
                        file_line[j]:='0';
                      if file_line[j]='.' then
                        file_line[j]:=',';
                      s:=s+file_line[j];
                      uv_var.uv_pts[k].y:=StrToFloat(s);
                    end;
                end;
            end;
        end;
    end;

  Repaint;
  with srf_var.srf_bmp.Canvas,srf_var,tex_var,uv_var do
    begin
      m1:=Trunc(tex_bmp_rct_pts[0].x)-2;
      m2:=Trunc(tex_bmp_rct_pts[0].y)-2;
      m3:=Trunc(tex_bmp_rct_pts[0].x)+3;
      m4:=Trunc(tex_bmp_rct_pts[0].y)+3;
      Pen.Color:=clBlack;
      Brush.Style:=bsClear;
      for i:=2 to tex_vts_cnt-1 do
        Rectangle(Trunc((tex_bmp_rct_pts[1].x-tex_bmp_rct_pts[0].x)*   uv_pts[i].x) +m1,
                  Trunc((tex_bmp_rct_pts[1].y-tex_bmp_rct_pts[0].y)*(1-uv_pts[i].y))+m2,
                  Trunc((tex_bmp_rct_pts[1].x-tex_bmp_rct_pts[0].x)*   uv_pts[i].x) +m3,
                  Trunc((tex_bmp_rct_pts[1].y-tex_bmp_rct_pts[0].y)*(1-uv_pts[i].y))+m4);
      Brush.Style:=bsSolid;
    end;
  InvalidateInnerWindow;

  eds_cnt:=vts_cnt; // TODO
  exec_timer.Stop;
  execution_time:=Trunc(exec_timer.Delay*1000)/1000;
  PB_ProgressBar1.Position:=100;
  L_Object_Info.Caption:=ObjectInfo0;
  node_first:=TV_Scene_Tree.Items.GetFirstVisibleNode;
  TV_Scene_Tree.Items.AddChild(node_first,ExtractFileName(OpenDialog1.Filename));
  node_first.Expanded:=true;
  {M_Loaded_File.Lines.LoadfromFile(OpenDialog1.Filename);}
  CloseFile(file_import);}
{end;} {$endregion}
{$endregion}

// (Save as) Сохранение файла:
{UI} {$region -fold}
{procedure TF_MainForm.MI_Save_AsClick(sender:TObject);} {$region -fold}
{begin}
  {TODO}
  {SaveDialog1.Filter:='Wavefront Obj|*.obj|Text|*.txt|All files|*.*';
  if (not SaveDialog1.Execute) then
    Exit;}
{end;} {$endregion}
{$endregion}

// (SystemInfo) Системная информация:
{LI} {$region -fold}
procedure ShowSystemInfo; {$region -fold}
var
  info                   : string;
  {$ifdef Windows}
  user_name,computer_name: string;
  buffer                 : array[byte] of char='';
  size                   : longword           =256;
  flags                  : longword           =000;
  {$endif}
begin
  {$ifdef Windows}
  GetUserName    (buffer,size);
  user_name    := buffer;
  size         := MAX_COMPUTERNAME_LENGTH+1;
  GetComputerName(buffer,size);
  computer_name:= buffer;
  {$endif}
  info:='Date..................................' +{$i %DATE%}
   +#13+'System Bit........................'     +{$i %FPCTARGET%}
   +#13+'CPU...................................' +{$i %FPCTARGETCPU%}
   +#13+'CPU Count.......................'       +IntToStr(CPUCount)
   +#13+'OS.....................................'+{$i %FPCTARGETOS%}
   +#13+'FPC Version.....................'       +{$i %FPCVERSION%}
   {$ifdef Windows}
   +#13+'User Name......................'        +user_name
   +#13+'Computer Name............'              +computer_name
   {$endif}
   +#13+'Internet............................';
  {$ifdef Windows}
  if (WinInet.InternetGetConnectedState(@flags,0)) then
  {$else}
  if GetSystemMetrics(SM_NETWORK) and ($01=$01) then
  {$endif}
    info:=info+'Available'
  else
    info:=info+'Unavailable';
  MessageDlg(info,mtInformation,[mbOK],0);
end; {$endregion}
{$endregion}

// (Resizing Viewport) Изменение окна просмотра:
{LI} {$region -fold}
procedure SplittersPosCalc; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with F_MainForm do
    begin
      if (S_Splitter1       .left   < 32) then
          S_Splitter1       .left   :=00;
      if (S_Splitter2       .top    > height-splitter_thickness-39) then
          S_Splitter2       .top    :=height-splitter_thickness;
      if (S_Splitter3       .left   > width -splitter_thickness-39) then
        begin
          S_Splitter3       .left   :=width -splitter_thickness;
          S_Splitter5       .left   :=width;
        end;
      if (S_Splitter8       .left   <  S_Splitter1.left+splitter_thickness) then
          S_Splitter8       .left   := S_Splitter1.left+splitter_thickness;
      Shape18               .visible:=(S_Splitter1.left>76);
      Shape19               .visible:=(S_Splitter1.left>76);
      P_Inner_Window_Buttons.left   := S_Splitter2.left+
                                       S_Splitter2.width>>1-
                            P_Inner_Window_Buttons.width>>1;
      splitters_arr[1]^             := S_Splitter1.left;
      splitters_arr[2]^             := S_Splitter2.top;
      splitters_arr[3]^             := S_Splitter3.left;
      splitters_arr[4]^             := S_Splitter4.top;
      splitters_arr[5]^             := S_Splitter5.left;
      splitters_arr[6]^             := S_Splitter6.top;
      splitters_arr[7]^             := S_Splitter7.top;
      splitters_arr[8]^             := S_Splitter8.left;
    end;
end; {$endregion}
procedure MoveBorders;      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with srf_var,sel_var,crc_sel_var do
    begin
      SplittersPosCalc;
      SnapGLCanvas;
      MainBmpRectCalc1;
      MainBmpRectCalc2;
      if (not ({fix_resolution and }down_play_anim_ptr^)) then
        EventGroupsCalc(calc_arr,[0,1,2,3,6,17,18,20,28,30,31,32,37,44,48,52,53,55]);
      iwr_is_iwr2:=AreRct1AndRct2Eq(inn_wnd_rct,inn_wnd_rct2);
      {if down_play_anim_ptr^ then
        inn_wnd_rct2:=inn_wnd_rct;}
      if down_select_items_ptr^ then
        begin
          ResizeCircleSelectionModeDraw;
          AddCircleSelection;
          CrtCircleSelection;
          with crc_sel_rct do
           {CircleSelectionModeDraw(left+width >>1,
                                    top +height>>1,
                                    srf_var);}
            FilSelPtsObj(left,top);
        end;
      SpeedButtonRepaint;
      ContentLibraryImagesListRepaint;
      ObjectTagsListRepaint;
    end;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.S_Splitter0ChangeBounds(sender:TObject); {$region -fold}
begin
  Update;
end; {$endregion}
procedure TF_MainForm.S_Splitter1ChangeBounds(sender:TObject); {$region -fold}
begin
  Shape18.Visible:=(S_Splitter1.left>76);
  Shape19.Visible:=(S_Splitter1.left>76);
  Update;
end; {$endregion}
procedure TF_MainForm.S_Splitter2ChangeBounds(sender:TObject); {$region -fold}
var
  k: integer;
begin
  if (S_Splitter2.top >F_MainForm.height-splitter_thickness) then
      S_Splitter2.top:=F_MainForm.height-splitter_thickness;
  k:=2*18-Trunc(420/Trunc(S_Splitter2.top/18));
  if (S_Splitter2.top<420) and (k>8) then
    begin
      L_Object_Info   .font.height:=k;
      L_Exec_Time_Info.font.height:=k;
    end;
  if (S_Splitter2.top<320) then
    begin
      L_Exec_Time_Info.AnchorParallel(akLeft  ,0,Nil);
      L_Exec_Time_Info.AnchorParallel(akBottom,0,Nil);
      L_Exec_Time_Info.left:=P_Inner_Window_Buttons.left+P_Inner_Window_Buttons.width+P_Inner_Window_Buttons.width>>4;
      L_Exec_Time_Info.top :=P_Inner_Window_Buttons.top +P_Inner_Window_Buttons.height>>2;
    end
  else
    begin
      L_Exec_Time_Info.AnchorParallel(akLeft  ,20,S_Splitter1);
      L_Exec_Time_Info.AnchorParallel(akBottom,20,S_Splitter2);
    end;
  Update;
end; {$endregion}
procedure TF_MainForm.S_Splitter3ChangeBounds(sender:TObject); {$region -fold}
begin
  S_Splitter5.left:=S_Splitter3.left+treeview_splitter_shift;
  if (S_Splitter5.left >F_MainForm.width-splitter_thickness) then
      S_Splitter5.left:=F_MainForm.width-splitter_thickness;
  Update;
end; {$endregion}
procedure TF_MainForm.S_Splitter5ChangeBounds(sender:TObject); {$region -fold}
begin
  if (S_Splitter5.left <F_MainForm.width-TV_Scene_Tree.width) then
      S_Splitter5.left:=F_MainForm.width-TV_Scene_Tree.width;
  treeview_splitter_shift:=S_Splitter5.left-S_Splitter3.left;
  ObjectTagsListRepaint;
  Update;
end; {$endregion}
procedure TF_MainForm.S_Splitter6ChangeBounds(sender:TObject); {$region -fold}
begin
  ObjectTagsListRepaint;
  Update;
end; {$endregion}
procedure TF_MainForm.S_Splitter7ChangeBounds(sender:TObject); {$region -fold}
begin
  Update;
end; {$endregion}
procedure TF_MainForm.S_Splitter8ChangeBounds(sender:TObject); {$region -fold}
begin
  Update;
end; {$endregion}
procedure TF_MainForm.S_Splitter1Moved       (sender:TObject); {$region -fold}
begin
  MoveBorders;
end; {$endregion}
procedure TF_MainForm.S_Splitter2Moved       (sender:TObject); {$region -fold}
begin
  MoveBorders;
end; {$endregion}
procedure TF_MainForm.S_Splitter3Moved       (sender:TObject); {$region -fold}
begin
  MoveBorders;
  treeview_splitter_shift:=S_Splitter5.left-S_Splitter3.left;
end; {$endregion}
procedure TF_MainForm.S_Splitter5Moved       (sender:TObject); {$region -fold}
begin
  ObjectTagsListRepaint;
end; {$endregion}
procedure TF_MainForm.S_Splitter6Moved       (sender:TObject); {$region -fold}
begin
  ObjectTagsListRepaint;
end; {$endregion}
procedure TF_MainForm.S_Splitter8Moved       (sender:TObject); {$region -fold}
begin
end; {$endregion}
{$endregion}

// (Unfold Viewport) Развернуть окно просмотра:
{UI} {$region -fold}
procedure TF_MainForm.SB_Change_LayoutClick     (sender:TObject); {$region -fold}

  procedure UnfoldWindow; {$ifdef Linux}[local]{$endif} {$region -fold}

    procedure SetSplittersAnchors(space:TSpacingSize; control:TControl); {$ifdef Linux}[local]{$endif} {$region -fold}
    begin
      S_Splitter1   .AnchorParallel(akBottom,space,F_MainForm);
      S_Splitter3   .AnchorParallel(akBottom,space,F_MainForm);
      P_Scene_Editor.AnchorParallel(akBottom,space,F_MainForm);
    //S_Splitter5   .AnchorParallel(akBottom,space,F_MainForm);
    //TV_Scene_Tree .AnchorParallel(akBottom,space,F_MainForm);
    //P_Object_Tags .AnchorParallel(akBottom,space,F_MainForm);
    end; {$endregion}

  begin
    with F_MainForm do
      begin
        SB_Change_Layout.down:=False;
        SetSplittersAnchors(0,F_MainForm);
        case tag of
          0:
            begin
              S_Splitter1        .left      :=0;
              S_Splitter2        .top       :=F_MainForm.height-splitter_thickness;
              S_Splitter3        .left      :=F_MainForm.width -splitter_thickness;
              S_Splitter5        .left      :=F_MainForm.width;
              tag                           :=1;
            end;
          1:
            begin
              S_Splitter1        .left      :=280-splitter_thickness;
              if (PC_Scene_Editor.TabPosition=tpBottom) or (PC_Scene_Editor.TabPosition=tpTop  ) then
                S_Splitter2      .top       :=F_MainForm.height-067
              else
              if (PC_Scene_Editor.TabPosition=tpLeft  ) or (PC_Scene_Editor.TabPosition=tpRight) then
                S_Splitter2      .top       :=F_MainForm.height-045;
              S_Splitter3        .left      :=F_MainForm.width -280;
              S_Splitter5        .left      :=F_MainForm.width -080;
              tag                           :=2;
            end;
          2:
            begin
              S_Splitter1        .left      :=280-splitter_thickness;
              if (PC_Scene_Editor.TabPosition=tpBottom) or (PC_Scene_Editor.TabPosition=tpTop  ) then
                S_Splitter2      .top       :=F_MainForm.height-327
              else
              if (PC_Scene_Editor.TabPosition=tpLeft  ) or (PC_Scene_Editor.TabPosition=tpRight) then
                S_Splitter2      .top       :=F_MainForm.height-305;
              S_Splitter3        .left      :=F_MainForm.width -280;
              S_Splitter5        .left      :=F_MainForm.width -080;
              tag                           :=3;
            end;
          3:
            begin
              S_Splitter1        .left      :=0;
              if (PC_Scene_Editor.TabPosition=tpBottom) or (PC_Scene_Editor.TabPosition=tpTop  ) then
                S_Splitter2      .top       :=F_MainForm.height-067
              else
              if (PC_Scene_Editor.TabPosition=tpLeft  ) or (PC_Scene_Editor.TabPosition=tpRight) then
                S_Splitter2      .top       :=F_MainForm.height-045;
              S_Splitter3        .left      :=F_MainForm.width -splitter_thickness;
              S_Splitter5        .left      :=F_MainForm.width;
              tag                           :=0;
            end;
        end;
        SplittersPosCalc;
      end;
  end; {$endregion}

begin
  UnfoldWindow;
  MoveBorders;
end; {$endregion}
procedure TF_MainForm.SB_Change_LayoutMouseEnter(sender:TObject); {$region -fold}
begin
  SB_Button_Bounds.Visible:=True;
  SB_Button_Bounds.Left   :=SB_Change_Layout.Left;
  SB_Button_Bounds.Top    :=SB_Change_Layout.Top;
end; {$endregion}
procedure TF_MainForm.SB_Change_LayoutMouseLeave(sender:TObject); {$region -fold}
begin
  SB_Button_Bounds.Visible:=False;
  SB_Change_Layout.Repaint;
end; {$endregion}
{$endregion}

// (Center the Scene on the World Axis) Центрировать сцену по мировой оси:
{UI} {$region -fold}
procedure TF_MainForm.SB_Centrify_PictureClick     (sender:TObject); {$region -fold}
begin
  with srf_var,inn_wnd_rct do
    begin
      SB_Centrify_Picture.down :=False;
      world_axis_shift         :=PtPosF((left+right )>>1-world_axis.x,
                                        (top +bottom)>>1-world_axis.y);
      world_axis_shift_centrify:=                        world_axis_shift;
      obj_var.SetWorldAxisShift                         (world_axis_shift);

      obj_var.SetRctDstPtr(@inn_wnd_rct,0,obj_var.obj_cnt-1);

      EventGroupsCalc(calc_arr,[18,30,31,32,41,52,53,55]+[41+7*Byte(down_select_items_ptr^)]);//EventGroupsCalc(calc_arr,[18,30,31,32,41,48,52,55]);
      SpeedButtonRepaint;
    end;
end; {$endregion}
procedure TF_MainForm.SB_Centrify_PictureMouseEnter(sender:TObject); {$region -fold}
begin
  SB_Button_Bounds.Visible:=True;
  SB_Button_Bounds.Left   :=SB_Centrify_Picture.Left;
  SB_Button_Bounds.Top    :=SB_Centrify_Picture.Top;
end; {$endregion}
procedure TF_MainForm.SB_Centrify_PictureMouseLeave(sender:TObject); {$region -fold}
begin
  SB_Button_Bounds.Visible:=False;
  SB_Centrify_Picture.Repaint;
end; {$endregion}
{$endregion}

// (Original Scene Scale) Исходный масштаб сцены:
{UI} {$region -fold}
procedure TF_MainForm.SB_Original_Scene_ScaleClick     (sender:TObject); {$region -fold}
var
  scl_mul_: TPtPosF;
begin
  with srf_var,cmr_var,inn_wnd_rct do
    begin
      SB_Original_Scene_Scale.down:=False;
      if (scl_dif=0) then
        Exit;
      scl_mul_   :=scl_mul;
      scl_mul_pow:=1;
      if (scl_dif>0) then
        scl_dir:=sdDown
      else
        scl_dir:=sdUp;
      scl_mul.x:=Power(scl_mul.x,Abs(scl_dif));
      scl_mul.y:=scl_mul.x;
      scl_dif  :=0;
      obj_var.SetRctDstPtr(@inn_wnd_rct,0,obj_var.obj_cnt-1);
      EventGroupsCalc(calc_arr,[18,19,23,24,30,31,32,41,52,53,55]+[41+7*Byte(down_select_items_ptr^)]);
      scl_mul  :=scl_mul_;
      scl_dir  :=sdNone;
      SpeedButtonRepaint;
    end;
end; {$endregion}
procedure TF_MainForm.SB_Original_Scene_ScaleMouseEnter(sender:TObject); {$region -fold}
begin
  SB_Button_Bounds.Visible:=True;
  SB_Button_Bounds.Left   :=SB_Original_Scene_Scale.Left;
  SB_Button_Bounds.Top    :=SB_Original_Scene_Scale.Top;
end; {$endregion}
procedure TF_MainForm.SB_Original_Scene_ScaleMouseLeave(sender:TObject); {$region -fold}
begin
  SB_Button_Bounds.Visible:=False;
  SB_Original_Scene_Scale.Repaint;
end; {$endregion}
{$endregion}

// (Selection Bounds) Ограничивающий прямоугольник при выделении кнопок:
{LI} {$region -fold}
procedure SelectionBounds(custom_bitmap:Graphics.TBitmap; custom_rect:TPtRect; custom_color:TColor; custom_width:integer); {$region -fold}
begin
  with custom_bitmap.Canvas do
    begin
      Pen  .Mode :=pmNotCopy{pmMergeNotPen}{pmNotMask};
      Pen  .Width:=custom_width;
      Pen  .Color:=$FFFFFF-custom_color;
      Brush.Style:=bsClear;
      {$ifdef Windows}
      Windows.Rectangle(custom_bitmap.Canvas.Handle,
                        custom_rect.Left,
                        custom_rect.Top,
                        custom_rect.Right,
                        custom_rect.Bottom);
      {$else}
      Rectangle(custom_rect.Left,
                custom_rect.Top,
                custom_rect.Right,
                custom_rect.Bottom);
      {$endif}
    end;
end; {$endregion}
procedure SelectionBoundsRepaint; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k: integer;
begin
  with F_MainForm do
    begin
      visibility_panel_picture.PixelFormat:=pf32bit;
        SelectionBounds(visibility_panel_picture,PtRct(2,2      ,I_Visibility_Panel.Width-1,29     ),NAV_SEL_COL_2,2);
      for k:=0 to 5 do
        SelectionBounds(visibility_panel_picture,PtRct(2,28+36*k,I_Visibility_Panel.Width-1,65+36*k),NAV_SEL_COL_2,2);
    end;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.I_Visibility_PanelPaint             (sender:TObject); {$region -fold}
begin
  I_Visibility_Panel.Canvas.Draw(0,0,visibility_panel_picture);
end; {$endregion}
procedure TF_MainForm.I_Visibility_PanelMouseLeave        (sender:TObject); {$region -fold}
begin
  SelectionBoundsRepaint;
  I_Visibility_Panel.Repaint;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_Show_AllMouseEnter    (sender:TObject); {$region -fold}
begin
  SelectionBoundsRepaint;
  SelectionBounds(visibility_panel_picture,PtRct(2,2,I_Visibility_Panel.Width-1,29),NAV_SEL_COL_3,2);
  I_Visibility_Panel.Invalidate;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_BackgroundMouseEnter  (sender:TObject); {$region -fold}
begin
  SelectionBoundsRepaint;
  SelectionBounds(visibility_panel_picture,PtRct(2,28,I_Visibility_Panel.Width-1,65),NAV_SEL_COL_3,2);
  I_Visibility_Panel.Invalidate;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_Snap_GridMouseEnter   (sender:TObject); {$region -fold}
begin
  SelectionBoundsRepaint;
  SelectionBounds(visibility_panel_picture,PtRct(2,64,I_Visibility_Panel.Width-1,101),NAV_SEL_COL_3,2);
  I_Visibility_Panel.Invalidate;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_Regular_GridMouseEnter(sender:TObject); {$region -fold}
begin
  SelectionBoundsRepaint;
  SelectionBounds(visibility_panel_picture,PtRct(2,100,I_Visibility_Panel.Width-1,137),NAV_SEL_COL_3,2);
  I_Visibility_Panel.Invalidate;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_SplineMouseEnter      (sender:TObject); {$region -fold}
begin
  SelectionBoundsRepaint;
  SelectionBounds(visibility_panel_picture,PtRct(2,136,I_Visibility_Panel.Width-1,173),NAV_SEL_COL_3,2);
  I_Visibility_Panel.Invalidate;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_Tile_MapMouseEnter    (sender:TObject); {$region -fold}
begin
  SelectionBoundsRepaint;
  SelectionBounds(visibility_panel_picture,PtRct(2,172,I_Visibility_Panel.Width-1,209),NAV_SEL_COL_3,2);
  I_Visibility_Panel.Invalidate;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_ActorMouseEnter       (sender:TObject); {$region -fold}
begin
  SelectionBoundsRepaint;
  SelectionBounds(visibility_panel_picture,PtRct(2,208,I_Visibility_Panel.Width-1,245),NAV_SEL_COL_3,2);
  I_Visibility_Panel.Invalidate;
end; {$endregion}
{$endregion}

// (Panel Drop-Down Settings) Выпадающая панель настроек:
{LI} {$region -fold}
procedure PanelDropDownSettings(panel:TPanel; shape:TShape); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with panel do
    begin
      if (Height<>constraints.MinHeight) then
        begin
          shape.Shape:=stTriangle;
          Sleep(16);
          Height     :=Height-Constraints.MaxHeight>>2;
          Sleep(16);
          Height     :=Height-Constraints.MaxHeight>>2;
          Sleep(16);
          Height     :=       Constraints.MinHeight;
        end
      else
        begin
          shape.Shape:=stTriangleDown;
          Sleep(16);
          Height     :=Height+Constraints.MaxHeight>>2;
          Sleep(16);
          Height     :=Height+Constraints.MaxHeight>>2;
          Sleep(16);
          Height     :=       Constraints.MaxHeight;
        end;
    end;
end; {$endregion}
{$endregion}

// (Visibility Panel) Панель видимости:
{LI} {$region -fold}
procedure TF_MainForm.VisibilityChange(set_visibility:boolean); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  I_Visibility_Panel        .Visible:=set_visibility;
  P_Inner_Window_Buttons    .Visible:=set_visibility;
  SB_Visibility_Background  .Visible:=set_visibility;
  SB_Visibility_Regular_Grid.Visible:=set_visibility;
  SB_Visibility_Spline      .Visible:=set_visibility;
  SB_Visibility_Tile_Map    .Visible:=set_visibility;
  SB_Visibility_Actor       .Visible:=set_visibility;
  SB_Visibility_Snap_Grid   .Visible:=set_visibility;
  SB_Visibility_Show_All    .Visible:=set_visibility;
  L_Object_Info             .Visible:=set_visibility;
  L_Exec_Time_Info          .Visible:=set_visibility;
  show_obj_info                     :=set_visibility;
end; {$endregion}
procedure SetVisibility(btn:TSpeedButton; var &exp:boolean);    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  btn.Transparent:=&exp;
  &exp       :=not &exp;
  btn.Down:=False;
  srf_var.EventGroupsCalc(calc_arr,[18,23,24,30,31,32,41,52,55]+[41+7*Byte(down_select_items_ptr^)]);
  //srf_var.low_bmp_draw:=show_rgrid or show_sgrid or (show_spline and (sln_var.sln_pts_cnt<>0));
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_Visibility_BackgroundClick  (sender:TObject); {$region -fold}
begin
  SetVisibility(SB_Visibility_Background,show_tex);
  SpeedButtonRepaint;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_Snap_GridClick   (sender:TObject); {$region -fold}
begin
  SetVisibility(SB_Visibility_Snap_Grid,show_sgrid);
  SpeedButtonRepaint;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_Regular_GridClick(sender:TObject); {$region -fold}
begin
  SetVisibility(SB_Visibility_Regular_Grid,show_rgrid);
  SpeedButtonRepaint;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_SplineClick      (sender:TObject); {$region -fold}
begin
  repaint_spline_calc:=True;
  rectangles_calc    :=True;
  spline_scale_calc  :=True;
  cmr_var.scl_dir    :=sdNone;
  SetVisibility(SB_Visibility_Spline,show_spline);
  repaint_spline_calc:=False;
  rectangles_calc    :=False;
  spline_scale_calc  :=False;
  SpeedButtonRepaint;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_Tile_MapClick    (sender:TObject); {$region -fold}
begin
  SetVisibility(SB_Visibility_Tile_Map,show_tile_map);
  SpeedButtonRepaint;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_ActorClick       (sender:TObject); {$region -fold}
begin
  SetVisibility(SB_Visibility_Actor,show_actor);
  SpeedButtonRepaint;
end; {$endregion}
procedure TF_MainForm.SB_Visibility_Show_AllClick    (sender:TObject); {$region -fold}
var
  i: integer;
begin
  show_all                              :=not show_all;
  SB_Visibility_Background  .Transparent:=not show_all;
  SB_Visibility_Regular_Grid.Transparent:=not show_all;
  SB_Visibility_Snap_Grid   .Transparent:=not show_all;
  SB_Visibility_Spline      .Transparent:=not show_all;
  SB_Visibility_Actor       .Transparent:=not show_all;
  SB_Visibility_Tile_Map    .Transparent:=not show_all;
  SB_Visibility_Show_All    .Transparent:=not show_all;
  for i:=0 to High(show_obj_arr) do
    show_obj_arr[i]:=show_all;
  SB_Visibility_Show_All.Down:=False;
  cmr_var.scl_dir            :=sdNone;
  srf_var.EventGroupsCalc(calc_arr,[18,23,24,30,31,32,41,52,55]+[41+7*Byte(down_select_items_ptr^)]);
  SpeedButtonRepaint;
end; {$endregion}
{$endregion}

// (Buttons PopUp Menu) Всплывающее меню панели инструментов:
{LI} {$region -fold}
procedure ButtonsPopUpMenu(pnl:TPanel; menu_item:TMenuItem; col1,col2,col3:TColor; &transparent:boolean); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  if menu_item.Checked then
    begin
      pnl.BevelColor:=col1;
      pnl.Color     :=col2;
    end;
  for i:=0 to pnl.ControlCount-1 do
    if       (pnl.Controls[i] is TSpeedButton) then // if (not (pnl.Controls[i] is TImage)) then
      begin
           //(pnl.Controls[i] as TSpeedButton).Transparent:=&transparent;
             (pnl.Controls[i] as TSpeedButton).Flat       :=&transparent;
              pnl.Controls[i].Color:=col3;
      end;
  pnl.Repaint;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.MI_Button_Style_1Click(sender:TObject); {$region -fold}
begin
  ButtonsPopUpMenu(P_Draw_Buttons,MI_Button_Style_1,$00CCC1BF,$00CCC1BF,0,MI_Button_Style_1.Checked);
  ButtonsPopUpMenu(P_Anim_Buttons,MI_Button_Style_1,$00CCC1BF,$00CCC1BF,0,MI_Button_Style_1.Checked);
end; {$endregion}
procedure TF_MainForm.MI_Button_Style_2Click(sender:TObject); {$region -fold}
begin
  ButtonsPopUpMenu(P_Draw_Buttons,MI_Button_Style_2,$006C6655,$00AB9A96,0,MI_Button_Style_2.Checked);
  ButtonsPopUpMenu(P_Anim_Buttons,MI_Button_Style_2,$006C6655,$00AB9A96,0,MI_Button_Style_2.Checked);
end; {$endregion}
procedure TF_MainForm.MI_Button_Style_3Click(sender:TObject); {$region -fold}
begin
  ButtonsPopUpMenu(P_Draw_Buttons,MI_Button_Style_3,$00434034,$008B7570,0,not MI_Button_Style_3.Checked);
  ButtonsPopUpMenu(P_Anim_Buttons,MI_Button_Style_3,$00434034,$008B7570,0,not MI_Button_Style_3.Checked);
end; {$endregion}
{$endregion}

// (Buttons Colorize) Окраска кнопок при нажатии:
{LI} {$region -fold}
procedure BtnColAndDown    (const spd_btn:TSpeedButton; var down_flag:boolean; color_down:TColor=NAV_SEL_COL_0; color_up:TColor=BTN_CHECKED); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with spd_btn do
    begin
      Flat     :=True; // Down;
      down_flag:=Down; // down_flag:=not down_flag;
      if Down then
        Color:=color_down
      else
        Color:=color_up;
    end;
end; {$endregion}
procedure MouseMoveProcInit(pnl:TPanel; pnl_proc:TMouseMoveEvent);                                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to pnl.ControlCount-1 do
    if (pnl.Controls[i] is TSpeedButton) then // if (not (pnl.Controls[i] is TImage)) then
       (pnl.Controls[i] as TSpeedButton).OnMouseMove:=pnl_proc;
end; {$endregion}
procedure ButtonColorize   (pnl:TPanel; btn_col:TColor=NAV_SEL_COL_0);                                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
 for i:=0 to pnl.ControlCount-1 do
   if (pnl.Controls[i] is TSpeedButton) then // if (not (pnl.Controls[i] is TImage)) then
     begin
      (pnl.Controls[i] as TSpeedButton).Transparent:=not (pnl.Controls[i] as TSpeedButton).Down;
       pnl.Controls[i].Color:=btn_col;
     end;
end; {$endregion}
procedure ButtonBounds0    (btn0,btn1:TSpeedButton);                                                                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  btn1.Visible:=True;
  btn1.Left   :=btn0.Left;
  btn1.Top    :=btn0.Top ;
end; {$endregion}
procedure ButtonBounds1    (     btn1:TSpeedButton);                                                                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  btn1.Visible:=False;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.P_Load_Save_ClearPaint               (sender:TObject);                                 {$region -fold}
begin
  ButtonColorize(P_Load_Save_Clear);
end; {$endregion}
procedure TF_MainForm.P_Draw_ButtonsPaint                  (sender:TObject);                                 {$region -fold}
begin
  if MI_Button_Style_1.Checked then
    begin
      ButtonColorize(P_Draw_Buttons);
      Exit;
    end;
  if MI_Button_Style_2.Checked then
    begin
      ButtonColorize(P_Draw_Buttons,clWhite);
      Exit;
    end;
  if MI_Button_Style_3.Checked then
    begin
      ButtonColorize(P_Draw_Buttons,clBlack);
      Exit;
    end;
end; {$endregion}
procedure TF_MainForm.P_Anim_ButtonsPaint                  (sender:TObject);                                 {$region -fold}
begin
  if MI_Button_Style_1.Checked then
    begin
      ButtonColorize(P_Anim_Buttons);
      Exit;
    end;
  if MI_Button_Style_2.Checked then
    begin
      ButtonColorize(P_Anim_Buttons,clWhite);
      Exit;
    end;
  if MI_Button_Style_3.Checked then
    begin
      ButtonColorize(P_Anim_Buttons,clBlack);
      Exit;
    end;
end; {$endregion}
procedure TF_MainForm.P_Draw_ButtonsMouseLeave             (sender:TObject);                                 {$region -fold}
begin
  SB_Draw_Buttons_Button_Bounds.Visible:=False;
  P_Draw_Buttons.Repaint;
end; {$endregion}
procedure TF_MainForm.P_Anim_ButtonsMouseLeave             (sender:TObject);                                 {$region -fold}
begin
  SB_Anim_Buttons_Button_Bounds.Visible:=False;
  P_Draw_Buttons.Repaint;
end; {$endregion}
procedure TF_MainForm.P_Draw_ButtonsMouseMove              (sender:TObject; shift:TShiftState; x,y:integer); {$region -fold}
begin
  //P_Draw_Buttons.Repaint;
end; {$endregion}
procedure TF_MainForm.P_Anim_ButtonsMouseMove              (sender:TObject; shift:TShiftState; x,y:integer); {$region -fold}
begin
  //P_Anim_Buttons.Repaint;
end; {$endregion}
procedure TF_MainForm.SB_TextMouseEnter                    (sender:TObject); {$region -fold}
begin
  ButtonBounds0(SB_Text,SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_TextMouseLeave                    (sender:TObject); {$region -fold}
begin
  ButtonBounds1(SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_BrushMouseEnter                   (sender:TObject); {$region -fold}
begin
  ButtonBounds0(SB_Brush,SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_BrushMouseLeave                   (sender:TObject); {$region -fold}
begin
  ButtonBounds1(SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_SprayMouseEnter                   (sender:TObject); {$region -fold}
begin
  ButtonBounds0(SB_Spray,SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_SprayMouseLeave                   (sender:TObject); {$region -fold}
begin
  ButtonBounds1(SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_SplineMouseEnter                  (sender:TObject); {$region -fold}
begin
  ButtonBounds0(SB_Spline,SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_SplineMouseLeave                  (sender:TObject); {$region -fold}
begin
  ButtonBounds1(SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_Select_ItemsMouseEnter            (sender:TObject); {$region -fold}
begin
  ButtonBounds0(SB_Select_Items,SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_Select_ItemsMouseLeave            (sender:TObject); {$region -fold}
begin
  ButtonBounds1(SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_Select_Background_RegionMouseEnter(sender:TObject); {$region -fold}
begin
  ButtonBounds0(SB_Select_Background_Region,SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_Select_Background_RegionMouseLeave(sender:TObject); {$region -fold}
begin
  ButtonBounds1(SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_BackgroundMouseEnter              (sender:TObject); {$region -fold}
begin
  ButtonBounds0(SB_Background,SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_BackgroundMouseLeave              (sender:TObject); {$region -fold}
begin
  ButtonBounds1(SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_SGridMouseEnter                   (sender:TObject); {$region -fold}
begin
  ButtonBounds0(SB_SGrid,SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_SGridMouseLeave                   (sender:TObject); {$region -fold}
begin
  ButtonBounds1(SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_RGridMouseEnter                   (sender:TObject); {$region -fold}
begin
  ButtonBounds0(SB_RGrid,SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_RGridMouseLeave                   (sender:TObject); {$region -fold}
begin
  ButtonBounds1(SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_Add_TilemapMouseEnter             (sender:TObject); {$region -fold}
begin
  ButtonBounds0(SB_Add_Tilemap,SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_Add_TilemapMouseLeave             (sender:TObject); {$region -fold}
begin
  ButtonBounds1(SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_Post_ProcessingMouseEnter         (sender:TObject); {$region -fold}
begin
  ButtonBounds0(SB_Post_Processing,SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_Post_ProcessingMouseLeave         (sender:TObject); {$region -fold}
begin
  ButtonBounds1(SB_Draw_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_Play_AnimMouseEnter               (sender:TObject); {$region -fold}
begin
  ButtonBounds0(SB_Play_Anim,SB_Anim_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_Play_AnimMouseLeave               (sender:TObject); {$region -fold}
begin
  ButtonBounds1(SB_Anim_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_Game_SettingsMouseEnter           (sender:TObject); {$region -fold}
begin
  ButtonBounds0(SB_Game_Settings,SB_Anim_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_Game_SettingsMouseLeave           (sender:TObject); {$region -fold}
begin
  ButtonBounds1(SB_Anim_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_Add_ActorMouseEnter               (sender:TObject); {$region -fold}
begin
  ButtonBounds0(SB_Add_Actor,SB_Anim_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_Add_ActorMouseLeave               (sender:TObject); {$region -fold}
begin
  ButtonBounds1(SB_Anim_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_Sound_ControlMouseEnter           (sender:TObject); {$region -fold}
begin
  ButtonBounds0(SB_Sound_Control,SB_Anim_Buttons_Button_Bounds);
end; {$endregion}
procedure TF_MainForm.SB_Sound_ControlMouseLeave           (sender:TObject); {$region -fold}
begin
  ButtonBounds1(SB_Anim_Buttons_Button_Bounds);
end; {$endregion}
{$endregion}

// (Buttons Scroll) Прокрутка панели кнопок:
{LI} {$region -fold}
procedure ButtonMoveToPrevPos(prnt_pnl:TPanel; constref btn:TControl; constref min_param,btn_width,margin:integer; constref left_or_top:TParamType); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  case left_or_top of
    ptLeft:
      begin
        if (btn.left=min_param) then
          Exit;
        for i in [0..prnt_pnl.ControlCount-1] do
          prnt_pnl.Controls[i].left:=prnt_pnl.Controls[i].left-(btn_width+margin);
      end;
    ptTop:
      begin
        if (btn.top=min_param) then
          Exit;
        for i in [0..prnt_pnl.ControlCount-1] do
          prnt_pnl.Controls[i].top:=prnt_pnl.Controls[i].top-(btn_width+margin);
      end;
  end;
end; {$endregion}
procedure ButtonMoveToSuccPos(prnt_pnl:TPanel; constref btn:TControl; constref max_param,btn_width,margin:integer; constref left_or_top:TParamType); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  case left_or_top of
    ptLeft:
      begin
        if (btn.left=max_param) then
          Exit;
        for i in [0..prnt_pnl.ControlCount-1] do
          prnt_pnl.Controls[i].left:=prnt_pnl.Controls[i].left+(btn_width+margin);
      end;
    ptTop:
      begin
        if (btn.top=max_param) then
          Exit;
        for i in [0..prnt_pnl.ControlCount-1] do
          prnt_pnl.Controls[i].top:=prnt_pnl.Controls[i].top+(btn_width+margin);
      end;
  end;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.TS_DrawMouseWheelDown(sender:TObject; shift:TShiftState; mousepos:TPoint; var handled:boolean); {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.TS_DrawMouseWheelUp  (sender:TObject; shift:TShiftState; mousepos:TPoint; var handled:boolean); {$region -fold}
begin
end; {$endregion}
{$endregion}

// (Buttons Panels Visibility) Видимость панелей для инструментов рисования:
{LI} {$region -fold}
procedure DrawingPanelsSetVisibility1(var down_button_ptr:PByteBool; prnt_panel:TPanel; active_panel,empty_panel:TScrollBox; var prev_panel,curr_panel:TScrollBox); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  curr_panel:=active_panel;
  if (not down_button_ptr^) then
    begin
      prev_panel .visible:=False;
      empty_panel.visible:=True;
      curr_panel .visible:=False;
    end
  else
    begin
      prev_panel .visible:=False;
      empty_panel.visible:=False;
      curr_panel .visible:=True;
    end;
  prev_panel:=curr_panel;
  prnt_panel.Repaint;
end; {$endregion}
procedure DrawingPanelsSetVisibility2;                                                                                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if down_select_items_ptr^ then
    begin
      crc_sel_var.only_fill:=False;
      {with obj_var do
        FilScene1(0,obj_cnt-1);
      if show_world_axis then
        with srf_var do
          WorldAxisBmp(world_axis.x-world_axis_bmp.bmp_ftimg_width_origin >>1,
                       world_axis.y-world_axis_bmp.bmp_ftimg_height_origin>>1);}
    end;
  if sln_var.has_hid_ln_elim_sln or sln_var.has_byte_mode_sln then
    begin
      if (not down_select_items_ptr^) then
        begin
          if (not repaint_spline_hid_ln_calc1) {and (down_spline_ptr^)} then
            begin
              srf_var.EventGroupsCalc(calc_arr,[18,21,23,24,{27,}30,31,32,34,41,48,50,52,55]);
              repaint_spline_hid_ln_calc1:=True;
              repaint_spline_hid_ln_calc2:=False;
            end;
        end
      else
        begin
          //if (not repaint_spline_hid_ln_calc2) then
          srf_var.EventGroupsCalc(calc_arr,[18,23,24,30,31,32{,34},41,48,52,55]);
          repaint_spline_hid_ln_calc1:=False;
          repaint_spline_hid_ln_calc2:=True;
        end;
    end
  else
  //if (not down_select_points_ptr^) {and (sel_var.sel_pts_cnt<>0)} then
    srf_var.EventGroupsCalc(calc_arr,[18,23,24,{27,}30,31,32,41,48,{?}52,55{?}]);
end; {$endregion}
{$endregion}

// (File: Load/Save Game Project) Файл: загрузка/сохранение сцены:
{UI} {$region -fold}
procedure TF_MainForm.TextureListItemMouseDown (sender:TObject; button:TMouseButton; shift:TShiftState; x,y:integer); {$region -fold}
{var
  item_index,i,j: integer;}
begin
  {item_index:=Trunc(tex_list_item_pos_x/tex_var.tex_list_item_size);
  if (item_index<=FP_Image_List.ControlCount-1) then
    begin
      (FP_Image_List.Controls[item_index] as TSpeedButton).Color:=$00884E2B;
      for i:=0 to item_index-1 do
        (FP_Image_List.Controls[i] as TSpeedButton).Color:=$00A6A6A6;
      for j:=item_index+1 to FP_Image_List.ControlCount-1 do
        (FP_Image_List.Controls[j] as TSpeedButton).Color:=$00A6A6A6;
    end;}
end; {$endregion}
procedure TF_MainForm.SB_Load_Game_ProjectClick(sender:TObject);                                                      {$region -fold}
begin
  {SB_Load_Game_Project.Down:=False;
  OpenPictureDialog1.Options:=OpenPictureDialog1.Options+[ofFileMustExist];
  if (not OpenPictureDialog1.Execute) then
    Exit;
  try
    tex_var.loaded_picture.LoadFromFile(OpenPictureDialog1.Filename);
  except
    on E: Exception do
      MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
  end;
  tex_var.LoadTexture;
  MI_Antialiasing.Checked:=True;
  tex_var.srf_var_ptr^.srf_bmp.Canvas.Antialiasingmode:=amOn;}
end; {$endregion}
procedure TF_MainForm.SB_Save_Game_ProjectClick(sender:TObject);                                                      {$region -fold}
begin
  {SB_Save_Game_Project.Down:=False;
  if tex_var.loaded_picture.Graphic=Nil then
    begin
      MessageDlg('No image','Please open an image, before save',mtError,[mbOk],0);
      Exit;
    end;
  SavePictureDialog1.Options:=SavePictureDialog1.Options+[ofPathMustExist];
  if (not SavePictureDialog1.Execute) then
    Exit;
  try
    tex_var.loaded_picture.SaveToFile(SavePictureDialog1.Filename);
  except
    on E: Exception do
      MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
  end;}
end; {$endregion}
{$endregion}

// (Content Library - Images) Контент-библиотека - изображения:
{LI} {$region -fold}
procedure ContentLibraryImagesListRepaint; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  color_info: TColorInfo;
  rct0      : TPtRect;
  rct1      : TPtRect;
  rct2      : TPtRect;
  rct3      : TPtRect;
  mrg       : TPtRect;
  pt        : double;
  i,w,h,t,c : integer;
  x0        : integer=2;
  y0        : integer=2;
begin
  c   :=4;
  w   :=F_MainForm.I_Content_Library_Images_List.width;
  h   :=F_MainForm.I_Content_Library_Images_List.height;
  rct0:=PtBounds(0,0,w  ,h  );
  rct1:=PtBounds(0,0,100{Trunc(w/c)},100{Trunc(h/c)});
  rct2:=PtBounds(2,2,w-2,h-2);
  mrg :=PtBounds(4,4,4,24);
  SetColorInfo($00665F4D,color_info);
  PPFloodFill(library_images_bmp_ptr,
              library_images_bmp.width,
              rct0,
              color_info.pix_col);
  x0:=mrg.left+2;
  y0:=mrg.top +2;
  for i:=0 to Length(library_images_inds_arr)-1 do
    with sprite_sheet_arr[library_images_inds_arr[i]],fast_image_data,fast_image_proc_var do
      begin
        if (x0+rct1.width+mrg.left+2>w) then
          begin
            x0:=mrg.left+2;
            Inc(y0,rct1.height);
            Inc(y0,mrg .bottom);
          end;

        rct3:=ClippedRct(
          rct2,
          PtRct(
            x0,
            y0,
            x0+rct1.width,
            y0+rct1.height));
        SetColorInfo($00858585{clLtGray},color_info);
        PPFloodFill(library_images_bmp_ptr,
                    library_images_bmp.width,
                    rct3,
                    color_info.pix_col);

        SetColorInfo($003C422F,color_info);
        Rectangle(x0,y0,x0+rct1.width,y0+rct1.height,library_images_bmp_ptr,library_images_bmp.width,rct2,color_info.pix_col);

        fast_image_data_ptr0:=@fast_image_data;
        SetBkgnd(library_images_bmp_ptr,
                 library_images_bmp.width,
                 library_images_bmp.height,
                 rct2);
        if    (bmp_ftimg_height_origin/
               bmp_ftimg_width_origin >=rct1.height/
                                        rct1.width ) then
           pt:=                         rct1.height/
               bmp_ftimg_height_origin
         else
           pt:=                         rct1.width /
               bmp_ftimg_width_origin;
        if    (bmp_ftimg_width_origin <=rct1.width ) and
              (bmp_ftimg_height_origin<=rct1.height) then
          begin
            scl_mul:=PtPosF(1,1);
            SdrProc[sdr_proc_ind](x0+(rct1.width -bmp_ftimg_width_origin )>>1,
                                  y0+(rct1.height-bmp_ftimg_height_origin)>>1,
                                  fast_image_data_ptr0);
          end
        else
          begin



            {scl_mul:=PtPosF(pt,pt);
            SetRctPos(x0+(rct1.width -Trunc(bmp_ftimg_width_origin *pt))>>1,
                      y0+(rct1.height-Trunc(bmp_ftimg_height_origin*pt))>>1);
            SetRctDst2;
            SetRctSrc;
            if (nt_pix_cnt<>0) then
              GenNTBeginProc[1](fast_image_data_ptr0,
                                fast_image_data_ptr0^);
            if (pt_pix_cnt<>0) then
              begin
                GenPTBeginProc[1](fast_image_data_ptr0,
                                  fast_image_data_ptr0^);
                FilPTValueArrG;
              end;
            if (nt_pix_cnt<>0) then
              RSDNTColorA04(fast_image_data_ptr0,
                            fast_image_data_ptr0^);
            if (pt_pix_cnt<>0) then
              begin
                RSDPTColorA04(fast_image_data_ptr0,
                              fast_image_data_ptr0^);
                FilPTValueArrH;
              end;}



          end;

        if i in [2..4] then
          begin
            PPHighlightLimit(
              library_images_bmp_ptr,
              library_images_bmp.width,
              rct3,
              32);
            SetColorInfo($00C8AE9B,color_info);
            Rectangle(x0-1,y0-1,x0+rct1.width+1,y0+rct1.height+mrg.bottom-3,library_images_bmp_ptr,library_images_bmp.width,rct2,color_info.pix_col);
            SetColorInfo($00DDCDC1,color_info);
            Rectangle(x0-2,y0-2,x0+rct1.width+2,y0+rct1.height+mrg.bottom-2,library_images_bmp_ptr,library_images_bmp.width,rct2,color_info.pix_col);
            rct3:=ClippedRct(
              rct2,
              PtRct(
                x0,
                y0+rct1.height,
                x0+rct1.width,
                y0+rct1.height+mrg.bottom-4));
            PPFloodFill(library_images_bmp_ptr,
                        library_images_bmp.width,
                        rct3,
                        color_info.pix_col);
            with library_images_bmp do
              begin
                SetTextInfo   (Canvas,16,clBlack);
                Canvas.TextOut(x0+4,
                               y0+rct1.height+4,
                               'Img '+IntToStr(i));
              end;
          end
        else
          with library_images_bmp do
            begin
              SetTextInfo   (Canvas,16,clWhite);
              Canvas.TextOut(x0+4,
                             y0+rct1.height+4,
                             'Img '+IntToStr(i));
            end;

        SetBkgnd(srf_var.srf_bmp_ptr,
                 srf_var.srf_bmp.width,
                 srf_var.srf_bmp.height,
                 srf_var.inn_wnd_rct);

        Inc(x0,rct1.width+mrg.left);
      end;
  with library_images_bmp do
    if (Length(library_images_inds_arr)=0) then
      begin
        if (F_MainForm.I_Content_Library_Images_List.width>=272) then
          t:=32
        else
          t:=Trunc(32-(272-F_MainForm.I_Content_Library_Images_List.width)*(32-16)/(272-104));  //w0=104; t0=16; w1=272; t=32;
        SetTextInfo   (Canvas,t);
        Canvas.TextOut(F_MainForm.I_Content_Library_Images_List.width >>1-085,
                       F_MainForm.I_Content_Library_Images_List.height>>1-032,
                       'Import Image or');
        Canvas.TextOut(F_MainForm.I_Content_Library_Images_List.width >>1-128,
                       F_MainForm.I_Content_Library_Images_List.height>>1-000,
                       'Drag''n''Drop right here');
      end;
  with library_images_bmp.Canvas do
    begin
      Brush.Style:=bsClear;
      Pen.Width  :=1;
      Pen.Mode   :=pmCopy;
      Pen.Color  :=clLtGray;
      Rectangle(0,0,w,h);
      Pen.Color  :=clWhite;
      Rectangle(1,1,w-1,h-1);
    end;
  CnvToCnv(rct0,
           F_MainForm.I_Content_Library_Images_List.Canvas,
           library_images_bmp.Canvas,
           SRCCOPY);
  F_MainForm.I_Content_Library_Images_List.Invalidate;

  //F_MainForm.M_Test_Log.Lines.Text:=IntToStr(Length(library_images_inds_arr));

end; {$endregion}
procedure AddLibrarySpriteObj;             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(library_images_inds_arr,Length(library_images_inds_arr)+1);
  SetLength(sprite_sheet_arr       ,Length(sprite_sheet_arr       )+1);
  with srf_var do
    sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
    (
      srf_bmp_ptr,
      srf_bmp.width,
      srf_bmp.height,
      inn_wnd_rct,
      max_sprite_w_h_rct,
      F_MainForm.OPD_Content_Library_Images_Load.Filename,
      Nil,
      0
    );
                        library_images_inds_arr[Length(library_images_inds_arr)-1]:=Length(sprite_sheet_arr)-1;
  with sprite_sheet_arr[library_images_inds_arr[Length(library_images_inds_arr)-1]],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      SetPPInfo (clRed);
      SetGradVec(0{fast_image_data_ptr0^.rct_ent.height>>1},
                 rct_ent.height);
      SetGradCol($00000000+$000000FF, //SetGradCol($FF000000+$000000FF,
                 $FF000000+$00FF0000);//           $FF000000+$00FF0000);
      set_grad_to_vis_area:=True{False};

      {FX Settings} {$region -fold}

      (*
      fx_cnt      :=002{002};
      pix_drw_type:=002{002};
      img_inv_type:=0;

      with fx_arr[0] do
        begin
          pt_as_nt:=False;
          with nt_fx_prop do
            begin
              is_fx_gradvec:=False{True};

              //if (img_kind=3{<>4}) then
                cfx_pow0  :=255;      //}100;
              rep_cnt     :=001;      //}001;
              pix_cfx_type:=000;      //}002;
              pix_cng_type:=000{001}; //}001;
              pix_srf_type:=001;      //}001;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;

      with fx_arr[1] do
        begin
          pt_as_nt:=False;
          with nt_fx_prop do
            begin
              is_fx_gradvec:={False}True;

              //if (img_kind=3{<>4}) then
                cfx_pow0  :=255;      //}100;
              rep_cnt     :=001;      //}001;
              pix_cfx_type:=005;      //}002;
              pix_cng_type:=000{001}; //}001;
              pix_srf_type:=001;      //}001;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;
      *)

      fx_cnt      :=001;
      pix_drw_type:=000;
      img_inv_type:=0;

      with fx_arr[0] do
        begin
          pt_as_nt:=False;
          with nt_fx_prop do
            begin
              is_fx_gradvec:=False;
                cfx_pow0  :=255;
              rep_cnt     :=001;
              pix_cfx_type:=000;
              pix_cng_type:=000;
              pix_srf_type:=001;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;

      with fx_arr[1] do
        begin
          pt_as_nt:=False;
          with nt_fx_prop do
            begin
              is_fx_gradvec:=False;
                cfx_pow0  :=255;
              rep_cnt     :=001;
              pix_cfx_type:=000;
              pix_cng_type:=000;
              pix_srf_type:=001;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;

      SdrTypeCng(fast_image_data_ptr0,
                 fast_image_data); {$endregion}

    end;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.P_Content_Library_Images_HeaderClick     (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Content_Library_Images_Settings,Shape18);
  ContentLibraryImagesListRepaint;
end; {$endregion}
procedure TF_MainForm.P_Content_Library_Images_HeaderMouseEnter(sender:TObject); {$region -fold}
begin
  P_Content_Library_Images_Header  .Color:=HighLightLimit(P_Content_Library_Images_Header  .Color,16);
  P_Content_Library_Images_Settings.Color:=HighLightLimit(P_Content_Library_Images_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Content_Library_Images_HeaderMouseLeave(sender:TObject); {$region -fold}
begin
  P_Content_Library_Images_Header  .Color:=Darken2(P_Content_Library_Images_Header  .Color,16);
  P_Content_Library_Images_Settings.Color:=Darken2(P_Content_Library_Images_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Content_Library_Sounds_HeaderClick     (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Content_Library_Sounds_Settings,Shape19);
end; {$endregion}
procedure TF_MainForm.P_Content_Library_Sounds_HeaderMouseEnter(sender:TObject); {$region -fold}
begin
  P_Content_Library_Sounds_Header  .Color:=HighLightLimit(P_Content_Library_Sounds_Header  .Color,16);
  P_Content_Library_Sounds_Settings.Color:=HighLightLimit(P_Content_Library_Sounds_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Content_Library_Sounds_HeaderMouseLeave(sender:TObject); {$region -fold}
begin
  P_Content_Library_Sounds_Header  .Color:=Darken2(P_Content_Library_Sounds_Header  .Color,16);
  P_Content_Library_Sounds_Settings.Color:=Darken2(P_Content_Library_Sounds_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.SB_Content_Library_Images_LoadClick      (sender:TObject); {$region -fold}
begin
  with srf_var,tlm_var do
    begin
      SB_Content_Library_Images_Load.down            :=False;
              OPD_Content_Library_Images_Load.Options:=
              OPD_Content_Library_Images_Load.Options+[ofFileMustExist];
      if (not OPD_Content_Library_Images_Load.Execute) then
        Exit;
      try
        begin
          AddLibrarySpriteObj;
          //srf_var.EventGroupsCalc(calc_arr,[30,37,41,48]);
        end;
      except
        on E: Exception do
          MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
      end;
      ContentLibraryImagesListRepaint;
      P_Content_Library_Images_Header.Caption:='  Images: '+IntToStr(Length(library_images_inds_arr));
    end;
end; {$endregion}
procedure TF_MainForm.SB_Content_Library_Images_EditClick      (sender:TObject); {$region -fold}
begin
  SB_Content_Library_Images_Edit.down:=False;
  F_Image_Editor.Show;
end; {$endregion}
procedure TF_MainForm.LE_Content_Library_Images_Find_ImageEnter(sender:TObject); {$region -fold}
begin
  KeysDisable0;
end; {$endregion}
procedure TF_MainForm.LE_Content_Library_Images_Find_ImageExit (sender:TObject); {$region -fold}
begin
  KeysEnable0;
end; {$endregion}
{$endregion}

// (Content Library - Sounds) Контент-библиотека - звуки:
{LI} {$region -fold}

{$endregion}
{UI} {$region -fold}

{$endregion}

// (Drawing Surface) Поверхность рисования:
{LI} {$region -fold}
constructor TSurface.Create(w,h:TColor);                                              {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  obj_var.Add(kooBkgnd,world_axis_shift);
  CreateNode('Background','',True);
  ObjIndsCalc;
  ScTIndsCalc;
  obj_var.VisObjArrCrt2;
  ObjectTagsListRepaint;

  canvas_rct_width    :=w;
  canvas_rct_height   :=h;

  srf_bmp             :=Graphics.TBitmap.Create;
  {$ifopt D+}
  srf_bmp.PixelFormat :=pfDevice;
  {$endif}

  low_bmp             :=Graphics.TBitmap.Create;
  {$ifopt D+}
  low_bmp.PixelFormat :=pfDevice;
  {$endif}
  low_bmp_draw        :=True;

  low_bmp2            :=Graphics.TBitmap.Create;
  {$ifopt D+}
  low_bmp2.PixelFormat:=pfDevice;
  {$endif}
  low_bmp2_draw       :=False;

  low_bmp3            :=Graphics.TBitmap.Create;
  {$ifopt D+}
  low_bmp3.PixelFormat:=pfDevice;
  {$endif}

  test_bmp            :=Graphics.TBitmap.Create;
  {$ifopt D+}
  test_bmp.PixelFormat:=pfDevice;
  {$endif}

  orgn_wnd_res :=PtPos(w,h);
  rszd_wnd_res :=PtPos(w,h);
  rszd_wnd_res2:=PtPos(w,h);

  {Baking Sprites} {$region -fold}
  {SetLength(scl_arr            ,2048{srf_bmp.width}*2048{srf_bmp.height});
  //ArrClr   (scl_arr,inn_wnd_rct,2048{srf_bmp.width});
  scl_arr_ptr:=Unaligned(@scl_arr[0]);} {$endregion}

  SetLength(tex_bmp_rct_pts       ,2);
  SetLength(tex_bmp_rct_origin_pts,2);
  tex_bmp_rct_origin_pts[0].x:=296{Trunc(inn_wnd_rct.left+inn_wnd_rct.right -w)>>1};
  tex_bmp_rct_origin_pts[0].y:=034{Trunc(inn_wnd_rct.top +inn_wnd_rct.bottom-h)>>1};
  tex_bmp_rct_origin_pts[1].x:=tex_bmp_rct_origin_pts[0].x+w;
  tex_bmp_rct_origin_pts[1].y:=tex_bmp_rct_origin_pts[0].y+h;
  tex_bmp_rct_pts            :=tex_bmp_rct_origin_pts;

  cmr_var.parallax_shift     :=obj_default_prop.parallax_shift;
  show_all                   :=True;
  inner_window_ui_visible    :=True;
  form_resized               :=True;
  bg_col                     :=SetColorInv($0044353C);
  bg_style                   :=bsGrayscale;
  show_tex                   :=True;
  srf_bmp.Canvas.Brush.Color :=bg_col;
  inn_wnd_cmr_shake_mrg      :=20;
  inn_wnd_mrg                :=00{01};
  pp_rep_cnt                 :=01;

  SetTextInfo(srf_bmp.Canvas,32,$00E6F9EB,'AR DESTINE');

  ResInnWndCreate;
  WorldAxisCreate;

end; {$endregion}
destructor  TSurface.Destroy;                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure TSurface.ResInnWndCreate;                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
  sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
  (
    low_bmp3_ptr,
    low_bmp3.width,
    low_bmp3.height,
    max_sprite_w_h_rct,
    max_sprite_w_h_rct,
    0
  );
  res_wnd_ind:=Length(sprite_sheet_arr)-1;
end; {$endregion}
procedure TSurface.ResInnWndToBmp;                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
label
  l1;
begin
  with sprite_sheet_arr[res_wnd_ind],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      scl_mul.x           :=inn_wnd_rct1.width /srf_bmp.width ;
      scl_mul.y           :=inn_wnd_rct1.height/srf_bmp.height;
      if (scl_mul.x=1.0) and (scl_mul.y=1.0) then
        begin
          CnvToCnv(srf_bmp_rct,F_MainForm.Canvas,srf_bmp.Canvas,SRCCOPY{NOTSRCCOPY});
          Exit;
        end;
      pvt0     .x     :=0;
      pvt0     .y     :=0;
      rct_ent_f.left  :=0;
      rct_ent_f.top   :=0;
      rct_ent  .width :=srf_bmp.width ;
      rct_ent  .height:=srf_bmp.height;
      bmp_color_ptr   :=srf_bmp_ptr;
      bmp_bkgnd_ptr   :=low_bmp3_ptr;
      bmp_bkgnd_width :=low_bmp3.width;
      if (scl_mul.x<>1.0) and (scl_mul.y<>1.0) then
        begin
          ImgSclDown2(fast_image_data_ptr0);
          goto l1;
        end;
      if (scl_mul.x= 1.0) and (scl_mul.y<>1.0) then
        begin
          ImgSclDown3(fast_image_data_ptr0);
          goto l1;
        end;
      if (scl_mul.x<>1.0) and (scl_mul.y= 1.0) then
        begin
          ImgSclDown4(fast_image_data_ptr0);
          goto l1;
        end;
      l1:
      CnvToCnv(inn_wnd_rct1,F_MainForm.Canvas,low_bmp3.Canvas,SRCCOPY{NOTSRCCOPY});
      ArrClr  (low_bmp3_ptr,PtRct(0,0,low_bmp3.width,low_bmp3.height),low_bmp3.width,bg_col,False,False);
    end;
end; {$endregion}
procedure TSurface.SetPtPosToResInnWndPos(var x,y:integer);                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sprite_sheet_arr[res_wnd_ind],fast_image_data do
    begin
      x:=Trunc((x-inn_wnd_rct1.left)/scl_mul.x);
      y:=Trunc((y-inn_wnd_rct1.top )/scl_mul.y);
    end;
end; {$endregion}
procedure TSurface.WorldAxisCreate;                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // Create World Axis Icon:
  SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
  sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
  (
    srf_bmp_ptr,
    srf_bmp.width,
    srf_bmp.height,
    inn_wnd_rct,
    max_sprite_w_h_rct,
    Application.Location+WORLD_AXIS_ICON,
    @F_MainForm.IL_World_Axis.GetBitmap,
    0
  );
  world_axis_bmp_ind:=Length(sprite_sheet_arr)-1;
  with sprite_sheet_arr[world_axis_bmp_ind],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      SetPPInfo (clRed           );
      SetGradVec(0,rct_ent.height);
      SetGradCol(0,255           );

      {FX Settings} {$region -fold}
      fx_cnt      :=001;
      pix_drw_type:=000;

      with fx_arr[0] do
        begin
          with nt_fx_prop do
            begin
              //if (img_kind=3{<>4}) then
                cfx_pow0  :=160;
              rep_cnt     :=001;
              pix_cfx_type:=002;
              pix_cng_type:=000;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;


      {fx_cnt      :=002;
      pix_drw_type:={000}001;

      with fx_arr[0] do
        begin
          pt_as_nt:=False;
          with nt_fx_prop do
            begin
              //if (img_kind=3{<>4}) then
                cfx_pow0  :=180;
              rep_cnt     :=001;
              pix_cfx_type:=002;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;

      with fx_arr[1] do
        begin
          pt_as_nt:=False;
          with nt_fx_prop do
            begin
              is_fx_gradvec:=False{True};
              cfx_pow0     :=155;
              rep_cnt      :=001;
              pix_cfx_type :=002;
              pix_cng_type :=001;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;}


      SdrTypeCng(fast_image_data_ptr0,
                 fast_image_data); {$endregion}

    end;
end; {$endregion}
procedure TSurface.WorldAxisToBmp(const x,y:integer);                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  world_axis_x,world_axis_y: integer;}
begin
  {srf_bmp.BeginUpdate(True);
  with srf_bmp.Canvas,world_axis_shift do
    begin
      Pen.Mode    :=pmNotMask{pmNotXor}{pmCopy};
      Pen.Color   :=clGreen;
      world_axis_x:=world_axis.x+world_axis_shift.x;
      world_axis_y:=world_axis.y+world_axis_shift.y;
      Line  ( 00+world_axis_x,
              00+world_axis_y,
              60+world_axis_x,
              00+world_axis_y);
      LineTo( 50+world_axis_x,
             -02+world_axis_y);
      LineTo( 50+world_axis_x,
              02+world_axis_y);
      LineTo( 60+world_axis_x,
              00+world_axis_y);
      Line  ( 00+world_axis_x,
              00+world_axis_y,
              00+world_axis_x,
             -60+world_axis_y);
      LineTo(-02+world_axis_x,
             -50+world_axis_y);
      LineTo( 02+world_axis_x,
             -50+world_axis_y);
      LineTo( 00+world_axis_x,
             -60+world_axis_y);
      Pen.Color:=clBlue;
      Pen.Style:=psDot;
      Line  ( 00+world_axis_x,
              00+world_axis_y,
             -60+world_axis_x,
              00+world_axis_y);
      Pen.Style:=psSolid;
      LineTo(-50+world_axis_x,
             -02+world_axis_y);
      LineTo(-50+world_axis_x,
              02+world_axis_y);
      LineTo(-60+world_axis_x,
              00+world_axis_y);
      Pen.Style:=psDot;
      Line  ( 00+world_axis_x,
              00+world_axis_y,
              00+world_axis_x,
              60+world_axis_y);
      Pen.Style:=psSolid;
      LineTo(-02+world_axis_x,
              50+world_axis_y);
      LineTo( 02+world_axis_x,
              50+world_axis_y);
      LineTo( 00+world_axis_x,
              60+world_axis_y);
    end;
  srf_bmp.EndUpdate(False);}

  with sprite_sheet_arr[world_axis_bmp_ind],fast_image_data,fast_image_proc_var do
    SdrProc[sdr_proc_ind](x+Trunc(world_axis_shift.x),
                          y+Trunc(world_axis_shift.y),
                          @fast_image_data);
end; {$endregion}
procedure InvalidateInnerWindow;                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {$ifdef Windows}
  Windows.InvalidateRect(F_MainForm.Handle,
                         Rect(splitters_arr[1]^+splitter_thickness,
                              splitters_arr[4]^+splitter_thickness,
                              splitters_arr[3]^,
                              splitters_arr[2]^),
                         True);
  {$else}
  F_MainForm.Invalidate;
  {$endif}
end; {$endregion}
procedure InvalidateRegion(rct_dst:TRect);                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {$ifdef Windows}
  Windows.InvalidateRect(F_MainForm.Handle,
                         Rect(rct_dst.Left,
                              rct_dst.Top,
                              rct_dst.Right,
                              rct_dst.Bottom),
                         True);
  {$else}
  F_MainForm.Invalidate;
  {$endif}
end; {$endregion}
procedure TSurface.InnerWindowDraw(color:TColor);                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_prop: TCurveProp;
  //a,b     : integer;
begin
 {with dst_canvas do
    begin
     a:=Trunc((inn_wnd_mrg+1)/2);
      b:=inn_wnd_mrg;
      if Odd(b) then
        b:=a
      else
        b:=a+1;
      Brush.Style:=bsClear;
      Pen.Mode   :=pmCopy;
      Pen.Color  :=color;
      Pen.Width  :=inn_wnd_mrg;
      Rectangle(inn_wnd_rct.left  -a,
                inn_wnd_rct.top   -a,
                inn_wnd_rct.right +b,
                inn_wnd_rct.bottom+b);
      Pen.Width:=1;
    end;}
  with rct_prop do
    begin
      pts_col           :=color;
      pts_col_inv       :=SetColorInv(pts_col);
      pts_rct_tns_left  :=inn_wnd_mrg;
      pts_rct_tns_top   :=inn_wnd_mrg;
      pts_rct_tns_right :=inn_wnd_mrg;
      pts_rct_tns_bottom:=inn_wnd_mrg;
      pts_rct_inn_width :=inn_wnd_rct.width ;
      pts_rct_inn_height:=inn_wnd_rct.height;
      SetRctWidth (rct_prop);
      SetRctHeight(rct_prop);
      SetRctValues(rct_prop);
      Fast_Graphics.Rectangle
      (
        inn_wnd_rct.left+inn_wnd_rct.width >>1-pts_rct_width__odd,
        inn_wnd_rct.top +inn_wnd_rct.height>>1-pts_rct_height_odd,
        srf_bmp_ptr,
        srf_bmp.width,
        srf_bmp.height,
        PtBounds
        (
          inn_wnd_rct.left  -inn_wnd_mrg,
          inn_wnd_rct.top   -inn_wnd_mrg,
          inn_wnd_rct.right +inn_wnd_mrg,
          inn_wnd_rct.bottom+inn_wnd_mrg
        ),
        rct_prop
      );
     {pts_col           :=Darken(pts_col);
      pts_col_inv       :=SetColorInv(pts_col);
      pts_rct_inn_width :=inn_wnd_rct.width -2;
      pts_rct_inn_height:=inn_wnd_rct.height-2;
      SetRctWidth (rct_prop);
      SetRctHeight(rct_prop);
      SetRctValues(rct_prop);
      Fast_Graphics.Rectangle
      (
        inn_wnd_rct.left+1+(inn_wnd_rct.width -2)>>1-pts_rct_width__odd,
        inn_wnd_rct.top +1+(inn_wnd_rct.height-2)>>1-pts_rct_height_odd,
        srf_bmp_ptr,
        srf_bmp.width,
        srf_bmp.height,
        PtBounds
        (
          inn_wnd_rct.left  +1-inn_wnd_mrg,
          inn_wnd_rct.top   +1-inn_wnd_mrg,
          inn_wnd_rct.right -1+inn_wnd_mrg,
          inn_wnd_rct.bottom-1+inn_wnd_mrg
        ),
        rct_prop
      );}
    end;
end; {$endregion}
procedure TSurface.MainBmpToLowerBmp;                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  BmpToBmp2(srf_bmp_ptr,low_bmp_ptr,srf_bmp.width,low_bmp.width,inn_wnd_rct,inn_wnd_mrg);
end; {$endregion}
procedure TSurface.MainBmpToLowerBmp2;                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  BmpToBmp2(srf_bmp_ptr,low_bmp2_ptr,srf_bmp.width,low_bmp2.width,inn_wnd_rct,inn_wnd_mrg);
end; {$endregion}
procedure TSurface.LowerBmpToMainBmp;                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  BmpToBmp2(low_bmp_ptr,srf_bmp_ptr,low_bmp.width,srf_bmp.width,inn_wnd_rct,inn_wnd_mrg);
end; {$endregion}
procedure TSurface.LowerBmp2ToMainBmp;                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  BmpToBmp2(low_bmp2_ptr,srf_bmp_ptr,low_bmp2.width,srf_bmp.width,inn_wnd_rct,inn_wnd_mrg);
end; {$endregion}
procedure TSurface.RefreshLowerLayer;                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  UpdateTickCounter(refresh_skip,refresh_step);
  if ((refresh_skip=0) and (exec_time0<=exec_time_sup)) then
    with obj_var do
      begin
        //bg_col:=Random($FFFFFF);
        SetObjBkgnd
        (
          srf_bmp_ptr,
          srf_bmp.width,
          srf_bmp.height,
          @inn_wnd_rct,
          0,
          low_lr_obj_cnt-1
        );
        rectangles_calc:=True;
        RepSplineDraw0;
        rectangles_calc:=False;
        FilScene(0,low_lr_obj_cnt-1);
        SetObjBkgnd
        (
          low_bmp_ptr,
          low_bmp.width,
          low_bmp.height,
          @inn_wnd_rct,
          0,
          low_lr_obj_cnt-1
        );
      end;
end; {$endregion}
procedure TSurface.BkgndDraw  (const bkgnd_ind:TColor; rct_clp_ptr_:PPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if show_tex then
    with obj_var.obj_arr[obj_var.bkgnd_inds_obj_arr[bkgnd_ind]] do
      PPFloodFill(bkgnd_ptr,bkgnd_width,rct_clp_ptr_^,bg_col);
end; {$endregion}
procedure TSurface.FilBkgndObj(const bkgnd_ind:TColor);                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  BkgndDraw(bkgnd_ind,obj_var.obj_arr[obj_var.bkgnd_inds_obj_arr[bkgnd_ind]].rct_clp_ptr);
end; {$endregion}
procedure TSurface.MovBkgndObj(const bkgnd_ind:TColor);                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  BkgndDraw(bkgnd_ind,obj_var.obj_arr[obj_var.bkgnd_inds_obj_arr[bkgnd_ind]].rct_dst_ptr);
end; {$endregion}
procedure TSurface.MovRight;                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  w: TPtPosF;
begin
  cmr_var.mov_dir   :=mdRight;
  w                 :=world_axis_shift;
  world_axis_shift.x-=cmr_var.spd_mul.x*obj_var.obj_arr[0].parallax_shift.x;
  ShiftErrorCalc(world_axis_shift.x,w.x,err.x,False);
  obj_var.MovWorldAxisShiftRight2;
  cmr_var.spd_mul_prev.x:=cmr_var.spd_mul.x;
end; {$endregion}
procedure TSurface.FilRight;                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct: TPtRect;
  t  : integer;
begin
  with obj_var do
    begin
      t:=Trunc(cmr_var.spd_mul.x*obj_var.obj_arr[0].parallax_shift.x)+err.x;
      BitBlt1
      (
        low_bmp_ptr,
        low_bmp_ptr,
        low_bmp.width,
        low_bmp.width,
        inn_wnd_rct.left +t,
        inn_wnd_rct.top,
        inn_wnd_rct.width-t,
        inn_wnd_rct.height,
        inn_wnd_rct.left,
        inn_wnd_rct.top
      );
      rct:=PtRct
      (
        inn_wnd_rct.right-t-1,
        inn_wnd_rct.top,
        inn_wnd_rct.right,
        inn_wnd_rct.bottom
      );
      SetRctDstPtr(@rct,0,low_lr_obj_cnt-1);
      err.x:=0;
    end;
end; {$endregion}
procedure TSurface.MovLeft;                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  w: TPtPosF;
begin
  cmr_var.mov_dir   :=mdLeft;
  w                 :=world_axis_shift;
  world_axis_shift.x+=cmr_var.spd_mul.x*obj_var.obj_arr[0].parallax_shift.x;
  ShiftErrorCalc(world_axis_shift.x,w.x,err.x,True);
  obj_var.MovWorldAxisShiftLeft2;
  cmr_var.spd_mul_prev.x:=cmr_var.spd_mul.x;
end; {$endregion}
procedure TSurface.FilLeft;                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct: TPtRect;
  t  : integer;
begin
  with obj_var do
    begin
      t:=Trunc(cmr_var.spd_mul.x*obj_var.obj_arr[0].parallax_shift.x)+err.x;
      BitBlt2
      (
        low_bmp_ptr,
        low_bmp_ptr,
        low_bmp.width,
        low_bmp.width,
        inn_wnd_rct.left,
        inn_wnd_rct.top,
        inn_wnd_rct.width-t,
        inn_wnd_rct.height,
        inn_wnd_rct.left +t,
        inn_wnd_rct.top
      );
      rct:=PtRct
      (
        inn_wnd_rct.left,
        inn_wnd_rct.top,
        inn_wnd_rct.left+t+1,
        inn_wnd_rct.bottom
      );
      SetRctDstPtr(@rct,0,low_lr_obj_cnt-1);
      err.x:=0;
    end;
end; {$endregion}
procedure TSurface.MovDown;                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  w: TPtPosF;
begin
  cmr_var.mov_dir   :=mdDown;
  w                 :=world_axis_shift;
  world_axis_shift.y-=cmr_var.spd_mul.y*obj_var.obj_arr[0].parallax_shift.y;
  ShiftErrorCalc(world_axis_shift.y,w.y,err.y,False);
  obj_var.MovWorldAxisShiftDown2;
  cmr_var.spd_mul_prev.y:=cmr_var.spd_mul.y;
end; {$endregion}
procedure TSurface.FilDown;                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct: TPtRect;
  t  : integer;
begin
  with obj_var do
    begin
      t:=Trunc(cmr_var.spd_mul.y*obj_var.obj_arr[0].parallax_shift.y)+err.y;
      BitBlt1
      (
        low_bmp_ptr,
        low_bmp_ptr,
        low_bmp.width,
        low_bmp.width,
        inn_wnd_rct.left,
        inn_wnd_rct.top   +t,
        inn_wnd_rct.width,
        inn_wnd_rct.height-t,
        inn_wnd_rct.left,
        inn_wnd_rct.top
      );
      rct:=PtRct
      (
        inn_wnd_rct.left,
        inn_wnd_rct.bottom-t-1,
        inn_wnd_rct.right,
        inn_wnd_rct.bottom
      );
      SetRctDstPtr(@rct,0,low_lr_obj_cnt-1);
      err.y:=0;
    end;
end; {$endregion}
procedure TSurface.MovUp;                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  w: TPtPosF;
begin
  cmr_var.mov_dir   :=mdUp;
  w                 :=world_axis_shift;
  world_axis_shift.y+=cmr_var.spd_mul.y*obj_var.obj_arr[0].parallax_shift.y;
  ShiftErrorCalc(world_axis_shift.y,w.y,err.y,True);
  obj_var.MovWorldAxisShiftUp2;
  cmr_var.spd_mul_prev.y:=cmr_var.spd_mul.y;
end; {$endregion}
procedure TSurface.FilUp;                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct: TPtRect;
  t  : integer;
begin
  with obj_var do
    begin
      t:=Trunc(cmr_var.spd_mul.y*obj_var.obj_arr[0].parallax_shift.y)+err.y;
      BitBlt2
      (
        low_bmp_ptr,
        low_bmp_ptr,
        low_bmp.width,
        low_bmp.width,
        inn_wnd_rct.left,
        inn_wnd_rct.top,
        inn_wnd_rct.width,
        inn_wnd_rct.height-t,
        inn_wnd_rct.left,
        inn_wnd_rct.top   +t
      );
      rct:=PtRct
      (
        inn_wnd_rct.left,
        inn_wnd_rct.top,
        inn_wnd_rct.right,
        inn_wnd_rct.top+t+1
      );
      SetRctDstPtr(@rct,0,low_lr_obj_cnt-1);
      err.y:=0;
    end;
end; {$endregion}
procedure TSurface.FilBkTexObj(const bktex_ind:TColor);                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}

{Events Queue}
{}
procedure TSurface.SetSurfParam0;                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with obj_var do
    SetObjBkgnd(low_bmp_ptr,low_bmp.width,low_bmp.height,@inn_wnd_rct,0,low_lr_obj_cnt-1);
end; {$endregion}
procedure TSurface.SetSurfParam1;                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with obj_var do
    SetObjBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct,0,low_lr_obj_cnt-1);
end; {$endregion}
procedure TSurface.SetSurfParam2;                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with obj_var do
    SetObjBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct,low_lr_obj_cnt,obj_cnt-1);
end; {$endregion}
procedure TSurface.SetSurfParam3;                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with obj_var do
    SetObjBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct,0,obj_cnt-1);
end; {$endregion}
{Scene scaling-----------------------------------}
procedure TSurface.SceneSclPowCalc;                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  cmr_var.scl_mul_pow:=Power(cmr_var.scl_mul.x,cmr_var.scl_dif);
end; {$endregion}
{}
procedure TSurface.MainBmpRectCalc0;                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  canvas_rct_width :=Max(canvas_rct_width ,F_MainForm.width );
  canvas_rct_height:=Max(canvas_rct_height,F_MainForm.height);
  srf_bmp_rct      :=PtBounds(0,0,canvas_rct_width,canvas_rct_height);
  //if (fix_resolution and down_play_anim_ptr^) then
    inn_wnd_rct:=PtRct(srf_bmp_rct.left  +splitter_thickness+inn_wnd_mrg,
                       srf_bmp_rct.top   +splitter_thickness+inn_wnd_mrg,
                       srf_bmp_rct.width -splitter_thickness-inn_wnd_mrg,
                       srf_bmp_rct.height-splitter_thickness-inn_wnd_mrg)
  {else
    inn_wnd_rct:=PtRct(splitters_arr[1]^+splitter_thickness+inn_wnd_mrg,
                       splitters_arr[4]^+splitter_thickness+inn_wnd_mrg,
                       splitters_arr[3]^                   -inn_wnd_mrg,
                       splitters_arr[2]^                   -inn_wnd_mrg)};
  MainBmpRectCalc1;
  MainBmpRectCalc2;
  pvt_var.SetPivotAxisRect(inn_wnd_rct);
end; {$endregion}
procedure TSurface.MainBmpRectCalc1;                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inn_wnd_rct1:=PtRct(splitters_arr[1]^,
                      splitters_arr[4]^,
                      splitters_arr[3]^+splitter_thickness,
                      splitters_arr[2]^+splitter_thickness);
  with sprite_sheet_arr[res_wnd_ind],fast_image_data do
    begin
      scl_mul.x:=inn_wnd_rct1.width /srf_bmp.width ;
      scl_mul.y:=inn_wnd_rct1.height/srf_bmp.height;
    end;
end; {$endregion}
procedure TSurface.MainBmpRectCalc2;                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inn_wnd_rct2:=PtRct(splitters_arr[1]^+splitter_thickness+inn_wnd_mrg,
                      splitters_arr[4]^+splitter_thickness+inn_wnd_mrg,
                      splitters_arr[3]^                   -inn_wnd_mrg,
                      splitters_arr[2]^                   -inn_wnd_mrg);
end; {$endregion}
{}
procedure TSurface.MainBmpSizeCalc;                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  srf_bmp .width :=srf_bmp_rct.width ;
  srf_bmp .height:=srf_bmp_rct.height;
  low_bmp .width :=srf_bmp_rct.width ;
  low_bmp .height:=srf_bmp_rct.height;
  low_bmp2.width :=srf_bmp_rct.width ;
  low_bmp2.height:=srf_bmp_rct.height;
  low_bmp3.width :=srf_bmp_rct.width ;
  low_bmp3.height:=srf_bmp_rct.height;
  scl_arr_width  :=srf_bmp.width;
  scl_arr_height :=srf_bmp.height;
//test_bmp.width :=srf_bmp_rct.width ;
//test_bmp.height:=srf_bmp_rct.height;
end; {$endregion}
{}
procedure TSurface.MainBmpArrsCalc;                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  if (not form_resized) then
    Exit;

  {Sqrt Table----} {$region -fold}
  SqrtArr0Init(srf_bmp.width,srf_bmp.height); {$endregion}

  {Spline--------} {$region -fold}
  with sln_var do
    begin
      with rct_eds_big_img do
        BuffersInit(srf_bmp.width  ,srf_bmp.height,False,True,False,False);
      with rct_pts_big_img do
        BuffersInit(srf_bmp.width  ,srf_bmp.height,False,True,False,False);
      with eds_big_img do
        BuffersInit(srf_bmp.width  ,srf_bmp.height,True ,True,False,True);
      with pts_big_img do
        BuffersInit(srf_bmp.width  ,srf_bmp.height,True ,True,False,True);
      SetLength(dup_pts_arr        ,srf_bmp.width*srf_bmp.height);
      ArrClr   (dup_pts_arr        ,inn_wnd_rct,  srf_bmp.width );
      SetLength(eds_useless_fld_arr,srf_bmp.width*srf_bmp.height);
      ArrClr   (eds_useless_fld_arr,inn_wnd_rct,  srf_bmp.width );
    end; {$endregion}

  {Selected Edges} {$region -fold}
  with sel_var do
    begin
      with outer_subgraph_img do
        begin
          BuffersInit(srf_bmp.width,srf_bmp.height,True,True,True,True);
          GCCArrInit;
        end;
      with inner_subgraph_img do
          BuffersInit(srf_bmp.width,srf_bmp.height,True,True,True,True);
      with sel_pts_img do
          BuffersInit(srf_bmp.width,srf_bmp.height,True,True,True,True);
      with selection_img do
          BuffersInit(srf_bmp.width,srf_bmp.height,True,True,True,True);
    end; {$endregion}

  {Physics-------} {$region -fold}
  {SetLength(fast_physics_var.coll_box_arr,srf_bmp.width*srf_bmp.height);
  SetLength(coll_arr                     ,srf_bmp.width*srf_bmp.height);
  SetLength(projectile_arr,10000);} {$endregion}

  {Baking Sprites} {$region -fold}
  {SetLength(scl_arr            ,2048{srf_bmp.width}*2048{srf_bmp.height});
  ArrClr   (scl_arr,inn_wnd_rct,2048{srf_bmp.width});
  scl_arr_ptr:=Unaligned(@scl_arr[0]);} {$endregion}

  form_resized:=False;

end; {$endregion}
{Get Handles-------------------------------------}
procedure TSurface.GetHandles;                                                inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Main Layer-------------------------} {$region -fold}
  with obj_var,rgr_var,sgr_var,sln_var do
    begin
      srf_bmp_ptr        :=GetBmpHandle(srf_bmp );
      low_bmp_ptr        :=GetBmpHandle(low_bmp );
      low_bmp2_ptr       :=GetBmpHandle(low_bmp2);
      low_bmp3_ptr       :=GetBmpHandle(low_bmp3);
    //test_bmp_ptr       :=GetBmpHandle(test_bmp);
    //SetObjBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct,0,obj_cnt-1);
    end; {$endregion}

  {Spline-----------------------------} {$region -fold}
  with sln_var do
    begin
      with rct_eds_big_img do
        begin
          GetLineBuffHndl;
          SetBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct);
        end;
      with rct_pts_big_img do
        begin
          GetLineBuffHndl;
          SetBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct);
        end;
      with eds_big_img do
        begin
          GetLineBuffHndl;
          SetBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct);
        end;
      with pts_big_img do
        begin
          GetLineBuffHndl;
          SetBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct);
        end;
    end; {$endregion}

  {Selected Edges---------------------} {$region -fold}
  with sel_var do
    begin
      with outer_subgraph_img do
        begin
          GetLineBuffHndl;
          SetBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct);
        end;
      with inner_subgraph_img do
        begin
          GetLineBuffHndl;
          SetBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct);
        end;
      with sel_pts_img do
        begin
          GetLineBuffHndl;
          SetBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct);
        end;
      with selection_img do
        begin
          GetLineBuffHndl;
          SetBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,@inn_wnd_rct);
        end;
    end; {$endregion}

  {Get Target Render For OpenGL Output} {$region -fold}
  GLBitmapInit(texture_id,srf_bmp,down_play_anim_ptr^);
  //if down_play_anim_ptr^ then
  {GetObject(srf_bmp.Handle,SizeOf(buffer),@buffer);} {$endregion}

end; {$endregion}
{World Axis: Drawing-----------------------------}
procedure TSurface.WorldAxisDraw;                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  WorldAxisToBmp(Trunc(world_axis.x)-sprite_sheet_arr[world_axis_bmp_ind].fast_image_data.bmp_ftimg_width_origin >>1,
                 Trunc(world_axis.y)-sprite_sheet_arr[world_axis_bmp_ind].fast_image_data.bmp_ftimg_height_origin>>1);
end; {$endregion}
{Align Spline: Calculation-----------------------}
procedure TSurface.AlnSplineCalc;                                                     {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_var,sel_var,sgr_var do
    AlignPts
    (
      sln_pts,
      sel_pts_inds,
      sln_pts_cnt,
      sel_pts_cnt
    );
end; {$endregion}
{Select Pivot: Calculation-----------------------}
procedure TSurface.SelectPivotCalc;                                                   {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (not show_spline) then
    Exit;
  with obj_var,sln_var,sel_var,pvt_var do
    begin
      SubgraphCalc
      (
        has_sel_pts,
        sln_pts,
        fst_lst_sln_obj_pts,
        sln_obj_ind,
        sln_obj_cnt,
        sln_pts_cnt
      );
      is_not_abst_obj_kind_after:=IsAnotherObjKindAfter4
      (
        kooCurve,
        sel_obj_min_ind
      );
      PivotCalc
      (
        sln_pts,
        sel_pts_inds,
        sel_pts_cnt
      );
    end;
end; {$endregion}
{Select Pivot: Drawing---------------------------}
procedure TSurface.SelectPivotDraw;                                                   {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j           : integer;
  editor_or_game: set of byte;
begin
  if (not show_spline) then
    Exit;
  with fast_image_proc_var,obj_var,sln_var,sel_var do
    begin
      editor_or_game:=[3,1+Byte(res_var_ptr^)];
      if (not is_not_abst_obj_kind_after) then
        ClrSplineAll(sel_obj_min_ind,obj_cnt-1);
      for i:=0 to sln_obj_cnt-1 do
        begin
          j:=obj_arr[curve_inds_obj_arr[i]].t_ind;
          if (j>=sel_obj_min_ind) and (j<=obj_cnt-1) and ((obj_arr[curve_inds_obj_arr[i]].obj_show and %00000011) in editor_or_game) then
            begin
              if (has_sel_pts[i]<>0) then
                begin
                  {Edges-} {$region -fold}
                  with eds_img_arr[i],local_prop do
                    if (eds_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                      begin
                        if ChkNTValueArr then
                          begin
                            AddSplineEds00(i);
                            CrtSplineEds  (i);
                          end;
                        RepSplineEds  (i);
                        AddSplineEds04(i);
                        CrtSplineEds  (i);
                      end; {$endregion}
                  {Points} {$region -fold}
                  with pts_img_arr[i],local_prop do
                    if (pts_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                      begin
                        AddSplineDupPts3(i);
                        RepSplinePts    (i);
                        AddSplinePts3   (i);
                        CrtSplinePts    (i);
                        ClrSplineDupPts3(i);
                      end; {$endregion}
                end;
            end;
        end;
      if (not is_not_abst_obj_kind_after) then
        FilScene(sel_obj_min_ind,obj_var.obj_cnt-1);
      SelPvtAndSplineEdsToBmp;
    end;
end; {$endregion}
{Unselect Pivot: Drawing-------------------------}
procedure TSurface.UnselectPivotDraw;                                                 {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j           : integer;
  editor_or_game: set of byte;
begin
  if (not show_spline) then
    Exit;
  with obj_var,sln_var,sel_var,crc_sel_var,pvt_var do
    begin
      editor_or_game:=[3,1+Byte(res_var_ptr^)];
      if rectangles_calc then
        RctSplineAll1(sel_obj_min_ind,obj_cnt-1);
      for i:=0 to sln_obj_cnt-1 do
        begin
          j:=obj_arr[curve_inds_obj_arr[i]].t_ind;
          if (j>=sel_obj_min_ind) and (j<=obj_cnt-1) and ((obj_arr[curve_inds_obj_arr[i]].obj_show and %00000011) in editor_or_game) then
            begin
              if (has_sel_pts[i]<>0) then
                begin
                  {Bounding Rectangles: Edges-} {$region -fold}
                  with rct_eds_img_arr[i],local_prop do
                    if (rct_eds_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                      begin
                        lazy_repaint_prev:=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                        AddSplineRctEds(i);
                        CrtSplineRctEds(i);
                      end; {$endregion}
                  {Bounding Rectangles: Points} {$region -fold}
                  with rct_pts_img_arr[i],local_prop do
                    if (rct_pts_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                      begin
                        lazy_repaint_prev:=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                        AddSplineRctPts(i);
                        CrtSplineRctPts(i);
                      end; {$endregion}
                  {---------------------Edges-} {$region -fold}
                  with eds_img_arr[i],local_prop do
                    if (eds_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                      begin
                        lazy_repaint_prev:=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                        RepSplineEds  (i);
                        AddSplineEds03(i);
                        CrtSplineEds  (i);
                      end; {$endregion}
                  {---------------------Points} {$region -fold}
                  with pts_img_arr[i],local_prop do
                    if (pts_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                      begin
                        lazy_repaint_prev:=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                        AddSplineDupPts2(i);
                        RepSplinePts    (i);
                        AddSplinePts2   (i);
                        CrtSplinePts    (i);
                        ClrSplineDupPts2(i);
                      end; {$endregion}
                end;
            end;
        end;
      if (not is_not_abst_obj_kind_after) then
        FilScene(sel_obj_min_ind,obj_var.obj_cnt-1);
      SelPvtAndSplineEdsToBmp;
      SelPtsIndsToFalse1;
      pvt_pos_last:=pvt_pos;
      pts_mod_calc:=(pvt_pos_last.x<>pvt_pos_first.x) or
                    (pvt_pos_last.y<>pvt_pos_first.y);
      {Check Grid Clipping}
      for i:=0 to sln_obj_cnt-1 do
        if (has_sel_pts[i]<>0) then
          begin
            has_mod_pts0[i]:=
            has_sel_pts [i];
          end;
      {Check Hidden Lines}
      if pts_mod_calc then
        for i:=0 to sln_obj_cnt-1 do
          if (has_sel_pts[i]<>0) then
            begin
              has_mod_pts1[i]:=
              has_sel_pts [i];
            end;
      FillByte (has_sel_pts    [0],Length(has_sel_pts    ),0);
      FillDWord(sln_sel_pts_cnt[0],Length(sln_sel_pts_cnt),0);
      crc_sel_rct               :=Default(TRect  );
      pvt_pos                   :=Default(TPtPosF);
      move_pvt                  :=False;
      pvt_to_pt                 :=False;
      pvt_marker_draw           :=False;
      need_align_pivot_x        :=False;
      need_align_pivot_y        :=False;
      need_align_pivot_p        :=False;
      need_align_pivot_p2       :=False;
      is_not_abst_obj_kind_after:=True;
      sln_with_sel_pts_cnt      :=0;
      sel_pts_cnt               :=0;
      outer_subgraph1_eds_cnt   :=0;
      outer_subgraph2_eds_cnt   :=0;
      outer_subgraph3_eds_cnt   :=0;
      inner_subgraph__eds_cnt   :=0;
      exp0                      :=(sel_pts_cnt>0);
    end;
end; {$endregion}
{Add Spline: Calculation-------------------------}
procedure TSurface.AddSplineCalc;                                                     {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (not show_spline) then
    Exit;
  with obj_var,sln_var do
    begin
      Add(kooCurve,world_axis_shift);
      SetObjBkgnd
      (
        @obj_arr[obj_cnt-1],
        low_bmp_ptr,
        low_bmp.width,
        low_bmp.height,
        @inn_wnd_rct
      );
      AddSplineObj;
      CreateNode('Spline',IntToStr(obj_var.curve_cnt)+' ');
      ObjIndsCalc;
      ScTIndsCalc;
      CngPnVsCalc;
      ChsDataCalc;
      VisObjArrCrt2;
      ObjectTagsListRepaint;
      if      (obj_arr[obj_cnt-1].anim_type<>ltStatic) or
        (not ((obj_arr[obj_cnt-1].parallax_shift.x=obj_arr[0].parallax_shift.x) and
              (obj_arr[obj_cnt-1].parallax_shift.y=obj_arr[0].parallax_shift.y))) then
        SetObjBkgnd
        (
          @obj_arr[obj_cnt-1],
          srf_bmp_ptr,
          srf_bmp.width,
          srf_bmp.height,
          @inn_wnd_rct
        );
    end;
end; {$endregion}
{Add Spline: Hidden Lines Calc.------------------}
procedure TSurface.AddSplineHdLn;                                                     {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (not show_spline) then
    Exit;
  with sln_var do
    begin
      {Edges}
      with eds_img_arr[sln_obj_cnt-1],local_prop do
        if hid_ln_elim then
          begin
            ArrClr        (eds_useless_fld_arr,
                           rct_clp_ptr^,
                           srf_bmp.width,
                           0);
            AddSplineEds07(sln_obj_cnt-1);
            ArrFil        (useless_arr,
                           @eds_useless_fld_arr[0],
                           srf_bmp.width,
                           srf_bmp.height,
                           rct_clp_ptr^);
            hid_ln_cnt   :=sln_obj_pts_cnt          [sln_obj_cnt-1]-ArrNzItCnt(@has_edge[partial_pts_sum[sln_obj_cnt-1]],
                                                                               @useless_arr[0],
                                                                               sln_obj_pts_cnt[sln_obj_cnt-1]-1)-1;
            vis_ln_cnt   :=sln_obj_pts_cnt          [sln_obj_cnt-1]-hid_ln_cnt-1;
            if (hid_ln_cnt=0) then
              Exit;
            SetLength     (sln_vis_eds_ind          [sln_obj_cnt-1],
                           vis_ln_cnt);
            ArrNzItCrt    (@has_edge[partial_pts_sum[sln_obj_cnt-1]],
                           @useless_arr[0],
                           @sln_vis_eds_ind[sln_obj_cnt-1,0],
                           sln_obj_pts_cnt [sln_obj_cnt-1]-1,
                           vis_ln_cnt);
          end;
    end;
end; {$endregion}
{Add Spline: Has Edge(Lines) Calc.---------------}
procedure TSurface.AddSplineHsLn;                                                     {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  sln_var.HasSplineEds(sln_var.sln_obj_cnt-1);
end; {$endregion}
{Add Spline: Drawing-----------------------------}
procedure TSurface.AddSplineDraw;                                                     {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (not show_spline) then
    Exit;
  with sln_var do
    begin
      {Bounding Rectangles: Edges-} {$region -fold}
      with rct_eds_img_arr[sln_obj_cnt-1],local_prop do
        if lazy_repaint then
          begin
            if rct_eds_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^)) then
              begin
                lazy_repaint_prev:=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                AddSplineRctEds(sln_obj_cnt-1);
                CrtSplineRctEds(sln_obj_cnt-1);
              end
            else
              lazy_repaint_prev:=False;
          end; {$endregion}
      {Bounding Rectangles: Points} {$region -fold}
      with rct_pts_img_arr[sln_obj_cnt-1],local_prop do
        if lazy_repaint then
          begin
            if rct_pts_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^)) then
              begin
                lazy_repaint_prev:=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                AddSplineRctPts(sln_obj_cnt-1);
                CrtSplineRctPts(sln_obj_cnt-1);
              end
            else
              lazy_repaint_prev:=False;
          end; {$endregion}
      {---------------------Edges-} {$region -fold}
      with eds_img_arr[sln_obj_cnt-1],local_prop do
        if lazy_repaint then
          begin
            if eds_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^)) then
              begin
                lazy_repaint_prev:=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                if lazy_repaint_prev then
                  begin
                    if byte_mode then
                      begin
                        if (not better_quality) then
                          begin
                            if hid_ln_elim then
                              begin
                                if (hid_ln_cnt=0) then
                                  AddSplineEds15(sln_obj_cnt-1)
                                else
                                  AddSplineEds11(sln_obj_cnt-1);
                              end
                            else
                              AddSplineEds09(sln_obj_cnt-1);
                          end
                        else
                          begin
                            if hid_ln_elim then
                              begin
                                if (hid_ln_cnt=0) then
                                  AddSplineEds21(sln_obj_cnt-1)
                                else
                                  AddSplineEds19(sln_obj_cnt-1);
                              end
                            else
                              AddSplineEds17(sln_obj_cnt-1);
                          end;
                      end
                    else
                      begin
                        if hid_ln_elim then
                          begin
                            if (hid_ln_cnt=0) then
                              AddSplineEds13(sln_obj_cnt-1)
                            else
                              AddSplineEds06(sln_obj_cnt-1);
                          end
                        else
                          AddSplineEds01(sln_obj_cnt-1);
                      end;
                  end
                else
                  begin
                    if byte_mode then
                      begin
                        if (not better_quality) then
                          begin
                            if hid_ln_elim then
                              begin
                                if (hid_ln_cnt=0) then
                                  AddSplineEds14(sln_obj_cnt-1)
                                else
                                  AddSplineEds10(sln_obj_cnt-1);
                              end
                            else
                              AddSplineEds08(sln_obj_cnt-1);
                          end
                        else
                          begin
                            if hid_ln_elim then
                              begin
                                if (hid_ln_cnt=0) then
                                  AddSplineEds20(sln_obj_cnt-1)
                                else
                                  AddSplineEds18(sln_obj_cnt-1);
                              end
                            else
                              AddSplineEds16(sln_obj_cnt-1);
                          end;
                      end
                    else
                      begin
                        if hid_ln_elim then
                          begin
                            if (hid_ln_cnt=0) then
                              AddSplineEds12(sln_obj_cnt-1)
                            else
                              AddSplineEds05(sln_obj_cnt-1);
                          end
                        else
                          AddSplineEds00(sln_obj_cnt-1);
                      end;
                  end;
                CrtSplineEds   (sln_obj_cnt-1);
              end
            else
              lazy_repaint_prev:=False;
          end; {$endregion}
      {---------------------Points} {$region -fold}
      with pts_img_arr[sln_obj_cnt-1],local_prop do
        if lazy_repaint then
          begin
            if pts_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^)) then
              begin
                lazy_repaint_prev:=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                AddSplineDupPts0(sln_obj_cnt-1);
                if byte_mode then
                  AddSplinePts4 (sln_obj_cnt-1)
                else
                  AddSplinePts0 (sln_obj_cnt-1);
                CrtSplinePts    (sln_obj_cnt-1);
                ClrSplineDupPts0(sln_obj_cnt-1);
              end
            else
              lazy_repaint_prev:=False;
          end; {$endregion}
    end;
end; {$endregion}
{Add Tile Map: Calculation-----------------------}
procedure TSurface.AddTileMapCalc;                                                    {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (not show_tile_map) then
    Exit;
  with obj_var,tlm_var do
    begin
      Add(kooTlMap,world_axis_shift);
      SetObjBkgnd
      (
        @obj_arr[obj_cnt-1],
        low_bmp_ptr,
        low_bmp.width,
        low_bmp.height,
        @inn_wnd_rct
      );
      AddTileMapObj;
      CreateNode('Tile Map',IntToStr(obj_var.tlmap_cnt)+' ');
      ObjIndsCalc;
      ScTIndsCalc;
      CngPnVsCalc;
      ChsDataCalc;
      VisObjArrCrt2;
      ObjectTagsListRepaint;
      if    {((obj_arr[obj_cnt-1].obj_show and %00010000)<>(obj_arr[0].obj_show and %00010000)) or}
              (obj_arr[obj_cnt-1].anim_type<>ltStatic) or
        (not ((obj_arr[obj_cnt-1].parallax_shift.x=obj_arr[0].parallax_shift.x) and
              (obj_arr[obj_cnt-1].parallax_shift.y=obj_arr[0].parallax_shift.y))) then
        SetObjBkgnd
        (
          @obj_arr[obj_cnt-1],
          srf_bmp_ptr,
          srf_bmp.width,
          srf_bmp.height,
          @inn_wnd_rct
        );
    end;
end; {$endregion}
{Add Post-Process FX: Calculation----------------}
procedure TSurface.AddPProcFXCalc;                                                    {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with obj_var,ppr_var do
    begin
      Add(kooPProc,world_axis_shift);
      SetObjBkgnd
      (
        @obj_arr[obj_cnt-1],
        low_bmp_ptr,
        low_bmp.width,
        low_bmp.height,
        @inn_wnd_rct
      );
      AddPProcObj;
      CreateNode('Post-process',IntToStr(pproc_cnt)+' ');
      ObjIndsCalc;
      ScTIndsCalc;
      CngPnVsCalc;
      ChsDataCalc;
      VisObjArrCrt2;
      ObjectTagsListRepaint;
    end;
end; {$endregion}
{Scale Spline: Calculation-----------------------}
procedure TSurface.SclSplineCalc;                                                     {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_var do
    begin
      PtsScl
      (
        PtPosF(world_axis.x,
               world_axis.y),
        sln_pts,
        cmr_var.scl_mul,
        cmr_var.scl_dir,
        0,
        sln_pts_cnt-1
      );
      SclMulDifCalc
      (
        cmr_var.scl_mul,
        cmr_var.scl_dir
      );
    end;
end; {$endregion}
{Repaint Splines with Hidden Lines---------------}
procedure TSurface.RepSplineHdLn;                                                     {$ifdef Linux}[local];{$endif} {$region -fold}
var
  eds_img_arr_ptr        : PFastLine;
  eds_useless_fld_arr_ptr: PInteger;
  i                      : integer;
begin
  if (not show_spline) then
    Exit;
  with sln_var do
    begin
      eds_img_arr_ptr        :=Unaligned(@eds_img_arr        [0]);
      eds_useless_fld_arr_ptr:=Unaligned(@eds_useless_fld_arr[0]);
      for i:=0 to sln_obj_cnt-1 do
        with (eds_img_arr_ptr+i)^,local_prop do
          if hid_ln_elim and (has_mod_pts1[i]<>0) then
            begin
              ArrClr       (eds_useless_fld_arr,
                            rct_clp_ptr^,
                            srf_bmp.width,
                            0);
              AddSplineEds07(i);
              ArrFil       (useless_arr,
                            eds_useless_fld_arr_ptr,
                            srf_bmp.width,
                            srf_bmp.height,
                            rct_clp_ptr^);
              hid_ln_cnt  :=sln_obj_pts_cnt[i]-ArrNzItCnt(@has_edge[partial_pts_sum[i]],
                                                          @useless_arr[0],
                                                          sln_obj_pts_cnt[i]-1)-1;
              vis_ln_cnt  :=sln_obj_pts_cnt[i]-hid_ln_cnt-1;
              if (hid_ln_cnt=0) then
                Exit;
              SetLength    (sln_vis_eds_ind[i],
                            vis_ln_cnt);
              ArrNzItCrt   (@has_edge[partial_pts_sum[i]],
                            @useless_arr[0],
                            @sln_vis_eds_ind[i,0],
                            sln_obj_pts_cnt [i]-1,
                            vis_ln_cnt);
              has_mod_pts1[i]:=0;
            end;
    end;
end; {$endregion}
{Repaint Splines: Points Grid Clipping-----------}
procedure TSurface.RepSplinePtsGrd;                                                   {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_img_arr_ptr: PFastLine;
  i              : integer;
begin
  if (not show_spline) then
    Exit;
  with sln_var do
    begin
      pts_img_arr_ptr:=Unaligned(@pts_img_arr[0]);
      for i:=0 to sln_obj_cnt-1 do
        with (pts_img_arr_ptr+i)^,local_prop do
          if grid_clipping_pts and (has_mod_pts0[i]<>0) then
            begin
              GrdSplineCalc(i);
              has_mod_pts0[i]:=0;
            end;
    end;
end; {$endregion}
{Repaint Spline: Drawing-------------------------}
procedure TSurface.RepSplineDraw0;                                                    {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_eds_img_ptr: PFastImageItem;
  rct_pts_img_ptr: PFastImageItem;
      eds_img_ptr: PFastImageItem;
      pts_img_ptr: PFastImageItem;
  rct_eds_var_ptr: PFastLine;
  rct_pts_var_ptr: PFastLine;
      eds_var_ptr: PFastLine;
      pts_var_ptr: PFastLine;
  i              : integer;
  b              : boolean;
  b0 ,b1 ,b2 ,b3 : boolean;
  b0_,b1_,b2_,b3_: boolean;
  editor_or_game : set of byte;
label
  l0,l1,l2,l3;
begin
  if (not show_spline) then
    Exit;
  with obj_var,sln_var,fast_image_proc_var do
    begin
      editor_or_game :=[3,1+Byte(res_var_ptr^)];
      rct_eds_var_ptr:=Unaligned(@rct_eds_img_arr[0]);
      rct_pts_var_ptr:=Unaligned(@rct_pts_img_arr[0]);
          eds_var_ptr:=Unaligned(@    eds_img_arr[0]);
          pts_var_ptr:=Unaligned(@    pts_img_arr[0]);
      b              :=repaint_spline_forced_calc or spline_scale_calc or ((not repaint_spline_hid_ln_calc1) and repaint_spline_hid_ln_calc2);
      for i:=0 to sln_obj_cnt-1 do
        if ((obj_arr[curve_inds_obj_arr[i]].obj_show and %00000011) in editor_or_game) then
          begin
            b:=b or Boolean(obj_arr[curve_inds_obj_arr[i]].obj_show and %00000100);
            {Bounding Rectangles: Edges-} {$region -fold}
            rct_eds_img_ptr:=@sprite_sheet_arr[rct_eds_ind_arr[i]];
            with (rct_eds_var_ptr+i)^,local_prop,rct_eds_img_ptr^ do
              if lazy_repaint then
                begin
                  if (rct_eds_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                    begin
                      b0 :=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                      if (not b0) then
                        begin
                          lazy_repaint_prev:=False;
                          goto l0;
                        end;
                      b0_:=(not b0){clipped} or (b0 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                      if b0_ then
                        begin
                          if free_mem_on_scale_down and (rct_eds_img_ptr^<>Nil) then
                            begin
                              fast_image_data_ptr0:=@fast_image_data;
                              ClrArr;
                            end;
                          AddSplineRctEds(i);
                          CrtSplineRctEds(i);
                        end;
                      lazy_repaint_prev:=b0;
                    end
                  else
                    begin
                      if free_mem_on_out_of_wnd and (rct_eds_img_ptr^<>Nil) then
                        begin
                          fast_image_data_ptr0:=@fast_image_data;
                          ClrArr;
                        end;
                      lazy_repaint_prev:=False;
                    end;
                end;
            l0: {$endregion}
            {Bounding Rectangles: Points} {$region -fold}
            rct_pts_img_ptr:=@sprite_sheet_arr[rct_pts_ind_arr[i]];
            with (rct_pts_var_ptr+i)^,local_prop,rct_pts_img_ptr^ do
              if lazy_repaint then
                begin
                  if (rct_pts_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                    begin
                      b1 :=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                      if (not b1) then
                        begin
                          lazy_repaint_prev:=False;
                          goto l1;
                        end;
                      b1_:=(not b1){clipped} or (b1 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                      if b1_ then
                        begin
                          if free_mem_on_scale_down and (rct_pts_img_ptr^<>Nil) then
                            begin
                              fast_image_data_ptr0:=@fast_image_data;
                              ClrArr;
                            end;
                          AddSplineRctPts(i);
                          CrtSplineRctPts(i);
                        end;
                      lazy_repaint_prev:=b1;
                    end
                  else
                    begin
                      if free_mem_on_out_of_wnd and (rct_pts_img_ptr^<>Nil) then
                        begin
                          fast_image_data_ptr0:=@fast_image_data;
                          ClrArr;
                        end;
                      lazy_repaint_prev:=False;
                    end;
                end;
            l1: {$endregion}
            {---------------------Edges-} {$region -fold}
            eds_img_ptr:=@sprite_sheet_arr[eds_ind_arr[i]];
            with (eds_var_ptr+i)^,local_prop,eds_img_ptr^ do
              if lazy_repaint then
                begin
                  if (eds_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                    begin
                      b2 :=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                      if (not b2) then
                        begin
                          lazy_repaint_prev:=False;
                          goto l2;
                        end;
                      b2_:=(not b2){clipped} or (b2 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                      if b2_ then
                        begin
                          if free_mem_on_scale_down and (eds_img_ptr^<>Nil) then
                            begin
                              fast_image_data_ptr0:=@fast_image_data;
                              ClrArr;
                            end;
                          //if ((has_sel_pts_ptr+i)^=0) then
                            begin
                              if b2 then
                                begin
                                  if byte_mode then
                                    begin
                                      if (not better_quality) then
                                        begin
                                          if hid_ln_elim then
                                            begin
                                              if (hid_ln_cnt=0) then
                                                AddSplineEds15(i)
                                              else
                                                AddSplineEds11(i);
                                            end
                                          else
                                            AddSplineEds09(i);
                                        end
                                      else
                                        begin
                                          if hid_ln_elim then
                                            begin
                                              if (hid_ln_cnt=0) then
                                                AddSplineEds21(i)
                                              else
                                                AddSplineEds19(i);
                                            end
                                          else
                                            AddSplineEds17(i);
                                        end;
                                    end
                                  else
                                    begin
                                      if hid_ln_elim then
                                        begin
                                          if (hid_ln_cnt=0) then
                                            AddSplineEds13(i)
                                          else
                                            AddSplineEds06(i);
                                        end
                                      else
                                        AddSplineEds01(i);
                                    end;
                                end
                              else
                                begin
                                  if byte_mode then
                                    begin
                                      if (not better_quality) then
                                        begin
                                          if hid_ln_elim then
                                            begin
                                              if (hid_ln_cnt=0) then
                                                AddSplineEds14(i)
                                              else
                                                AddSplineEds10(i);
                                            end
                                          else
                                            AddSplineEds08(i);
                                        end
                                      else
                                        begin
                                          if hid_ln_elim then
                                            begin
                                              if (hid_ln_cnt=0) then
                                                AddSplineEds20(i)
                                              else
                                                AddSplineEds18(i);
                                            end
                                          else
                                            AddSplineEds16(i);
                                        end;
                                    end
                                  else
                                    begin
                                      if hid_ln_elim then
                                        begin
                                          if (hid_ln_cnt=0) then
                                            AddSplineEds12(i)
                                          else
                                            AddSplineEds05(i);
                                        end
                                      else
                                        AddSplineEds00(i);
                                    end;
                                end;
                            end;
                          CrtSplineEds(i);
                        end;
                      lazy_repaint_prev:=b2;
                    end
                  else
                    begin
                      if free_mem_on_out_of_wnd and (eds_img_ptr^<>Nil) then
                        begin
                          fast_image_data_ptr0:=@fast_image_data;
                          ClrArr;
                        end;
                      lazy_repaint_prev:=False;
                    end;
                end;
            l2: {$endregion}
            {---------------------Points} {$region -fold}
            pts_img_ptr:=@sprite_sheet_arr[pts_ind_arr[i]];
            with (pts_var_ptr+i)^,local_prop,pts_img_ptr^ do
              if lazy_repaint then
                begin
                  if (pts_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                    begin
                      b3 :=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                      if (not b3) then
                        begin
                          lazy_repaint_prev:=False;
                          goto l3;
                        end;
                      b3_:=(not b3){clipped} or (b3 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                      if b3_ then
                        begin
                          if free_mem_on_scale_down and (pts_img_ptr^<>Nil) then
                            begin
                              fast_image_data_ptr0:=@fast_image_data;
                              ClrArr;
                            end;
                          AddSplineDupPts0(i);
                          if byte_mode then
                            AddSplinePts4 (i)
                          else
                            AddSplinePts0 (i);
                          ClrSplineDupPts0(i);
                          CrtSplinePts    (i);
                        end;
                      lazy_repaint_prev:=b3;
                    end
                  else
                    begin
                      if free_mem_on_out_of_wnd and (pts_img_ptr^<>Nil) then
                        begin
                          fast_image_data_ptr0:=@fast_image_data;
                          ClrArr;
                        end;
                      lazy_repaint_prev:=False;
                    end;
                end;
            l3: {$endregion}
          end;
    end;
end; {$endregion}
procedure TSurface.RepSplineDraw1;                                                    {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_eds_img_ptr: PFastImageItem;
  rct_pts_img_ptr: PFastImageItem;
      eds_img_ptr: PFastImageItem;
      pts_img_ptr: PFastImageItem;
  rct_eds_var_ptr: PFastLine;
  rct_pts_var_ptr: PFastLine;
      eds_var_ptr: PFastLine;
      pts_var_ptr: PFastLine;
  i,j            : integer;
  editor_or_game : set of byte;
begin
  if (not show_spline) then
    Exit;
  with obj_var,sln_var,fast_image_proc_var do
    begin
      if (upp_lr_obj_cnt=0) then
        Exit;
      editor_or_game :=[3,1+Byte(res_var_ptr^)];
      rct_eds_var_ptr:=Unaligned(@rct_eds_img_arr[0]);
      rct_pts_var_ptr:=Unaligned(@rct_pts_img_arr[0]);
          eds_var_ptr:=Unaligned(@    eds_img_arr[0]);
          pts_var_ptr:=Unaligned(@    pts_img_arr[0]);
      for i:=0 to sln_obj_cnt-1 do
        begin
          j:=obj_arr[curve_inds_obj_arr[i]].t_ind;
          if (j>=low_lr_obj_cnt) and (j<=obj_cnt-1) and ((obj_arr[curve_inds_obj_arr[i]].obj_show and %00000011) in editor_or_game) then
            begin
              {Bounding Rectangles: Edges-} {$region -fold}
              rct_eds_img_ptr:=@sprite_sheet_arr[rct_eds_ind_arr[i]];
              with (rct_eds_var_ptr+i)^,local_prop,rct_eds_img_ptr^ do
                if lazy_repaint then
                  if rct_eds_show then
                    begin
                      if IsRct1InRct2(rct_ent_2,rct_clp_ptr^) then
                        begin
                          if (not lazy_repaint_prev) and
                             (fast_image_data.nt_pix_cnt=0) and
                             (fast_image_data.pt_pix_cnt=0) then
                            begin
                              AddSplineRctEds(i);
                              CrtSplineRctEds(i);
                              lazy_repaint_prev:=True;
                            end;
                        end
                      else
                      if IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^) then
                        begin
                          if free_mem_on_scale_down and (rct_eds_img_ptr^<>Nil) then
                            begin
                              fast_image_data_ptr0:=@fast_image_data;
                              ClrArr;
                              lazy_repaint_prev:=False;
                            end;
                        end;
                    end; {$endregion}
              {Bounding Rectangles: Points} {$region -fold}
              rct_pts_img_ptr:=@sprite_sheet_arr[rct_pts_ind_arr[i]];
              with (rct_pts_var_ptr+i)^,local_prop,rct_pts_img_ptr^ do
                if rct_pts_show then
                  if lazy_repaint then
                    begin
                      if IsRct1InRct2(rct_ent_2,rct_clp_ptr^) then
                        begin
                          if (not lazy_repaint_prev) and
                             (fast_image_data.nt_pix_cnt=0) and
                             (fast_image_data.pt_pix_cnt=0) then
                            begin
                              AddSplineRctPts(i);
                              CrtSplineRctPts(i);
                              lazy_repaint_prev:=True;
                            end;
                        end
                      else
                      if IsRct1OutOfRct2 (rct_ent_2,rct_clp_ptr^) then
                        begin
                          if free_mem_on_scale_down and (rct_pts_img_ptr^<>Nil) then
                            begin
                              fast_image_data_ptr0:=@fast_image_data;
                              ClrArr;
                              lazy_repaint_prev:=False;
                            end;
                        end;
                    end; {$endregion}
              {---------------------Edges-} {$region -fold}
              eds_img_ptr:=@sprite_sheet_arr[eds_ind_arr[i]];
              with (eds_var_ptr+i)^,local_prop,eds_img_ptr^ do
                if eds_show then
                  if lazy_repaint then
                    begin
                      if IsRct1InRct2(rct_ent_2,rct_clp_ptr^) then
                        begin
                          if (not lazy_repaint_prev) and
                             (fast_image_data.nt_pix_cnt=0) and
                             (fast_image_data.pt_pix_cnt=0) then
                            begin
                              if byte_mode then
                                begin
                                  if (not better_quality) then
                                    begin
                                      if hid_ln_elim then
                                        begin
                                          if (hid_ln_cnt=0) then
                                            AddSplineEds15(i)
                                          else
                                            AddSplineEds11(i);
                                        end
                                      else
                                        AddSplineEds09(i);
                                    end
                                  else
                                    begin
                                      if hid_ln_elim then
                                        begin
                                          if (hid_ln_cnt=0) then
                                            AddSplineEds21(i)
                                          else
                                            AddSplineEds19(i);
                                        end
                                      else
                                        AddSplineEds17(i);
                                    end;
                                end
                              else
                                begin
                                  if hid_ln_elim then
                                    begin
                                      if (hid_ln_cnt=0) then
                                        AddSplineEds13(i)
                                      else
                                        AddSplineEds06(i);
                                    end
                                  else
                                    AddSplineEds01(i);
                                end;
                            CrtSplineEds(i);
                            lazy_repaint_prev:=True;
                          end;
                        end
                      else
                      if IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^) then
                        begin
                          if free_mem_on_scale_down and (eds_img_ptr^<>Nil) then
                            begin
                              fast_image_data_ptr0:=@fast_image_data;
                              ClrArr;
                              lazy_repaint_prev:=False;
                            end;
                        end;
                    end; {$endregion}
              {---------------------Points} {$region -fold}
              pts_img_ptr:=@sprite_sheet_arr[pts_ind_arr[i]];
              with (pts_var_ptr+i)^,local_prop,pts_img_ptr^ do
                if pts_show then
                  if lazy_repaint then
                    begin
                      if IsRct1InRct2(rct_ent_2,rct_clp_ptr^) then
                        begin
                          if (not lazy_repaint_prev) and
                             (fast_image_data.nt_pix_cnt=0) and
                             (fast_image_data.pt_pix_cnt=0) then
                            begin
                              AddSplineDupPts0(i);
                              if byte_mode then
                                AddSplinePts4 (i)
                              else
                                AddSplinePts0 (i);
                              ClrSplineDupPts0(i);
                              CrtSplinePts(i);
                              lazy_repaint_prev:=True;
                            end;
                        end
                      else
                      if IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^) then
                        begin
                          if free_mem_on_scale_down and (pts_img_ptr^<>Nil) then
                            begin
                              fast_image_data_ptr0:=@fast_image_data;
                              ClrArr;
                              lazy_repaint_prev:=False;
                            end;
                        end;
                    end; {$endregion}
            end;
        end;
    end;
end; {$endregion}
procedure TSurface.RepSplineDraw2;                                                    {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_eds_img_ptr: PFastImageItem;
  rct_pts_img_ptr: PFastImageItem;
      eds_img_ptr: PFastImageItem;
      pts_img_ptr: PFastImageItem;
  rct_eds_var_ptr: PFastLine;
  rct_pts_var_ptr: PFastLine;
      eds_var_ptr: PFastLine;
      pts_var_ptr: PFastLine;
  i,j            : integer;
  b              : boolean;
  b0 ,b1 ,b2 ,b3 : boolean;
  b0_,b1_,b2_,b3_: boolean;
  editor_or_game : set of byte;
label
  l0,l1,l2,l3;
begin
  if (not show_spline) then
    Exit;
  with obj_var,sln_var,fast_image_proc_var do
    begin
      if (upp_lr_obj_cnt=0) then
        Exit;
      editor_or_game :=[3,1+Byte(res_var_ptr^)];
      rct_eds_var_ptr:=Unaligned(@rct_eds_img_arr[0]);
      rct_pts_var_ptr:=Unaligned(@rct_pts_img_arr[0]);
          eds_var_ptr:=Unaligned(@    eds_img_arr[0]);
          pts_var_ptr:=Unaligned(@    pts_img_arr[0]);
      b              :=repaint_spline_forced_calc or spline_scale_calc or ((not repaint_spline_hid_ln_calc1) and repaint_spline_hid_ln_calc2);
      for i:=0 to sln_obj_cnt-1 do
        begin
          j:=obj_arr[curve_inds_obj_arr[i]].t_ind;
          if (j>=low_lr_obj_cnt) and (j<=obj_cnt-1) and ((obj_arr[curve_inds_obj_arr[i]].obj_show and %00000011) in editor_or_game) then
            begin
              b:=b or Boolean(obj_arr[curve_inds_obj_arr[i]].obj_show and %00000100);
              {Bounding Rectangles: Edges-} {$region -fold}
              rct_eds_img_ptr:=@sprite_sheet_arr[rct_eds_ind_arr[i]];
              with (rct_eds_var_ptr+i)^,local_prop,rct_eds_img_ptr^ do
                if lazy_repaint then
                  begin
                    if (rct_eds_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                      begin
                        b0 :=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                        if (not b0) then
                          begin
                            lazy_repaint_prev:=False;
                            goto l0;
                          end;
                        b0_:=(not b0){clipped} or (b0 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                        if b0_ then
                          begin
                            if free_mem_on_scale_down and (rct_eds_img_ptr^<>Nil) then
                              begin
                                fast_image_data_ptr0:=@fast_image_data;
                                ClrArr;
                              end;
                            AddSplineRctEds(i);
                            CrtSplineRctEds(i);
                          end;
                        lazy_repaint_prev:=b0;
                      end
                    else
                      begin
                        if free_mem_on_out_of_wnd and (rct_eds_img_ptr^<>Nil) then
                          begin
                            fast_image_data_ptr0:=@fast_image_data;
                            ClrArr;
                          end;
                        lazy_repaint_prev:=False;
                      end;
                  end;
              l0: {$endregion}
              {Bounding Rectangles: Points} {$region -fold}
              rct_pts_img_ptr:=@sprite_sheet_arr[rct_pts_ind_arr[i]];
              with (rct_pts_var_ptr+i)^,local_prop,rct_pts_img_ptr^ do
                if lazy_repaint then
                  begin
                    if (rct_pts_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                      begin
                        b1 :=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                        if (not b1) then
                          begin
                            lazy_repaint_prev:=False;
                            goto l1;
                          end;
                        b1_:=(not b1){clipped} or (b1 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                        if b1_ then
                          begin
                            if free_mem_on_scale_down and (rct_pts_img_ptr^<>Nil) then
                              begin
                                fast_image_data_ptr0:=@fast_image_data;
                                ClrArr;
                              end;
                            AddSplineRctPts(i);
                            CrtSplineRctPts(i);
                          end;
                        lazy_repaint_prev:=b1;
                      end
                    else
                      begin
                        if free_mem_on_out_of_wnd and (rct_pts_img_ptr^<>Nil) then
                          begin
                            fast_image_data_ptr0:=@fast_image_data;
                            ClrArr;
                          end;
                        lazy_repaint_prev:=False;
                      end;
                  end;
              l1: {$endregion}
              {---------------------Edges-} {$region -fold}
              eds_img_ptr:=@sprite_sheet_arr[eds_ind_arr[i]];
              with (eds_var_ptr+i)^,local_prop,eds_img_ptr^ do
                if lazy_repaint then
                  begin
                    if (eds_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                      begin
                        b2 :=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                        if (not b2) then
                          begin
                            lazy_repaint_prev:=False;
                            goto l2;
                          end;
                        b2_:=(not b2){clipped} or (b2 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                        if b2_ then
                          begin
                            if free_mem_on_scale_down and (eds_img_ptr^<>Nil) then
                              begin
                                fast_image_data_ptr0:=@fast_image_data;
                                ClrArr;
                              end;
                            if b2 then
                              begin
                                if byte_mode then
                                  begin
                                    if (not better_quality) then
                                      begin
                                        if hid_ln_elim then
                                          begin
                                            if (hid_ln_cnt=0) then
                                              AddSplineEds15(i)
                                            else
                                              AddSplineEds11(i);
                                          end
                                        else
                                          AddSplineEds09(i);
                                      end
                                    else
                                      begin
                                        if hid_ln_elim then
                                          begin
                                            if (hid_ln_cnt=0) then
                                              AddSplineEds21(i)
                                            else
                                              AddSplineEds19(i);
                                          end
                                        else
                                          AddSplineEds17(i);
                                      end;
                                  end
                                else
                                  begin
                                    if hid_ln_elim then
                                      begin
                                        if (hid_ln_cnt=0) then
                                          AddSplineEds13(i)
                                        else
                                          AddSplineEds06(i);
                                      end
                                    else
                                      AddSplineEds01(i);
                                  end;
                              end
                            else
                              begin
                                if byte_mode then
                                  begin
                                    if (not better_quality) then
                                      begin
                                        if hid_ln_elim then
                                          begin
                                            if (hid_ln_cnt=0) then
                                              AddSplineEds14(i)
                                            else
                                              AddSplineEds10(i);
                                          end
                                        else
                                          AddSplineEds08(i);
                                      end
                                    else
                                      begin
                                        if hid_ln_elim then
                                          begin
                                            if (hid_ln_cnt=0) then
                                              AddSplineEds20(i)
                                            else
                                              AddSplineEds18(i);
                                          end
                                        else
                                          AddSplineEds16(i);
                                      end;
                                  end
                                else
                                  begin
                                    if hid_ln_elim then
                                      begin
                                        if (hid_ln_cnt=0) then
                                          AddSplineEds12(i)
                                        else
                                          AddSplineEds05(i);
                                      end
                                    else
                                      AddSplineEds00(i);
                                  end;
                              end;
                            CrtSplineEds(i);
                          end;
                        lazy_repaint_prev:=b2;
                      end
                    else
                      begin
                        if free_mem_on_out_of_wnd and (eds_img_ptr^<>Nil) then
                          begin
                            fast_image_data_ptr0:=@fast_image_data;
                            ClrArr;
                          end;
                        lazy_repaint_prev:=False;
                      end;
                  end;
              l2: {$endregion}
              {---------------------Points} {$region -fold}
              pts_img_ptr:=@sprite_sheet_arr[pts_ind_arr[i]];
              with (pts_var_ptr+i)^,local_prop,pts_img_ptr^ do
                if lazy_repaint then
                  begin
                    if (pts_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                      begin
                        b3 :=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                        if (not b3) then
                          begin
                            lazy_repaint_prev:=False;
                            goto l3;
                          end;
                        b3_:=(not b3){clipped} or (b3 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                        if b3_ then
                          begin
                            if free_mem_on_scale_down and (pts_img_ptr^<>Nil) then
                              begin
                                fast_image_data_ptr0:=@fast_image_data;
                                ClrArr;
                              end;
                            AddSplineDupPts0(i);
                            if byte_mode then
                              AddSplinePts4 (i)
                            else
                              AddSplinePts0 (i);
                            ClrSplineDupPts0(i);
                            CrtSplinePts(i);
                          end;
                        lazy_repaint_prev:=b3;
                      end
                    else
                      begin
                        if free_mem_on_out_of_wnd and (pts_img_ptr^<>Nil) then
                          begin
                            fast_image_data_ptr0:=@fast_image_data;
                            ClrArr;
                          end;
                        lazy_repaint_prev:=False;
                      end;
                  end;
              l3: {$endregion}
            end;
        end;
    end;
end; {$endregion}
procedure TSurface.RepSplineDraw3;                                                    {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_eds_img_ptr: PFastImageItem;
  rct_pts_img_ptr: PFastImageItem;
      eds_img_ptr: PFastImageItem;
      pts_img_ptr: PFastImageItem;
  rct_eds_var_ptr: PFastLine;
  rct_pts_var_ptr: PFastLine;
      eds_var_ptr: PFastLine;
      pts_var_ptr: PFastLine;
  has_sel_pts_ptr: PByte;
  i              : integer;
  b              : boolean;
  b0 ,b1 ,b2 ,b3 : boolean;
  b0_,b1_,b2_,b3_: boolean;
  editor_or_game : set of byte;
begin
  if (not show_spline) then
    Exit;
  with fast_image_proc_var,obj_var,sln_var do
    begin
      editor_or_game :=[3,1+Byte(res_var_ptr^)];
      rct_eds_var_ptr:=Unaligned(@rct_eds_img_arr[0]);
      rct_pts_var_ptr:=Unaligned(@rct_pts_img_arr[0]);
          eds_var_ptr:=Unaligned(@    eds_img_arr[0]);
          pts_var_ptr:=Unaligned(@    pts_img_arr[0]);
      has_sel_pts_ptr:=Unaligned(@has_sel_pts    [0]);
      b              :=repaint_spline_forced_calc or spline_scale_calc or (not repaint_spline_hid_ln_calc2);
      for i:=0 to sln_obj_cnt-1 do
        if ((obj_arr[curve_inds_obj_arr[i]].obj_show and %00000011) in editor_or_game) then
          begin
            b:=b or Boolean(obj_arr[curve_inds_obj_arr[i]].obj_show and %00000100);
            {Bounding Rectangles: Edges-} {$region -fold}
            rct_eds_img_ptr:=@sprite_sheet_arr[rct_eds_ind_arr[i]];
            with (rct_eds_var_ptr+i)^,local_prop,rct_eds_img_ptr^ do
              begin
                if (rct_eds_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                  begin
                    b0 :=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                    b0_:=(not b0){clipped} or (b0 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                    if b0_ then
                      begin
                        if free_mem_on_scale_down and (rct_eds_img_ptr^<>Nil) then
                          begin
                            fast_image_data_ptr0:=@fast_image_data;
                            ClrArr;
                          end;
                        AddSplineRctEds(i);
                        CrtSplineRctEds(i);
                      end;
                    lazy_repaint_prev:=b0;
                  end
                else
                  begin
                    if free_mem_on_out_of_wnd and (rct_eds_img_ptr^<>Nil) then
                      begin
                        fast_image_data_ptr0:=@fast_image_data;
                        ClrArr;
                      end;
                    lazy_repaint_prev:=False;
                  end;
              end; {$endregion}
            {Bounding Rectangles: Points} {$region -fold}
            rct_pts_img_ptr:=@sprite_sheet_arr[rct_pts_ind_arr[i]];
            with (rct_pts_var_ptr+i)^,local_prop,rct_pts_img_ptr^ do
              begin
                if (rct_pts_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                  begin
                    b1 :=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                    b1_:=(not b1){clipped} or (b1 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                    if b1_ then
                      begin
                        if free_mem_on_scale_down and (rct_pts_img_ptr^<>Nil) then
                          begin
                            fast_image_data_ptr0:=@fast_image_data;
                            ClrArr;
                          end;
                        AddSplineRctPts(i);
                        CrtSplineRctPts(i);
                      end;
                    lazy_repaint_prev:=b1;
                  end
                else
                  begin
                    if free_mem_on_out_of_wnd and (rct_pts_img_ptr^<>Nil) then
                      begin
                        fast_image_data_ptr0:=@fast_image_data;
                        ClrArr;
                      end;
                    lazy_repaint_prev:=False;
                  end;
              end; {$endregion}
            {---------------------Edges-} {$region -fold}
            eds_img_ptr:=@sprite_sheet_arr[eds_ind_arr[i]];
            with (eds_var_ptr+i)^,local_prop,eds_img_ptr^ do
              begin
                if (eds_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                  begin
                    b2 :=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                    b2_:=(not b2){clipped} or (b2 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                    if b2_ then
                      begin
                        if free_mem_on_scale_down and (eds_img_ptr^<>Nil) then
                          begin
                            fast_image_data_ptr0:=@fast_image_data;
                            ClrArr;
                          end;
                        if ((has_sel_pts_ptr+i)^=0) then
                          AddSplineEds00(i)
                        else
                          AddSplineEds02(i);
                        CrtSplineEds    (i);
                      end;
                    lazy_repaint_prev:=b2;
                  end
                else
                  begin
                    if free_mem_on_out_of_wnd and (eds_img_ptr^<>Nil) then
                      begin
                        fast_image_data_ptr0:=@fast_image_data;
                        ClrArr;
                      end;
                    lazy_repaint_prev:=False;
                  end;
              end; {$endregion}
            {---------------------Points} {$region -fold}
            pts_img_ptr:=@sprite_sheet_arr[pts_ind_arr[i]];
            with (pts_var_ptr+i)^,local_prop,pts_img_ptr^ do
              begin
                if (pts_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) then
                  begin
                    b3 :=IsRct1InRct2(rct_ent_2,rct_clp_ptr^);
                    b3_:=(not b3){clipped} or (b3 and (not lazy_repaint_prev)){not clipped, in window} or b or (not lazy_repaint);
                    if b3_ then
                      begin
                        if free_mem_on_scale_down and (pts_img_ptr^<>Nil) then
                          begin
                            fast_image_data_ptr0:=@fast_image_data;
                            ClrArr;
                          end;
                        if ((has_sel_pts_ptr+i)^=0) then
                          begin
                            AddSplineDupPts0(i);
                            AddSplinePts0   (i);
                            ClrSplineDupPts0(i);
                          end
                        else
                          begin
                            AddSplineDupPts1(i);
                            AddSplinePts1   (i);
                            ClrSplineDupPts1(i);
                          end;
                        CrtSplinePts(i);
                      end;
                    lazy_repaint_prev:=b3;
                  end
                else
                  begin
                    if free_mem_on_out_of_wnd and (pts_img_ptr^<>Nil) then
                      begin
                        fast_image_data_ptr0:=@fast_image_data;
                        ClrArr;
                      end;
                    lazy_repaint_prev:=False;
                  end;
              end; {$endregion}
        end;
    end;
end; {$endregion}
procedure TSurface.RepSplineDraw4;                                                    {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with obj_var,sln_var,sel_var do
    begin
      if rectangles_calc then
        RctSplineAll2(0,obj_cnt-1){RctSplineAll0(0,sln_obj_cnt-1)};
      if down_select_items_ptr^ and (not sel_pts) then
        RepSplineDraw3
      else
        RepSplineDraw2;
    end;
end; {$endregion}
{Duplicated Points: Drawing----------------------}
procedure TSurface.DupPtsDraw;                                                        {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_var do
    ArrFil(dup_pts_arr,srf_bmp_ptr,srf_bmp.width,srf_bmp.height,inn_wnd_rct,clGreen);
end; {$endregion}
{Sprite Sheet: Reset Background Settings---------}
procedure TSurface.SpriteSheetSetBckgd;                                               {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to Length(sprite_sheet_arr)-1 do
    with sprite_sheet_arr[i],fast_image_proc_var do
      begin
        fast_image_data_ptr0:=@fast_image_data;
        SetBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,inn_wnd_rct);
      end;
end; {$endregion}
{Actors      : Reset Background Settings---------}
procedure TSurface.ActSetBckgd;                                                       {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with fast_actor_set_var.d_icon,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      SetBkgnd(srf_bmp_ptr,srf_bmp.width,srf_bmp.height,inn_wnd_rct);
    end;
end; {$endregion}
{Selected Subgraph: Drawing----------------------}
procedure TSurface.SelectedSubgrtaphDraw;                                             {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sln_var,sel_var,pvt_var do
    begin
      //SelPtsPosCalc     (Trunc(pvt_pos.x),Trunc(pvt_pos.y));
      //WholeSubgraphDraw0(Trunc(pvt_pos.x),Trunc(pvt_pos.y),pvt_pos,sln_pts,srf_bmp_ptr,inn_wnd_rct,ClippedRct(inn_wnd_rct,sel_pts_rct));
      FillSelBmpAndSelPtsBRectDraw;
    end;
end; {$endregion}
{Background Post-Processing----------------------}
procedure TSurface.BkgPP;                                                             {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i:integer;
begin
  if (bg_style=bsGrayscale) or (bg_style=bsBoth) then
    PPGrayscaleG(srf_bmp_ptr,srf_bmp.width,inn_wnd_rct);
  if (bg_style=bsBlur) or (bg_style=bsBoth) then
    for i:=0 to pp_rep_cnt-1 do
      PPBlur(srf_bmp_ptr,srf_bmp.width,inn_wnd_rct,@BlurRGB4);
end; {$endregion}
{Main Render Procedure}
procedure TSurface.MainDraw;                                                          {$ifdef Linux}[local];{$endif} {$region -fold}
var
  exec_time,i: integer;
begin

  exec_timer.Start;

  {Calculation of Some Expressions}
  if (sel_var<>Nil) then
    begin
      exp0             :=(sel_var.sel_pts_cnt>0);
      sel_var.sel_pts  :=sel_var.sel_pts   and exp0;
      sel_eds_draw_calc:=sel_eds_draw_calc and exp0;
      bkg_pp_calc      :=bkg_pp_calc       and exp0;
    end;
  if (sln_var<>Nil) then
    repaint_spline_calc:=repaint_spline_calc and (sln_var.sln_pts_cnt>0) and (not add_spline_calc);
  if (down_play_anim_ptr<>Nil) then
    begin
      timeline_draw:=down_play_anim_ptr^;
      cursor_draw  :=down_play_anim_ptr^;
    end;

  {Scene scaling------------------------------------} {$region -fold}
  if scale_scene_calc then
    SceneSclPowCalc; {$endregion}

  {Rectangles---------------------------------------} {$region -fold}
  if main_bmp_rect_calc then
    MainBmpRectCalc0; {$endregion}

  {Sizes--------------------------------------------} {$region -fold}
  if main_bmp_size_calc then
    MainBmpSizeCalc; {$endregion}

  {Arrays-------------------------------------------} {$region -fold}
  if main_bmp_arrs_calc then
    MainBmpArrsCalc; {$endregion}

  {Handles -----------------------------------------} {$region -fold}
  if main_bmp_hndl_calc then
    GetHandles; {$endregion}

  {Set Surface Parameters---------------------------} {$region -fold}
  if set_surf_param00 then
    SetSurfParam0;
  if set_surf_param01 then
    SetSurfParam1;
  if set_surf_param02 then
    SetSurfParam2;
  if set_surf_param03 then
    SetSurfParam3; {$endregion}

  {Background Settings: Sprite Sheet----------------} {$region -fold}
  if sprite_sheet_set_bckgd then
    SpriteSheetSetBckgd; {$endregion}

  {Background Settings: Actors----------------------} {$region -fold}
  if actor_set_bckgd then
    ActSetBckgd; {$endregion}

  {Add Spline---------------------------------------} {$region -fold}
  if add_spline_calc then
    AddSplineCalc; {$endregion}

  {Scale Splines------------------------------------} {$region -fold}
  if spline_scale_calc then
    SclSplineCalc; {$endregion}

  {Align Splines------------------------------------} {$region -fold}
  if sgr_var.align_pts and align_pts_calc then
    AlnSplineCalc; {$endregion}

  {Add Tile Map-------------------------------------} {$region -fold}
  if add_tlmap_calc then
    AddTileMapCalc; {$endregion}

  {Add Post-Process---------------------------------} {$region -fold}
  if add_pproc_calc then
    AddPProcFXCalc; {$endregion}

  {Select Pivot-------------------------------------} {$region -fold}
  if sel_var.sel_pts then
    SelectPivotCalc; {$endregion}

  need_repaint:=True;

  {Select Pivot-------------------------------------} {$region -fold}
  if sel_var.sel_pts then
    SelectPivotDraw; {$endregion}

  {Unselect Pivot-----------------------------------} {$region -fold}
  if unselect_pivot_calc then
    UnselectPivotDraw; {$endregion}

  {Add Spline: Hidden Lines Calc.-------------------} {$region -fold}
  if add_hid_ln_calc then
    AddSplineHdLn; {$endregion}

  {Add Spline: Has Edge Calc.-----------------------} {$region -fold}
  if has_edge_calc then
    AddSplineHsLn; {$endregion}

  {Add Spline---------------------------------------} {$region -fold}
  if add_spline_calc then
    AddSplineDraw; {$endregion}

  {Repaint Splines: Hidden Lines--------------------} {$region -fold}
  if repaint_spline_hid_ln_calc0 then
    RepSplineHdLn; {$endregion}

  {Repaint Splines: Points Grid Clipping------------} {$region -fold}
  if pts_grd_calc then
    RepSplinePtsGrd; {$endregion}

  {Repaint Splines----------------------------------} {$region -fold}
  if repaint_spline_calc then
    RepSplineDraw4; {$endregion}

  {Scene Drawing(Lower Layer)-----------------------} {$region -fold}
  with obj_var,sel_var do
    if ((fill_scene_calc and is_not_abst_obj_kind_after and (not unselect_pivot_calc)) or main_bmp_hndl_calc or scale_scene_calc) then
      //if exp1 then
        FilScene(0,low_lr_obj_cnt-1); {$endregion}

  {Copy Lower Buffer To Main Buffer-----------------} {$region -fold}
  if lower_bmp_to_main_bmp_calc then
    LowerBmpToMainBmp; {$endregion}

  {Copy Main Buffer To Lower Buffer-----------------} {$region -fold}
  if copy1_calc then
    //if exp1 then
      MainBmpToLowerBmp; {$endregion}

  {Scene Drawing(Upper Layer)-----------------------} {$region -fold}
  with obj_var,sel_var do

    if not (reserved_4_calc and down_play_anim_ptr^) then

      if ((fill_scene_calc and is_not_abst_obj_kind_after and (not unselect_pivot_calc)) or main_bmp_hndl_calc or scale_scene_calc) {and (not down_play_anim_ptr^)} then
        FilScene(low_lr_obj_cnt,obj_cnt-1); {$endregion}

  {Background Post-Processing After Points Selection} {$region -fold}
  if bkg_pp_calc then
    BkgPP; {$endregion}

  {Copy Main Buffer To Lower Buffer-----------------} {$region -fold}
  if copy2_calc then
    MainBmpToLowerBmp; {$endregion}

  {World Axis---------------------------------------} {$region -fold}
  if show_world_axis and (not exp0) then
    WorldAxisDraw; {$endregion}

  {Copy Main Buffer To Lower Buffer-----------------} {$region -fold}
  if copy4_calc then
    MainBmpToLowerBmp; {$endregion}

  {Inner Window Rectangle---------------------------} {$region -fold}
  if (inn_wnd_mrg>0) then
    InnerWindowDraw($00FF9F66); {$endregion}

  {Copy Main Buffer To Lower Buffer-----------------} {$region -fold}
  if copy5_calc then
    MainBmpToLowerBmp; {$endregion}

  {Selected Subgraph--------------------------------} {$region -fold}
  if sel_eds_draw_calc then
    SelectedSubgrtaphDraw; {$endregion}

  {Copy Main Buffer To Lower Buffer-----------------} {$region -fold}
  if copy6_calc then
    MainBmpToLowerBmp; {$endregion}

  {Pivot--------------------------------------------} {$region -fold}
  if exp0 then
    pvt_var.PivotDraw(PtPos(0,0),Trunc(pvt_var.pvt_pos.x),Trunc(pvt_var.pvt_pos.y)); {$endregion}

  {Copy Main Buffer To Lower Buffer ----------------} {$region -fold}
  if copy7_calc then
    MainBmpToLowerBmp; {$endregion}

  {Copy Main Buffer To Lower Buffer 2---------------} {$region -fold}
  if copy8_calc then
    MainBmpToLowerBmp2; {$endregion}

  {Invalidate Drawing Area(Editor Inner Window)-----} {$region -fold}
  if (not down_play_anim_ptr^) then
    InvalidateInnerWindow; {$endregion}

  {Drawing of Inner Window Buttons------------------} {$region -fold}
  {if F_MainForm.P_Inner_Window_Buttons.Visible then
     F_MainForm.P_Inner_Window_Buttons.Invalidate;} {$endregion}

  {Set Surface Parameters---------------------------} {$region -fold}
  if set_surf_param10 then
    SetSurfParam0;
  if set_surf_param11 then
    SetSurfParam1;
  if set_surf_param12 then
    SetSurfParam2;
  if set_surf_param13 then
    SetSurfParam3; {$endregion}

  need_repaint:=False;

  exec_timer.Stop;
  exec_time:=Trunc(exec_timer.Delay*1000);

  {Log.}
  DrawObjectInfo0;
  DrawObjectInfo1
  (
    inn_wnd_rct.right -170,
    inn_wnd_rct.bottom-030,
    srf_bmp,
    'Execution time: '+IntToStr(exec_time)+' ms.'
  );

end; {$endregion}
procedure TSurface.EventGroupsCalc(var arr:TBool2Arr; event_group:TEventGroupEnum);   {$ifdef Linux}[local];{$endif} {$region -fold}
var
  b: byte;
begin
  for b in event_group do
    arr[b]:=True;
  MainDraw;
  for b in event_group do
    arr[b]:=False;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_BackgroundClick      (sender:TObject); {$region -fold}
begin
  SB_Draw_Buttons_Button_Bkgnd.Left   :=SB_Background.Left;
  SB_Draw_Buttons_Button_Bkgnd.Visible:=SB_Background.Down;
  DrawingPanelsSetVisibility1(down_bkgnd_ptr,P_Draw_Buttons,P_Background,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_bkgnd_ptr^) then
    Exit;
end; {$endregion}
procedure TF_MainForm.SB_Background_ColorClick(sender:TObject); {$region -fold}
begin
  CD_Select_Color      .Color:=SB_Background_Color.Color;
  CD_Select_Color      .Execute;
  srf_var.bg_col             :=SetColorInv(CD_Select_Color.Color);
  SB_Background_Color  .Color:=CD_Select_Color.Color;
  SB_Background_Color  .Down :=False;
  srf_var.EventGroupsCalc(calc_arr,[21,30]);
  SpeedButtonRepaint;
  L_Object_Info   .Font.Color:=Integer(Abs($FFFFFFFF-srf_var.bg_col)>>1);
  L_Exec_Time_Info.Font.Color:=L_Object_Info.Font.Color;
  L_Camera_Speed  .Font.Color:=L_Object_Info.Font.Color;
  ST_Sprite_Scale .Font.Color:=L_Object_Info.Font.Color;
end; {$endregion}
{$endregion}

// (Camera) Камера:
{LI} {$region -fold}
constructor TCamera.Create(w,h:TColor);                                                              {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  srf_var_ptr             :=@srf_var;
  bmp_rect                :=PtBounds(0,0,w,h);
  spd_mul                 :=PtPosF  (1.0,1.0);
  scl_mul                 :=PtPosF(DEFAULT_SCL_MUL,
                                   DEFAULT_SCL_MUL);
  scl_mul_pow             :=1;
  scl_dif                 :=0;
  scl_min                 :=-17;
  scl_max                 := 25;
  scl_dir                 :=TSclDir(2);
  obj_var.spd_mul_ptr     :=@spd_mul;
  obj_var.spd_mul_prev_ptr:=@spd_mul_prev;
end; {$endregion}
destructor  TCamera.Destroy;                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure   TCamera.CameraMove(dir1,dir2:boolean; movdir1,movdir2,movdir3:TMovingDirection); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if dir1 then
    mov_dir:=movdir1
  else
  if dir2 then
    mov_dir:=movdir2
  else
    mov_dir:=movdir3;
end; {$endregion}
{$endregion}

// (Snap Grid) Сетка привязки:
{LI} {$region -fold}
constructor TSGrid.Create(w,h:TColor);                                                                                                {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  srf_var_ptr:=@srf_var;
  obj_var.Add(kooSGrid,srf_var_ptr^.world_axis_shift);
  CreateNode('Snap Grid','');
  ObjIndsCalc;
  ScTIndsCalc;
  CngPnVsCalc;
  ChsDataCalc;
  obj_var.VisObjArrCrt2;
  ObjectTagsListRepaint;
  sgrid_dnt :=8{16};
  sgrid_col :=SetColorInv($0055424B);
  show_sgrid:=True;
end; {$endregion}
destructor  TSGrid.Destroy;                                                                                                           {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure TSGrid.SGridToBmp (const pvt:TPtPosF; const bmp_dst_ptr:PInteger; const bmp_dst_width:TColor; rct_clp_ptr:PPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  sht_pow_mul  : double;
  w_inc,h_inc  : double;
  sht_pow_mul_ : integer;
  w_inc_,h_inc_: integer;
  pvt_x,pvt_y  : integer;
  i,x0,y0,x1,y1: integer;
begin
  with rct_clp_ptr^ do
    begin

      sht_pow_mul :=sgrid_dnt*cmr_var.scl_mul_pow;

      // Horizontal Lines:
      x0    :=left;
      x1    :=left+width;
      h_inc :=0;
      for i :=0 to Trunc((pvt.y-top)/sht_pow_mul) do
        begin
          y0:=Trunc(pvt.y-h_inc);
          if LineHC(x0,y0,x1,rct_clp_ptr^) then
             LineH (x0,y0,x1,bmp_dst_ptr,bmp_dst_width,sgrid_col);
          h_inc+=sht_pow_mul;
        end;
      h_inc :=sht_pow_mul;
      for i :=0 to Trunc((bottom-pvt.y)/sht_pow_mul)-1 do
        begin
          y0:=Trunc(pvt.y+h_inc);
          if LineHC(x0,y0,x1,rct_clp_ptr^) then
             LineH (x0,y0,x1,bmp_dst_ptr,bmp_dst_width,sgrid_col);
          h_inc+=sht_pow_mul;
        end;

      // Vertical Lines:
      y0    :=top;
      y1    :=top+height;
      w_inc :=0;
      for i :=0 to Trunc((pvt.x-left)/sht_pow_mul) do
        begin
          x0:=Trunc(pvt.x-w_inc);
          if LineVC(x0,y0,y1,rct_clp_ptr^) then
             LineV (x0,y0,y1,bmp_dst_ptr,bmp_dst_width,sgrid_col);
          w_inc+=sht_pow_mul;
        end;
      w_inc :=sht_pow_mul;
      for i :=0 to Trunc((right-pvt.x)/sht_pow_mul)-1 do
        begin
          x0:=Trunc(pvt.x+w_inc);
          if LineVC(x0,y0,y1,rct_clp_ptr^) then
             LineV (x0,y0,y1,bmp_dst_ptr,bmp_dst_width,sgrid_col);
          w_inc+=sht_pow_mul;
        end;

      {
      sht_pow_mul:=sgrid_dnt*cmr_var.scl_mul_pow;

      // Horizontal Lines:
      x0:=left;
      x1:=left+width;

     {h_inc:=0;
      for i:=0 to Trunc((pvt.y-top)/sht_pow_mul) do
        begin
          y0:=Trunc(pvt.y-h_inc);
          if LineHC(x0,y0,x1,rct_clp_ptr^) then
             LineH (x0,y0,x1,bmp_dst_ptr,bmp_dst_width,sgrid_col);
          h_inc+=sht_pow_mul;
        end;}
      h_inc:=sht_pow_mul;
      for i:=0 to Trunc((pvt.y-top)/sht_pow_mul)-1 do
        begin
          y0:=Trunc(pvt.y)-Trunc(h_inc);
          if LineHC(x0,y0,x1,rct_clp_ptr^) then
             LineH (x0,y0,x1,bmp_dst_ptr,bmp_dst_width,sgrid_col);
          h_inc+=sht_pow_mul;
        end;

      h_inc:=0{-sht_pow_mul};
      for i:=0 to Trunc((bottom-pvt.y)/sht_pow_mul)+1 do
        begin
          y0:=Trunc(pvt.y)+Trunc(h_inc);
          if LineHC(x0,y0,x1,rct_clp_ptr^) then
             LineH (x0,y0,x1,bmp_dst_ptr,bmp_dst_width,sgrid_col);
          h_inc+=sht_pow_mul;
        end;

      // Vertical Lines:
      y0:=top;
      y1:=top+height;

     {w_inc:=0;
      for i:=0 to Trunc((pvt.x-left)/sht_pow_mul) do
        begin
          x0:=Trunc(pvt.x-w_inc);
          if LineVC(x0,y0,y1,rct_clp_ptr^) then
             LineV (x0,y0,y1,bmp_dst_ptr,bmp_dst_width,sgrid_col);
          w_inc+=sht_pow_mul;
        end;}
      w_inc:=sht_pow_mul;
      for i:=0 to Trunc((pvt.x-left)/sht_pow_mul)-1 do
        begin
          x0:=Trunc(pvt.x)-Trunc(w_inc);
          if LineVC(x0,y0,y1,rct_clp_ptr^) then
             LineV (x0,y0,y1,bmp_dst_ptr,bmp_dst_width,sgrid_col);
          w_inc+=sht_pow_mul;
        end;

      w_inc:=0{-sht_pow_mul};
      for i:=0 to Trunc((right-pvt.x)/sht_pow_mul)+1 do
        begin
          x0:=Trunc(pvt.x)+Trunc(w_inc);
          if LineVC(x0,y0,y1,rct_clp_ptr^) then
             LineV (x0,y0,y1,bmp_dst_ptr,bmp_dst_width,sgrid_col);
          w_inc+=sht_pow_mul;
        end;
      }

      {
      sht_pow_mul :=sgrid_dnt*cmr_var.scl_mul_pow;
      sht_pow_mul_:=Trunc(sht_pow_mul*$10000);
      pvt_x       :=Trunc(pvt.x      *$10000);
      pvt_y       :=Trunc(pvt.y      *$10000);

      // Horizontal Lines:
      x0    :=left;
      x1    :=left+width;
      h_inc :=0;
      h_inc_:=Trunc(h_inc*$10000);
      for i :=0 to Trunc((pvt.y-top)/sht_pow_mul) do
        begin
          y0:=(pvt_y-h_inc_)>>16;
          if LineHC(x0,y0,x1,rct_clp_ptr^) then
             LineH (x0,y0,x1,bmp_dst_ptr,bmp_dst_width,sgrid_col);
          h_inc_+=sht_pow_mul_;
        end;
      h_inc :=sht_pow_mul;
      h_inc_:=Trunc(h_inc*$10000);
      for i :=0 to Trunc((bottom-pvt.y)/sht_pow_mul)-1 do
        begin
          y0:=(pvt_y+h_inc_)>>16;
          if LineHC(x0,y0,x1,rct_clp_ptr^) then
             LineH (x0,y0,x1,bmp_dst_ptr,bmp_dst_width,sgrid_col);
          h_inc_+=sht_pow_mul_;
        end;

      // Vertical Lines:
      y0    :=top;
      y1    :=top+height;
      w_inc :=0;
      w_inc_:=Trunc(w_inc*$10000);
      for i :=0 to Trunc((pvt.x-left)/sht_pow_mul) do
        begin
          x0:=(pvt_x-w_inc_)>>16;
          if LineVC(x0,y0,y1,rct_clp_ptr^) then
             LineV (x0,y0,y1,bmp_dst_ptr,bmp_dst_width,sgrid_col);
          w_inc_+=sht_pow_mul_;
        end;
      w_inc :=sht_pow_mul;
      w_inc_:=Trunc(w_inc*$10000);
      for i :=0 to Trunc((right-pvt.x)/sht_pow_mul)-1 do
        begin
          x0:=(pvt_x+w_inc_)>>16;
          if LineVC(x0,y0,y1,rct_clp_ptr^) then
             LineV (x0,y0,y1,bmp_dst_ptr,bmp_dst_width,sgrid_col);
          w_inc_+=sht_pow_mul_;
        end;
      }

    end;
end; {$endregion}
procedure TSGrid.SGridDraw  (const sgrid_ind:TColor; rct_clp_ptr_:PPtRect);                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjProp;
begin
  with srf_var_ptr^ do
    if show_sgrid then
      begin
        obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.sgrid_inds_obj_arr[sgrid_ind]]);
        with obj_arr_ptr^ do
          begin
            sgrid_dnt:=Max(1<<(3-cmr_var.scl_dif>>2),4{0});
            SGridToBmp(PtPosF(0.5+world_axis.x+Trunc(obj_arr_ptr^.world_axis_shift.x),
                              0.5+world_axis.y+Trunc(obj_arr_ptr^.world_axis_shift.y)),
                       bkgnd_ptr,
                       bkgnd_width,
                       rct_clp_ptr_);
          end;
      end;
end; {$endregion}
procedure TSGrid.FilSGridObj(const sgrid_ind:TColor);                                                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SGridDraw(sgrid_ind,obj_var.obj_arr[obj_var.sgrid_inds_obj_arr[sgrid_ind]].rct_clp_ptr);
end; {$endregion}
procedure TSGrid.MovSGridObj(const sgrid_ind:TColor);                                                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SGridDraw(sgrid_ind,obj_var.obj_arr[obj_var.sgrid_inds_obj_arr[sgrid_ind]].rct_dst_ptr);
end; {$endregion}
procedure TSGrid.AlignPts(var pts:TPtPosFArr; const sel_pts_inds:TColorArr; const pts_cnt,sel_pts_cnt:TColor);                        {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_SGridClick                                (sender:TObject);                                                                                        {$region -fold}
begin
  SB_Draw_Buttons_Button_Bkgnd.Left   :=SB_SGrid.Left;
  SB_Draw_Buttons_Button_Bkgnd.Visible:=SB_SGrid.Down;
  DrawingPanelsSetVisibility1(down_sgrid_ptr,P_Draw_Buttons,P_SGrid,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_sgrid_ptr^) then
    Exit;
end; {$endregion}
procedure TF_MainForm.SB_SGrid_ColorClick                          (sender:TObject);                                                                                        {$region -fold}
begin
  CD_Select_Color.Color:=SB_SGrid_Color.Color;
  CD_Select_Color.Execute;
  sgr_var.sgrid_col    :=SetColorInv(CD_Select_Color.Color);
  SB_SGrid_Color.Color :=CD_Select_Color.Color;
  SB_SGrid_Color.Down  :=False;
  sgr_var.srf_var_ptr^.EventGroupsCalc(calc_arr,[21,30]);
  SpeedButtonRepaint;
end; {$endregion}
{$endregion}

// (Grid) Сетка:
{LI} {$region -fold}
constructor TRGrid.Create(w,h:TColor);                                              {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  srf_var_ptr:=@srf_var;
  obj_var.Add(kooRGrid,srf_var_ptr^.world_axis_shift);
  CreateNode('Regular Grid','');
  ObjIndsCalc;
  ScTIndsCalc;
  CngPnVsCalc;
  ChsDataCalc;
  obj_var.VisObjArrCrt2;
  ObjectTagsListRepaint;
  rgrid_dnt :=64;
  rgrid_col :=SetColorInv($008A7C92);
  show_rgrid:=True;
end; {$endregion}
destructor  TRGrid.Destroy;                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure TRGrid.RGridDraw  (const rgrid_ind:TColor; rct_clp_ptr_:PPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjProp;
  sgrid_dnt2 : integer;
  sgrid_col2 : TColor;
  i          : TColor;
begin
  with srf_var_ptr^ do
    if show_rgrid then
      begin
        obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.rgrid_inds_obj_arr[rgrid_ind]]);
        with obj_arr_ptr^ do
          begin
                    sgrid_dnt2:=sgr_var.sgrid_dnt;
                    sgrid_col2:=sgr_var.sgrid_col;
            sgr_var.sgrid_dnt :=        rgrid_dnt;
            sgr_var.sgrid_col :=        rgrid_col;
            sgr_var.SGridToBmp(PtPosF(0.5+world_axis.x+Trunc(world_axis_shift.x),
                                      0.5+world_axis.y+Trunc(world_axis_shift.y)),
                               bkgnd_ptr,
                               bkgnd_width,
                               rct_clp_ptr_);
            sgr_var.sgrid_dnt :=sgrid_dnt2;
            sgr_var.sgrid_col :=sgrid_col2;
          end;
      end;
end; {$endregion}
procedure TRGrid.FilRGridObj(const rgrid_ind:TColor                      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RGridDraw(rgrid_ind,obj_var.obj_arr[obj_var.rgrid_inds_obj_arr[rgrid_ind]].rct_clp_ptr);
end; {$endregion}
procedure TRGrid.MovRGridObj(const rgrid_ind:TColor                      ); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  RGridDraw(rgrid_ind,obj_var.obj_arr[obj_var.rgrid_inds_obj_arr[rgrid_ind]].rct_dst_ptr);
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_RGridClick      (sender:TObject);                                                                                                                  {$region -fold}
begin
  SB_Draw_Buttons_Button_Bkgnd.Left   :=SB_RGrid.Left;
  SB_Draw_Buttons_Button_Bkgnd.Visible:=SB_RGrid.Down;
  DrawingPanelsSetVisibility1(down_rgrid_ptr,P_Draw_Buttons,P_RGrid,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_rgrid_ptr^) then
    Exit;
end; {$endregion}
procedure TF_MainForm.SB_RGrid_ColorClick(sender:TObject);                                                                                                                  {$region -fold}
begin
  CD_Select_Color.Color:=SB_RGrid_Color.Color;
  CD_Select_Color.Execute;
  rgr_var.rgrid_col    :=SetColorInv(CD_Select_Color.Color);
  SB_RGrid_Color.Color :=CD_Select_Color.Color;
  SB_RGrid_Color.Down  :=False;
  rgr_var.srf_var_ptr^.EventGroupsCalc(calc_arr,[21,30]);
  SpeedButtonRepaint;
end; {$endregion}
{$endregion}

// (Text) Текст:
{LI} {$region -fold}
constructor TFText.Create(w,h:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  srf_var_ptr:=@srf_var;
  global_prop:=ftext_default_prop;
end; {$endregion}
destructor TFText.Destroy;             {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_TextClick                 (sender:TObject); {$region -fold}
begin
  SB_Draw_Buttons_Button_Bkgnd.Left   :=SB_Text.Left;
  SB_Draw_Buttons_Button_Bkgnd.Visible:=SB_Text.Down;
  DrawingPanelsSetVisibility1(down_text_ptr,P_Draw_Buttons,P_Text,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_text_ptr^) then
    Exit;
end; {$endregion}
{Drawing}
procedure TF_MainForm.P_Text_Drawing_PropMouseEnter(sender:TObject); {$region -fold}
begin
  P_Text.Color:=HighLightLimit(P_Text.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Text_Drawing_PropMouseLeave(sender:TObject); {$region -fold}
begin
  P_Text.Color:=Darken0(P_Text.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.P_Text_SettingsMouseEnter    (sender:TObject); {$region -fold}
begin
  P_Text_Settings       .Color:=HighLightLimit(P_Text_Settings       .Color,16);
  P_Text_Settings_Header.Color:=HighLightLimit(P_Text_Settings_Header.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Text_SettingsMouseLeave    (sender:TObject); {$region -fold}
begin
  P_Text_Settings       .Color:=Darken0(P_Text_Settings       .Color,0,0,0,0,0,16);
  P_Text_Settings_Header.Color:=Darken0(P_Text_Settings_Header.Color,0,0,0,0,0,16);
end; {$endregion}
procedure TF_MainForm.CB_Text_BackgroundChange     (sender:TObject); {$region -fold}
begin
  txt_var.global_prop.bkgnd_draw:=not txt_var.global_prop.bkgnd_draw;
end; {$endregion}
procedure TF_MainForm.SB_Text_Select_FontClick     (sender:TObject); {$region -fold}
begin
  //SB_Text_Select_Font.Down:=False;
  if (not FontDialog1.Execute) then
    Exit;
  try
    with FontDialog1,Font do
      begin
        {SetTextInfo(txt_var.srf_var_ptr^.srf_bmp.Canvas,height,color,name,charset);
        txt_var.srf_var_ptr^.srf_bmp.Canvas.TextOut(10,400,'Start Demo');}
      end;
  except
    on E: Exception do
      MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
  end;
end; {$endregion}
{$endregion}

// (Brush) Кисть:
{LI} {$region -fold}
procedure BrushDraw(x,y:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_BrushClick(sender:TObject);                     {$region -fold}
begin
  SB_Draw_Buttons_Button_Bkgnd.Left   :=SB_Brush.Left;
  SB_Draw_Buttons_Button_Bkgnd.Visible:=SB_Brush.Down;
  DrawingPanelsSetVisibility1(down_brush_ptr,P_Draw_Buttons,P_Brush,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_brush_ptr^) then
    Exit;
end; {$endregion}
{$endregion}

// (Spray) Спрей:
{LI} {$region -fold}
procedure SprayDraw(x,y,r:integer; custom_color:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rad,a  : double;
  i,m1,m2: integer;
begin
  a  :=Random*2*pi;
  rad:=Random*r;
  m1 :=Trunc(rad*Cos(a));
  m2 :=Trunc(rad*Sin(a));
  {for i:=0 to 100 do
    srf_var.loaded_picture.Bitmap.Canvas.Pixels[X+m1,Y+m2]:=custom_color;}
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_SprayClick(sender:TObject);                                            {$region -fold}
begin
  SB_Draw_Buttons_Button_Bkgnd.Left   :=SB_Spray.Left;
  SB_Draw_Buttons_Button_Bkgnd.Visible:=SB_Spray.Down;
  DrawingPanelsSetVisibility1(down_spray_ptr,P_Draw_Buttons,P_Spray,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_spray_ptr^) then
    Exit;
end; {$endregion}
{$endregion}

// (Spline) Сплайн:
{LI} {$region -fold}
constructor TCurve.Create          (const w,h              :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  srf_var_ptr:=@srf_var;

  // spline edges bounding rectangles:
  rct_eds_big_img:=TFastLine.Create;
  with rct_eds_big_img do
    begin
      BuffersInit(w,h,False,True,False,False);
      SetBkgnd   (srf_var_ptr^.srf_bmp_ptr,srf_var_ptr^.srf_bmp.width,srf_var_ptr^.srf_bmp.height,@srf_var_ptr^.inn_wnd_rct);
    end;

  // spline points bounding rectangles:
  rct_pts_big_img:=TFastLine.Create;
  with rct_pts_big_img do
    begin
      BuffersInit(w,h,False,True,False,False);
      SetBkgnd   (srf_var_ptr^.srf_bmp_ptr,srf_var_ptr^.srf_bmp.width,srf_var_ptr^.srf_bmp.height,@srf_var_ptr^.inn_wnd_rct);
    end;

  // spline edges:
  eds_big_img:=TFastLine.Create;
  with eds_big_img do
    begin
      BuffersInit(w,h,True,True,False,True);
      SetBkgnd   (srf_var_ptr^.srf_bmp_ptr,srf_var_ptr^.srf_bmp.width,srf_var_ptr^.srf_bmp.height,@srf_var_ptr^.inn_wnd_rct);
    end;

  // spline points:
  pts_big_img:=TFastLine.Create;
  with pts_big_img do
    begin
      BuffersInit(w,h,True,True,False,True);
      SetBkgnd   (srf_var_ptr^.srf_bmp_ptr,srf_var_ptr^.srf_bmp.width,srf_var_ptr^.srf_bmp.height,@srf_var_ptr^.inn_wnd_rct);
    end;

  // duplicated points:
  SetLength      (dup_pts_arr,w*h);

  global_prop        :=curve_default_prop;
  has_hid_ln_elim_sln:=False;
  cur_tlt_dwn_btn_ind:=-1;
  show_spline        :=True;
  eds_simpl_angle_sum:=0;
  FmlSplineInit;
  SetLength(fml_pts,global_prop.cycloid_pts_cnt);

end; {$endregion}
destructor  TCurve.Destroy;                                                                                                                                                  {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure TCurve.PrimitiveComp     (const spline_ind       :TColor;  const pmt_var_ptr,pmt_big_var_ptr:PFastLine; pmt_bld_stl:TDrawingStyle; fast_image_ptr:PFastImageItem); {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pmt_var_ptr^,fast_image_ptr^,fast_image_data,fast_image_proc_var do
    begin
      with rct_vis do
        SetRctPos
        (
          left,
          top
        );
      with pmt_big_var_ptr^ do
        SetValInfo
        (
          ln_arr1_ptr,
          ln_arr1_ptr,
          ln_arr1_ptr,
          ln_arr_width,
          ln_arr_height
        );
      with obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]] do
        SetBkgnd
        (
          bkgnd_ptr,
          bkgnd_width,
          bkgnd_height,
          pmt_var_ptr^.rct_clp_ptr^
        );
      bmp_src_rct_clp:=rct_vis;
      img_kind       :=001{11};
      fx_cnt         :=002;
      pix_drw_type   :=001;
      with fx_arr[1] do
        begin
          with nt_fx_prop do
            begin
              cfx_pow0    :=064;
              rep_cnt     :=001;
              pix_srf_type:=001;
              pix_cfx_type:=GetEnumVal(pmt_bld_stl);
            end;
          pt_fx_prop:=nt_fx_prop;
        end;
      if local_prop.byte_mode and (not down_select_items_ptr^) then
        begin
          bmp_alpha_ptr2:=pmt_big_var_ptr^.ln_arr0_ptr;
          better_quality:=local_prop.better_quality;
        end
      else
        begin
          bmp_alpha_ptr2:=Nil;
          better_quality:=False;
        end;
      realloc_mem     :=local_prop.realloc_mem;
      remove_brunching:=local_prop.remove_brunching;
      need_store_value:=down_select_items_ptr^;
      CmpProc[11];
      {if (bmp_alpha_ptr2<>Nil) and remove_brunching and (not better_quality) then
        begin
          Randomize;
          F_MainForm.M_Test_Log.Lines.Text:=IntToStr(Random(1000));
        end;}
      SdrProcInd(fast_image_data);
      SetRctPos (bmp_src_rct_clp);
      SdrTypeCng(fast_image_data_ptr0,
                 fast_image_data);
    end;
end; {$endregion}
procedure TCurve.AddPoint          (const x,y              :integer; const bmp_dst_ptr:PInteger; const bmp_dst_width:TColor; var color_info:TColorInfo; const rct_clp:TPtRect; var add_spline_calc_:boolean; sleep_:boolean=False); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  spray_pt: TSprayProp;
  angle_  : double;
label
  l1;
begin
  with spray_pt do
    begin

      {Check If You Need to Add Point} {$region -fold}
      if (global_prop.sln_mode<>smDiscrete) then
        if sleep_ then
          begin
            if (sln_pts_skip_counter<global_prop.sln_pts_frq) then
              begin
                Inc(sln_pts_skip_counter);
                spray_pt        :=Default(TSprayProp);
                add_spline_calc_:=True;
                Exit;
              end
            else
            if (sln_pts_skip_counter=global_prop.sln_pts_frq) then
                sln_pts_skip_counter:=0;
          end;
      spray_pt        :=Default(TSprayProp);
      add_spline_calc_:=True; {$endregion}

      {LOD Simplification------------} {$region -fold}
      {if global_prop.eds_lod and global_prop.eds_lod_on_create then
        begin
          if (sln_pts_cnt=0) then
            begin
              sln_3_pts[0]:=PtPosF(x,y);
            end
          else
          if (sln_pts_cnt=1) then
            begin
              sln_3_pts[0]:=sln_3_pts[1];
              sln_3_pts[1]:=PtPosF(x,y);
            end
          else
            begin
              sln_3_pts[0]:=sln_3_pts[1];
              sln_3_pts[1]:=sln_3_pts[2];
              sln_3_pts[2]:=PtPosF(x,y);
            end;
          if (sln_pts_cnt in [0..2]) then
            goto l1;
          angle_:=180-GetAngle(sln_3_pts[0],sln_3_pts[1],sln_3_pts[2]);
              eds_simpl_angle_sum+=angle_;
          if (eds_simpl_angle_sum<global_prop.eds_simpl_angle) {and (angle_<global_prop.eds_simpl_angle)} then
            Exit;
              eds_simpl_angle_sum:=0;
          l1:
        end;} {$endregion}

      {Misc. Calc.-------------------} {$region -fold}
      Inc(sln_pts_cnt    );
      Inc(sln_pts_cnt_add); {$endregion}

      {Spline Drawing Mode: Spray----} {$region -fold}
      if (global_prop.sln_mode=smSpray) then
        begin
          a  :=Random*2*pi;
          rad:={Random*}global_prop.spray_rad;
          m1 :=Trunc(rad*Cos(a));
          m2 :=Trunc(rad*Sin(a));
        end; {$endregion}

      {Add Point to Array/List-------} {$region -fold}
      AddListItem(PtPosF(x-srf_var_ptr^.world_axis_shift.x+m1,
                         y-srf_var_ptr^.world_axis_shift.y+m2),
                  first_item,
                  p1,
                  p2);
      {SetLength(sln_pts_add,sln_pts_cnt_add);
      sln_pts_add[sln_pts_cnt_add-1].x:=x-srf_var_ptr^.world_axis_shift.x;
      sln_pts_add[sln_pts_cnt_add-1].y:=y-srf_var_ptr^.world_axis_shift.y;} {$endregion}

      {Draw Point--------------------} {$region -fold}
      SetColorInfo2(clRed,color_info);
      Point(x+m1,
            y+m2,
            bmp_dst_ptr,
            bmp_dst_width,
            rct_clp,
            color_info); {$endregion}

    end;
end; {$endregion}
procedure TCurve.RctSplineRct0     (const spline_ind       :TColor;  var   rct_out_:TRect; var   rct_ent_:TPtRectF);                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_eds_img_arr[spline_ind] do
    rct_out_:=Rect
    (
      rct_clp_ptr^.left,
      rct_clp_ptr^.top,
      rct_clp_ptr^.right,
      rct_clp_ptr^.bottom
    );
end; {$endregion}
procedure TCurve.RctSplineRct1     (const spline_ind       :TColor;  var   rct_out_:TRect; var   rct_ent_:TPtRectF);                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  rct_ent_:=PtsRngRctCalc2
  (
    sln_pts,
    rct_bnd_ind_arr[spline_ind],
    partial_pts_sum[spline_ind],
    partial_pts_sum[spline_ind]+sln_obj_pts_cnt[spline_ind]-1
  );
end; {$endregion}
procedure TCurve.RctSplineRct2     (const spline_ind       :TColor;  var   rct_out_:TRect; var   rct_ent_:TPtRectF);                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PtRctF(sln_pts,rct_bnd_ind_arr[spline_ind],rct_ent_);
end; {$endregion}
procedure TCurve.RctSplineRctEds   (const spline_ind       :TColor;  const rct_out_:TRect; const rct_ent_:TPtRectF);                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjProp;
begin
  with rct_eds_img_arr[spline_ind],local_prop do
    begin

      {Final   Rectangle} {$region -fold}
      rct_wnd:=rct_out_; {$endregion}

      {Entire  Rectangle} {$region -fold}
      rct_ent:=eds_img_arr[spline_ind].rct_ent;
      {$endregion}

      {Clipped Rectangle} {$region -fold}
      {rct_vis:=eds_img_arr[spline_ind].rct_vis;} {$endregion}

    end;
end; {$endregion}
procedure TCurve.RctSplineRctPts   (const spline_ind       :TColor;  const rct_out_:TRect; const rct_ent_:TPtRectF);                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjProp;
begin
  with rct_pts_img_arr[spline_ind],local_prop do
    begin

      {Final   Rectangle} {$region -fold}
      rct_wnd:=rct_out_; {$endregion}

      {Entire  Rectangle} {$region -fold}
      rct_ent:=pts_img_arr[spline_ind].rct_ent;
      {$endregion}

      {Clipped Rectangle} {$region -fold}
      {rct_vis:=pts_img_arr[spline_ind].rct_vis;} {$endregion}

    end;
end; {$endregion}
procedure TCurve.RctSplineEds      (const spline_ind       :TColor;  const rct_out_:TRect; const rct_ent_:TPtRectF);                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjProp;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Final   Rectangle} {$region -fold}
      rct_wnd:=rct_out_; {$endregion}

      {Entire  Rectangle} {$region -fold}
      with rct_ent do
        begin
          obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
          left       :=rct_ent_.left  -eds_width_half-1+eds_width_odd;
          top        :=rct_ent_.top   -eds_width_half-1+eds_width_odd;
          right      :=rct_ent_.right +eds_width_half+1;
          bottom     :=rct_ent_.bottom+eds_width_half+1;
          width      :=right-left;
          height     :=bottom-top;
        end; {$endregion}

      {Clipped Rectangle} {$region -fold}
      {rct_vis:=ClippedRct(rct_wnd,rct_ent_2);} {$endregion}

    end;
end; {$endregion}
procedure TCurve.RctSplinePts      (const spline_ind       :TColor;  const rct_out_:TRect; const rct_ent_:TPtRectF);                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjProp;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin

      {Final   Rectangle} {$region -fold}
      rct_wnd:=rct_out_; {$endregion}

      {Entire  Rectangle} {$region -fold}
      with rct_ent do
        begin
          obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
          left       :=rct_ent_.left  -pts_rct_inn_width >>1-pts_rct_tns_left+pts_rct_width__odd;
          top        :=rct_ent_.top   -pts_rct_inn_height>>1-pts_rct_tns_top +pts_rct_height_odd;
          right      :=rct_ent_.right +pts_rct_inn_width >>1+pts_rct_tns_right;
          bottom     :=rct_ent_.bottom+pts_rct_inn_height>>1+pts_rct_tns_bottom;
          width      :=right-left;
          height     :=bottom-top;
        end; {$endregion}

      {Clipped Rectangle} {$region -fold}
      {rct_vis:=ClippedRct(rct_wnd,rct_ent_2);} {$endregion}

    end;
end; {$endregion}
procedure TCurve.RctSplineEntAndVis(const w_a_s_x,w_a_s_y  :integer; const f_ln_arr_item_ptr:PFastLine);                                                                     {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with f_ln_arr_item_ptr^,local_prop do
    begin
      with rct_ent_2 do
        begin
          width :=Trunc(rct_ent.width );
          height:=Trunc(rct_ent.height);
          left  :=Trunc(rct_ent.left  )+w_a_s_x;
          top   :=Trunc(rct_ent.top   )+w_a_s_y;
          right :=Trunc(rct_ent.right )+w_a_s_x;
          bottom:=Trunc(rct_ent.bottom)+w_a_s_y;
        end;
      rct_vis:=ClippedRct(rct_wnd,rct_ent_2);
    end;
end; {$endregion}
procedure TCurve.RctSplineObj0     (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  rct_ent_       : TPtRectF;
  rct_out_       : TRect;
  w_a_s_x,w_a_s_y: integer;
begin
  obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]];
  w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
  w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
  RctSplineRct0     (spline_ind,rct_out_,rct_ent_);
  RctSplineRct1     (spline_ind,rct_out_,rct_ent_);
  RctSplineEds      (spline_ind,rct_out_,rct_ent_);
  RctSplinePts      (spline_ind,rct_out_,rct_ent_);
  RctSplineRctEds   (spline_ind,rct_out_,rct_ent_);
  RctSplineRctPts   (spline_ind,rct_out_,rct_ent_);
  RctSplineEntAndVis(w_a_s_x,w_a_s_y,@rct_eds_img_arr[spline_ind]);
  RctSplineEntAndVis(w_a_s_x,w_a_s_y,@rct_pts_img_arr[spline_ind]);
  RctSplineEntAndVis(w_a_s_x,w_a_s_y,@    eds_img_arr[spline_ind]);
  RctSplineEntAndVis(w_a_s_x,w_a_s_y,@    pts_img_arr[spline_ind]);
end; {$endregion}
procedure TCurve.RctSplineObj1     (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  rct_ent_       : TPtRectF;
  rct_out_       : TRect;
  w_a_s_x,w_a_s_y: integer;
begin
  obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]];
  w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
  w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
  RctSplineRct0     (spline_ind,rct_out_,rct_ent_);
  RctSplineRct2     (spline_ind,rct_out_,rct_ent_);
  RctSplineEds      (spline_ind,rct_out_,rct_ent_);
  RctSplinePts      (spline_ind,rct_out_,rct_ent_);
  RctSplineRctEds   (spline_ind,rct_out_,rct_ent_);
  RctSplineRctPts   (spline_ind,rct_out_,rct_ent_);
  RctSplineEntAndVis(w_a_s_x,w_a_s_y,@rct_eds_img_arr[spline_ind]);
  RctSplineEntAndVis(w_a_s_x,w_a_s_y,@rct_pts_img_arr[spline_ind]);
  RctSplineEntAndVis(w_a_s_x,w_a_s_y,@    eds_img_arr[spline_ind]);
  RctSplineEntAndVis(w_a_s_x,w_a_s_y,@    pts_img_arr[spline_ind]);
end; {$endregion}
procedure TCurve.RctSplineAll0     (const start_ind,end_ind:TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to sln_obj_cnt-1 do
    begin
      j:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].t_ind;
      if (j>=start_ind) and (j<=end_ind) then
        RctSplineObj0(i);
    end;
end; {$endregion}
procedure TCurve.RctSplineAll1     (const start_ind,end_ind:TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to sln_obj_cnt-1 do
    begin
      j:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].t_ind;
      if (j>=start_ind) and (j<=end_ind) then
        begin
          if (has_sel_pts[i]=0) then
            Continue;
          RctSplineObj0(i);
        end;
    end;
end; {$endregion}
procedure TCurve.RctSplineAll2     (const start_ind,end_ind:TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to sln_obj_cnt-1 do
    begin
      j:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].t_ind;
      if (j>=start_ind) and (j<=end_ind) then
        RctSplineObj1(i);
    end;
end; {$endregion}
procedure TCurve.RctSplineAll3     (const start_ind,end_ind:TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=0 to sln_obj_cnt-1 do
    begin
      j:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].t_ind;
      if (j>=start_ind) and (j<=end_ind) then
        begin
          if (has_sel_pts[i]=0) then
            Continue;
          RctSplineObj1(i);
        end;
    end;
end; {$endregion}
procedure TCurve.GrdSplineCalc     (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
  k: integer=-1;
  {Debug}
//s: string='';
begin
  if         (sln_obj_pts_cnt                [spline_ind]=1) or
             (pts_img_arr                    [spline_ind].local_prop.grd_pts_dns=1) then
    Exit;
  if  pts_img_arr                            [spline_ind].local_prop.grid_clipping_adaptive then
    begin                                                                          {Debug} // min pts_cnt=29941 max grd_pts_dns=256
      pts_img_arr                            [spline_ind].local_prop.grd_pts_dns:=Trunc(
      Sqrt   (sln_obj_pts_cnt                [spline_ind]));
    end;
  if         (pts_srt_pos_x                  [spline_ind]=Nil) then
    SetLength(pts_srt_pos_x                  [spline_ind],sln_obj_pts_cnt[spline_ind]);
  if         (pts_srt_pos_y                  [spline_ind]=Nil) then
    SetLength(pts_srt_pos_y                  [spline_ind],sln_obj_pts_cnt[spline_ind]);
  if         (pts_srt_inds                   [spline_ind]=Nil) then
    SetLength(pts_srt_inds                   [spline_ind],sln_obj_pts_cnt[spline_ind]);
  if         (min_max_inds                   [spline_ind]=Nil) then
    SetLength(min_max_inds                   [spline_ind],   pts_img_arr [spline_ind].local_prop.grd_pts_dns);
  if         (has_pts                        [spline_ind]=Nil) then
    SetLength(has_pts                        [spline_ind],   pts_img_arr [spline_ind].local_prop.grd_pts_dns);
  if         (pts_srt_pos_y_min_max          [spline_ind]=Nil) then
    SetLength(pts_srt_pos_y_min_max          [spline_ind],   pts_img_arr [spline_ind].local_prop.grd_pts_dns);
  FillByte   (has_pts                        [spline_ind][0],pts_img_arr [spline_ind].local_prop.grd_pts_dns,0);
  FillArray  (sln_pts,
              pts_srt_pos_x                  [spline_ind],
              pts_srt_pos_y                  [spline_ind],
              pts_srt_inds                   [spline_ind],
              partial_pts_sum                [spline_ind],
              sln_obj_pts_cnt                [spline_ind]);
  ShellSortY (pts_srt_pos_x                  [spline_ind],
              pts_srt_pos_y                  [spline_ind],
              pts_srt_inds                   [spline_ind],
              0,
       Length(pts_srt_pos_x                  [spline_ind]));
  d0__:=      pts_srt_pos_y                  [spline_ind][0];
  d1__:=     (pts_srt_pos_y                  [spline_ind][sln_obj_pts_cnt[spline_ind]-1]-d0__+2)/
              pts_img_arr                    [spline_ind].local_prop.grd_pts_dns;
  for i:=0 to pts_img_arr                    [spline_ind].local_prop.grd_pts_dns-1 do
    with      min_max_inds                   [spline_ind][i] do
      begin
        b:=                                               k+1;
        r:=                     pts_srt_inds [spline_ind][k+1];
        {Debug} {$region -fold}
        {
        if (b<Length(pts_srt_inds[spline_ind])) then
          begin
            s+='k='+IntToStr(k)+';'+#13; // 299;
            s+='b='+IntToStr(b)+';'+#13; // 300;
            s+='r='+IntToStr(r)+';'+#13; // 1933248849;
          end;
        } {$endregion}
        k:=BinarySearch4(Length(pts_srt_pos_y[spline_ind]),
                            @{(}pts_srt_pos_y[spline_ind]{)}[0],
                         d0__+(i+1)*d1__);
        g:=                     pts_srt_inds [spline_ind][k+0];
        a:=                                               k+0;
        {Debug} {$region -fold}
        {
        s+='d='+IntToStr(Trunc(d0__+(i+1)*d1__))+';'+#13; // 687;
        s+='g='+IntToStr(g                     )+';'+#13; // 68;
        s+='a='+IntToStr(a                     )+';'+#13; // 299;
        s+=#13;
        } {$endregion}
        if (b>a) then
          has_pts                            [spline_ind][i]:=0
        else
        if (b=a) then
          has_pts                            [spline_ind][i]:=1
        else
        if (b<a) then
          has_pts                            [spline_ind][i]:=2;
                 pts_srt_pos_y_min_max       [spline_ind][i].x:=pts_srt_pos_y[spline_ind][b];
                 pts_srt_pos_y_min_max       [spline_ind][i].y:=pts_srt_pos_y[spline_ind][a];
      end;
  {Debug} {$region -fold}
  {
  F_MainForm.M_Test_Log.Lines.Text:=s;
  } {$endregion}
  for i:=0 to    pts_img_arr                 [spline_ind].local_prop.grd_pts_dns-1 do
    if          (has_pts                     [spline_ind][i]=2) then
      ShellSortX(pts_srt_pos_x               [spline_ind],
                 pts_srt_pos_y               [spline_ind],
                 pts_srt_inds                [spline_ind],
                 min_max_inds                [spline_ind][i].b,
                 min_max_inds                [spline_ind][i].a-
                 min_max_inds                [spline_ind][i].b+1);
  scl_mul_dif                                [spline_ind]:=PtPosF(1.0,1.0);
end; {$endregion}
procedure TCurve.SclMulDifCalc     (const scl_mul          :TPtPosF; const scl_dir:TSclDir);                                                                                 {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to sln_obj_cnt-1 do
    if pts_img_arr[i].local_prop.grid_clipping_pts then
      case scl_dir of
        sdUp:
          begin
            scl_mul_dif[i].x*=scl_mul.x;
            scl_mul_dif[i].y*=scl_mul.y;
          end;
        sdDown:
          begin
            scl_mul_dif[i].x/=scl_mul.x;
            scl_mul_dif[i].y/=scl_mul.y;
          end;
      end;
end; {$endregion}
procedure TCurve.AddSplineObj;                                                                                                                                               {$ifdef Linux}[local];{$endif} {$region -fold}
var
  sln_pts_ptr     : PPtPosF;
  sln_pts_add_ptr : PPtPosF;
  m,i,d_cnt       : integer;
  sln_pts_cnt_add2: integer;
begin

  {Misc. Precalc.---------------} {$region -fold}
  Inc   (sln_obj_cnt);
  m    :=sln_obj_cnt-1;
  d_cnt:=sln_pts_cnt-sln_pts_cnt_add; {$endregion}

  {Buffers Init.----------------} {$region -fold}
  SetLength(sln_sprite_counter_pos_arr,sln_obj_cnt);
  SetLength(sln_sprite_counter_rad_arr,sln_obj_cnt);
  SetLength(sln_sprite_counter_pow_arr,sln_obj_cnt);
  Randomize;
  sln_sprite_counter_rad_arr[m]:={064}002+Random(030);
  sln_sprite_counter_pow_arr[m]:={016}200+Random(032);
  SetLength(rct_eds_img_arr            ,sln_obj_cnt);
  SetLength(rct_pts_img_arr            ,sln_obj_cnt);
  SetLength(    eds_img_arr            ,sln_obj_cnt);
  SetLength(    pts_img_arr            ,sln_obj_cnt);
  SetLength(partial_pts_sum            ,sln_obj_cnt);
  SetLength(sln_obj_pts_cnt            ,sln_obj_cnt);
  SetLength(has_sel_pts                ,sln_obj_cnt);
  SetLength(has_mod_pts0               ,sln_obj_cnt);
  SetLength(has_mod_pts1               ,sln_obj_cnt);
  SetLength(rct_bnd_ind_arr            ,sln_obj_cnt);
  SetLength(sln_vis_eds_ind            ,sln_obj_cnt);
  SetLength(sln_sel_pts_cnt            ,sln_obj_cnt);
  SetLength(scl_mul_dif                ,sln_obj_cnt);
  SetLength(pts_srt_pos_x              ,sln_obj_cnt);
  SetLength(pts_srt_pos_y              ,sln_obj_cnt);
  SetLength(pts_srt_inds               ,sln_obj_cnt);
  SetLength(min_max_inds               ,sln_obj_cnt);
  SetLength(pts_srt_pos_y_min_max      ,sln_obj_cnt);
  SetLength(has_pts                    ,sln_obj_cnt);
  SetLength(sln_pts                    ,sln_pts_cnt);
  SetLength(sln_pts_res                ,sln_pts_cnt);
  SetLength(sln_obj_ind                ,sln_pts_cnt);
  SetLength(fst_lst_sln_obj_pts        ,sln_pts_cnt);
  SetLength(has_edge                   ,sln_pts_cnt);
  with sel_var do
    begin
      SetLength(out_or_inn_subgraph_pts,sln_pts_cnt);
      SetLength(sel_pts_inds           ,sln_pts_cnt);
      SetLength(is_point_selected      ,sln_pts_cnt);
      SetLength(is_point_in_circle     ,sln_pts_cnt);
      SetLength(is_point_pos_calc      ,sln_pts_cnt);
    end;

  if (sln_pts_cnt_add>0) then
    begin
      if (global_prop.sln_type=stFreeHand) then
        begin
          SetLength(sln_pts_add,sln_pts_cnt_add );
          ListToArr(sln_pts_add,first_item,p1,p2);
          FreeList2(            first_item,p1,p2);
        end;
      Move(sln_pts_add[00000],sln_pts    [d_cnt],sln_pts_cnt_add<<4); // Check sln_pts_cnt_add<<4 !!!!!!!!!!!!!!!!!!!!!!!!!!
      Move(sln_pts_add[00000],sln_pts_res[d_cnt],sln_pts_cnt_add<<4); // Check sln_pts_cnt_add<<4 !!!!!!!!!!!!!!!!!!!!!!!!!!
     {sln_pts_cnt_add2:=0;
      sln_pts_ptr     :=Unaligned(@sln_pts    [d_cnt]);
      sln_pts_add_ptr :=Unaligned(@sln_pts_add[00000]);
      for i:=0 to sln_pts_cnt_add-1 do
        (sln_pts_ptr+i)^:=(sln_pts_add_ptr+i)^;
      SetLength(sln_pts_add,0);
      sln_pts_cnt_add2:=sln_pts_cnt_add;}
      sln_pts_cnt_add :=0;
    end;

  // spline edges bounding rectangles:
  rct_eds_img_arr[m]           :=TFastLine.Create;
  rct_eds_img_arr[m].local_prop:=global_prop;
  // spline points bounding rectangles:
  rct_pts_img_arr[m]           :=TFastLine.Create;
  rct_pts_img_arr[m].local_prop:=global_prop;
  // spline edges:
      eds_img_arr[m]           :=TFastLine.Create;
      eds_img_arr[m].local_prop:=global_prop;
  // spline points:
      pts_img_arr[m]           :=TFastLine.Create;
      pts_img_arr[m].local_prop:=global_prop; {$endregion}

  {Spline Object Calc.----------} {$region -fold}
  if (sln_obj_cnt=1) then
    begin
      partial_pts_sum[0]:=0;
      sln_obj_pts_cnt[0]:=sln_pts_cnt;
    end;
  if (sln_obj_cnt>1) then
    begin
      partial_pts_sum[m]:=partial_pts_sum[m-1]+sln_obj_pts_cnt[m-1];
      sln_obj_pts_cnt[m]:=sln_pts_cnt         -partial_pts_sum[m  ];
    end;
  if (sln_obj_pts_cnt[m]=1) then // if spline object has 1 point
    begin
      fst_lst_sln_obj_pts[partial_pts_sum[m]                     ]:=3; // set first spline object point
      fst_lst_sln_obj_pts[partial_pts_sum[m]+sln_obj_pts_cnt[m]-1]:=3; // set last  spline object point
    end;
  if (sln_obj_pts_cnt[m]>1) then // if spline object has more than 1 point
    begin
      fst_lst_sln_obj_pts[partial_pts_sum[m]                     ]:=1; // set first spline object point
      fst_lst_sln_obj_pts[partial_pts_sum[m]+sln_obj_pts_cnt[m]-1]:=2; // set last  spline object point
    end;
  {if (global_prop.sln_mode=smSpray) and (global_prop.sln_type=stFreeHand) then
    FillByte(has_edge [partial_pts_sum[m]],sln_obj_pts_cnt[m]-1,1);}
  {for i:=0 to sln_obj_pts_cnt[m]-1 do
    begin
      has_edge[partial_pts_sum[m]+i]:=Random(2);
    end;}
  FillWord(sln_obj_ind[partial_pts_sum[m]],sln_obj_pts_cnt[m],m);
  sln_eds_cnt:=sln_pts_cnt-sln_obj_cnt; {$endregion}

  {Aligning Points--------------} {$region -fold}
  {if snp_grd_var.align_pts then
    with sel_pts_var do
      snp_grd_var.AlignPts(sln_pts,sel_pts_inds,sln_pts_cnt,sel_pts_cnt);} {$endregion}

  {Spline Init.-----------------} {$region -fold}

  {Spline Edges Bounding Rectangles-} {$region -fold}
  with rct_eds_img_arr[m],local_prop do
    begin

      {Settings-----} {$region -fold}
      rct_clp_ptr:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[obj_var.curve_cnt-1]].rct_clp_ptr;
      if rct_eds_col_fall_off then
        begin
          rct_eds_col:=HighLightLimit(global_prop.rct_eds_col,global_prop.rct_eds_col_fall_off_inc);
          if   (global_prop.rct_eds_col_fall_off_inc<>255) then
            Inc(global_prop.rct_eds_col_fall_off_inc);
        end
      else
      if rct_eds_col_rnd then
        RndSplineCol(local_prop,rct_eds_col,rct_eds_col_inv,rct_eds_col_ptr,F_MainForm.SB_Spline_Edges_Bounds_Color);
      rct_eds_col_inv:=SetColorInv(rct_eds_col);
      pts_col_inv:=rct_eds_col_inv; {$endregion}

      {Create Sprite} {$region -fold}
      SetLength(rct_eds_ind_arr ,Length(rct_eds_ind_arr )+1);
      SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
      sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
      (
        bmp_dst_ptr,
        bmp_dst_width,
        bmp_dst_height,
        rct_clp_ptr^,
        rct_vis,
        0
      );
      rct_eds_ind_arr[Length(rct_eds_ind_arr)-1]:=Length(sprite_sheet_arr)-1; {$endregion}

    end; {$endregion}

  {Spline Points Bounding Rectangles} {$region -fold}
  with rct_pts_img_arr[m],local_prop do
    begin

      {Settings-----} {$region -fold}
      rct_clp_ptr:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[obj_var.curve_cnt-1]].rct_clp_ptr;
      if rct_pts_col_fall_off then
        begin
          eds_col:=HighLightLimit(global_prop.rct_pts_col,global_prop.rct_pts_col_fall_off_inc);
          if   (global_prop.rct_pts_col_fall_off_inc<>255) then
            Inc(global_prop.rct_pts_col_fall_off_inc);
        end
      else
      if rct_pts_col_rnd then
        RndSplineCol(local_prop,rct_pts_col,rct_pts_col_inv,rct_pts_col_ptr,F_MainForm.SB_Spline_Points_Bounds_Color);
      rct_pts_col_inv:=SetColorInv(rct_pts_col);
      pts_col_inv    :=rct_pts_col_inv; {$endregion}

      {Create Sprite} {$region -fold}
      SetLength(rct_pts_ind_arr ,Length(rct_pts_ind_arr )+1);
      SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
      sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
      (
        bmp_dst_ptr,
        bmp_dst_width,
        bmp_dst_height,
        rct_clp_ptr^,
        rct_vis,
        0
      );
      rct_pts_ind_arr[Length(rct_pts_ind_arr)-1]:=Length(sprite_sheet_arr)-1; {$endregion}

    end; {$endregion}

  {Spline Edges---------------------} {$region -fold}
  with eds_img_arr[m],local_prop do
    begin

      {Settings-----} {$region -fold}
      rct_clp_ptr:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[obj_var.curve_cnt-1]].rct_clp_ptr;
      if eds_col_fall_off then
        begin
          eds_col:=HighLightLimit(global_prop.eds_col,global_prop.eds_col_fall_off_inc);
          if   (global_prop.eds_col_fall_off_inc<>255) then
            Inc(global_prop.eds_col_fall_off_inc);
          F_MainForm.SB_Spline_Edges_Post_Processing_Color.Color:=eds_col;
        end
      else
      if eds_col_rnd then
        RndSplineCol(local_prop,eds_col,eds_col_inv,eds_col_ptr,F_MainForm.SB_Spline_Edges_Post_Processing_Color);
      eds_show   :=(eds_show             ) and
                   (eds_width         <>0) and
                   (sln_obj_pts_cnt[m]<>1);
      cnc_ends   :=(cnc_ends             ) and
                   (sln_obj_pts_cnt[m] >2);
      eds_col_inv:=SetColorInv(eds_col);
      if hid_ln_elim then
        begin
          SetLength(useless_arr,sln_obj_pts_cnt[m]{-1});
          has_hid_ln_elim_sln:=True;
        end;
      if byte_mode then
        has_byte_mode_sln:=True; {$endregion}

      {Create Sprite} {$region -fold}
      SetLength(eds_ind_arr     ,Length(eds_ind_arr     )+1);
      SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
      sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
      (
        bmp_dst_ptr,
        bmp_dst_width,
        bmp_dst_height,
        rct_clp_ptr^,
        rct_vis,
        0
      );
      eds_ind_arr[Length(eds_ind_arr)-1]:=Length(sprite_sheet_arr)-1; {$endregion}

    end; {$endregion}

  {Spline Points--------------------} {$region -fold}
  with pts_img_arr[m],local_prop do
    begin

      {Grid Clipping} {$region -fold}
      if grid_clipping_pts then
        GrdSplineCalc(m); {$endregion}

      {Settings-----} {$region -fold}
      rct_clp_ptr:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[obj_var.curve_cnt-1]].rct_clp_ptr;
      if pts_col_fall_off then
        begin
          pts_col:=HighLightLimit(global_prop.pts_col,global_prop.pts_col_fall_off_inc);
          if   (global_prop.pts_col_fall_off_inc<>255) then
            Inc(global_prop.pts_col_fall_off_inc);
          F_MainForm.SB_Spline_Points_Post_Processing_Color.Color:=pts_col;
        end
      else
      if pts_col_rnd then
        RndSplineCol(local_prop,pts_col,pts_col_inv,pts_col_ptr,F_MainForm.SB_Spline_Points_Post_Processing_Color);
      pts_show   :=(pts_show     ) and
                   (pts_width <>0) and
                   (pts_height<>0);
      pts_col_inv:=SetColorInv(pts_col);
      if byte_mode then
        has_byte_mode_sln:=True;
      SetRctDupId(local_prop); {$endregion}

      {Create Sprite} {$region -fold}
      SetLength(pts_ind_arr     ,Length(pts_ind_arr     )+1);
      SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
      sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
      (
        bmp_dst_ptr,
        bmp_dst_width,
        bmp_dst_height,
        rct_clp_ptr^,
        rct_vis,
        0
      );
      pts_ind_arr[Length(pts_ind_arr)-1]:=Length(sprite_sheet_arr)-1; {$endregion}

    end; {$endregion} {$endregion}

  {Spline Object Rectangle Init.} {$region -fold}
  RctSplineObj0(m); {$endregion}

end; {$endregion}
procedure TCurve.ClippedLineW2     (x0,y0,x1,y1:double; const rct_clp:TPtRect; const proc1:TProc20; const proc2,proc3,proc4,proc5:TProc0);                                   {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with eds_big_img do
    begin
      ClippedLine2
      (
        x0,
        y0,
        x1,
        y1,
        rct_clp,
        proc1,
        proc2,
        proc3,
        proc4,
        proc5
      );
      if (Abs(y1-y0)<Abs(x1-x0)) then
        ClippedLine2
        (
          x0+0,
          y0+1,
          x1+0,
          y1+1,
          rct_clp,
          proc1,
          proc2,
          proc3,
          proc4,
          proc5
        )
      else
        ClippedLine2
        (
          x0+1,
          y0+0,
          x1+1,
          y1+0,
          rct_clp,
          proc1,
          proc2,
          proc3,
          proc4,
          proc5
        );
    end;
end; {$endregion}
procedure TCurve.ClippedLineW3     (x0,y0,x1,y1:double; const rct_clp:TPtRect; const proc1:TProc20; const proc2,proc3,proc4,proc5:TProc0);                                   {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with eds_big_img do
    begin
      ClippedLine2
      (
        x0,
        y0,
        x1,
        y1,
        rct_clp,
        proc1,
        proc2,
        proc3,
        proc4,
        proc5
      );
      if (Abs(y1-y0)<Abs(x1-x0)) then
        begin
          ClippedLine2
          (
            x0+0,
            y0+1,
            x1+0,
            y1+1,
            rct_clp,
            proc1,
            proc2,
            proc3,
            proc4,
            proc5
          );
          ClippedLine2
          (
            x0+0,
            y0-1,
            x1+0,
            y1-1,
            rct_clp,
            proc1,
            proc2,
            proc3,
            proc4,
            proc5
          );
        end
      else
        begin
          ClippedLine2
          (
            x0+1,
            y0+0,
            x1+1,
            y1+0,
            rct_clp,
            proc1,
            proc2,
            proc3,
            proc4,
            proc5
          );
          ClippedLine2
          (
            x0-1,
            y0+0,
            x1-1,
            y1+0,
            rct_clp,
            proc1,
            proc2,
            proc3,
            proc4,
            proc5
          );
        end;
    end;
end; {$endregion}
procedure TCurve.AddSplineRctEds   (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_eds_img_arr[spline_ind],local_prop do
    begin
      pts_rct_inn_width :=rct_ent_2.width -2;
      pts_rct_inn_height:=rct_ent_2.height-2;
      pts_rct_tns_left  :=1;
      pts_rct_tns_top   :=1;
      pts_rct_tns_right :=1;
      pts_rct_tns_bottom:=1;
      SetRctWidth (local_prop);
      SetRctHeight(local_prop);
      SetRctValues(local_prop);
      Rectangle
      (
        pts_rct_width__half-pts_rct_width__odd+rct_ent_2.left,
        pts_rct_height_half-pts_rct_height_odd+rct_ent_2.top ,
        rct_eds_big_img.ln_arr1_ptr,
        rct_eds_big_img.ln_arr_width,
        rct_eds_big_img.ln_arr_height,
        rct_vis,
        local_prop,
        @PPFloodFillAdd
      );
    end;
end; {$endregion}
procedure TCurve.AddSplineRctPts   (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_pts_img_arr[spline_ind],local_prop do
    begin
      pts_rct_inn_width :=rct_ent_2.width -2;
      pts_rct_inn_height:=rct_ent_2.height-2;
      pts_rct_tns_left  :=1;
      pts_rct_tns_top   :=1;
      pts_rct_tns_right :=1;
      pts_rct_tns_bottom:=1;
      SetRctWidth (local_prop);
      SetRctHeight(local_prop);
      SetRctValues(local_prop);
      Rectangle
      (
        pts_rct_width__half-pts_rct_width__odd+rct_ent_2.left,
        pts_rct_height_half-pts_rct_height_odd+rct_ent_2.top ,
        rct_pts_big_img.ln_arr1_ptr,
        rct_pts_big_img.ln_arr_width,
        rct_pts_big_img.ln_arr_height,
        rct_vis,
        local_prop,
        @PPFloodFillAdd
      );
    end;
end; {$endregion}
procedure TCurve.AddSplineEds00    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  w_a_s_x,w_a_s_y: integer;
  x0,y0,x1,y1    : double;
  rct_rad        : double;
  b,i            : integer;
  max_w_h_div_2  : integer;
  min_w_h_div_2  : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b            :=partial_pts_sum[spline_ind];
      obj_arr_ptr  :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr  :=Unaligned(@sln_pts [b]);
      has_edge_ptr :=Unaligned(@has_edge[b]);
      max_w_h_div_2:=Max(rct_clp_ptr^.width,rct_clp_ptr^.height)>>1;
      min_w_h_div_2:=Min(rct_clp_ptr^.width,rct_clp_ptr^.height)>>1;
      rct_rad      :=sqrt(sqr(max_w_h_div_2)+sqr(min_w_h_div_2));
      w_a_s_x      :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y      :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir      :=mdNone;} {$endregion}


      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine2
                (
                  sln_pts[b+00000000000000000000000000000].x+w_a_s_x,
                  sln_pts[b+00000000000000000000000000000].y+w_a_s_y,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y,
                  rct_clp_ptr^,
                  Unaligned(@LinePHL20),
                  Unaligned(@LineSHL20),
                  Unaligned(@LineSVL20),
                  Unaligned(@LinePHL21),
                  Unaligned(@LinePHL22)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                with eds_big_img do
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                      y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                      x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                      y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                      //if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_clp_ptr^)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad,0)} then
                        ClippedLine2
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20),
                          Unaligned(@LineSVL20),
                          Unaligned(@LinePHL21),
                          Unaligned(@LinePHL22)
                        );
                    end;
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20),
                    Unaligned(@LineSVL20),
                    Unaligned(@LinePHL21),
                    Unaligned(@LinePHL22)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine2
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20),
                      Unaligned(@LineSVL20),
                      Unaligned(@LinePHL21),
                      Unaligned(@LinePHL22)
                    )
                  else
                    ClippedLine2
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20),
                      Unaligned(@LineSVL20),
                      Unaligned(@LinePHL21),
                      Unaligned(@LinePHL22)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                if (has_edge_ptr^=0) then
                  begin
                    x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                    y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                    x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                    y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                    //if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_clp_ptr^)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad+1,0)} then
                      begin
                        ClippedLine2
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20),
                          Unaligned(@LineSVL20),
                          Unaligned(@LinePHL21),
                          Unaligned(@LinePHL22)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          ClippedLine2
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL20),
                            Unaligned(@LineSHL20),
                            Unaligned(@LineSVL20),
                            Unaligned(@LinePHL21),
                            Unaligned(@LinePHL22)
                          )
                        else
                          ClippedLine2
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL20),
                            Unaligned(@LineSHL20),
                            Unaligned(@LineSVL20),
                            Unaligned(@LinePHL21),
                            Unaligned(@LinePHL22)
                          );
                      end;
                    Inc(sln_pts_ptr );
                    Inc(has_edge_ptr);
                  end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20),
                    Unaligned(@LineSVL20),
                    Unaligned(@LinePHL21),
                    Unaligned(@LinePHL22)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                      ClippedLine2
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                    end
                  else
                    begin
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                      ClippedLine2
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                if (has_edge_ptr^=0) then
                  begin
                    x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                    y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                    x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                    y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                    //if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_clp_ptr^)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad+2,0)} then
                      begin
                        ClippedLine2
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20),
                          Unaligned(@LineSVL20),
                          Unaligned(@LinePHL21),
                          Unaligned(@LinePHL22)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          begin
                            ClippedLine2
                            (
                              x0+0,
                              y0+1,
                              x1+0,
                              y1+1,
                              rct_clp_ptr^,
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20),
                              Unaligned(@LineSVL20),
                              Unaligned(@LinePHL21),
                              Unaligned(@LinePHL22)
                            );
                            ClippedLine2
                            (
                              x0+0,
                              y0-1,
                              x1+0,
                              y1-1,
                              rct_clp_ptr^,
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20),
                              Unaligned(@LineSVL20),
                              Unaligned(@LinePHL21),
                              Unaligned(@LinePHL22)
                            );
                          end
                        else
                          begin
                            ClippedLine2
                            (
                              x0+1,
                              y0+0,
                              x1+1,
                              y1+0,
                              rct_clp_ptr^,
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20),
                              Unaligned(@LineSVL20),
                              Unaligned(@LinePHL21),
                              Unaligned(@LinePHL22)
                            );
                            ClippedLine2
                            (
                              x0-1,
                              y0+0,
                              x1-1,
                              y1+0,
                              rct_clp_ptr^,
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20),
                              Unaligned(@LineSVL20),
                              Unaligned(@LinePHL21),
                              Unaligned(@LinePHL22)
                            );
                          end;
                      end;
                    Inc(sln_pts_ptr );
                    Inc(has_edge_ptr);
                  end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds01    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  x0,y0,x1,y1    : double;
  w_a_s_x,w_a_s_y: integer;
  b,i            : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]);
      w_a_s_x     :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y     :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir     :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL20(x0,y0,x1,y1);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                with eds_big_img do
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                      y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                      x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                      y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                      LinePHL20(x0,y0,x1,y1);
                    end;
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL20(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL20(x0+0,y0+1,x1+0,y1+1)
                  else
                    LinePHL20(x0+1,y0+0,x1+1,y1+0);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                if (has_edge_ptr^=0) then
                  begin
                    x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                    y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                    x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                    y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                    LinePHL20(x0,y0,x1,y1);
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      LinePHL20(x0+0,y0+1,x1+0,y1+1)
                    else
                      LinePHL20(x0+1,y0+0,x1+1,y1+0);
                    Inc(sln_pts_ptr );
                    Inc(has_edge_ptr);
                  end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL20(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL20(x0+0,y0+1,x1+0,y1+1);
                      LinePHL20(x0+0,y0-1,x1+0,y1-1);
                    end
                  else
                    begin
                      LinePHL20(x0+1,y0+0,x1+1,y1+0);
                      LinePHL20(x0-1,y0+0,x1-1,y1+0);
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                if (has_edge_ptr^=0) then
                  begin
                    x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                    y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                    x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                    y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                    LinePHL20(x0,y0,x1,y1);
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      begin
                        LinePHL20(x0+0,y0+1,x1+0,y1+1);
                        LinePHL20(x0+0,y0-1,x1+0,y1-1);
                      end
                    else
                      begin
                        LinePHL20(x0+1,y0+0,x1+1,y1+0);
                        LinePHL20(x0-1,y0+0,x1-1,y1+0);
                      end;
                    Inc(sln_pts_ptr );
                    Inc(has_edge_ptr);
                  end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds02    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  w_a_s_x,w_a_s_y: integer;
  x0,y0,x1,y1    : double;
  b,i            : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]);
      w_a_s_x     :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y     :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir     :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if (not (sel_var.is_point_selected[b+00000000000000000000000000000] or
                     sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1])) then
              if cnc_ends then
                with eds_big_img do
                  ClippedLine2
                  (
                    sln_pts[b+00000000000000000000000000000].x+w_a_s_x,
                    sln_pts[b+00000000000000000000000000000].y+w_a_s_y,
                    sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x,
                    sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20),
                    Unaligned(@LineSVL20),
                    Unaligned(@LinePHL21),
                    Unaligned(@LinePHL22)
                  ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if (not (sel_var.is_point_selected[b+i] or
                         sel_var.is_point_selected[b+i+1])) then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      ClippedLine2
                      (
                        (sln_pts_ptr+0)^.x+w_a_s_x,
                        (sln_pts_ptr+0)^.y+w_a_s_y,
                        (sln_pts_ptr+1)^.x+w_a_s_x,
                        (sln_pts_ptr+1)^.y+w_a_s_y,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if (not (sel_var.is_point_selected[b+00000000000000000000000000000] or
                     sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1])) then
              if cnc_ends then
                with eds_big_img do
                  begin
                    x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                    y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                    x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                    y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                    ClippedLine2
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20),
                      Unaligned(@LineSVL20),
                      Unaligned(@LinePHL21),
                      Unaligned(@LinePHL22)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      )
                    else
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                  end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if (not (sel_var.is_point_selected[b+i] or
                         sel_var.is_point_selected[b+i+1])) then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      begin
                        x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                        y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                        x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                        y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                        ClippedLine2
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20),
                          Unaligned(@LineSVL20),
                          Unaligned(@LinePHL21),
                          Unaligned(@LinePHL22)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          ClippedLine2
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL20),
                            Unaligned(@LineSHL20),
                            Unaligned(@LineSVL20),
                            Unaligned(@LinePHL21),
                            Unaligned(@LinePHL22)
                          )
                        else
                          ClippedLine2
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL20),
                            Unaligned(@LineSHL20),
                            Unaligned(@LineSVL20),
                            Unaligned(@LinePHL21),
                            Unaligned(@LinePHL22)
                          );
                      end;
                  Inc(sln_pts_ptr);
                  Inc(has_edge_ptr);
              end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if (not (sel_var.is_point_selected[b+00000000000000000000000000000] or
                     sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1])) then
              if cnc_ends then
                with eds_big_img do
                  begin
                    x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                    y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                    x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                    y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                    ClippedLine2
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20),
                      Unaligned(@LineSVL20),
                      Unaligned(@LinePHL21),
                      Unaligned(@LinePHL22)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      begin
                        ClippedLine2
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20),
                          Unaligned(@LineSVL20),
                          Unaligned(@LinePHL21),
                          Unaligned(@LinePHL22)
                        );
                        ClippedLine2
                        (
                          x0+0,
                          y0-1,
                          x1+0,
                          y1-1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20),
                          Unaligned(@LineSVL20),
                          Unaligned(@LinePHL21),
                          Unaligned(@LinePHL22)
                        );
                      end
                    else
                      begin
                        ClippedLine2
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20),
                          Unaligned(@LineSVL20),
                          Unaligned(@LinePHL21),
                          Unaligned(@LinePHL22)
                        );
                        ClippedLine2
                        (
                          x0-1,
                          y0+0,
                          x1-1,
                          y1+0,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20),
                          Unaligned(@LineSVL20),
                          Unaligned(@LinePHL21),
                          Unaligned(@LinePHL22)
                        );
                      end;
                  end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if (not (sel_var.is_point_selected[b+i] or
                         sel_var.is_point_selected[b+i+1])) then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      begin
                        x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                        y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                        x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                        y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                        ClippedLine2
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20),
                          Unaligned(@LineSVL20),
                          Unaligned(@LinePHL21),
                          Unaligned(@LinePHL22)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          begin
                            ClippedLine2
                            (
                              x0+0,
                              y0+1,
                              x1+0,
                              y1+1,
                              rct_clp_ptr^,
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20),
                              Unaligned(@LineSVL20),
                              Unaligned(@LinePHL21),
                              Unaligned(@LinePHL22)
                            );
                            ClippedLine2
                            (
                              x0+0,
                              y0-1,
                              x1+0,
                              y1-1,
                              rct_clp_ptr^,
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20),
                              Unaligned(@LineSVL20),
                              Unaligned(@LinePHL21),
                              Unaligned(@LinePHL22)
                            );
                          end
                        else
                          begin
                            ClippedLine2
                            (
                              x0+1,
                              y0+0,
                              x1+1,
                              y1+0,
                              rct_clp_ptr^,
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20),
                              Unaligned(@LineSVL20),
                              Unaligned(@LinePHL21),
                              Unaligned(@LinePHL22)
                            );
                            ClippedLine2
                            (
                              x0-1,
                              y0+0,
                              x1-1,
                              y1+0,
                              rct_clp_ptr^,
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20),
                              Unaligned(@LineSVL20),
                              Unaligned(@LinePHL21),
                              Unaligned(@LinePHL22)
                            );
                          end;
                      end;
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds03    (const spline_ind       :TColor); {TODO: optimization}                                                                                    {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  w_a_s_x,w_a_s_y: integer;
  x0,y0,x1,y1    : double;
  b,i            : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]);
      w_a_s_x     :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y     :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir     :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if sel_var.is_point_selected[b+00000000000000000000000000000] or
               sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1] then
              if cnc_ends then
                with eds_big_img do
                  ClippedLine2
                  (
                    sln_pts[b+00000000000000000000000000000].x+w_a_s_x,
                    sln_pts[b+00000000000000000000000000000].y+w_a_s_y,
                    sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x,
                    sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20),
                    Unaligned(@LineSVL20),
                    Unaligned(@LinePHL21),
                    Unaligned(@LinePHL22)
                  ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if sel_var.is_point_selected[b+i+0] or
                   sel_var.is_point_selected[b+i+1] then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      ClippedLine2
                      (
                        (sln_pts_ptr+0)^.x+w_a_s_x,
                        (sln_pts_ptr+0)^.y+w_a_s_y,
                        (sln_pts_ptr+1)^.x+w_a_s_x,
                        (sln_pts_ptr+1)^.y+w_a_s_y,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if sel_var.is_point_selected[b+00000000000000000000000000000] or
               sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1] then
              if cnc_ends then
                with eds_big_img do
                  begin
                    x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                    y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                    x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                    y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                    ClippedLine2
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20),
                      Unaligned(@LineSVL20),
                      Unaligned(@LinePHL21),
                      Unaligned(@LinePHL22)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      )
                    else
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                  end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if sel_var.is_point_selected[b+i+0] or
                   sel_var.is_point_selected[b+i+1] then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      begin
                        x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                        y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                        x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                        y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                        ClippedLine2
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20),
                          Unaligned(@LineSVL20),
                          Unaligned(@LinePHL21),
                          Unaligned(@LinePHL22)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          ClippedLine2
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL20),
                            Unaligned(@LineSHL20),
                            Unaligned(@LineSVL20),
                            Unaligned(@LinePHL21),
                            Unaligned(@LinePHL22)
                          )
                        else
                          ClippedLine2
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL20),
                            Unaligned(@LineSHL20),
                            Unaligned(@LineSVL20),
                            Unaligned(@LinePHL21),
                            Unaligned(@LinePHL22)
                          );
                      end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
              end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if sel_var.is_point_selected[b+00000000000000000000000000000] or
               sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1] then
              if cnc_ends then
                with eds_big_img do
                  begin
                    x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                    y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                    x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                    y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                    ClippedLine2
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20),
                      Unaligned(@LineSVL20),
                      Unaligned(@LinePHL21),
                      Unaligned(@LinePHL22)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      begin
                        ClippedLine2
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20),
                          Unaligned(@LineSVL20),
                          Unaligned(@LinePHL21),
                          Unaligned(@LinePHL22)
                        );
                        ClippedLine2
                        (
                          x0+0,
                          y0-1,
                          x1+0,
                          y1-1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20),
                          Unaligned(@LineSVL20),
                          Unaligned(@LinePHL21),
                          Unaligned(@LinePHL22)
                        );
                      end
                    else
                      begin
                        ClippedLine2
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20),
                          Unaligned(@LineSVL20),
                          Unaligned(@LinePHL21),
                          Unaligned(@LinePHL22)
                        );
                        ClippedLine2
                        (
                          x0-1,
                          y0+0,
                          x1-1,
                          y1+0,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20),
                          Unaligned(@LineSVL20),
                          Unaligned(@LinePHL21),
                          Unaligned(@LinePHL22)
                        );
                      end;
                  end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if sel_var.is_point_selected[b+i+0] or
                   sel_var.is_point_selected[b+i+1] then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      begin
                        x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                        y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                        x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                        y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                        ClippedLine2
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL20),
                          Unaligned(@LineSHL20),
                          Unaligned(@LineSVL20),
                          Unaligned(@LinePHL21),
                          Unaligned(@LinePHL22)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          begin
                            ClippedLine2
                            (
                              x0+0,
                              y0+1,
                              x1+0,
                              y1+1,
                              rct_clp_ptr^,
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20),
                              Unaligned(@LineSVL20),
                              Unaligned(@LinePHL21),
                              Unaligned(@LinePHL22)
                            );
                            ClippedLine2
                            (
                              x0+0,
                              y0-1,
                              x1+0,
                              y1-1,
                              rct_clp_ptr^,
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20),
                              Unaligned(@LineSVL20),
                              Unaligned(@LinePHL21),
                              Unaligned(@LinePHL22)
                            );
                          end
                        else
                          begin
                            ClippedLine2
                            (
                              x0+1,
                              y0+0,
                              x1+1,
                              y1+0,
                              rct_clp_ptr^,
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20),
                              Unaligned(@LineSVL20),
                              Unaligned(@LinePHL21),
                              Unaligned(@LinePHL22)
                            );
                            ClippedLine2
                            (
                              x0-1,
                              y0+0,
                              x1-1,
                              y1+0,
                              rct_clp_ptr^,
                              Unaligned(@LinePHL20),
                              Unaligned(@LineSHL20),
                              Unaligned(@LineSVL20),
                              Unaligned(@LinePHL21),
                              Unaligned(@LinePHL22)
                            );
                          end;
                      end;
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds04    (const spline_ind       :TColor); {TODO: optimization}                                                                                    {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  w_a_s_x,w_a_s_y: integer;
  x0,y0,x1,y1    : double;
  b,i            : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]);
      w_a_s_x     :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y     :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir     :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if sel_var.is_point_selected[b+00000000000000000000000000000] or
               sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1] then
              if cnc_ends then
                with eds_big_img do
                  ClippedLine2
                  (
                    sln_pts[b+00000000000000000000000000000].x+w_a_s_x,
                    sln_pts[b+00000000000000000000000000000].y+w_a_s_y,
                    sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x,
                    sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL10),
                    Unaligned(@LineSHL10),
                    Unaligned(@LineSVL10),
                    Unaligned(@LinePHL11),
                    Unaligned(@LinePHL12)
                  ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if sel_var.is_point_selected[b+i+0] or
                   sel_var.is_point_selected[b+i+1] then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      ClippedLine2
                      (
                        (sln_pts_ptr+0)^.x+w_a_s_x,
                        (sln_pts_ptr+0)^.y+w_a_s_y,
                        (sln_pts_ptr+1)^.x+w_a_s_x,
                        (sln_pts_ptr+1)^.y+w_a_s_y,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL10),
                        Unaligned(@LineSHL10),
                        Unaligned(@LineSVL10),
                        Unaligned(@LinePHL11),
                        Unaligned(@LinePHL12)
                      );
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if sel_var.is_point_selected[b+00000000000000000000000000000] or
               sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1] then
              if cnc_ends then
                with eds_big_img do
                  begin
                    x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                    y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                    x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                    y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                    ClippedLine2
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL10),
                      Unaligned(@LineSHL10),
                      Unaligned(@LineSVL10),
                      Unaligned(@LinePHL11),
                      Unaligned(@LinePHL12)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL10),
                        Unaligned(@LineSHL10),
                        Unaligned(@LineSVL10),
                        Unaligned(@LinePHL11),
                        Unaligned(@LinePHL12)
                      )
                    else
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL10),
                        Unaligned(@LineSHL10),
                        Unaligned(@LineSVL10),
                        Unaligned(@LinePHL11),
                        Unaligned(@LinePHL12)
                      );
                  end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if sel_var.is_point_selected[b+i+0] or
                   sel_var.is_point_selected[b+i+1] then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      begin
                        x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                        y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                        x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                        y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                        ClippedLine2
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL10),
                          Unaligned(@LineSHL10),
                          Unaligned(@LineSVL10),
                          Unaligned(@LinePHL11),
                          Unaligned(@LinePHL12)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          ClippedLine2
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL10),
                            Unaligned(@LineSHL10),
                            Unaligned(@LineSVL10),
                            Unaligned(@LinePHL11),
                            Unaligned(@LinePHL12)
                          )
                        else
                          ClippedLine2
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL10),
                            Unaligned(@LineSHL10),
                            Unaligned(@LineSVL10),
                            Unaligned(@LinePHL11),
                            Unaligned(@LinePHL12)
                          );
                      end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
              end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if sel_var.is_point_selected[b+00000000000000000000000000000] or
               sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1] then
              if cnc_ends then
                with eds_big_img do
                  begin
                    x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                    y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                    x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                    y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                    ClippedLine2
                    (
                      x0,
                      y0,
                      x1,
                      y1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL10),
                      Unaligned(@LineSHL10),
                      Unaligned(@LineSVL10),
                      Unaligned(@LinePHL11),
                      Unaligned(@LinePHL12)
                    );
                    if (Abs(y1-y0)<Abs(x1-x0)) then
                      begin
                        ClippedLine2
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL10),
                          Unaligned(@LineSHL10),
                          Unaligned(@LineSVL10),
                          Unaligned(@LinePHL11),
                          Unaligned(@LinePHL12)
                        );
                        ClippedLine2
                        (
                          x0+0,
                          y0-1,
                          x1+0,
                          y1-1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL10),
                          Unaligned(@LineSHL10),
                          Unaligned(@LineSVL10),
                          Unaligned(@LinePHL11),
                          Unaligned(@LinePHL12)
                        );
                      end
                    else
                      begin
                        ClippedLine2
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL10),
                          Unaligned(@LineSHL10),
                          Unaligned(@LineSVL10),
                          Unaligned(@LinePHL11),
                          Unaligned(@LinePHL12)
                        );
                        ClippedLine2
                        (
                          x0-1,
                          y0+0,
                          x1-1,
                          y1+0,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL10),
                          Unaligned(@LineSHL10),
                          Unaligned(@LineSVL10),
                          Unaligned(@LinePHL11),
                          Unaligned(@LinePHL12)
                        );
                      end;
                  end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                if sel_var.is_point_selected[b+i+0] or
                   sel_var.is_point_selected[b+i+1] then
                  with eds_big_img do
                    if (has_edge_ptr^=0) then
                      begin
                        x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                        y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                        x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                        y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                        ClippedLine2
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL10),
                          Unaligned(@LineSHL10),
                          Unaligned(@LineSVL10),
                          Unaligned(@LinePHL11),
                          Unaligned(@LinePHL12)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          begin
                            ClippedLine2
                            (
                              x0+0,
                              y0+1,
                              x1+0,
                              y1+1,
                              rct_clp_ptr^,
                              Unaligned(@LinePHL10),
                              Unaligned(@LineSHL10),
                              Unaligned(@LineSVL10),
                              Unaligned(@LinePHL11),
                              Unaligned(@LinePHL12)
                            );
                            ClippedLine2
                            (
                              x0+0,
                              y0-1,
                              x1+0,
                              y1-1,
                              rct_clp_ptr^,
                              Unaligned(@LinePHL10),
                              Unaligned(@LineSHL10),
                              Unaligned(@LineSVL10),
                              Unaligned(@LinePHL11),
                              Unaligned(@LinePHL12)
                            );
                          end
                        else
                          begin
                            ClippedLine2
                            (
                              x0+1,
                              y0+0,
                              x1+1,
                              y1+0,
                              rct_clp_ptr^,
                              Unaligned(@LinePHL10),
                              Unaligned(@LineSHL10),
                              Unaligned(@LineSVL10),
                              Unaligned(@LinePHL11),
                              Unaligned(@LinePHL12)
                            );
                            ClippedLine2
                            (
                              x0-1,
                              y0+0,
                              x1-1,
                              y1+0,
                              rct_clp_ptr^,
                              Unaligned(@LinePHL10),
                              Unaligned(@LineSHL10),
                              Unaligned(@LineSVL10),
                              Unaligned(@LinePHL11),
                              Unaligned(@LinePHL12)
                            );
                          end;
                      end;
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds05    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr        : PObjProp;
  sln_pts_ptr        : PPtPosF;
  sln_pts_ptr2       : PPtPosF;
  sln_vis_eds_ind_ptr: PColor;
  w_a_s_x,w_a_s_y: integer;
  x0,y0,x1,y1        : double;
  b,i                : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b                  :=partial_pts_sum[spline_ind];
      obj_arr_ptr        :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr        :=Unaligned(@sln_pts[b]);
      sln_vis_eds_ind_ptr:=@sln_vis_eds_ind[spline_ind,0];
      w_a_s_x            :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y            :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir            :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine2
                (
                  sln_pts[b+00000000000000000000000000000].x+w_a_s_x,
                  sln_pts[b+00000000000000000000000000000].y+w_a_s_y,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y,
                  rct_clp_ptr^,
                  Unaligned(@LinePHL20),
                  Unaligned(@LineSHL20),
                  Unaligned(@LineSVL20),
                  Unaligned(@LinePHL21),
                  Unaligned(@LinePHL22)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  ClippedLine2
                  (
                    (sln_pts_ptr2+0)^.x+w_a_s_x,
                    (sln_pts_ptr2+0)^.y+w_a_s_y,
                    (sln_pts_ptr2+1)^.x+w_a_s_x,
                    (sln_pts_ptr2+1)^.y+w_a_s_y,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20),
                    Unaligned(@LineSVL20),
                    Unaligned(@LinePHL21),
                    Unaligned(@LinePHL22)
                  );
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20),
                    Unaligned(@LineSVL20),
                    Unaligned(@LinePHL21),
                    Unaligned(@LinePHL22)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine2
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20),
                      Unaligned(@LineSVL20),
                      Unaligned(@LinePHL21),
                      Unaligned(@LinePHL22)
                    )
                  else
                    ClippedLine2
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20),
                      Unaligned(@LineSVL20),
                      Unaligned(@LinePHL21),
                      Unaligned(@LinePHL22)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:= sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                  y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                  x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                  y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20),
                    Unaligned(@LineSVL20),
                    Unaligned(@LinePHL21),
                    Unaligned(@LinePHL22)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine2
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20),
                      Unaligned(@LineSVL20),
                      Unaligned(@LinePHL21),
                      Unaligned(@LinePHL22)
                    )
                  else
                    ClippedLine2
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20),
                      Unaligned(@LineSVL20),
                      Unaligned(@LinePHL21),
                      Unaligned(@LinePHL22)
                    );
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20),
                    Unaligned(@LineSVL20),
                    Unaligned(@LinePHL21),
                    Unaligned(@LinePHL22)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                      ClippedLine2
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                    end
                  else
                    begin
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                      ClippedLine2
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:= sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                  y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                  x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                  y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20),
                    Unaligned(@LineSVL20),
                    Unaligned(@LinePHL21),
                    Unaligned(@LinePHL22)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                      ClippedLine2
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                    end
                  else
                    begin
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                      ClippedLine2
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                    end;
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds06    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr        : PObjProp;
  sln_pts_ptr        : PPtPosF;
  sln_pts_ptr2       : PPtPosF;
  sln_vis_eds_ind_ptr: PColor;
  x0,y0,x1,y1        : double;
  w_a_s_x,w_a_s_y    : integer;
  b,i                : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b                  :=partial_pts_sum[spline_ind];
      obj_arr_ptr        :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr        :=Unaligned(@sln_pts[b]);
      sln_vis_eds_ind_ptr:=Unaligned(@sln_vis_eds_ind[spline_ind,0]);
      w_a_s_x            :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y            :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir            :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL20(x0,y0,x1,y1);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0          :=(sln_pts_ptr+0)^.x+w_a_s_x;
                  y0          :=(sln_pts_ptr+0)^.y+w_a_s_y;
                  x1          :=(sln_pts_ptr+1)^.x+w_a_s_x;
                  y1          :=(sln_pts_ptr+1)^.y+w_a_s_y;
                  LinePHL20(x0,y0,x1,y1);
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL20(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL20(x0+0,y0+1,x1+0,y1+1)
                  else
                    LinePHL20(x0+1,y0+0,x1+1,y1+0);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:= sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                  y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                  x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                  y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                  LinePHL20(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL20(x0+0,y0+1,x1+0,y1+1)
                  else
                    LinePHL20(x0+1,y0+0,x1+1,y1+0);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL20(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL20(x0+0,y0+1,x1+0,y1+1);
                      LinePHL20(x0+0,y0-1,x1+0,y1-1);
                    end
                  else
                    begin
                      LinePHL20(x0+1,y0+0,x1+1,y1+0);
                      LinePHL20(x0-1,y0+0,x1-1,y1+0);
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:= sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                  y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                  x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                  y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                  LinePHL20(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL20(x0+0,y0+1,x1+0,y1+1);
                      LinePHL20(x0+0,y0-1,x1+0,y1-1);
                    end
                  else
                    begin
                      LinePHL20(x0+1,y0+0,x1+1,y1+0);
                      LinePHL20(x0-1,y0+0,x1-1,y1+0);
                    end;
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds07    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  scl_mul             : TPtPosF;
  pt_shift            : TPtPos;
  sln_pts_ptr         : PPtPosF;
  bmp_dst_ptr2        : PInteger;
  has_edge_ptr        : PShortInt;
  x0,y0,x1,y1,d0,d1,pt: double;
  b,i,eds_col_inv2    : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]);
      pt_shift    :=PtPos( rct_ent.left  -rct_clp_ptr^.left,
                           rct_ent.top   -rct_clp_ptr^.top);
      if (  rct_ent.height/rct_ent.width>=rct_clp_ptr^.height/rct_clp_ptr^.width) then
        pt:=rct_ent.height/               rct_clp_ptr^.height
      else
        pt:=rct_ent.width /               rct_clp_ptr^.width;
      scl_mul     :=PtPosF(1/pt,1/pt);
      d0          :=(rct_ent.left-pt_shift.x)*(1-scl_mul.x);
      d1          :=(rct_ent.top -pt_shift.y)*(1-scl_mul.y); {$endregion}

      {Save and Set Destination Surface Handle-----------} {$region -fold}
      bmp_dst_ptr2           := eds_big_img.bmp_dst_ptr;
      eds_big_img.bmp_dst_ptr:=@eds_useless_fld_arr[0]; {$endregion}

      {Save and Set Color(inverted value)----------------} {$region -fold}
      eds_col_inv2                      :=eds_big_img.local_prop.eds_col_inv;
      eds_big_img.local_prop.eds_col_inv:=1; {$endregion}

      if (not only_fit_to_wnd_calc) then
        case eds_width of
          1: {Drawing Of Spline Object Edges(Width 1 Px.)} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    ClippedLine2
                    (
                      ((sln_pts_ptr+0)^.x-pt_shift.x)*scl_mul.x+d0,
                      ((sln_pts_ptr+0)^.y-pt_shift.y)*scl_mul.y+d1,
                      ((sln_pts_ptr+1)^.x-pt_shift.x)*scl_mul.x+d0,
                      ((sln_pts_ptr+1)^.y-pt_shift.y)*scl_mul.y+d1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL30),
                      Unaligned(@LineSHL30),
                      Unaligned(@LineSVL30),
                      Unaligned(@LinePHL31),
                      Unaligned(@LinePHL32)
                    );
                  Inc(sln_pts_ptr           );
                  Inc(has_edge_ptr          );
                  Inc(local_prop.eds_col_inv);
                end; {$endregion}
          2: {Drawing Of Spline Object Edges(Width 2 Px.)} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=(sln_pts_ptr+0)^.x;
                      y0:=(sln_pts_ptr+0)^.y;
                      x1:=(sln_pts_ptr+1)^.x;
                      y1:=(sln_pts_ptr+1)^.y;
                      ClippedLine2
                      (
                        (x0-pt_shift.x)*scl_mul.x+d0,
                        (y0-pt_shift.y)*scl_mul.y+d1,
                        (x1-pt_shift.x)*scl_mul.x+d0,
                        (y1-pt_shift.y)*scl_mul.y+d1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL30),
                        Unaligned(@LineSHL30),
                        Unaligned(@LineSVL30),
                        Unaligned(@LinePHL31),
                        Unaligned(@LinePHL32)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        ClippedLine2
                        (
                          (x0+0-pt_shift.x)*scl_mul.x+d0,
                          (y0+1-pt_shift.y)*scl_mul.y+d1,
                          (x1+0-pt_shift.x)*scl_mul.x+d0,
                          (y1+1-pt_shift.y)*scl_mul.y+d1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30),
                          Unaligned(@LineSVL30),
                          Unaligned(@LinePHL31),
                          Unaligned(@LinePHL32)
                        )
                      else
                        ClippedLine2
                        (
                          (x0+1-pt_shift.x)*scl_mul.x+d0,
                          (y0+0-pt_shift.y)*scl_mul.y+d1,
                          (x1+1-pt_shift.x)*scl_mul.x+d0,
                          (y1+0-pt_shift.y)*scl_mul.y+d1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30),
                          Unaligned(@LineSVL30),
                          Unaligned(@LinePHL31),
                          Unaligned(@LinePHL32)
                        );
                    end;
                  Inc(sln_pts_ptr           );
                  Inc(has_edge_ptr          );
                  Inc(local_prop.eds_col_inv);
                end; {$endregion}
          3: {Drawing Of Spline Object Edges(Width 3 Px.)} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=(sln_pts_ptr+0)^.x;
                      y0:=(sln_pts_ptr+0)^.y;
                      x1:=(sln_pts_ptr+1)^.x;
                      y1:=(sln_pts_ptr+1)^.y;
                      ClippedLine2
                      (
                        (x0-pt_shift.x)*scl_mul.x+d0,
                        (y0-pt_shift.y)*scl_mul.y+d1,
                        (x1-pt_shift.x)*scl_mul.x+d0,
                        (y1-pt_shift.y)*scl_mul.y+d1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL30),
                        Unaligned(@LineSHL30),
                        Unaligned(@LineSVL30),
                        Unaligned(@LinePHL31),
                        Unaligned(@LinePHL32)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        begin
                          ClippedLine2
                          (
                            (x0+0-pt_shift.x)*scl_mul.x+d0,
                            (y0+1-pt_shift.y)*scl_mul.y+d1,
                            (x1+0-pt_shift.x)*scl_mul.x+d0,
                            (y1+1-pt_shift.y)*scl_mul.y+d1,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          );
                          ClippedLine2
                          (
                            (x0+0-pt_shift.x)*scl_mul.x+d0,
                            (y0-1-pt_shift.y)*scl_mul.y+d1,
                            (x1+0-pt_shift.x)*scl_mul.x+d0,
                            (y1-1-pt_shift.y)*scl_mul.y+d1,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          );
                        end
                      else
                        begin
                          ClippedLine2
                          (
                            (x0+1-pt_shift.x)*scl_mul.x+d0,
                            (y0+0-pt_shift.y)*scl_mul.y+d1,
                            (x1+1-pt_shift.x)*scl_mul.x+d0,
                            (y1+0-pt_shift.y)*scl_mul.y+d1,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          );
                          ClippedLine2
                          (
                            (x0-1-pt_shift.x)*scl_mul.x+d0,
                            (y0+0-pt_shift.y)*scl_mul.y+d1,
                            (x1-1-pt_shift.x)*scl_mul.x+d0,
                            (y1+0-pt_shift.y)*scl_mul.y+d1,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          );
                        end;
                    end;
                  Inc(sln_pts_ptr           );
                  Inc(has_edge_ptr          );
                  Inc(local_prop.eds_col_inv);
                end; {$endregion}
        end;

      {Reset Destination Surface Handle------------------} {$region -fold}
      eds_big_img.bmp_dst_ptr:=bmp_dst_ptr2; {$endregion}

      {Reset Color(inverted value)-----------------------} {$region -fold}
      eds_big_img.local_prop.eds_col_inv:=eds_col_inv2; {$endregion}

    end;
end; {$endregion}
procedure TCurve.AddSplineEds08    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  w_a_s_x,w_a_s_y: integer;
  x0,y0,x1,y1    : double;
  b,i            : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]);
      w_a_s_x     :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y     :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir     :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine2
                (
                  sln_pts[b+00000000000000000000000000000].x+w_a_s_x,
                  sln_pts[b+00000000000000000000000000000].y+w_a_s_y,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y,
                  rct_clp_ptr^,
                  Unaligned(@LinePHL40),
                  Unaligned(@LineSHL40),
                  Unaligned(@LineSVL40),
                  Unaligned(@LinePHL41),
                  Unaligned(@LinePHL42)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                with eds_big_img do
                  if (has_edge_ptr^=0) then
                    ClippedLine2
                    (
                      (sln_pts_ptr+0)^.x+w_a_s_x,
                      (sln_pts_ptr+0)^.y+w_a_s_y,
                      (sln_pts_ptr+1)^.x+w_a_s_x,
                      (sln_pts_ptr+1)^.y+w_a_s_y,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL40),
                      Unaligned(@LineSHL40),
                      Unaligned(@LineSVL40),
                      Unaligned(@LinePHL41),
                      Unaligned(@LinePHL42)
                    );
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL40),
                    Unaligned(@LineSHL40),
                    Unaligned(@LineSVL40),
                    Unaligned(@LinePHL41),
                    Unaligned(@LinePHL42)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine2
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL40),
                      Unaligned(@LineSHL40),
                      Unaligned(@LineSVL40),
                      Unaligned(@LinePHL41),
                      Unaligned(@LinePHL42)
                    )
                  else
                    ClippedLine2
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL40),
                      Unaligned(@LineSHL40),
                      Unaligned(@LineSVL40),
                      Unaligned(@LinePHL41),
                      Unaligned(@LinePHL42)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                      y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                      x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                      y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                      ClippedLine2
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        ClippedLine2
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL40),
                          Unaligned(@LineSHL40),
                          Unaligned(@LineSVL40),
                          Unaligned(@LinePHL41),
                          Unaligned(@LinePHL42)
                        )
                      else
                        ClippedLine2
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL40),
                          Unaligned(@LineSHL40),
                          Unaligned(@LineSVL40),
                          Unaligned(@LinePHL41),
                          Unaligned(@LinePHL42)
                        );
                    end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL40),
                    Unaligned(@LineSHL40),
                    Unaligned(@LineSVL40),
                    Unaligned(@LinePHL41),
                    Unaligned(@LinePHL42)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                      ClippedLine2
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                    end
                  else
                    begin
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                      ClippedLine2
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                      y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                      x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                      y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                      ClippedLine2
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        begin
                          ClippedLine2
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL40),
                            Unaligned(@LineSHL40),
                            Unaligned(@LineSVL40),
                            Unaligned(@LinePHL41),
                            Unaligned(@LinePHL42)
                          );
                          ClippedLine2
                          (
                            x0+0,
                            y0-1,
                            x1+0,
                            y1-1,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL40),
                            Unaligned(@LineSHL40),
                            Unaligned(@LineSVL40),
                            Unaligned(@LinePHL41),
                            Unaligned(@LinePHL42)
                          );
                        end
                      else
                        begin
                          ClippedLine2
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL40),
                            Unaligned(@LineSHL40),
                            Unaligned(@LineSVL40),
                            Unaligned(@LinePHL41),
                            Unaligned(@LinePHL42)
                          );
                          ClippedLine2
                          (
                            x0-1,
                            y0+0,
                            x1-1,
                            y1+0,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL40),
                            Unaligned(@LineSHL40),
                            Unaligned(@LineSVL40),
                            Unaligned(@LinePHL41),
                            Unaligned(@LinePHL42)
                          );
                        end;
                    end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds09    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  x0,y0,x1,y1    : double;
  w_a_s_x,w_a_s_y: integer;
  b,i            : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]);
      w_a_s_x     :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y     :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir     :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL40(x0,y0,x1,y1);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                with eds_big_img do
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                      y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                      x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                      y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                      LinePHL40(x0,y0,x1,y1);
                    end;
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL40(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL40(x0+0,y0+1,x1+0,y1+1)
                  else
                    LinePHL40(x0+1,y0+0,x1+1,y1+0);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                      y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                      x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                      y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                      LinePHL40(x0,y0,x1,y1);
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        LinePHL40(x0+0,y0+1,x1+0,y1+1)
                      else
                        LinePHL40(x0+1,y0+0,x1+1,y1+0);
                    end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL40(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL40(x0+0,y0+1,x1+0,y1+1);
                      LinePHL40(x0+0,y0-1,x1+0,y1-1);
                    end
                  else
                    begin
                      LinePHL40(x0+1,y0+0,x1+1,y1+0);
                      LinePHL40(x0-1,y0+0,x1-1,y1+0);
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                      y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                      x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                      y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                      LinePHL40(x0,y0,x1,y1);
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        begin
                          LinePHL40(x0+0,y0+1,x1+0,y1+1);
                          LinePHL40(x0+0,y0-1,x1+0,y1-1);
                        end
                      else
                        begin
                          LinePHL40(x0+1,y0+0,x1+1,y1+0);
                          LinePHL40(x0-1,y0+0,x1-1,y1+0);
                        end;
                        end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds10    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr        : PObjProp;
  sln_pts_ptr        : PPtPosF;
  sln_pts_ptr2       : PPtPosF;
  sln_vis_eds_ind_ptr: PColor;
  w_a_s_x,w_a_s_y: integer;
  x0,y0,x1,y1        : double;
  b,i                : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b                  :=partial_pts_sum[spline_ind];
      obj_arr_ptr        :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr        :=Unaligned(@sln_pts[b]);
      sln_vis_eds_ind_ptr:=@sln_vis_eds_ind[spline_ind,0];
      w_a_s_x            :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y            :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir            :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine2
                (
                  sln_pts[b+00000000000000000000000000000].x+w_a_s_x,
                  sln_pts[b+00000000000000000000000000000].y+w_a_s_y,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y,
                  rct_clp_ptr^,
                  Unaligned(@LinePHL40),
                  Unaligned(@LineSHL40),
                  Unaligned(@LineSVL40),
                  Unaligned(@LinePHL41),
                  Unaligned(@LinePHL42)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  ClippedLine2
                  (
                    (sln_pts_ptr2+0)^.x+w_a_s_x,
                    (sln_pts_ptr2+0)^.y+w_a_s_y,
                    (sln_pts_ptr2+1)^.x+w_a_s_x,
                    (sln_pts_ptr2+1)^.y+w_a_s_y,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL40),
                    Unaligned(@LineSHL40),
                    Unaligned(@LineSVL40),
                    Unaligned(@LinePHL41),
                    Unaligned(@LinePHL42)
                  );
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL40),
                    Unaligned(@LineSHL40),
                    Unaligned(@LineSVL40),
                    Unaligned(@LinePHL41),
                    Unaligned(@LinePHL42)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine2
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL40),
                      Unaligned(@LineSHL40),
                      Unaligned(@LineSVL40),
                      Unaligned(@LinePHL41),
                      Unaligned(@LinePHL42)
                    )
                  else
                    ClippedLine2
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL40),
                      Unaligned(@LineSHL40),
                      Unaligned(@LineSVL40),
                      Unaligned(@LinePHL41),
                      Unaligned(@LinePHL42)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:= sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                  y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                  x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                  y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL40),
                    Unaligned(@LineSHL40),
                    Unaligned(@LineSVL40),
                    Unaligned(@LinePHL41),
                    Unaligned(@LinePHL42)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine2
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL40),
                      Unaligned(@LineSHL40),
                      Unaligned(@LineSVL40),
                      Unaligned(@LinePHL41),
                      Unaligned(@LinePHL42)
                    )
                  else
                    ClippedLine2
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL40),
                      Unaligned(@LineSHL40),
                      Unaligned(@LineSVL40),
                      Unaligned(@LinePHL41),
                      Unaligned(@LinePHL42)
                    );
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL40),
                    Unaligned(@LineSHL40),
                    Unaligned(@LineSVL40),
                    Unaligned(@LinePHL41),
                    Unaligned(@LinePHL42)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                      ClippedLine2
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                    end
                  else
                    begin
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                      ClippedLine2
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:= sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                  y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                  x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                  y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL40),
                    Unaligned(@LineSHL40),
                    Unaligned(@LineSVL40),
                    Unaligned(@LinePHL41),
                    Unaligned(@LinePHL42)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                      ClippedLine2
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                    end
                  else
                    begin
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                      ClippedLine2
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                    end;
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds11    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr        : PObjProp;
  sln_pts_ptr        : PPtPosF;
  sln_pts_ptr2       : PPtPosF;
  sln_vis_eds_ind_ptr: PColor;
  x0,y0,x1,y1        : double;
  w_a_s_x,w_a_s_y    : integer;
  b,i                : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b                  :=partial_pts_sum[spline_ind];
      obj_arr_ptr        :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr        :=Unaligned(@sln_pts[b]);
      sln_vis_eds_ind_ptr:=Unaligned(@sln_vis_eds_ind[spline_ind,0]);
      w_a_s_x            :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y            :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir            :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL40(x0,y0,x1,y1);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                  y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                  x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                  y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                  LinePHL40(x0,y0,x1,y1);
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL40(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL40(x0+0,y0+1,x1+0,y1+1)
                  else
                    LinePHL40(x0+1,y0+0,x1+1,y1+0);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:= sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                  y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                  x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                  y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                  LinePHL40(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL40(x0+0,y0+1,x1+0,y1+1)
                  else
                    LinePHL40(x0+1,y0+0,x1+1,y1+0);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL40(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL40(x0+0,y0+1,x1+0,y1+1);
                      LinePHL40(x0+0,y0-1,x1+0,y1-1);
                    end
                  else
                    begin
                      LinePHL40(x0+1,y0+0,x1+1,y1+0);
                      LinePHL40(x0-1,y0+0,x1-1,y1+0);
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:= sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                  y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                  x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                  y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                  LinePHL40(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL40(x0+0,y0+1,x1+0,y1+1);
                      LinePHL40(x0+0,y0-1,x1+0,y1-1);
                    end
                  else
                    begin
                      LinePHL40(x0+1,y0+0,x1+1,y1+0);
                      LinePHL40(x0-1,y0+0,x1-1,y1+0);
                    end;
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds12    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  w_a_s_x,w_a_s_y: integer;
  x0,y0,x1,y1    : double;
  b,i            : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir    :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine2
                (
                  sln_pts[b+00000000000000000000000000000].x+w_a_s_x,
                  sln_pts[b+00000000000000000000000000000].y+w_a_s_y,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y,
                  rct_clp_ptr^,
                  Unaligned(@LinePHL20),
                  Unaligned(@LineSHL20),
                  Unaligned(@LineSVL20),
                  Unaligned(@LinePHL21),
                  Unaligned(@LinePHL22)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  ClippedLine2
                  (
                    (sln_pts_ptr+0)^.x+w_a_s_x,
                    (sln_pts_ptr+0)^.y+w_a_s_y,
                    (sln_pts_ptr+1)^.x+w_a_s_x,
                    (sln_pts_ptr+1)^.y+w_a_s_y,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20),
                    Unaligned(@LineSVL20),
                    Unaligned(@LinePHL21),
                    Unaligned(@LinePHL22)
                  );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20),
                    Unaligned(@LineSVL20),
                    Unaligned(@LinePHL21),
                    Unaligned(@LinePHL22)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine2
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20),
                      Unaligned(@LineSVL20),
                      Unaligned(@LinePHL21),
                      Unaligned(@LinePHL22)
                    )
                  else
                    ClippedLine2
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20),
                      Unaligned(@LineSVL20),
                      Unaligned(@LinePHL21),
                      Unaligned(@LinePHL22)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                  y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                  x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                  y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20),
                    Unaligned(@LineSVL20),
                    Unaligned(@LinePHL21),
                    Unaligned(@LinePHL22)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine2
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20),
                      Unaligned(@LineSVL20),
                      Unaligned(@LinePHL21),
                      Unaligned(@LinePHL22)
                    )
                  else
                    ClippedLine2
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL20),
                      Unaligned(@LineSHL20),
                      Unaligned(@LineSVL20),
                      Unaligned(@LinePHL21),
                      Unaligned(@LinePHL22)
                    );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20),
                    Unaligned(@LineSVL20),
                    Unaligned(@LinePHL21),
                    Unaligned(@LinePHL22)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                      ClippedLine2
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                    end
                  else
                    begin
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                      ClippedLine2
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                  y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                  x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                  y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL20),
                    Unaligned(@LineSHL20),
                    Unaligned(@LineSVL20),
                    Unaligned(@LinePHL21),
                    Unaligned(@LinePHL22)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                      ClippedLine2
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                    end
                  else
                    begin
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                      ClippedLine2
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL20),
                        Unaligned(@LineSHL20),
                        Unaligned(@LineSVL20),
                        Unaligned(@LinePHL21),
                        Unaligned(@LinePHL22)
                      );
                    end;
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds13    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  x0,y0,x1,y1    : double;
  w_a_s_x,w_a_s_y: integer;
  b,i            : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir    :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL20(x0,y0,x1,y1);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                  y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                  x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                  y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                  LinePHL20(x0,y0,x1,y1);
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL20(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL20(x0+0,y0+1,x1+0,y1+1)
                  else
                    LinePHL20(x0+1,y0+0,x1+1,y1+0);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                  y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                  x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                  y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                  LinePHL20(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL20(x0+0,y0+1,x1+0,y1+1)
                  else
                    LinePHL20(x0+1,y0+0,x1+1,y1+0);
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL20(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL20(x0+0,y0+1,x1+0,y1+1);
                      LinePHL20(x0+0,y0-1,x1+0,y1-1);
                    end
                  else
                    begin
                      LinePHL20(x0+1,y0+0,x1+1,y1+0);
                      LinePHL20(x0-1,y0+0,x1-1,y1+0);
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                  y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                  x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                  y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                  LinePHL20(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL20(x0+0,y0+1,x1+0,y1+1);
                      LinePHL20(x0+0,y0-1,x1+0,y1-1);
                    end
                  else
                    begin
                      LinePHL20(x0+1,y0+0,x1+1,y1+0);
                      LinePHL20(x0-1,y0+0,x1-1,y1+0);
                    end;
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds14    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  w_a_s_x,w_a_s_y: integer;
  x0,y0,x1,y1    : double;
  b,i            : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir    :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine2
                (
                  sln_pts[b+00000000000000000000000000000].x+w_a_s_x,
                  sln_pts[b+00000000000000000000000000000].y+w_a_s_y,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y,
                  rct_clp_ptr^,
                  Unaligned(@LinePHL40),
                  Unaligned(@LineSHL40),
                  Unaligned(@LineSVL40),
                  Unaligned(@LinePHL41),
                  Unaligned(@LinePHL42)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  ClippedLine2
                  (
                    (sln_pts_ptr+0)^.x+w_a_s_x,
                    (sln_pts_ptr+0)^.y+w_a_s_y,
                    (sln_pts_ptr+1)^.x+w_a_s_x,
                    (sln_pts_ptr+1)^.y+w_a_s_y,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL40),
                    Unaligned(@LineSHL40),
                    Unaligned(@LineSVL40),
                    Unaligned(@LinePHL41),
                    Unaligned(@LinePHL42)
                  );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL40),
                    Unaligned(@LineSHL40),
                    Unaligned(@LineSVL40),
                    Unaligned(@LinePHL41),
                    Unaligned(@LinePHL42)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine2
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL40),
                      Unaligned(@LineSHL40),
                      Unaligned(@LineSVL40),
                      Unaligned(@LinePHL41),
                      Unaligned(@LinePHL42)
                    )
                  else
                    ClippedLine2
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL40),
                      Unaligned(@LineSHL40),
                      Unaligned(@LineSVL40),
                      Unaligned(@LinePHL41),
                      Unaligned(@LinePHL42)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                  y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                  x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                  y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL40),
                    Unaligned(@LineSHL40),
                    Unaligned(@LineSVL40),
                    Unaligned(@LinePHL41),
                    Unaligned(@LinePHL42)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine2
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL40),
                      Unaligned(@LineSHL40),
                      Unaligned(@LineSVL40),
                      Unaligned(@LinePHL41),
                      Unaligned(@LinePHL42)
                    )
                  else
                    ClippedLine2
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL40),
                      Unaligned(@LineSHL40),
                      Unaligned(@LineSVL40),
                      Unaligned(@LinePHL41),
                      Unaligned(@LinePHL42)
                    );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL40),
                    Unaligned(@LineSHL40),
                    Unaligned(@LineSVL40),
                    Unaligned(@LinePHL41),
                    Unaligned(@LinePHL42)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                      ClippedLine2
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                    end
                  else
                    begin
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                      ClippedLine2
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                  y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                  x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                  y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL40),
                    Unaligned(@LineSHL40),
                    Unaligned(@LineSVL40),
                    Unaligned(@LinePHL41),
                    Unaligned(@LinePHL42)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                      ClippedLine2
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                    end
                  else
                    begin
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                      ClippedLine2
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL40),
                        Unaligned(@LineSHL40),
                        Unaligned(@LineSVL40),
                        Unaligned(@LinePHL41),
                        Unaligned(@LinePHL42)
                      );
                    end;
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds15    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  x0,y0,x1,y1    : double;
  w_a_s_x,w_a_s_y: integer;
  b,i            : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir    :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL40(x0,y0,x1,y1);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                  y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                  x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                  y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                  LinePHL40(x0,y0,x1,y1);
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL40(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL40(x0+0,y0+1,x1+0,y1+1)
                  else
                    LinePHL40(x0+1,y0+0,x1+1,y1+0);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                  y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                  x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                  y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                  LinePHL40(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL40(x0+0,y0+1,x1+0,y1+1)
                  else
                    LinePHL40(x0+1,y0+0,x1+1,y1+0);
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL40(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL40(x0+0,y0+1,x1+0,y1+1);
                      LinePHL40(x0+0,y0-1,x1+0,y1-1);
                    end
                  else
                    begin
                      LinePHL40(x0+1,y0+0,x1+1,y1+0);
                      LinePHL40(x0-1,y0+0,x1-1,y1+0);
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                  y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                  x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                  y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                  LinePHL40(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL40(x0+0,y0+1,x1+0,y1+1);
                      LinePHL40(x0+0,y0-1,x1+0,y1-1);
                    end
                  else
                    begin
                      LinePHL40(x0+1,y0+0,x1+1,y1+0);
                      LinePHL40(x0-1,y0+0,x1-1,y1+0);
                    end;
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds16    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  w_a_s_x,w_a_s_y: integer;
  x0,y0,x1,y1    : double;
  b,i            : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]);
      w_a_s_x     :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y     :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir     :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine2
                (
                  sln_pts[b+00000000000000000000000000000].x+w_a_s_x,
                  sln_pts[b+00000000000000000000000000000].y+w_a_s_y,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y,
                  rct_clp_ptr^,
                  Unaligned(@LinePHL00),
                  Unaligned(@LineSHL00),
                  Unaligned(@LineSVL00),
                  Unaligned(@LinePHL01),
                  Unaligned(@LinePHL02)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                with eds_big_img do
                  if (has_edge_ptr^=0) then
                    ClippedLine2
                    (
                      (sln_pts_ptr+0)^.x+w_a_s_x,
                      (sln_pts_ptr+0)^.y+w_a_s_y,
                      (sln_pts_ptr+1)^.x+w_a_s_x,
                      (sln_pts_ptr+1)^.y+w_a_s_y,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00),
                      Unaligned(@LineSVL00),
                      Unaligned(@LinePHL01),
                      Unaligned(@LinePHL02)
                    );
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00),
                    Unaligned(@LineSVL00),
                    Unaligned(@LinePHL01),
                    Unaligned(@LinePHL02)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine2
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00),
                      Unaligned(@LineSVL00),
                      Unaligned(@LinePHL01),
                      Unaligned(@LinePHL02)
                    )
                  else
                    ClippedLine2
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00),
                      Unaligned(@LineSVL00),
                      Unaligned(@LinePHL01),
                      Unaligned(@LinePHL02)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                      y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                      x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                      y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                      ClippedLine2
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        ClippedLine2
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL00),
                          Unaligned(@LineSHL00),
                          Unaligned(@LineSVL00),
                          Unaligned(@LinePHL01),
                          Unaligned(@LinePHL02)
                        )
                      else
                        ClippedLine2
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          rct_clp_ptr^,
                          Unaligned(@LinePHL00),
                          Unaligned(@LineSHL00),
                          Unaligned(@LineSVL00),
                          Unaligned(@LinePHL01),
                          Unaligned(@LinePHL02)
                        );
                    end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00),
                    Unaligned(@LineSVL00),
                    Unaligned(@LinePHL01),
                    Unaligned(@LinePHL02)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                      ClippedLine2
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                    end
                  else
                    begin
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                      ClippedLine2
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                      y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                      x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                      y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                      ClippedLine2
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        begin
                          ClippedLine2
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL00),
                            Unaligned(@LineSHL00),
                            Unaligned(@LineSVL00),
                            Unaligned(@LinePHL01),
                            Unaligned(@LinePHL02)
                          );
                          ClippedLine2
                          (
                            x0+0,
                            y0-1,
                            x1+0,
                            y1-1,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL00),
                            Unaligned(@LineSHL00),
                            Unaligned(@LineSVL00),
                            Unaligned(@LinePHL01),
                            Unaligned(@LinePHL02)
                          );
                        end
                      else
                        begin
                          ClippedLine2
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL00),
                            Unaligned(@LineSHL00),
                            Unaligned(@LineSVL00),
                            Unaligned(@LinePHL01),
                            Unaligned(@LinePHL02)
                          );
                          ClippedLine2
                          (
                            x0-1,
                            y0+0,
                            x1-1,
                            y1+0,
                            rct_clp_ptr^,
                            Unaligned(@LinePHL00),
                            Unaligned(@LineSHL00),
                            Unaligned(@LineSVL00),
                            Unaligned(@LinePHL01),
                            Unaligned(@LinePHL02)
                          );
                        end;
                    end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds17    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  has_edge_ptr   : PShortInt;
  x0,y0,x1,y1    : double;
  w_a_s_x,w_a_s_y: integer;
  b,i            : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b           :=partial_pts_sum[spline_ind];
      obj_arr_ptr :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr :=Unaligned(@sln_pts [b]);
      has_edge_ptr:=Unaligned(@has_edge[b]);
      w_a_s_x     :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y     :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir     :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL00(x0,y0,x1,y1);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              begin
                with eds_big_img do
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                      y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                      x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                      y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                      LinePHL00(x0,y0,x1,y1);
                    end;
                Inc(sln_pts_ptr );
                Inc(has_edge_ptr);
              end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL00(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL00(x0+0,y0+1,x1+0,y1+1)
                  else
                    LinePHL00(x0+1,y0+0,x1+1,y1+0);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                      y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                      x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                      y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                      LinePHL00(x0,y0,x1,y1);
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        LinePHL00(x0+0,y0+1,x1+0,y1+1)
                      else
                        LinePHL00(x0+1,y0+0,x1+1,y1+0);
                        end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL00(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL00(x0+0,y0+1,x1+0,y1+1);
                      LinePHL00(x0+0,y0-1,x1+0,y1-1);
                    end
                  else
                    begin
                      LinePHL00(x0+1,y0+0,x1+1,y1+0);
                      LinePHL00(x0-1,y0+0,x1-1,y1+0);
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  if (has_edge_ptr^=0) then
                    begin
                      x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                      y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                      x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                      y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                      LinePHL00(x0,y0,x1,y1);
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        begin
                          LinePHL00(x0+0,y0+1,x1+0,y1+1);
                          LinePHL00(x0+0,y0-1,x1+0,y1-1);
                        end
                      else
                        begin
                          LinePHL00(x0+1,y0+0,x1+1,y1+0);
                          LinePHL00(x0-1,y0+0,x1-1,y1+0);
                        end;
                    end;
                  Inc(sln_pts_ptr );
                  Inc(has_edge_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds18    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr        : PObjProp;
  sln_pts_ptr        : PPtPosF;
  sln_pts_ptr2       : PPtPosF;
  sln_vis_eds_ind_ptr: PColor;
  w_a_s_x,w_a_s_y    : integer;
  x0,y0,x1,y1        : double;
  b,i                : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b                  :=partial_pts_sum[spline_ind];
      obj_arr_ptr        :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr        :=Unaligned(@sln_pts[b]);
      sln_vis_eds_ind_ptr:=Unaligned(@sln_vis_eds_ind[spline_ind,0]);
      w_a_s_x            :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y            :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir            :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine2
                (
                  sln_pts[b+00000000000000000000000000000].x+w_a_s_x,
                  sln_pts[b+00000000000000000000000000000].y+w_a_s_y,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y,
                  rct_clp_ptr^,
                  Unaligned(@LinePHL00),
                  Unaligned(@LineSHL00),
                  Unaligned(@LineSVL00),
                  Unaligned(@LinePHL01),
                  Unaligned(@LinePHL02)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  ClippedLine2
                  (
                    (sln_pts_ptr2+0)^.x+w_a_s_x,
                    (sln_pts_ptr2+0)^.y+w_a_s_y,
                    (sln_pts_ptr2+1)^.x+w_a_s_x,
                    (sln_pts_ptr2+1)^.y+w_a_s_y,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00),
                    Unaligned(@LineSVL00),
                    Unaligned(@LinePHL01),
                    Unaligned(@LinePHL02)
                  );
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00),
                    Unaligned(@LineSVL00),
                    Unaligned(@LinePHL01),
                    Unaligned(@LinePHL02)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine2
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00),
                      Unaligned(@LineSVL00),
                      Unaligned(@LinePHL01),
                      Unaligned(@LinePHL02)
                    )
                  else
                    ClippedLine2
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00),
                      Unaligned(@LineSVL00),
                      Unaligned(@LinePHL01),
                      Unaligned(@LinePHL02)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:= sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                  y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                  x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                  y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00),
                    Unaligned(@LineSVL00),
                    Unaligned(@LinePHL01),
                    Unaligned(@LinePHL02)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine2
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00),
                      Unaligned(@LineSVL00),
                      Unaligned(@LinePHL01),
                      Unaligned(@LinePHL02)
                    )
                  else
                    ClippedLine2
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00),
                      Unaligned(@LineSVL00),
                      Unaligned(@LinePHL01),
                      Unaligned(@LinePHL02)
                    );
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00),
                    Unaligned(@LineSVL00),
                    Unaligned(@LinePHL01),
                    Unaligned(@LinePHL02)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                      ClippedLine2
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                    end
                  else
                    begin
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                      ClippedLine2
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:= sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                  y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                  x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                  y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00),
                    Unaligned(@LineSVL00),
                    Unaligned(@LinePHL01),
                    Unaligned(@LinePHL02)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                      ClippedLine2
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                    end
                  else
                    begin
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                      ClippedLine2
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                    end;
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds19    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr        : PObjProp;
  sln_pts_ptr        : PPtPosF;
  sln_pts_ptr2       : PPtPosF;
  sln_vis_eds_ind_ptr: PColor;
  x0,y0,x1,y1        : double;
  w_a_s_x,w_a_s_y    : integer;
  b,i                : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b                  :=partial_pts_sum[spline_ind];
      obj_arr_ptr        :=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr        :=Unaligned(@sln_pts[b]);
      sln_vis_eds_ind_ptr:=Unaligned(@sln_vis_eds_ind[spline_ind,0]);
      w_a_s_x            :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y            :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir            :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL00(x0,y0,x1,y1);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:=sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                  y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                  x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                  y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                  LinePHL00(x0,y0,x1,y1);
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL00(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL00(x0+0,y0+1,x1+0,y1+1)
                  else
                    LinePHL00(x0+1,y0+0,x1+1,y1+0);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:= sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                  y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                  x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                  y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                  LinePHL00(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL00(x0+0,y0+1,x1+0,y1+1)
                  else
                    LinePHL00(x0+1,y0+0,x1+1,y1+0);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL00(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL00(x0+0,y0+1,x1+0,y1+1);
                      LinePHL00(x0+0,y0-1,x1+0,y1-1);
                    end
                  else
                    begin
                      LinePHL00(x0+1,y0+0,x1+1,y1+0);
                      LinePHL00(x0-1,y0+0,x1-1,y1+0);
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to vis_ln_cnt-1 do
              with eds_big_img do
                begin
                  sln_pts_ptr2:= sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                  x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                  y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                  x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                  y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                  LinePHL00(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL00(x0+0,y0+1,x1+0,y1+1);
                      LinePHL00(x0+0,y0-1,x1+0,y1-1);
                    end
                  else
                    begin
                      LinePHL00(x0+1,y0+0,x1+1,y1+0);
                      LinePHL00(x0-1,y0+0,x1-1,y1+0);
                    end;
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds20    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  w_a_s_x,w_a_s_y: integer;
  x0,y0,x1,y1    : double;
  b,i            : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir    :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                ClippedLine2
                (
                  sln_pts[b+00000000000000000000000000000].x+w_a_s_x,
                  sln_pts[b+00000000000000000000000000000].y+w_a_s_y,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x,
                  sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y,
                  rct_clp_ptr^,
                  Unaligned(@LinePHL00),
                  Unaligned(@LineSHL00),
                  Unaligned(@LineSVL00),
                  Unaligned(@LinePHL01),
                  Unaligned(@LinePHL02)
                ); {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  ClippedLine2
                  (
                    (sln_pts_ptr+0)^.x+w_a_s_x,
                    (sln_pts_ptr+0)^.y+w_a_s_y,
                    (sln_pts_ptr+1)^.x+w_a_s_x,
                    (sln_pts_ptr+1)^.y+w_a_s_y,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00),
                    Unaligned(@LineSVL00),
                    Unaligned(@LinePHL01),
                    Unaligned(@LinePHL02)
                  );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00),
                    Unaligned(@LineSVL00),
                    Unaligned(@LinePHL01),
                    Unaligned(@LinePHL02)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine2
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00),
                      Unaligned(@LineSVL00),
                      Unaligned(@LinePHL01),
                      Unaligned(@LinePHL02)
                    )
                  else
                    ClippedLine2
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00),
                      Unaligned(@LineSVL00),
                      Unaligned(@LinePHL01),
                      Unaligned(@LinePHL02)
                    );
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                  y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                  x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                  y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00),
                    Unaligned(@LineSVL00),
                    Unaligned(@LinePHL01),
                    Unaligned(@LinePHL02)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    ClippedLine2
                    (
                      x0+0,
                      y0+1,
                      x1+0,
                      y1+1,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00),
                      Unaligned(@LineSVL00),
                      Unaligned(@LinePHL01),
                      Unaligned(@LinePHL02)
                    )
                  else
                    ClippedLine2
                    (
                      x0+1,
                      y0+0,
                      x1+1,
                      y1+0,
                      rct_clp_ptr^,
                      Unaligned(@LinePHL00),
                      Unaligned(@LineSHL00),
                      Unaligned(@LineSVL00),
                      Unaligned(@LinePHL01),
                      Unaligned(@LinePHL02)
                    );
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00),
                    Unaligned(@LineSVL00),
                    Unaligned(@LinePHL01),
                    Unaligned(@LinePHL02)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                      ClippedLine2
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                    end
                  else
                    begin
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                      ClippedLine2
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                  y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                  x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                  y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                  ClippedLine2
                  (
                    x0,
                    y0,
                    x1,
                    y1,
                    rct_clp_ptr^,
                    Unaligned(@LinePHL00),
                    Unaligned(@LineSHL00),
                    Unaligned(@LineSVL00),
                    Unaligned(@LinePHL01),
                    Unaligned(@LinePHL02)
                  );
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      ClippedLine2
                      (
                        x0+0,
                        y0+1,
                        x1+0,
                        y1+1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                      ClippedLine2
                      (
                        x0+0,
                        y0-1,
                        x1+0,
                        y1-1,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                    end
                  else
                    begin
                      ClippedLine2
                      (
                        x0+1,
                        y0+0,
                        x1+1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                      ClippedLine2
                      (
                        x0-1,
                        y0+0,
                        x1-1,
                        y1+0,
                        rct_clp_ptr^,
                        Unaligned(@LinePHL00),
                        Unaligned(@LineSHL00),
                        Unaligned(@LineSVL00),
                        Unaligned(@LinePHL01),
                        Unaligned(@LinePHL02)
                      );
                    end;
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplineEds21    (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  x0,y0,x1,y1    : double;
  w_a_s_x,w_a_s_y: integer;
  b,i            : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    begin

      {Misc. Precalc.------------------------------------------------------------------} {$region -fold}
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
     {mov_dir    :=mdNone;} {$endregion}

      case eds_width of
        1:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL00(x0,y0,x1,y1);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                  y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                  x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                  y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                  LinePHL00(x0,y0,x1,y1);
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;

        2:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL00(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL00(x0+0,y0+1,x1+0,y1+1)
                  else
                    LinePHL00(x0+1,y0+0,x1+1,y1+0);
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                  y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                  x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                  y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                  LinePHL00(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    LinePHL00(x0+0,y0+1,x1+0,y1+1)
                  else
                    LinePHL00(x0+1,y0+0,x1+1,y1+0);
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
        3:
          begin

            {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
            if cnc_ends then
              with eds_big_img do
                begin
                  x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                  y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                  x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                  y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                  LinePHL00(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL00(x0+0,y0+1,x1+0,y1+1);
                      LinePHL00(x0+0,y0-1,x1+0,y1-1);
                    end
                  else
                    begin
                      LinePHL00(x0+1,y0+0,x1+1,y1+0);
                      LinePHL00(x0-1,y0+0,x1-1,y1+0);
                    end;
                end; {$endregion}

            {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
            for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
              with eds_big_img do
                begin
                  x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                  y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                  x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                  y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                  LinePHL00(x0,y0,x1,y1);
                  if (Abs(y1-y0)<Abs(x1-x0)) then
                    begin
                      LinePHL00(x0+0,y0+1,x1+0,y1+1);
                      LinePHL00(x0+0,y0-1,x1+0,y1-1);
                    end
                  else
                    begin
                      LinePHL00(x0+1,y0+0,x1+1,y1+0);
                      LinePHL00(x0-1,y0+0,x1-1,y1+0);
                    end;
                  Inc(sln_pts_ptr);
                end; {$endregion}

          end;
      end;

    end;
end; {$endregion}
procedure TCurve.AddSplinePts0     (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  dup_pts_arr_ptr: PPtPos3;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                    Trunc(sln_pts_ptr^.y)+w_a_s_y);
          if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
            begin
              dup_pts_arr_ptr:=Unaligned(@dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width]);
              if (dup_pts_arr_ptr^*dup_pts_id    ) and
                 (dup_pts_arr_ptr^.dup_pts_cnt =0) then
                begin
                  dup_pts_arr_ptr^.dup_pts_cnt:=1;
                  Rectangle
                  (
                    pt.x,
                    pt.y,
                    pts_big_img.ln_arr1_ptr,
                    pts_big_img.ln_arr_width,
                    pts_big_img.ln_arr_height,
                    rct_vis,
                    local_prop,
                    @PPFloodFillAdd
                  );
                end;
            end
          else
            Rectangle
            (
              pt.x,
              pt.y,
              pts_big_img.ln_arr1_ptr,
              pts_big_img.ln_arr_width,
              pts_big_img.ln_arr_height,
              rct_vis,
              local_prop,
              @PPFloodFillAdd
            );
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.AddSplinePts1     (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  dup_pts_arr_ptr: PPtPos3;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          if (not sel_var.is_point_selected[b+i]) then
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                        Trunc(sln_pts_ptr^.y)+w_a_s_y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                begin
                  dup_pts_arr_ptr:=Unaligned(@dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width]);
                  if (dup_pts_arr_ptr^*dup_pts_id    ) and
                     (dup_pts_arr_ptr^.dup_pts_cnt =0) then
                    begin
                      dup_pts_arr_ptr^.dup_pts_cnt:=1;
                      Rectangle
                      (
                        pt.x,
                        pt.y,
                        pts_big_img.ln_arr1_ptr,
                        pts_big_img.ln_arr_width,
                        pts_big_img.ln_arr_height,
                        rct_vis,
                        local_prop,
                        @PPFloodFillAdd
                      );
                    end;
                end
              else
                Rectangle
                (
                  pt.x,
                  pt.y,
                  pts_big_img.ln_arr1_ptr,
                  pts_big_img.ln_arr_width,
                  pts_big_img.ln_arr_height,
                  rct_vis,
                  local_prop,
                  @PPFloodFillAdd
                );
            end;
          Inc(sln_pts_ptr);
        end
    end;
end; {$endregion}
procedure TCurve.AddSplinePts2     (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  dup_pts_arr_ptr: PPtPos3;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          if sel_var.is_point_selected[b+i] then
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                        Trunc(sln_pts_ptr^.y)+w_a_s_y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                begin
                  dup_pts_arr_ptr:=Unaligned(@dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width]);
                  if (not (dup_pts_arr_ptr^*dup_pts_id)   ) and
                     (     dup_pts_arr_ptr^.dup_pts_cnt =0) then
                    begin
                           dup_pts_arr_ptr^.dup_pts_cnt:=1;
                      Rectangle
                      (
                        pt.x,
                        pt.y,
                        pts_big_img.ln_arr1_ptr,
                        pts_big_img.ln_arr_width,
                        pts_big_img.ln_arr_height,
                        rct_vis,
                        local_prop,
                        @PPFloodFillAdd
                      );
                    end;
                end
              else
                Rectangle
                (
                  pt.x,
                  pt.y,
                  pts_big_img.ln_arr1_ptr,
                  pts_big_img.ln_arr_width,
                  pts_big_img.ln_arr_height,
                  rct_vis,
                  local_prop,
                  @PPFloodFillAdd
                );
            end;
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.AddSplinePts3     (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  dup_pts_arr_ptr: PPtPos3;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          if sel_var.is_point_selected[b+i] then
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                        Trunc(sln_pts_ptr^.y)+w_a_s_y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                begin
                  dup_pts_arr_ptr:=Unaligned(@dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width]);
                  if (dup_pts_arr_ptr^*dup_pts_id    ) and
                     (dup_pts_arr_ptr^.dup_pts_cnt =0) then
                    begin
                      dup_pts_arr_ptr^.dup_pts_cnt:=1;
                      Rectangle
                      (
                        pt.x,
                        pt.y,
                        pts_big_img.ln_arr1_ptr,
                        pts_big_img.ln_arr_width,
                        pts_big_img.ln_arr_height,
                        rct_vis,
                        local_prop,
                        @PPFloodFillSub
                      );
                    end;
                end
              else
                Rectangle
                (
                  pt.x,
                  pt.y,
                  pts_big_img.ln_arr1_ptr,
                  pts_big_img.ln_arr_width,
                  pts_big_img.ln_arr_height,
                  rct_vis,
                  local_prop,
                  @PPFloodFillSub
                );
            end;
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.AddSplinePts4     (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  dup_pts_arr_ptr: PPtPos3;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                    Trunc(sln_pts_ptr^.y)+w_a_s_y);
          if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
            begin
              dup_pts_arr_ptr:=Unaligned(@dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width]);
              if (dup_pts_arr_ptr^*dup_pts_id    ) and
                 (dup_pts_arr_ptr^.dup_pts_cnt =0) then
                begin
                  dup_pts_arr_ptr^.dup_pts_cnt:=1;
                  Rectangle
                  (
                    pt.x,
                    pt.y,
                    pts_big_img.ln_arr0_ptr,
                    pts_big_img.ln_arr_width,
                    pts_big_img.ln_arr_height,
                    rct_vis,
                    local_prop,
                    @PPFloodFill
                  );
                end;
            end
          else
            Rectangle
            (
              pt.x,
              pt.y,
              pts_big_img.ln_arr0_ptr,
              pts_big_img.ln_arr_width,
              pts_big_img.ln_arr_height,
              rct_vis,
              local_prop,
              @PPFloodFill
            );
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.AddSplinePts5     (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  dup_pts_arr_ptr: PPtPos3;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          if (not sel_var.is_point_selected[b+i]) then
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                        Trunc(sln_pts_ptr^.y)+w_a_s_y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                begin
                  dup_pts_arr_ptr:=Unaligned(@dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width]);
                  if (dup_pts_arr_ptr^*dup_pts_id    ) and
                     (dup_pts_arr_ptr^.dup_pts_cnt =0) then
                    begin
                      dup_pts_arr_ptr^.dup_pts_cnt:=1;
                      Rectangle
                      (
                        pt.x,
                        pt.y,
                        pts_big_img.ln_arr0_ptr,
                        pts_big_img.ln_arr_width,
                        pts_big_img.ln_arr_height,
                        rct_vis,
                        local_prop,
                        @PPFloodFill
                      );
                    end;
                end
              else
                Rectangle
                (
                  pt.x,
                  pt.y,
                  pts_big_img.ln_arr0_ptr,
                  pts_big_img.ln_arr_width,
                  pts_big_img.ln_arr_height,
                  rct_vis,
                  local_prop,
                  @PPFloodFill
                );
            end;
          Inc(sln_pts_ptr);
        end
    end;
end; {$endregion}
procedure TCurve.AddSplinePts6     (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  dup_pts_arr_ptr: PPtPos3;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          if sel_var.is_point_selected[b+i] then
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                        Trunc(sln_pts_ptr^.y)+w_a_s_y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                begin
                  dup_pts_arr_ptr:=Unaligned(@dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width]);
                  if (not (dup_pts_arr_ptr^*dup_pts_id)   ) and
                     (     dup_pts_arr_ptr^.dup_pts_cnt =0) then
                    begin
                           dup_pts_arr_ptr^.dup_pts_cnt:=1;
                      Rectangle
                      (
                        pt.x,
                        pt.y,
                        pts_big_img.ln_arr0_ptr,
                        pts_big_img.ln_arr_width,
                        pts_big_img.ln_arr_height,
                        rct_vis,
                        local_prop,
                        @PPFloodFill
                      );
                    end;
                end
              else
                Rectangle
                (
                  pt.x,
                  pt.y,
                  pts_big_img.ln_arr0_ptr,
                  pts_big_img.ln_arr_width,
                  pts_big_img.ln_arr_height,
                  rct_vis,
                  local_prop,
                  @PPFloodFill
                );
            end;
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.AddSplinePts7     (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  dup_pts_arr_ptr: PPtPos3;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          if sel_var.is_point_selected[b+i] then
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                        Trunc(sln_pts_ptr^.y)+w_a_s_y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                begin
                  dup_pts_arr_ptr:=Unaligned(@dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width]);
                  if (dup_pts_arr_ptr^*dup_pts_id    ) and
                     (dup_pts_arr_ptr^.dup_pts_cnt =0) then
                    begin
                      dup_pts_arr_ptr^.dup_pts_cnt:=1;
                      Rectangle
                      (
                        pt.x,
                        pt.y,
                        pts_big_img.ln_arr0_ptr,
                        pts_big_img.ln_arr_width,
                        pts_big_img.ln_arr_height,
                        rct_vis,
                        local_prop,
                        @PPFloodFill
                      );
                    end;
                end
              else
                Rectangle
                (
                  pt.x,
                  pt.y,
                  pts_big_img.ln_arr0_ptr,
                  pts_big_img.ln_arr_width,
                  pts_big_img.ln_arr_height,
                  rct_vis,
                  local_prop,
                  @PPFloodFill
                );
            end;
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.AddSplineDupPts0  (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      //if (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^)) then
        for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
          begin
            pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                      Trunc(sln_pts_ptr^.y)+w_a_s_y);
            if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
              dup_pts_id.SetEqual2(dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width],dup_pts_id);
            Inc(sln_pts_ptr);
          end;
    end;
end; {$endregion}
procedure TCurve.AddSplineDupPts1  (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      //if (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^)) then
        for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
          begin
            if (not sel_var.is_point_selected[b+i]) then
              begin
                pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                          Trunc(sln_pts_ptr^.y)+w_a_s_y);
                if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                  dup_pts_id.SetEqual2(dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width],dup_pts_id);
              end;
            Inc(sln_pts_ptr);
          end;
    end;
end; {$endregion}
procedure TCurve.AddSplineDupPts2  (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      //if (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^)) then
        for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
          begin
            if (not sel_var.is_point_selected[b+i]) then
              begin
                pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                          Trunc(sln_pts_ptr^.y)+w_a_s_y);
                if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                  dup_pts_id.SetEqual2(dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width],dup_pts_id);
              end;
            Inc(sln_pts_ptr);
          end;
    end;
end; {$endregion}
procedure TCurve.AddSplineDupPts3  (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      //if (not IsRct1OutOfRct2(rct_ent,rct_clp_ptr^)) then
        for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
          begin
            if sel_var.is_point_selected[b+i] then
              begin
                pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                          Trunc(sln_pts_ptr^.y)+w_a_s_y);
                if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                  dup_pts_id.SetEqual2(dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width],dup_pts_id);
              end;
            Inc(sln_pts_ptr);
          end;
    end;
end; {$endregion}
procedure TCurve.AddSplineDupPtsAll(const start_ind,end_ind:TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i,j          : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  for j:=start_ind to end_ind do
    with pts_img_arr[j] do
      begin
        b          :=partial_pts_sum[j];
        obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[j]]);
        sln_pts_ptr:=Unaligned(@sln_pts[b]);
        w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
        w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
        if (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^)) then
          for i:=0 to sln_obj_pts_cnt[j]-1 do
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                        Trunc(sln_pts_ptr^.y)+w_a_s_y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                begin
                  dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width].obj_ind:=j;
                  dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width].pts_ind:=partial_pts_sum[j]+i;
                end;
              Inc(sln_pts_ptr);
            end;
      end;
end; {$endregion}
procedure TCurve.ClrSplineDupPts0  (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                    Trunc(sln_pts_ptr^.y)+w_a_s_y);
          if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
            dup_pts_id.SetEqual1(dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width],Default(TPtPos3));
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.ClrSplineDupPts1  (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          if (not sel_var.is_point_selected[b+i]) then
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                        Trunc(sln_pts_ptr^.y)+w_a_s_y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                dup_pts_id.SetEqual1(dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width],Default(TPtPos3));
            end;
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.ClrSplineDupPts2  (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          begin
            pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                      Trunc(sln_pts_ptr^.y)+w_a_s_y);
            if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
              dup_pts_id.SetEqual1(dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width],Default(TPtPos3));
          end;
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.ClrSplineDupPts3  (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  pt             : TPtPos;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    begin
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        begin
          if sel_var.is_point_selected[b+i] then
            begin
              pt:=PtPos(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                        Trunc(sln_pts_ptr^.y)+w_a_s_y);
              if IsPtInRct(pt.x,pt.y,rct_clp_ptr^) then
                dup_pts_id.SetEqual1(dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width],Default(TPtPos3));
            end;
          Inc(sln_pts_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.ClrSplineRctEds   (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_eds_img_arr[spline_ind],local_prop,sprite_sheet_arr[rct_eds_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
    if (rct_eds_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) and (nt_pix_cnt<>0) then
      begin
        fast_image_data_ptr0:=@fast_image_data;
        ClrBkgnd;
      end;
end; {$endregion}
procedure TCurve.ClrSplineRctPts   (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_pts_img_arr[spline_ind],local_prop,sprite_sheet_arr[rct_pts_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
    if (rct_pts_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) and (nt_pix_cnt<>0) then
      begin
        fast_image_data_ptr0:=@fast_image_data;
        ClrBkgnd;
      end;
end; {$endregion}
procedure TCurve.ClrSplineEds      (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with eds_img_arr[spline_ind],local_prop,sprite_sheet_arr[eds_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
    if (eds_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) and (nt_pix_cnt<>0) then
      begin
        fast_image_data_ptr0:=@fast_image_data;
        ClrBkgnd;
      end;
end; {$endregion}
procedure TCurve.ClrSplinePts      (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pts_img_arr[spline_ind],local_prop,sprite_sheet_arr[pts_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
    if (pts_show and (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^))) and (nt_pix_cnt<>0) then
      begin
        fast_image_data_ptr0:=@fast_image_data;
        ClrBkgnd;
      end;
end; {$endregion}
procedure TCurve.ClrSplineAll      (const start_ind,end_ind:TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j,k         : integer;
  editor_or_game: set of byte;
begin
  editor_or_game:=[3,1+Byte(obj_var.res_var_ptr^)];
  for i:=sln_obj_cnt-1 downto 0 do
    begin
      j:=obj_var.curve_inds_sct_arr[i];
      if (j>=start_ind) and (j<=end_ind) then
        if ((obj_var.obj_arr[obj_var.obj_inds_arr[j]].obj_show and %00000011) in editor_or_game) then
          begin
            k:=obj_var.obj_arr[obj_var.obj_inds_arr[j]].k_ind;
            ClrSplinePts   (k);
            ClrSplineEds   (k);
            ClrSplineRctPts(k);
            ClrSplineRctEds(k);
          end;
    end;
end; {$endregion}
procedure TCurve.CrtSplineRctEds   (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_eds_img_arr[spline_ind],local_prop,sprite_sheet_arr[rct_eds_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
    begin

      fast_image_data_ptr0:=@fast_image_data;

      {Compress Sprite} {$region -fold}

      // clear buffers:
      ClrArr({%0000011111111111}%0000000011111111);

      // set color of edges  bounding rectangle sprite:
      SetPPInfo(rct_eds_col);

      // compress edges  bounding rectangle sprite:
      PrimitiveComp(spline_ind,@rct_eds_img_arr[spline_ind],@rct_eds_big_img,rct_eds_bld_stl,@{fast_image}sprite_sheet_arr[rct_eds_ind_arr[spline_ind]]); {$endregion}

      {Clear Buffer---} {$region -fold}
      FilNTValueArrA(rct_eds_big_img.ln_arr1,
                     rct_eds_big_img.ln_arr_width); {$endregion}

    end;
end; {$endregion}
procedure TCurve.CrtSplineRctPts   (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_pts_img_arr[spline_ind],local_prop,sprite_sheet_arr[rct_pts_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
    begin

      fast_image_data_ptr0:=@fast_image_data;

      {Compress Sprite} {$region -fold}

      // clear buffers:
      ClrArr({%0000011111111111}%0000000011111111);

      // set color of edges  bounding rectangle sprite:
      SetPPInfo(rct_pts_col);

      // compress edges  bounding rectangle sprite:
      PrimitiveComp(spline_ind,@rct_pts_img_arr[spline_ind],@rct_pts_big_img,rct_pts_bld_stl,@{fast_image}sprite_sheet_arr[rct_pts_ind_arr[spline_ind]]); {$endregion}

      {Clear Buffer---} {$region -fold}
      FilNTValueArrA(rct_pts_big_img.ln_arr1,
                     rct_pts_big_img.ln_arr_width); {$endregion}

    end;
end; {$endregion}
procedure TCurve.CrtSplineEds      (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with eds_img_arr[spline_ind],local_prop,sprite_sheet_arr[eds_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
    begin

      fast_image_data_ptr0:=@fast_image_data;

      {Compress Sprite} {$region -fold}

      // clear buffers:
      ClrArr({%0000011111111111}%0000000011111111);

      // set color of spline edges:
      SetPPInfo(eds_col);

      // compress edges sprite:
      PrimitiveComp(spline_ind,@eds_img_arr[spline_ind],@eds_big_img,eds_bld_stl,@{fast_image}sprite_sheet_arr[eds_ind_arr[spline_ind]]); {$endregion}

      {Antialiasing---} {$region -fold}
      {if sln_eds_var_ptr^.spline_local_prop.ed_aa then
        begin
          BorderCalc1
          (
            sln_eds_var_ptr^.f_ln_arr1 ,
            sln_eds_var_ptr^.f_brd_arr1,
            sln_eds_var_ptr^.f_bmp_width,
            sln_eds_var_ptr^.f_bmp_width,
            0,
            0,
            sln_eds_var_ptr^.obj_rect_vis.Width ,
            sln_eds_var_ptr^.obj_rect_vis.Height,
            sln_eds_var_ptr^.aa_nz_arr_items_count
          );
          BorderCalc2
          (
            sln_eds_var_ptr^.f_ln_arr1 ,
            sln_eds_var_ptr^.f_brd_arr1,
            sln_eds_var_ptr^.f_brd_arr2,
            sln_eds_var_ptr^.f_bmp_width,
            sln_eds_var_ptr^.f_bmp_width,
            0,
            0,
            sln_eds_var_ptr^.obj_rect_vis.Width ,
            sln_eds_var_ptr^.obj_rect_vis.Height,
            sln_eds_var_ptr^.aa_line_count
          );
          BorderFill
          (
            sln_eds_var_ptr^.f_brd_arr2,
            sln_eds_var_ptr^.obj_rect_vis.Left,
            sln_eds_var_ptr^.obj_rect_vis.Top,
            m_c_var.srf_bmp_ptr,
            m_c_var.srf_bmp.Width ,
            sln_eds_var_ptr^.aa_line_count,
            sln_eds_var_ptr^.spline_local_prop.ed_color
          );
        end;} {$endregion}

      {Clear Buffer---} {$region -fold}
      if byte_mode and (not down_select_items_ptr^) then
        FilNTValueArrB(eds_big_img.ln_arr0,
                       eds_big_img.ln_arr_width)
      else
        FilNTValueArrA(eds_big_img.ln_arr1,
                       eds_big_img.ln_arr_width); {$endregion}

    end;
end; {$endregion}
procedure TCurve.CrtSplinePts      (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pts_img_arr[spline_ind],local_prop,sprite_sheet_arr[pts_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
    begin

      fast_image_data_ptr0:=@fast_image_data;

      {Compress Sprite} {$region -fold}

      // clear buffers:
      ClrArr({%0000011111111111}%0000000011111111);

      // set color of spline points:
      SetPPInfo(pts_col);

      // compress points sprite:
      PrimitiveComp(spline_ind,@pts_img_arr[spline_ind],@pts_big_img,pts_bld_stl,@{fast_image}sprite_sheet_arr[pts_ind_arr[spline_ind]]); {$endregion}

      {Clear Buffer---} {$region -fold}
      if byte_mode and (not down_select_items_ptr^) then
        FilNTValueArrB(pts_big_img.ln_arr0,
                       pts_big_img.ln_arr_width)
      else
        FilNTValueArrA(pts_big_img.ln_arr1,
                       pts_big_img.ln_arr_width); {$endregion}

    end;
end; {$endregion}
procedure TCurve.CrtSplineAll0     (const start_ind,end_ind:TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=start_ind to end_ind do
    begin
      j:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].t_ind;
      if (j>=start_ind) and (j<=end_ind) then
        begin
          CrtSplineRctEds(i);
          CrtSplineRctPts(i);
          CrtSplineEds   (i);
          CrtSplinePts   (i);
        end;
    end;
end; {$endregion}
procedure TCurve.CrtSplineAll1     (const start_ind,end_ind:TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  for i:=start_ind to end_ind do
    begin
      j:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].t_ind;
      if (j>=start_ind) and (j<=end_ind) then
        begin
          if (has_sel_pts[i]=0) then
            Continue;
          CrtSplineRctEds(i);
          CrtSplineRctPts(i);
          CrtSplineEds   (i);
          CrtSplinePts   (i);
        end;
    end;
end; {$endregion}
procedure TCurve.FilSplineLazy     (const spline_ind       :TColor; const obj_arr_ptr:PObjProp; const b2,b3:boolean);                                                        {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with obj_var,srf_var_ptr^ do
    begin
      if add_spline_calc or scale_scene_calc or repaint_spline_calc then
        SetRctDstPtr(@inn_wnd_rct,curve_inds_obj_arr[spline_ind],curve_inds_obj_arr[spline_ind]);
      if b2 then
        begin
          if add_spline_calc or add_tlmap_calc then
            SetObjBkgnd
            (
              obj_arr_ptr,
              low_bmp_ptr,
              low_bmp.width,
              low_bmp.height,
              @inn_wnd_rct
            );
        end
      else
      if b3 then
        begin
          if scale_scene_calc or repaint_spline_calc or rectangles_calc or fill_scene_calc then
            SetObjBkgnd
            (
              obj_arr_ptr,
              srf_bmp_ptr,
              srf_bmp.width,
              srf_bmp.height,
              @inn_wnd_rct
            );
        end;
    end;
end; {$endregion}
procedure TCurve.HasSplineEds      (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with eds_img_arr[spline_ind],local_prop do
    if (not hid_ln_elim) then
      begin
        all_ln_cnt:=ArrNzItCnt(@has_edge[partial_pts_sum[spline_ind]],
                               sln_obj_pts_cnt[spline_ind]-1,
                               False);
        if (all_ln_cnt=0) then
          Exit;
        SetLength (sln_vis_eds_ind[spline_ind],
                   all_ln_cnt);
        ArrNzItCrt(@has_edge[partial_pts_sum[spline_ind]],
                   @sln_vis_eds_ind[spline_ind,0],
                   sln_obj_pts_cnt [spline_ind]-1,
                   all_ln_cnt);
      end;
end; {$endregion}
procedure TCurve.SplineRctEdsDraw  (const spline_ind       :TColor; rct_clp_ptr_:PPtRect);                                                                                   {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  w_a_s_x,w_a_s_y: integer;
begin
  with rct_eds_img_arr[spline_ind],local_prop do
    if rct_eds_show then
      begin
        obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]];
        w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
        w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
        with rct_ent_2 do
          begin
            left  :=Trunc(rct_ent.left  )+w_a_s_x;
            top   :=Trunc(rct_ent.top   )+w_a_s_y;
            right :=Trunc(rct_ent.right )+w_a_s_x;
            bottom:=Trunc(rct_ent.bottom)+w_a_s_y;
            width :=right -left;
            height:=bottom-top ;
          end;
        if (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr_^)) then
          begin

            {Is There A Fully Rendered Sprite-----------------} {$region -fold}
            with sprite_sheet_arr[rct_eds_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
              if (obj_arr_ptr^.t_ind<obj_var.low_lr_obj_cnt) then
                if (nt_pix_cnt<>0) then
                  if lazy_repaint_prev and lazy_repaint then
                    begin
                      fast_image_data_arr[0].monochrome_val:=fast_image_data.monochrome_val;
                      bmp_src_rct_clp     :=rct_ent_2;
                      SdrProc[sdr_proc_ind](rct_ent_2.left,
                                            rct_ent_2.top,
                                            @fast_image_data);
                      Exit;
                    end; {$endregion}

            {Misc. Precalc.-----------------------------------} {$region -fold}
            SetBkgnd
            (
              obj_arr_ptr^.bkgnd_ptr,
              obj_arr_ptr^.bkgnd_width,
              obj_arr_ptr^.bkgnd_height,
              obj_arr_ptr^.rct_clp_ptr
            ); {$endregion}

            {Drawing Of Spline Object Edges Bounding Rectangle} {$region -fold}
            Rectangle
            (
              pts_rct_width__half-pts_rct_width__odd+rct_ent_2.left,
              pts_rct_height_half-pts_rct_height_odd+rct_ent_2.top ,
              bmp_dst_ptr,
              bmp_dst_width,
              bmp_dst_height,
              rct_clp_ptr_^,
              local_prop
            ); {$endregion}

          end;
      end;
end; {$endregion}
procedure TCurve.SplineRctPtsDraw  (const spline_ind       :TColor; rct_clp_ptr_:PPtRect);                                                                                   {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  w_a_s_x,w_a_s_y: integer;
begin
  with rct_pts_img_arr[spline_ind],local_prop do
    if rct_pts_show then
      begin
        obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]];
        w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
        w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
        with rct_ent_2 do
          begin
            left  :=Trunc(rct_ent.left  )+w_a_s_x;
            top   :=Trunc(rct_ent.top   )+w_a_s_y;
            right :=Trunc(rct_ent.right )+w_a_s_x;
            bottom:=Trunc(rct_ent.bottom)+w_a_s_y;
            width :=right -left;
            height:=bottom-top ;
          end;
        if (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr_^)) then
          begin

            {Is There A Fully Rendered Sprite-----------------} {$region -fold}
            with sprite_sheet_arr[rct_pts_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
              if (obj_arr_ptr^.t_ind<obj_var.low_lr_obj_cnt) then
                if (nt_pix_cnt<>0) then
                  if lazy_repaint_prev and lazy_repaint then
                    begin
                      fast_image_data_arr[0].monochrome_val:=fast_image_data.monochrome_val;
                      bmp_src_rct_clp     :=rct_ent_2;
                      SdrProc[sdr_proc_ind](rct_ent_2.left,
                                            rct_ent_2.top,
                                            @fast_image_data);
                      Exit;
                    end; {$endregion}

            {Misc. Precalc.-----------------------------------} {$region -fold}
            SetBkgnd
            (
              obj_arr_ptr^.bkgnd_ptr,
              obj_arr_ptr^.bkgnd_width,
              obj_arr_ptr^.bkgnd_height,
              obj_arr_ptr^.rct_clp_ptr
            ); {$endregion}

            {Drawing Of Spline Object Edges Bounding Rectangle} {$region -fold}
            Rectangle
            (
              pts_rct_width__half-pts_rct_width__odd+rct_ent_2.left,
              pts_rct_height_half-pts_rct_height_odd+rct_ent_2.top,
              bmp_dst_ptr,
              bmp_dst_width,
              bmp_dst_height,
              rct_clp_ptr_^,
              local_prop
            ); {$endregion}

          end;
      end;
end; {$endregion}
procedure TCurve.SplineEds0Draw    (const spline_ind       :TColor; rct_clp_ptr_:PPtRect);                                                                                   {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  w_a_s_x,w_a_s_y: integer;
  x0,y0,x1,y1    : double;
  rct_rad        : double;
  b,i            : integer;
  max_w_h_div_2  : integer;
  min_w_h_div_2  : integer;
begin
  {if IsPtInRct(x0,y0,rct_clp) and
     IsPtInRct(x1,y1,rct_clp) then
    begin
      proc1(x0,y0,x1,y1);
      Exit;
    end;}
  with eds_img_arr[spline_ind],local_prop do
    if eds_show then
      begin
        obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]];
        w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
        w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
        with rct_ent_2 do
          begin
            left  :=Trunc(rct_ent.left  )+w_a_s_x;
            top   :=Trunc(rct_ent.top   )+w_a_s_y;
            right :=Trunc(rct_ent.right )+w_a_s_x;
            bottom:=Trunc(rct_ent.bottom)+w_a_s_y;
            width :=right-left;
            height:=bottom-top;
          end;

        //F_MainForm.M_Test_Log.Lines.Text:='';
        //F_MainForm.M_Test_Log.Lines.Text:='Begin0';

        if (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr_^)) then
          begin

            //F_MainForm.M_Test_Log.Lines.Text:='';
            //F_MainForm.M_Test_Log.Lines.Text:='Begin1';

            {Is There A Fully Rendered Sprite} {$region -fold}
            with sprite_sheet_arr[eds_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
              if (obj_arr_ptr^.t_ind>=obj_var.low_lr_obj_cnt) then
                if (nt_pix_cnt<>0) then
                  if lazy_repaint_prev and lazy_repaint then
                    begin

                      //F_MainForm.M_Test_Log.Lines.Text:='';
                      //F_MainForm.M_Test_Log.Lines.Text:='Skip';

                      fast_image_data_arr[0].monochrome_val:=fast_image_data.monochrome_val;
                      bmp_src_rct_clp     :=rct_ent_2;
                      SdrProc[sdr_proc_ind](rct_ent_2.left,
                                            rct_ent_2.top,
                                            @fast_image_data);
                      Exit;
                    end; {$endregion}

            {Misc. Precalc.------------------} {$region -fold}
            SetBkgnd
            (
              obj_arr_ptr^.bkgnd_ptr,
              obj_arr_ptr^.bkgnd_width,
              obj_arr_ptr^.bkgnd_height,
              obj_arr_ptr^.rct_clp_ptr
            );
            b            :=partial_pts_sum[spline_ind];
            mov_dir      :=cmr_var.mov_dir;
            max_w_h_div_2:=Max(rct_clp_ptr_^.width,rct_clp_ptr_^.height)>>1;
            min_w_h_div_2:=Min(rct_clp_ptr_^.width,rct_clp_ptr_^.height)>>1;
            rct_rad      :=sqrt(sqr(max_w_h_div_2)+sqr(min_w_h_div_2)); {$endregion}

            {Drawing Of Spline Object Edges--} {$region -fold}

            //Randomize;
            //F_MainForm.M_Test_Log.Lines.Text:=IntToStr(Random(1000));

            case eds_width of
              1:
                begin

                  {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                  if cnc_ends then
                    ClippedLine2
                    (
                      sln_pts[b+00000000000000000000000000000].x+w_a_s_x,
                      sln_pts[b+00000000000000000000000000000].y+w_a_s_y,
                      sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x,
                      sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y,
                      rct_clp_ptr_^,
                      Unaligned(@LinePHL30),
                      Unaligned(@LineSHL30),
                      Unaligned(@LineSVL30),
                      Unaligned(@LinePHL31),
                      Unaligned(@LinePHL32)
                    ); {$endregion}

                  {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                  sln_pts_ptr:=Unaligned(@sln_pts[b]);
                  for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
                    begin
                      x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                      y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                      x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                      y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                      //if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_clp_ptr_^)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad,0)} then
                        ClippedLine2
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_clp_ptr_^,
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30),
                          Unaligned(@LineSVL30),
                          Unaligned(@LinePHL31),
                          Unaligned(@LinePHL32)
                        );
                      Inc(sln_pts_ptr);
                    end; {$endregion}

                end;

              2:
                begin

                  {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                  if cnc_ends then
                    begin
                      x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                      y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                      x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                      y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                      ClippedLine2
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        rct_clp_ptr_^,
                        Unaligned(@LinePHL30),
                        Unaligned(@LineSHL30),
                        Unaligned(@LineSVL30),
                        Unaligned(@LinePHL31),
                        Unaligned(@LinePHL32)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        ClippedLine2
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          rct_clp_ptr_^,
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30),
                          Unaligned(@LineSVL30),
                          Unaligned(@LinePHL31),
                          Unaligned(@LinePHL32)
                        )
                      else
                        ClippedLine2
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          rct_clp_ptr_^,
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30),
                          Unaligned(@LineSVL30),
                          Unaligned(@LinePHL31),
                          Unaligned(@LinePHL32)
                        )
                    end; {$endregion}

                  {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                  sln_pts_ptr:=Unaligned(@sln_pts[b]);
                  for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
                    begin
                      x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                      y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                      x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                      y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                      //if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_clp_ptr_^)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad+1,0)} then
                        begin
                          ClippedLine2
                          (
                            x0,
                            y0,
                            x1,
                            y1,
                            rct_clp_ptr_^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          );
                          if (Abs(y1-y0)<Abs(x1-x0)) then
                            ClippedLine2
                            (
                              x0+0,
                              y0+1,
                              x1+0,
                              y1+1,
                              rct_clp_ptr_^,
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30),
                              Unaligned(@LineSVL30),
                              Unaligned(@LinePHL31),
                              Unaligned(@LinePHL32)
                            )
                          else
                            ClippedLine2
                            (
                              x0+1,
                              y0+0,
                              x1+1,
                              y1+0,
                              rct_clp_ptr_^,
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30),
                              Unaligned(@LineSVL30),
                              Unaligned(@LinePHL31),
                              Unaligned(@LinePHL32)
                            );
                        end;
                      Inc(sln_pts_ptr);
                    end; {$endregion}

                end;
              3:
                begin

                  {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                  if cnc_ends then
                    begin
                      x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                      y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                      x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                      y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                      ClippedLine2
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        rct_clp_ptr_^,
                        Unaligned(@LinePHL30),
                        Unaligned(@LineSHL30),
                        Unaligned(@LineSVL30),
                        Unaligned(@LinePHL31),
                        Unaligned(@LinePHL32)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        begin
                          ClippedLine2
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_clp_ptr_^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          );
                          ClippedLine2
                          (
                            x0+0,
                            y0-1,
                            x1+0,
                            y1-1,
                            rct_clp_ptr_^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          );
                        end
                      else
                        begin
                          ClippedLine2
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_clp_ptr_^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          );
                          ClippedLine2
                          (
                            x0-1,
                            y0+0,
                            x1-1,
                            y1+0,
                            rct_clp_ptr_^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          );
                        end;
                    end; {$endregion}

                  {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                  sln_pts_ptr:=Unaligned(@sln_pts[b]);
                  for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
                    begin
                      x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                      y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                      x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                      y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                      //if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_clp_ptr_^)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad+2,0)} then
                        begin
                          ClippedLine2
                          (
                            x0,
                            y0,
                            x1,
                            y1,
                            rct_clp_ptr_^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          );
                          if (Abs(y1-y0)<Abs(x1-x0)) then
                            begin
                              ClippedLine2
                              (
                                x0+0,
                                y0+1,
                                x1+0,
                                y1+1,
                                rct_clp_ptr_^,
                                Unaligned(@LinePHL30),
                                Unaligned(@LineSHL30),
                                Unaligned(@LineSVL30),
                                Unaligned(@LinePHL31),
                                Unaligned(@LinePHL32)
                              );
                              ClippedLine2
                              (
                                x0+0,
                                y0-1,
                                x1+0,
                                y1-1,
                                rct_clp_ptr_^,
                                Unaligned(@LinePHL30),
                                Unaligned(@LineSHL30),
                                Unaligned(@LineSVL30),
                                Unaligned(@LinePHL31),
                                Unaligned(@LinePHL32)
                              );
                            end
                          else
                            begin
                              ClippedLine2
                              (
                                x0+1,
                                y0+0,
                                x1+1,
                                y1+0,
                                rct_clp_ptr_^,
                                Unaligned(@LinePHL30),
                                Unaligned(@LineSHL30),
                                Unaligned(@LineSVL30),
                                Unaligned(@LinePHL31),
                                Unaligned(@LinePHL32)
                              );
                              ClippedLine2
                              (
                                x0-1,
                                y0+0,
                                x1-1,
                                y1+0,
                                rct_clp_ptr_^,
                                Unaligned(@LinePHL30),
                                Unaligned(@LineSHL30),
                                Unaligned(@LineSVL30),
                                Unaligned(@LinePHL31),
                                Unaligned(@LinePHL32)
                              );
                            end;
                        end;
                      Inc(sln_pts_ptr);
                    end; {$endregion}

                end;
            end; {$endregion}

          end;
      end;
end; {$endregion}
procedure TCurve.SplineEds1Draw    (const spline_ind       :TColor; rct_clp_ptr_:PPtRect);                                                                                   {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  w_a_s_x,w_a_s_y: integer;
  x0,y0,x1,y1    : double;
  rct_rad        : double;
  b,i            : integer;
  max_w_h_div_2  : integer;
  min_w_h_div_2  : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    if eds_show then
      begin
        obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]];
        w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
        w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
        with rct_ent_2 do
          begin
            left  :=Trunc(rct_ent.left  )+w_a_s_x;
            top   :=Trunc(rct_ent.top   )+w_a_s_y;
            right :=Trunc(rct_ent.right )+w_a_s_x;
            bottom:=Trunc(rct_ent.bottom)+w_a_s_y;
            width :=right -left;
            height:=bottom-top ;
          end;
        if (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr_^)) then
          begin

            {Is There A Fully Rendered Sprite} {$region -fold}
            with sprite_sheet_arr[eds_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
              if (obj_arr_ptr^.t_ind>=obj_var.low_lr_obj_cnt) then
                if (nt_pix_cnt<>0) then
                  if lazy_repaint_prev and lazy_repaint then
                    begin
                      fast_image_data_arr[0].monochrome_val:=fast_image_data.monochrome_val;
                      bmp_src_rct_clp     :=rct_ent_2;
                      SdrProc[sdr_proc_ind](rct_ent_2.left,
                                            rct_ent_2.top,
                                            @fast_image_data);
                      Exit;
                    end; {$endregion}

            {Misc. Precalc.------------------} {$region -fold}
            SetBkgnd
            (
              obj_arr_ptr^.bkgnd_ptr,
              obj_arr_ptr^.bkgnd_width,
              obj_arr_ptr^.bkgnd_height,
              obj_arr_ptr^.rct_clp_ptr
            );
            b            :=partial_pts_sum[spline_ind];
            mov_dir      :=cmr_var.mov_dir;
            max_w_h_div_2:=Max(rct_clp_ptr_^.width,rct_clp_ptr_^.height)>>1;
            min_w_h_div_2:=Min(rct_clp_ptr_^.width,rct_clp_ptr_^.height)>>1;
            rct_rad      :=sqrt(sqr(max_w_h_div_2)+sqr(min_w_h_div_2)); {$endregion}

            {Drawing Of Spline Object Edges--} {$region -fold}
            case eds_width of
              1:
                begin

                  {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                  if (not (sel_var.is_point_selected[b+00000000000000000000000000000] or
                           sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1])) then
                    if cnc_ends then
                      ClippedLine2
                      (
                        sln_pts[b+00000000000000000000000000000].x+w_a_s_x,
                        sln_pts[b+00000000000000000000000000000].y+w_a_s_y,
                        sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x,
                        sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y,
                        rct_clp_ptr_^,
                        Unaligned(@LinePHL30),
                        Unaligned(@LineSHL30),
                        Unaligned(@LineSVL30),
                        Unaligned(@LinePHL31),
                        Unaligned(@LinePHL32)
                      ); {$endregion}

                  {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                  sln_pts_ptr:=Unaligned(@sln_pts[b]);
                  for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
                    begin
                      if (not (sel_var.is_point_selected[b+i] or
                               sel_var.is_point_selected[b+i+1])) then
                        begin
                          x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                          y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                          x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                          y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                          //if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_clp_ptr_^)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad,0)} then
                            ClippedLine2
                            (
                              x0,
                              y0,
                              x1,
                              y1,
                              rct_clp_ptr_^,
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30),
                              Unaligned(@LineSVL30),
                              Unaligned(@LinePHL31),
                              Unaligned(@LinePHL32)
                            );
                        end;
                      Inc(sln_pts_ptr);
                    end; {$endregion}

                end;

              2:
                begin

                  {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                  if (not (sel_var.is_point_selected[b+00000000000000000000000000000] or
                           sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1])) then
                    if cnc_ends then
                      begin
                        x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                        y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                        x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                        y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                        ClippedLine2
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_clp_ptr_^,
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30),
                          Unaligned(@LineSVL30),
                          Unaligned(@LinePHL31),
                          Unaligned(@LinePHL32)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          ClippedLine2
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_clp_ptr_^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          )
                        else
                          ClippedLine2
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_clp_ptr_^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          )
                      end; {$endregion}

                  {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                  sln_pts_ptr:=Unaligned(@sln_pts[b]);
                  for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
                    begin
                      if (not (sel_var.is_point_selected[b+i] or
                               sel_var.is_point_selected[b+i+1])) then
                        begin
                          x0:=Trunc((sln_pts_ptr+0)^.x)+w_a_s_x;
                          y0:=Trunc((sln_pts_ptr+0)^.y)+w_a_s_y;
                          x1:=Trunc((sln_pts_ptr+1)^.x)+w_a_s_x;
                          y1:=Trunc((sln_pts_ptr+1)^.y)+w_a_s_y;
                          //if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_clp_ptr_^)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad+1,0)} then
                            begin
                              ClippedLine2
                              (
                                x0,
                                y0,
                                x1,
                                y1,
                                rct_clp_ptr_^,
                                Unaligned(@LinePHL30),
                                Unaligned(@LineSHL30),
                                Unaligned(@LineSVL30),
                                Unaligned(@LinePHL31),
                                Unaligned(@LinePHL32)
                              );
                              if (Abs(y1-y0)<Abs(x1-x0)) then
                                ClippedLine2
                                (
                                  x0+0,
                                  y0+1,
                                  x1+0,
                                  y1+1,
                                  rct_clp_ptr_^,
                                  Unaligned(@LinePHL30),
                                  Unaligned(@LineSHL30),
                                  Unaligned(@LineSVL30),
                                  Unaligned(@LinePHL31),
                                  Unaligned(@LinePHL32)
                                )
                              else
                                ClippedLine2
                                (
                                  x0+1,
                                  y0+0,
                                  x1+1,
                                  y1+0,
                                  rct_clp_ptr_^,
                                  Unaligned(@LinePHL30),
                                  Unaligned(@LineSHL30),
                                  Unaligned(@LineSVL30),
                                  Unaligned(@LinePHL31),
                                  Unaligned(@LinePHL32)
                                );
                            end;
                        end;
                      Inc(sln_pts_ptr);
                    end; {$endregion}

                end;
              3:
                begin

                  {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                  if (not (sel_var.is_point_selected[b+00000000000000000000000000000] or
                           sel_var.is_point_selected[b+sln_obj_pts_cnt[spline_ind]-1])) then
                    if cnc_ends then
                      begin
                        x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                        y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                        x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                        y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                        ClippedLine2
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_clp_ptr_^,
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30),
                          Unaligned(@LineSVL30),
                          Unaligned(@LinePHL31),
                          Unaligned(@LinePHL32)
                        );
                        if (Abs(y1-y0)<Abs(x1-x0)) then
                          begin
                            ClippedLine2
                            (
                              x0+0,
                              y0+1,
                              x1+0,
                              y1+1,
                              rct_clp_ptr_^,
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30),
                              Unaligned(@LineSVL30),
                              Unaligned(@LinePHL31),
                              Unaligned(@LinePHL32)
                            );
                            ClippedLine2
                            (
                              x0+0,
                              y0-1,
                              x1+0,
                              y1-1,
                              rct_clp_ptr_^,
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30),
                              Unaligned(@LineSVL30),
                              Unaligned(@LinePHL31),
                              Unaligned(@LinePHL32)
                            );
                          end
                        else
                          begin
                            ClippedLine2
                            (
                              x0+1,
                              y0+0,
                              x1+1,
                              y1+0,
                              rct_clp_ptr_^,
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30),
                              Unaligned(@LineSVL30),
                              Unaligned(@LinePHL31),
                              Unaligned(@LinePHL32)
                            );
                            ClippedLine2
                            (
                              x0-1,
                              y0+0,
                              x1-1,
                              y1+0,
                              rct_clp_ptr_^,
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30),
                              Unaligned(@LineSVL30),
                              Unaligned(@LinePHL31),
                              Unaligned(@LinePHL32)
                            );
                          end;
                      end; {$endregion}

                  {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                  sln_pts_ptr:=Unaligned(@sln_pts[b]);
                  for i:=0 to sln_obj_pts_cnt[spline_ind]-2 do
                    begin
                      if (not (sel_var.is_point_selected[b+i] or
                               sel_var.is_point_selected[b+i+1])) then
                        begin
                          x0:=(sln_pts_ptr+0)^.x+w_a_s_x;
                          y0:=(sln_pts_ptr+0)^.y+w_a_s_y;
                          x1:=(sln_pts_ptr+1)^.x+w_a_s_x;
                          y1:=(sln_pts_ptr+1)^.y+w_a_s_y;
                          //if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_clp_ptr_^)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad+2,0)} then
                            begin
                              ClippedLine2
                              (
                                x0,
                                y0,
                                x1,
                                y1,
                                rct_clp_ptr_^,
                                Unaligned(@LinePHL30),
                                Unaligned(@LineSHL30),
                                Unaligned(@LineSVL30),
                                Unaligned(@LinePHL31),
                                Unaligned(@LinePHL32)
                              );
                              if (Abs(y1-y0)<Abs(x1-x0)) then
                                begin
                                  ClippedLine2
                                  (
                                    x0+0,
                                    y0+1,
                                    x1+0,
                                    y1+1,
                                    rct_clp_ptr_^,
                                    Unaligned(@LinePHL30),
                                    Unaligned(@LineSHL30),
                                    Unaligned(@LineSVL30),
                                    Unaligned(@LinePHL31),
                                    Unaligned(@LinePHL32)
                                  );
                                  ClippedLine2
                                  (
                                    x0+0,
                                    y0-1,
                                    x1+0,
                                    y1-1,
                                    rct_clp_ptr_^,
                                    Unaligned(@LinePHL30),
                                    Unaligned(@LineSHL30),
                                    Unaligned(@LineSVL30),
                                    Unaligned(@LinePHL31),
                                    Unaligned(@LinePHL32)
                                  );
                                end
                              else
                                begin
                                  ClippedLine2
                                  (
                                    x0+1,
                                    y0+0,
                                    x1+1,
                                    y1+0,
                                    rct_clp_ptr_^,
                                    Unaligned(@LinePHL30),
                                    Unaligned(@LineSHL30),
                                    Unaligned(@LineSVL30),
                                    Unaligned(@LinePHL31),
                                    Unaligned(@LinePHL32)
                                  );
                                  ClippedLine2
                                  (
                                    x0-1,
                                    y0+0,
                                    x1-1,
                                    y1+0,
                                    rct_clp_ptr_^,
                                    Unaligned(@LinePHL30),
                                    Unaligned(@LineSHL30),
                                    Unaligned(@LineSVL30),
                                    Unaligned(@LinePHL31),
                                    Unaligned(@LinePHL32)
                                  );
                                end;
                            end;
                        end;
                      Inc(sln_pts_ptr);
                    end; {$endregion}

                end;
            end; {$endregion}

          end;
      end;
end; {$endregion}
procedure TCurve.SplineEds2Draw    (const spline_ind       :TColor; rct_clp_ptr_:PPtRect);                                                                                   {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr        : PObjProp;
  sln_pts_ptr        : PPtPosF;
  sln_pts_ptr2       : PPtPosF;
  sln_vis_eds_ind_ptr: PColor;
  w_a_s_x,w_a_s_y    : integer;
  x0,y0,x1,y1        : double;
  rct_rad            : double;
  b,i                : integer;
  max_w_h_div_2      : integer;
  min_w_h_div_2      : integer;
begin
  with eds_img_arr[spline_ind],local_prop do
    if eds_show then
      begin
        obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]];
        w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
        w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
        with rct_ent_2 do
          begin
            left  :=Trunc(rct_ent.left  )+w_a_s_x;
            top   :=Trunc(rct_ent.top   )+w_a_s_y;
            right :=Trunc(rct_ent.right )+w_a_s_x;
            bottom:=Trunc(rct_ent.bottom)+w_a_s_y;
            width :=right -left;
            height:=bottom-top ;
          end;
        if (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr_^)) then
          begin

            {Is There A Fully Rendered Sprite} {$region -fold}
            with sprite_sheet_arr[eds_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
              if (obj_arr_ptr^.t_ind>=obj_var.low_lr_obj_cnt) then
                if (nt_pix_cnt<>0) then
                  if lazy_repaint_prev and lazy_repaint then
                    begin
                      fast_image_data_arr[0].monochrome_val:=fast_image_data.monochrome_val;
                      bmp_src_rct_clp     :=rct_ent_2;
                      SdrProc[sdr_proc_ind](rct_ent_2.left,
                                            rct_ent_2.top,
                                            @fast_image_data);
                      Exit;
                    end; {$endregion}

            {Misc. Precalc.------------------} {$region -fold}
            SetBkgnd
            (
              obj_arr_ptr^.bkgnd_ptr,
              obj_arr_ptr^.bkgnd_width,
              obj_arr_ptr^.bkgnd_height,
              obj_arr_ptr^.rct_clp_ptr
            );
            b                  :=partial_pts_sum[spline_ind];
            sln_pts_ptr        :=Unaligned(@sln_pts[b]);
            sln_vis_eds_ind_ptr:=Unaligned(@sln_vis_eds_ind[spline_ind,0]);
            mov_dir            :=cmr_var.mov_dir;
            max_w_h_div_2      :=Max(rct_clp_ptr_^.width,rct_clp_ptr_^.height)>>1;
            min_w_h_div_2      :=Min(rct_clp_ptr_^.width,rct_clp_ptr_^.height)>>1;
            rct_rad            :=sqrt(sqr(max_w_h_div_2)+sqr(min_w_h_div_2)); {$endregion}

            {Drawing Of Spline Object Edges--} {$region -fold}
            case eds_width of
              1:
                begin

                  {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                  if cnc_ends then
                    ClippedLine2
                    (
                      sln_pts[b+00000000000000000000000000000].x+w_a_s_x,
                      sln_pts[b+00000000000000000000000000000].y+w_a_s_y,
                      sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x,
                      sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y,
                      rct_clp_ptr_^,
                      Unaligned(@LinePHL30),
                      Unaligned(@LineSHL30),
                      Unaligned(@LineSVL30),
                      Unaligned(@LinePHL31),
                      Unaligned(@LinePHL32)
                    ); {$endregion}

                  {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                  for i:=0 to vis_ln_cnt-1 do
                    begin
                      sln_pts_ptr2:= sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                      x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                      y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                      x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                      y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                      //if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_clp_ptr_^)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad,0)} then
                        ClippedLine2
                        (
                          x0,
                          y0,
                          x1,
                          y1,
                          rct_clp_ptr_^,
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30),
                          Unaligned(@LineSVL30),
                          Unaligned(@LinePHL31),
                          Unaligned(@LinePHL32)
                        );
                    end; {$endregion}

                end;

              2:
                begin

                  {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                  if cnc_ends then
                    begin
                      x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                      y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                      x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                      y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                      ClippedLine2
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        rct_clp_ptr_^,
                        Unaligned(@LinePHL30),
                        Unaligned(@LineSHL30),
                        Unaligned(@LineSVL30),
                        Unaligned(@LinePHL31),
                        Unaligned(@LinePHL32)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        ClippedLine2
                        (
                          x0+0,
                          y0+1,
                          x1+0,
                          y1+1,
                          rct_clp_ptr_^,
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30),
                          Unaligned(@LineSVL30),
                          Unaligned(@LinePHL31),
                          Unaligned(@LinePHL32)
                        )
                      else
                        ClippedLine2
                        (
                          x0+1,
                          y0+0,
                          x1+1,
                          y1+0,
                          rct_clp_ptr_^,
                          Unaligned(@LinePHL30),
                          Unaligned(@LineSHL30),
                          Unaligned(@LineSVL30),
                          Unaligned(@LinePHL31),
                          Unaligned(@LinePHL32)
                        );
                    end; {$endregion}

                  {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                  for i:=0 to vis_ln_cnt-1 do
                    begin
                      sln_pts_ptr2:= sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                      x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                      y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                      x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                      y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                      //if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_clp_ptr_^)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad+1,0)} then
                        begin
                          ClippedLine2
                          (
                            x0,
                            y0,
                            x1,
                            y1,
                            rct_clp_ptr_^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          );
                          if (Abs(y1-y0)<Abs(x1-x0)) then
                            ClippedLine2
                            (
                              x0+0,
                              y0+1,
                              x1+0,
                              y1+1,
                              rct_clp_ptr_^,
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30),
                              Unaligned(@LineSVL30),
                              Unaligned(@LinePHL31),
                              Unaligned(@LinePHL32)
                            )
                          else
                            ClippedLine2
                            (
                              x0+1,
                              y0+0,
                              x1+1,
                              y1+0,
                              rct_clp_ptr_^,
                              Unaligned(@LinePHL30),
                              Unaligned(@LineSHL30),
                              Unaligned(@LineSVL30),
                              Unaligned(@LinePHL31),
                              Unaligned(@LinePHL32)
                            );
                        end;
                    end; {$endregion}

                end;
              3:
                begin

                  {Drawing Of Connected Edges(Between First And Last Points Of Spline Object)} {$region -fold}
                  if cnc_ends then
                    begin
                      x0:=sln_pts[b+00000000000000000000000000000].x+w_a_s_x;
                      y0:=sln_pts[b+00000000000000000000000000000].y+w_a_s_y;
                      x1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].x+w_a_s_x;
                      y1:=sln_pts[b+sln_obj_pts_cnt[spline_ind]-1].y+w_a_s_y;
                      ClippedLine2
                      (
                        x0,
                        y0,
                        x1,
                        y1,
                        rct_clp_ptr_^,
                        Unaligned(@LinePHL30),
                        Unaligned(@LineSHL30),
                        Unaligned(@LineSVL30),
                        Unaligned(@LinePHL31),
                        Unaligned(@LinePHL32)
                      );
                      if (Abs(y1-y0)<Abs(x1-x0)) then
                        begin
                          ClippedLine2
                          (
                            x0+0,
                            y0+1,
                            x1+0,
                            y1+1,
                            rct_clp_ptr_^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          );
                          ClippedLine2
                          (
                            x0+0,
                            y0-1,
                            x1+0,
                            y1-1,
                            rct_clp_ptr_^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          );
                        end
                      else
                        begin
                          ClippedLine2
                          (
                            x0+1,
                            y0+0,
                            x1+1,
                            y1+0,
                            rct_clp_ptr_^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          );
                          ClippedLine2
                          (
                            x0-1,
                            y0+0,
                            x1-1,
                            y1+0,
                            rct_clp_ptr_^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          );
                        end;
                    end; {$endregion}

                  {Drawing Of Spline Object Edges--------------------------------------------} {$region -fold}
                  for i:=0 to vis_ln_cnt-1 do
                    begin
                      sln_pts_ptr2:= sln_pts_ptr+(sln_vis_eds_ind_ptr+i)^;
                      x0          :=(sln_pts_ptr2+0)^.x+w_a_s_x;
                      y0          :=(sln_pts_ptr2+0)^.y+w_a_s_y;
                      x1          :=(sln_pts_ptr2+1)^.x+w_a_s_x;
                      y1          :=(sln_pts_ptr2+1)^.y+w_a_s_y;
                      //if (not IsRct1OutOfRct2(LineBndRct(x0,y0,x1,y1,eds_width),rct_clp_ptr_^)){LineCrcIntPt(x0,y0,x1,y1,rct_out.left+rct_out.width>>1,rct_out.top+rct_out.height>>1,rct_rad+2,0)} then
                        begin
                          ClippedLine2
                          (
                            x0,
                            y0,
                            x1,
                            y1,
                            rct_clp_ptr_^,
                            Unaligned(@LinePHL30),
                            Unaligned(@LineSHL30),
                            Unaligned(@LineSVL30),
                            Unaligned(@LinePHL31),
                            Unaligned(@LinePHL32)
                          );
                          if (Abs(y1-y0)<Abs(x1-x0)) then
                            begin
                              ClippedLine2
                              (
                                x0+0,
                                y0+1,
                                x1+0,
                                y1+1,
                                rct_clp_ptr_^,
                                Unaligned(@LinePHL30),
                                Unaligned(@LineSHL30),
                                Unaligned(@LineSVL30),
                                Unaligned(@LinePHL31),
                                Unaligned(@LinePHL32)
                              );
                              ClippedLine2
                              (
                                x0+0,
                                y0-1,
                                x1+0,
                                y1-1,
                                rct_clp_ptr_^,
                                Unaligned(@LinePHL30),
                                Unaligned(@LineSHL30),
                                Unaligned(@LineSVL30),
                                Unaligned(@LinePHL31),
                                Unaligned(@LinePHL32)
                              );
                            end
                          else
                            begin
                              ClippedLine2
                              (
                                x0+1,
                                y0+0,
                                x1+1,
                                y1+0,
                                rct_clp_ptr_^,
                                Unaligned(@LinePHL30),
                                Unaligned(@LineSHL30),
                                Unaligned(@LineSVL30),
                                Unaligned(@LinePHL31),
                                Unaligned(@LinePHL32)
                              );
                              ClippedLine2
                              (
                                x0-1,
                                y0+0,
                                x1-1,
                                y1+0,
                                rct_clp_ptr_^,
                                Unaligned(@LinePHL30),
                                Unaligned(@LineSHL30),
                                Unaligned(@LineSVL30),
                                Unaligned(@LinePHL31),
                                Unaligned(@LinePHL32)
                              );
                            end;
                        end;
                    end; {$endregion}

                end;
            end; {$endregion}

          end;
      end;
end; {$endregion}
procedure TCurve.SplinePts0Draw    (const spline_ind       :TColor; rct_clp_ptr_:PPtRect);                                                                                   {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  sln_pts_ptr0   : PPtPosF;
  sln_pts_ptr1   : PPtPosF;
  sln_pts_ptr2   : PPtPosF;
  sln_pts_ptr3   : PPtPosF;
  d0,d1          : TPtPosF;
  w_a_s_x,w_a_s_y: integer;
  i,j,k          : integer;
  c0,c1          : integer;
  minwh          : integer;

  {Test0} {$region -fold}
  {
  x0,y0          : integer;
  test_rct1      : TPtRect;
  test_rct2      : TPtRect;
  } {$endregion}

  {Test1} {$region -fold}
  {color_info2    : TColorInfo;} {$endregion}

begin
  with pts_img_arr[spline_ind],local_prop do
    if pts_show then
      begin
        obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]];
        w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
        w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
        with rct_ent_2 do
          begin
            left  :=Trunc(rct_ent.left  )+w_a_s_x;
            top   :=Trunc(rct_ent.top   )+w_a_s_y;
            right :=Trunc(rct_ent.right )+w_a_s_x;
            bottom:=Trunc(rct_ent.bottom)+w_a_s_y;
            width :=right -left;
            height:=bottom-top ;
          end;
        if (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr_^)) then
          begin

            {Is There A Fully Rendered Sprite} {$region -fold}
            with sprite_sheet_arr[pts_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
              if (obj_arr_ptr^.t_ind>=obj_var.low_lr_obj_cnt) then
                if (nt_pix_cnt<>0) then
                  if lazy_repaint_prev and lazy_repaint then
                    begin
                      fast_image_data_arr[0].monochrome_val:=fast_image_data.monochrome_val;
                      bmp_src_rct_clp     :=rct_ent_2;
                      SdrProc[sdr_proc_ind](rct_ent_2.left,
                                            rct_ent_2.top,
                                            @fast_image_data);
                      Exit;
                    end; {$endregion}

            {Misc. Precalc.------------------} {$region -fold}
            k:=partial_pts_sum[spline_ind];
            SetBkgnd
            (
              obj_arr_ptr^.bkgnd_ptr,
              obj_arr_ptr^.bkgnd_width,
              obj_arr_ptr^.bkgnd_height,
              obj_arr_ptr^.rct_clp_ptr
            ); {$endregion}

            {Drawing Of Spline Object Points-} {$region -fold}

            {Test1} {$region -fold}
            {minwh:=Min2(pts_rct_width,pts_rct_height);
            SetColorInfo(clBlue,color_info2);} {$endregion}

            if (not grid_clipping_pts) or
                down_select_items_ptr^ or
               (pts_img_arr[spline_ind].local_prop.grd_pts_dns=1) then
              begin
                sln_pts_ptr0:=Unaligned(@sln_pts[k]);
                for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
                  begin
                    Rectangle
                    (
                      Trunc((sln_pts_ptr0+i)^.x)+w_a_s_x,
                      Trunc((sln_pts_ptr0+i)^.y)+w_a_s_y,
                      bmp_dst_ptr,
                      bmp_dst_width,
                      bmp_dst_height,
                      rct_clp_ptr_^,
                      local_prop
                    );

                    {Test1} {$region -fold}
                    {
                    CircleHighlight001(Trunc((sln_pts_ptr0+i)^.x)+w_a_s_x,
                                       Trunc((sln_pts_ptr0+i)^.y)+w_a_s_y,
                                       bmp_dst_ptr,
                                       bmp_dst_width,
                                       rct_clp_ptr_^,
                                       color_info2,
                                       minwh,
                                       255);
                    CircleHighlight003(Trunc((sln_pts_ptr0+i)^.x)+w_a_s_x,
                                       Trunc((sln_pts_ptr0+i)^.y)+w_a_s_y,
                                       bmp_dst_ptr,
                                       bmp_dst_width,
                                       rct_clp_ptr_^,
                                       color_info2,
                                       minwh,
                                       150);
                    } {$endregion}

                  end;
              end
            else
              begin

                {Test0} {$region -fold}
                {
                with test_rct1 do
                  begin
                    left  :=rct_clp_ptr_^.left  +100;
                    top   :=rct_clp_ptr_^.top   +100;
                    right :=rct_clp_ptr_^.right -100;
                    bottom:=rct_clp_ptr_^.bottom-100;
                    width :=right-left;
                    height:=bottom-top;
                  end;
                with test_rct2 do
                  begin
                    left  :=rct_clp_ptr_^.left  ;
                    top   :=rct_clp_ptr_^.top   ;
                    right :=rct_clp_ptr_^.right ;
                    bottom:=rct_clp_ptr_^.bottom;
                    width :=right-left;
                    height:=bottom-top;
                  end;
                with rct_clp_ptr_^ do
                  begin
                    left  :=test_rct1.left  ;
                    top   :=test_rct1.top   ;
                    right :=test_rct1.right ;
                    bottom:=test_rct1.bottom;
                    width :=right-left;
                    height:=bottom-top;
                  end;
                y0:=     rct_clp_ptr_^.top;
                LineH(   rct_clp_ptr_^.left,y0,obj_arr_ptr^.rct_clp_ptr_^.right,bmp_dst_ptr,bmp_dst_width,clRed);
                y0:=     rct_clp_ptr_^.bottom;
                LineH(   rct_clp_ptr_^.left,y0,obj_arr_ptr^.rct_clp_ptr_^.right,bmp_dst_ptr,bmp_dst_width,clRed);
                x0:=     rct_clp_ptr_^.left;
                LineV(x0,rct_clp_ptr_^.top,    obj_arr_ptr^.rct_clp_ptr_^.bottom,bmp_dst_ptr,bmp_dst_width,clRed);
                x0:=     rct_clp_ptr_^.right;
                LineV(x0,rct_clp_ptr_^.top,    obj_arr_ptr^.rct_clp_ptr_^.bottom,bmp_dst_ptr,bmp_dst_width,clRed);

                for i:=1 to pts_img_arr[spline_ind].local_prop.grd_pts_dns do
                  begin
                    y0:=Trunc(d0__+i*d1__)+w_a_s_y;
                    if LineHC(rct_ent_2.left,y0,rct_ent_2.right,rct_clp_ptr_^) then
                       LineH (rct_ent_2.left,y0,rct_ent_2.right,bmp_dst_ptr,bmp_dst_width,clBlue);
                  end;
                } {$endregion}

                if (sln_obj_pts_cnt[spline_ind]=1) then
                  begin
                    Rectangle
                    (
                      Trunc(sln_pts[k].x)+w_a_s_x,
                      Trunc(sln_pts[k].y)+w_a_s_y,
                      bmp_dst_ptr,
                      bmp_dst_width,
                      bmp_dst_height,
                      rct_clp_ptr_^,
                      local_prop
                    );

                    {Test1} {$region -fold}
                    {
                    CircleHighlight001(Trunc(sln_pts[k].x)+w_a_s_x,
                                       Trunc(sln_pts[k].y)+w_a_s_y,
                                       bmp_dst_ptr,
                                       bmp_dst_width,
                                       rct_clp_ptr_^,
                                       color_info2,
                                       minwh,
                                       255);
                    CircleHighlight003(Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                       Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                       bmp_dst_ptr,
                                       bmp_dst_width,
                                       rct_clp_ptr_^,
                                       color_info2,
                                       minwh,
                                       150);
                    } {$endregion}

                    Exit;
                  end;
                sln_pts_ptr0:=Unaligned(@sln_pts[0]);
                if (scl_mul_dif          [spline_ind].x=1.0) and
                   (scl_mul_dif          [spline_ind].y=1.0) then
                  begin
                    for i:=0 to pts_img_arr[spline_ind].local_prop.grd_pts_dns-1 do
                      with min_max_inds    [spline_ind][i] do
                        begin
                          if (     has_pts [spline_ind][i]<>0 ) then
                            if (not (Trunc((sln_pts_ptr0+r)^.y)>rct_clp_ptr_^.bottom-w_a_s_y+pts_rct_height_half)) and
                               (not (Trunc((sln_pts_ptr0+g)^.y)<rct_clp_ptr_^.top   -w_a_s_y-pts_rct_height_half)) then
                              case has_pts [spline_ind][i] of
                                1: {claster has a single point---} {$region -fold}
                                  begin
                                    sln_pts_ptr1:=sln_pts_ptr0+pts_srt_inds[spline_ind][b];
                                    Rectangle
                                    (
                                      Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                      Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                      bmp_dst_ptr,
                                      bmp_dst_width,
                                      bmp_dst_height,
                                      rct_clp_ptr_^,
                                      local_prop
                                    );

                                    {Test0} {$region -fold}
                                    {
                                    SetTextInfo(srf_var_ptr^.srf_bmp.Canvas,22,clRed);
                                    Text
                                    (
                                      Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                      Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                      srf_var_ptr^.srf_bmp.Canvas,
                                      IntToStr(b)
                                    );
                                    } {$endregion}

                                    {Test1} {$region -fold}
                                    {
                                    CircleHighlight001(Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                                       Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                                       bmp_dst_ptr,
                                                       bmp_dst_width,
                                                       rct_clp_ptr_^,
                                                       color_info2,
                                                       minwh,
                                                       255);
                                    CircleHighlight003(Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                                       Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                                       bmp_dst_ptr,
                                                       bmp_dst_width,
                                                       rct_clp_ptr_^,
                                                       color_info2,
                                                       minwh,
                                                       150);
                                    } {$endregion}

                                  end; {$endregion}
                                2: {claster has more then 1 point} {$region -fold}
                                  begin
                                    if (Trunc                     (pts_srt_pos_x[spline_ind][b])>=rct_clp_ptr_^.left -w_a_s_x-pts_rct_width__half-1) then
                                      c0:=b
                                    else
                                      c0:=b+BinarySearch4(a-b+1,  @pts_srt_pos_x[spline_ind][b],  rct_clp_ptr_^.left -w_a_s_x-pts_rct_width__half-1)+1;
                                      c1:=b+BinarySearch4(a-b+1,  @pts_srt_pos_x[spline_ind][b],  rct_clp_ptr_^.right-w_a_s_x+pts_rct_width__half-0)+0;
                                    for j:=c0 to c1 do
                                      begin
                                        sln_pts_ptr1:=sln_pts_ptr0+pts_srt_inds [spline_ind][j];
                                        Rectangle
                                        (
                                          Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                          Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                          bmp_dst_ptr,
                                          bmp_dst_width,
                                          bmp_dst_height,
                                          rct_clp_ptr_^,
                                          local_prop
                                        );

                                        {Test0} {$region -fold}
                                        {
                                        SetTextInfo(srf_var_ptr^.srf_bmp.Canvas,22,clBlue);
                                        Text
                                        (
                                          Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                          Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                          srf_var_ptr^.srf_bmp.Canvas,
                                          IntToStr(j)
                                        );
                                        } {$endregion}

                                        {Test1} {$region -fold}
                                        {
                                        CircleHighlight001(Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                                           Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                                           bmp_dst_ptr,
                                                           bmp_dst_width,
                                                           rct_clp_ptr_^,
                                                           color_info2,
                                                           minwh,
                                                           255);
                                        CircleHighlight003(Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                                           Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                                           bmp_dst_ptr,
                                                           bmp_dst_width,
                                                           rct_clp_ptr_^,
                                                           color_info2,
                                                           minwh,
                                                           150);
                                        } {$endregion}

                                      end;
                                  end; {$endregion}
                              end;
                        end;
                  end
                else
                  begin
                    d0:=PtPosF(srf_var_ptr^.world_axis.x*(1-scl_mul_dif[spline_ind].x),
                               srf_var_ptr^.world_axis.y*(1-scl_mul_dif[spline_ind].y));
                    d1:=PtPosF((rct_clp_ptr_^.left -w_a_s_x-pts_rct_width__half-d0.x)/scl_mul_dif[spline_ind].x,
                               (rct_clp_ptr_^.right-w_a_s_x+pts_rct_width__half-d0.x)/scl_mul_dif[spline_ind].x);

                    for i:=0 to pts_img_arr         [spline_ind].local_prop.grd_pts_dns-1 do
                      with min_max_inds             [spline_ind][i] do
                        begin
                          if (     has_pts            [spline_ind][i]<>0 ) then
                            if (not (Trunc(scl_mul_dif[spline_ind].y*pts_srt_pos_y_min_max[spline_ind][i].x+d0.y)>rct_clp_ptr_^.bottom-w_a_s_y+pts_rct_height_half)) and
                               (not (Trunc(scl_mul_dif[spline_ind].y*pts_srt_pos_y_min_max[spline_ind][i].y+d0.y)<rct_clp_ptr_^.top   -w_a_s_y-pts_rct_height_half)) then
                              case has_pts            [spline_ind][i] of
                                1: {claster has a single point---} {$region -fold}
                                  begin
                                    sln_pts_ptr1:=sln_pts_ptr0+pts_srt_inds[spline_ind][b];
                                    Rectangle
                                    (
                                      Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                      Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                      bmp_dst_ptr,
                                      bmp_dst_width,
                                      bmp_dst_height,
                                      rct_clp_ptr_^,
                                      local_prop
                                    );

                                    {Test0} {$region -fold}
                                    {
                                    SetTextInfo(srf_var_ptr^.srf_bmp.Canvas,22,clRed);
                                    Text
                                    (
                                      Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                      Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                      srf_var_ptr^.srf_bmp.Canvas,
                                      IntToStr(b)
                                    );
                                    } {$endregion}

                                    {Test1} {$region -fold}
                                    {
                                    CircleHighlight001(Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                                       Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                                       bmp_dst_ptr,
                                                       bmp_dst_width,
                                                       rct_clp_ptr_^,
                                                       color_info2,
                                                       minwh,
                                                       255);
                                    CircleHighlight003(Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                                       Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                                       bmp_dst_ptr,
                                                       bmp_dst_width,
                                                       rct_clp_ptr_^,
                                                       color_info2,
                                                       minwh,
                                                       150);
                                    } {$endregion}

                                  end; {$endregion}
                                2: {claster has more then 1 point} {$region -fold}
                                  begin
                                    if (Trunc                     (pts_srt_pos_x[spline_ind][b])>=d1.x-1) then
                                      c0:=b
                                    else
                                      c0:=b+BinarySearch4(a-b+1,  @pts_srt_pos_x[spline_ind][b],  d1.x-1)+1;
                                      c1:=b+BinarySearch4(a-b+1,  @pts_srt_pos_x[spline_ind][b],  d1.y-0)+0;
                                    for j:={b}c0 to {a}c1 do
                                      begin
                                        sln_pts_ptr1:=sln_pts_ptr0+pts_srt_inds [spline_ind][j];
                                        Rectangle
                                        (
                                          Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                          Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                          bmp_dst_ptr,
                                          bmp_dst_width,
                                          bmp_dst_height,
                                          rct_clp_ptr_^,
                                          local_prop
                                        );

                                        {Test0} {$region -fold}
                                        {
                                        SetTextInfo(srf_var_ptr^.srf_bmp.Canvas,22,clBlue);
                                        Text
                                        (
                                          Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                          Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                          srf_var_ptr^.srf_bmp.Canvas,
                                          IntToStr(j)
                                        );
                                        } {$endregion}

                                        {Test1} {$region -fold}
                                        {
                                        CircleHighlight001(Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                                           Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                                           bmp_dst_ptr,
                                                           bmp_dst_width,
                                                           rct_clp_ptr_^,
                                                           color_info2,
                                                           minwh,
                                                           255);
                                        CircleHighlight003(Trunc(sln_pts_ptr1^.x)+w_a_s_x,
                                                           Trunc(sln_pts_ptr1^.y)+w_a_s_y,
                                                           bmp_dst_ptr,
                                                           bmp_dst_width,
                                                           rct_clp_ptr_^,
                                                           color_info2,
                                                           minwh,
                                                           150);
                                        } {$endregion}

                                      end;
                                  end; {$endregion}
                              end;
                        end;
                  end;

                {Test0} {$region -fold}
                {
                with rct_clp_ptr_^ do
                  begin
                    left  :=test_rct2.left  ;
                    top   :=test_rct2.top   ;
                    right :=test_rct2.right ;
                    bottom:=test_rct2.bottom;
                    width :=right-left;
                    height:=bottom-top;
                  end;
                } {$endregion}

              end; {$endregion}

          end;

        {Test2} {$region -fold}
        {
        sln_pts_ptr:=Unaligned(@sln_pts[partial_pts_sum[spline_ind]]);
        with sprite_sheet_arr[pvt_var.local_axis_bmp_ind],fast_image_data,fast_image_proc_var do
          begin
            fast_image_data_ptr0:=@fast_image_data;
            SetBkgnd
            (
              srf_var_ptr^.low_bmp_ptr,
              srf_var_ptr^.srf_bmp.width,
              srf_var_ptr^.srf_bmp.height,
              rct_clp_ptr_^
            );
            for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
              begin
                bmp_src_rct_clp:=PtBounds(0,0,bmp_ftimg_width_origin,bmp_ftimg_height_origin);
                SdrProc[sdr_proc_ind](Trunc((sln_pts_ptr+i)^.x)+w_a_s_x-bmp_ftimg_width_origin >>1,
                                      Trunc((sln_pts_ptr+i)^.y)+w_a_s_y-bmp_ftimg_height_origin>>1,
                                      @fast_image_data);
              end;
            SetBkgnd
            (
              srf_var_ptr^.srf_bmp_ptr,
              srf_var_ptr^.srf_bmp.width,
              srf_var_ptr^.srf_bmp.height,
              rct_clp_ptr_^
            );
          end;
        } {$endregion}

        {Test3} {$region -fold}
        {
        sln_pts_ptr:=Unaligned(@sln_pts[partial_pts_sum[spline_ind]]);
        SetColorInfo(clRed,color_info);
        for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
          CircleHighlight001(Trunc((sln_pts_ptr+i)^.x)+w_a_s_x,
                             Trunc((sln_pts_ptr+i)^.y)+w_a_s_y,
                             srf_var_ptr^.low_bmp_ptr,
                             srf_var_ptr^.srf_bmp.width,
                             rct_clp_ptr_^,
                             color_info,
                             1+Random(32),
                             255);
        } {$endregion}

      end;
end; {$endregion}
procedure TCurve.SplinePts1Draw    (const spline_ind       :TColor; rct_clp_ptr_:PPtRect);                                                                                   {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  w_a_s_x,w_a_s_y: integer;
  b,i            : integer;
begin
  with pts_img_arr[spline_ind],local_prop do
    if pts_show then
      begin
        obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]];
        w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
        w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
        with rct_ent_2 do
          begin
            left  :=Trunc(rct_ent.left  )+w_a_s_x;
            top   :=Trunc(rct_ent.top   )+w_a_s_y;
            right :=Trunc(rct_ent.right )+w_a_s_x;
            bottom:=Trunc(rct_ent.bottom)+w_a_s_y;
            width :=right -left;
            height:=bottom-top ;
          end;
        if (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr_^)) then
          begin

            {Is There A Fully Rendered Sprite} {$region -fold}
            with sprite_sheet_arr[pts_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
              if (obj_arr_ptr^.t_ind>=obj_var.low_lr_obj_cnt) then
                if (nt_pix_cnt<>0) then
                  if lazy_repaint_prev and lazy_repaint then
                    begin
                      fast_image_data_arr[0].monochrome_val:=fast_image_data.monochrome_val;
                      bmp_src_rct_clp     :=rct_ent_2;
                      SdrProc[sdr_proc_ind](rct_ent_2.left,
                                            rct_ent_2.top,
                                            @fast_image_data);
                      Exit;
                    end; {$endregion}

            {Misc. Precalc.------------------} {$region -fold}
            b:=partial_pts_sum[spline_ind];
            SetBkgnd
            (
              obj_arr_ptr^.bkgnd_ptr,
              obj_arr_ptr^.bkgnd_width,
              obj_arr_ptr^.bkgnd_height,
              obj_arr_ptr^.rct_clp_ptr
            ); {$endregion}

            {Drawing Of Spline Object Points-} {$region -fold}
            sln_pts_ptr:=Unaligned(@sln_pts[b]);
            for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
              begin
                if (not sel_var.is_point_selected[b+i]) then
                  Rectangle
                  (
                    Trunc(sln_pts_ptr^.x)+w_a_s_x,
                    Trunc(sln_pts_ptr^.y)+w_a_s_y,
                    bmp_dst_ptr,
                    bmp_dst_width,
                    bmp_dst_height,
                    rct_clp_ptr_^,
                    local_prop
                  );
                Inc(sln_pts_ptr);
              end; {$endregion}

          end;
      end;
end; {$endregion}
procedure TCurve.FilSplineRctEds   (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  w_a_s_x,w_a_s_y: integer;
  b0,b1          : boolean;
begin
  with rct_eds_img_arr[spline_ind],local_prop,obj_var,srf_var_ptr^ do
    if rct_eds_show then
      begin
        obj_arr_ptr:=@obj_arr[curve_inds_obj_arr[spline_ind]];
        if (not down_select_items_ptr^) then
          begin
            b0:=(obj_arr_ptr^.t_ind<low_lr_obj_cnt);
            b1:=(not b0);
            if lazy_repaint then
              FilSplineLazy (spline_ind,obj_arr_ptr,b0 and lazy_repaint_prev,b1 and (not lazy_repaint_prev))
            else
              FilSplineLazy (spline_ind,obj_arr_ptr,b0,b1);
            SplineRctEdsDraw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_clp_ptr);
            Exit;
          end;
        w_a_s_x:=Trunc(obj_arr_ptr^.world_axis_shift.x);
        w_a_s_y:=Trunc(obj_arr_ptr^.world_axis_shift.y);
        with rct_ent_2 do
          begin
            width :=Trunc(rct_ent.width );
            height:=Trunc(rct_ent.height);
            left  :=Trunc(rct_ent.left  )+w_a_s_x;
            top   :=Trunc(rct_ent.top   )+w_a_s_y;
            right :=Trunc(rct_ent.right )+w_a_s_x;
            bottom:=Trunc(rct_ent.bottom)+w_a_s_y;
          end;
        rct_vis:=ClippedRct(rct_wnd,rct_ent_2);
        with sprite_sheet_arr[rct_eds_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
          if (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^)) and (nt_pix_cnt<>0) then
            begin
              fast_image_data_ptr0:=@fast_image_data;
              //if lazy_repaint_prev and lazy_repaint then
                with fast_image_data_ptr0^ do
                  begin
                    bmp_src_rct_clp:=rct_vis;
                    SetRctPos       (rct_vis.left,
                                     rct_vis.top);
                    SetRctDst0     (fast_image_data_ptr0^);
                    if (pix_clp_type=3) then
                      Exit;
                    SetRctSrc      (fast_image_data_ptr0^);
                  end;
              if down_select_items_ptr^ then
                StrNTLowerBmpA     (fast_image_data_ptr0);
              fast_image_data_arr[0].monochrome_val:=fast_image_data.monochrome_val;
              SdrProc[sdr_proc_ind](rct_vis.left,
                                    rct_vis.top,
                                    fast_image_data_ptr0);
            end;
      end;
end; {$endregion}
procedure TCurve.FilSplineRctPts   (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  w_a_s_x,w_a_s_y: integer;
  b0,b1          : boolean;
begin
  with rct_pts_img_arr[spline_ind],local_prop,obj_var,srf_var_ptr^ do
    if rct_pts_show then
      begin
        obj_arr_ptr:=@obj_arr[curve_inds_obj_arr[spline_ind]];
        if (not down_select_items_ptr^) then
          begin
            b0:=(obj_arr_ptr^.t_ind<low_lr_obj_cnt);
            b1:=(not b0);
            if lazy_repaint then
              FilSplineLazy (spline_ind,obj_arr_ptr,b0 and lazy_repaint_prev,b1 and (not lazy_repaint_prev))
            else
              FilSplineLazy (spline_ind,obj_arr_ptr,b0,b1);
            SplineRctPtsDraw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_clp_ptr);
            Exit;
          end;
        w_a_s_x:=Trunc(obj_arr_ptr^.world_axis_shift.x);
        w_a_s_y:=Trunc(obj_arr_ptr^.world_axis_shift.y);
        with rct_ent_2 do
          begin
            width :=Trunc(rct_ent.width );
            height:=Trunc(rct_ent.height);
            left  :=Trunc(rct_ent.left  )+w_a_s_x;
            top   :=Trunc(rct_ent.top   )+w_a_s_y;
            right :=Trunc(rct_ent.right )+w_a_s_x;
            bottom:=Trunc(rct_ent.bottom)+w_a_s_y;
          end;
        rct_vis:=ClippedRct(rct_wnd,rct_ent_2);
        with sprite_sheet_arr[rct_pts_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
          if (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^)) and (nt_pix_cnt<>0) then
            begin
              fast_image_data_ptr0:=@fast_image_data;
              //if lazy_repaint_prev and lazy_repaint then
                with fast_image_data_ptr0^ do
                  begin
                    bmp_src_rct_clp:=rct_vis;
                    SetRctPos       (rct_vis.left,
                                     rct_vis.top);
                    SetRctDst0     (fast_image_data_ptr0^);
                    if (pix_clp_type=3) then
                      Exit;
                    SetRctSrc      (fast_image_data_ptr0^);
                  end;
              if down_select_items_ptr^ then
                StrNTLowerBmpA     (fast_image_data_ptr0);
              fast_image_data_arr[0].monochrome_val:=fast_image_data.monochrome_val;
              SdrProc[sdr_proc_ind](rct_vis.left,
                                    rct_vis.top,
                                    fast_image_data_ptr0);
            end;
      end;
end; {$endregion}
procedure TCurve.FilSplineEds      (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  w_a_s_x,w_a_s_y: integer;
  b0,b1          : boolean;
begin
  with eds_img_arr[spline_ind],local_prop,obj_var,srf_var_ptr^ do
    if eds_show then
      begin
        obj_arr_ptr:=@obj_arr[curve_inds_obj_arr[spline_ind]];
        if (not down_select_items_ptr^) then
          begin
            b0:=(obj_arr_ptr^.t_ind<low_lr_obj_cnt);
            b1:=(not b0);
            if lazy_repaint then
              begin
                FilSplineLazy   (spline_ind,obj_arr_ptr,b0 and lazy_repaint_prev,b1 and (not lazy_repaint_prev));
                if ((not hid_ln_elim) or (hid_ln_cnt=0)) then
                  SplineEds0Draw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_clp_ptr)
                else
                  SplineEds2Draw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_clp_ptr);
              end
            else
              begin
                FilSplineLazy(spline_ind,obj_arr_ptr,b0,b1);
                if ((not hid_ln_elim) or (hid_ln_cnt=0)) then
                  SplineEds0Draw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_clp_ptr)
                else
                  SplineEds2Draw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_clp_ptr);
              end;
            Exit;
          end;
        w_a_s_x:=Trunc(obj_arr_ptr^.world_axis_shift.x);
        w_a_s_y:=Trunc(obj_arr_ptr^.world_axis_shift.y);
        with rct_ent_2 do
          begin
            width :=Trunc(rct_ent.width );
            height:=Trunc(rct_ent.height);
            left  :=Trunc(rct_ent.left  )+w_a_s_x;
            top   :=Trunc(rct_ent.top   )+w_a_s_y;
            right :=Trunc(rct_ent.right )+w_a_s_x;
            bottom:=Trunc(rct_ent.bottom)+w_a_s_y;
          end;
        rct_vis:=ClippedRct(rct_wnd,rct_ent_2);
        with sprite_sheet_arr[eds_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
          if (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^)) and (nt_pix_cnt<>0) then
            begin
              fast_image_data_ptr0:=@fast_image_data;
              //if lazy_repaint_prev and lazy_repaint then
                with fast_image_data_ptr0^ do
                  begin
                    bmp_src_rct_clp:=rct_vis;
                    SetRctPos       (rct_vis.left,
                                     rct_vis.top);
                    SetRctDst0     (fast_image_data_ptr0^);
                    if (pix_clp_type=3) then
                      Exit;
                    SetRctSrc      (fast_image_data_ptr0^);
                  end;
              if down_select_items_ptr^ then
                StrNTLowerBmpA     (fast_image_data_ptr0);
              fast_image_data_arr[0].monochrome_val:=fast_image_data.monochrome_val;
              SdrProc[sdr_proc_ind](rct_vis.left,
                                    rct_vis.top,
                                    fast_image_data_ptr0);
            end;
      end;
end; {$endregion}
procedure TCurve.FilSplinePts      (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr    : PObjProp;
  w_a_s_x,w_a_s_y: integer;
  b0,b1          : boolean;
begin
  with pts_img_arr[spline_ind],local_prop,obj_var do
    if pts_show then
      begin
        obj_arr_ptr:=@obj_arr[curve_inds_obj_arr[spline_ind]];
        if (not down_select_items_ptr^) then
          begin
            b0:=(obj_arr_ptr^.t_ind<low_lr_obj_cnt);
            b1:=(not b0);
            if lazy_repaint then
              FilSplineLazy(spline_ind,obj_arr_ptr,b0 and lazy_repaint_prev,b1 and (not lazy_repaint_prev))
            else
              FilSplineLazy(spline_ind,obj_arr_ptr,b0,b1);
            SplinePts0Draw (spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_clp_ptr);
            Exit;
          end;
        w_a_s_x:=Trunc(obj_arr_ptr^.world_axis_shift.x);
        w_a_s_y:=Trunc(obj_arr_ptr^.world_axis_shift.y);
        with rct_ent_2 do
          begin
            width :=Trunc(rct_ent.width );
            height:=Trunc(rct_ent.height);
            left  :=Trunc(rct_ent.left  )+w_a_s_x;
            top   :=Trunc(rct_ent.top   )+w_a_s_y;
            right :=Trunc(rct_ent.right )+w_a_s_x;
            bottom:=Trunc(rct_ent.bottom)+w_a_s_y;
          end;
        rct_vis:=ClippedRct(rct_wnd,rct_ent_2);
        with sprite_sheet_arr[pts_ind_arr[spline_ind]],fast_image_data,fast_image_proc_var do
          if (not IsRct1OutOfRct2(rct_ent_2,rct_clp_ptr^)) and (nt_pix_cnt<>0) then
            begin
              fast_image_data_ptr0:=@fast_image_data;
              //if lazy_repaint_prev and lazy_repaint then
                with fast_image_data_ptr0^ do
                  begin
                    bmp_src_rct_clp:=rct_vis;
                    SetRctPos       (rct_vis.left,
                                     rct_vis.top);
                    SetRctDst0     (fast_image_data_ptr0^);
                    if (pix_clp_type=3) then
                      Exit;
                    SetRctSrc      (fast_image_data_ptr0^);
                  end;
              if down_select_items_ptr^ then
                StrNTLowerBmpA     (fast_image_data_ptr0);
              fast_image_data_arr[0].monochrome_val:=fast_image_data.monochrome_val;
              SdrProc[sdr_proc_ind](rct_vis.left,
                                    rct_vis.top,
                                    fast_image_data_ptr0);
            end;
      end;
end; {$endregion}
procedure TCurve.FilSplineObj      (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
{var
  obj_arr_ptr    : PObjProp;
  sln_pts_ptr    : PPtPosF;
  b,i            : integer;
  w_a_s_x,w_a_s_y: integer;}
begin
  if show_spline then
    begin
      if (has_sel_pts[spline_ind]=0) then
        begin
          FilSplineRctEds(spline_ind);
          FilSplineRctPts(spline_ind);
        end;
      FilSplineEds(spline_ind);
      FilSplinePts(spline_ind);
    end;

  {Test} {$region -fold}
  {with sprite_sheet_arr[pvt_var.local_axis_bmp_ind],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      b          :=partial_pts_sum[spline_ind];
      obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]]);
      sln_pts_ptr:=Unaligned(@sln_pts[b]);
      w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
      w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
      SetBkgnd
      (
        srf_var_ptr^.{srf_bmp_ptr}low_bmp_ptr,
        srf_var_ptr^.srf_bmp.width,
        srf_var_ptr^.srf_bmp.height,
        obj_arr_ptr^.rct_clp_ptr^
      );
      for i:=0 to sln_obj_pts_cnt[spline_ind]-1 do
        SdrProc[sdr_proc_ind](Trunc((sln_pts_ptr+i)^.x)+w_a_s_x-bmp_ftimg_width_origin >>1,
                              Trunc((sln_pts_ptr+i)^.y)+w_a_s_y-bmp_ftimg_height_origin>>1,
                              @fast_image_data);

    end;} {$endregion}

end; {$endregion}
procedure TCurve.FilSplineAll      (const start_ind,end_ind:TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j: integer;
begin
  if show_spline then
    for i:=0 to sln_obj_cnt-1 do
      begin
        j:=obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].t_ind;
        if (j>=start_ind) and (j<=end_ind) then
          FilSplineObj(i);
      end;
end; {$endregion}
procedure TCurve.MovSplineRctEds   (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SplineRctEdsDraw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_dst_ptr);
end; {$endregion}
procedure TCurve.MovSplineRctPts   (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SplineRctPtsDraw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_dst_ptr);
end; {$endregion}
procedure TCurve.MovSplineEds0     (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SplineEds0Draw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_dst_ptr);
end; {$endregion}
procedure TCurve.MovSplineEds1     (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SplineEds1Draw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_dst_ptr);
end; {$endregion}
procedure TCurve.MovSplineEds2     (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SplineEds2Draw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_dst_ptr);
end; {$endregion}
procedure TCurve.MovSplinePts0     (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SplinePts0Draw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_dst_ptr);
end; {$endregion}
procedure TCurve.MovSplinePts1     (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SplinePts1Draw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_dst_ptr);
end; {$endregion}
procedure TCurve.MovSplineObj      (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if show_spline then
    begin
      SplineRctEdsDraw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_dst_ptr);
      SplineRctPtsDraw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_dst_ptr);
      if (has_sel_pts[spline_ind]=0) then
        begin
          if ((not eds_img_arr[spline_ind].local_prop.hid_ln_elim) or (eds_img_arr[spline_ind].hid_ln_cnt=0)) then
            SplineEds0Draw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_dst_ptr)
          else
            SplineEds2Draw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_dst_ptr);
            SplinePts0Draw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_dst_ptr);
        end
      else
        begin
          SplineEds1Draw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_dst_ptr);
          SplinePts1Draw(spline_ind,obj_var.obj_arr[obj_var.curve_inds_obj_arr[spline_ind]].rct_dst_ptr);
        end;
    end;
end; {$endregion}
procedure TCurve.MovSplineAll      (const start_ind,end_ind:TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  if (not show_spline) then
    Exit;
  for i:=start_ind to end_ind do
    MovSplineObj(i);
end; {$endregion}
procedure TCurve.RepSplineRctEds   (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_eds_img_arr[spline_ind],local_prop,sprite_sheet_arr[rct_eds_ind_arr[spline_ind]],fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      ResNTValueArr(rct_eds_big_img.ln_arr1,
                    rct_eds_big_img.ln_arr_width);
    end;
end; {$endregion}
procedure TCurve.RepSplineRctPts   (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with rct_pts_img_arr[spline_ind],local_prop,sprite_sheet_arr[rct_pts_ind_arr[spline_ind]],fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      ResNTValueArr(rct_pts_big_img.ln_arr1,
                    rct_pts_big_img.ln_arr_width);
    end;
end; {$endregion}
procedure TCurve.RepSplineEds      (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with eds_img_arr[spline_ind],local_prop,sprite_sheet_arr[eds_ind_arr[spline_ind]],fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      ResNTValueArr(eds_big_img.ln_arr1,
                    eds_big_img.ln_arr_width);
    end;
end; {$endregion}
procedure TCurve.RepSplinePts      (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pts_img_arr[spline_ind],local_prop,sprite_sheet_arr[pts_ind_arr[spline_ind]],fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      ResNTValueArr(pts_big_img.ln_arr1,
                    pts_big_img.ln_arr_width);
    end;
end; {$endregion}
procedure TCurve.RndSplineCol      (var   local_prop       :TCurveProp; var col,col_inv:TColor; var col_ptr:PInteger; const btn:TSpeedButton);                               {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with local_prop do
   begin
     col     :=Random($7FFFFFFF);
     col_inv :=SetColorInv(col);
     col_ptr :=@btn.Color;
     col_ptr^:=col;
     btn.Repaint;
   end;
end; {$endregion}
procedure TCurve.RndSplineObj      (const pt               :TPtPos; const w,h:TColor);                                                                                       {$ifdef Linux}[local];{$endif} {$region -fold}
var
  sln_pts_add_ptr: PPtPosF;
  i,w_,h_        : integer;
  rnd            : boolean;
begin
  Randomize;
  w_             :=pt.x-w>>1;
  h_             :=pt.y-h>>1;
  sln_pts_cnt_add:=global_prop.pts_cnt_val;
  Inc(sln_pts_cnt,sln_pts_cnt_add);
  SetLength(sln_pts_add,0);
  SetLength(sln_pts_add,sln_pts_cnt_add);
  sln_pts_add_ptr:=Unaligned(@sln_pts_add[0]);



  {(changed)}for i:=0 to sln_pts_cnt_add-1 do
    begin
      (sln_pts_add_ptr+i)^.x:=w_+Random(w);
      (sln_pts_add_ptr+i)^.y:=h_+Random(h);
    end;
  {for i:=0 to Trunc(sln_pts_cnt_add/2)-1 do
    begin
      sln_pts_add[i<<1+0].x:=w_;
      sln_pts_add[i<<1+0].y:=h_;
      sln_pts_add[i<<1+1].x:=w_+w;
      sln_pts_add[i<<1+1].y:=h_+i;
    end;}



  {for i:=0 to sln_pts_cnt_add-1 do
    begin
      (sln_pts_add_ptr+i)^.x:=w_+w>>1{Random(w)};
      (sln_pts_add_ptr+i)^.y:=h_+h>>1{Random(h)};
    end;}

  {for i:=0 to Trunc(sln_pts_cnt_add/2)-1 do
    begin
      sln_pts_add[i<<1+0].x:=w_+w;
      sln_pts_add[i<<1+0].y:=h_;
      sln_pts_add[i<<1+1].x:=w_;
      sln_pts_add[i<<1+1].y:=h_+Random(h);
    end;}

  {for i:=0 to Trunc(sln_pts_cnt_add/2)-1 do
    begin
      sln_pts_add[i<<1+0].x:=w_     +Random(10);
      sln_pts_add[i<<1+0].y:=h_     +Random(h );
      sln_pts_add[i<<1+1].x:=w_+w-10+Random(10);
      sln_pts_add[i<<1+1].y:=h_     +Random(h );
    end;
  if Odd(sln_pts_cnt_add) then
    begin
      sln_pts_add[sln_pts_cnt_add-1].x:=w_+w-10+Random(10);
      sln_pts_add[sln_pts_cnt_add-1].y:=h_     +Random(h );
    end;}

  {for i:=0 to Trunc(sln_pts_cnt_add/2)-1 do
    begin
      sln_pts_add[i<<1+0].x:=w_     +Random(w );
      sln_pts_add[i<<1+0].y:=h_     +Random(10);
      sln_pts_add[i<<1+1].x:=w_     +Random(w );
      sln_pts_add[i<<1+1].y:=h_+h-10+Random(10);
    end;
  if Odd(sln_pts_cnt_add) then
    begin
      sln_pts_add[sln_pts_cnt_add-1].x:=w_     +Random(w );
      sln_pts_add[sln_pts_cnt_add-1].y:=h_+h-10+Random(10);
    end;}

  {for i:=0 to Trunc(sln_pts_cnt_add/2)-1 do
    begin
      rnd:=Boolean(Random(2));
      if rnd then
        begin
          sln_pts_add[i<<1+0].x:=w_+Random(w);
          sln_pts_add[i<<1+0].y:=h_+Random(h);
          sln_pts_add[i<<1+1].x:=w_+Random(w);
          sln_pts_add[i<<1+1].y:=sln_pts_add[i<<1+0].y;
        end
      else
        begin
          sln_pts_add[i<<1+0].x:=w_+Random(w);
          sln_pts_add[i<<1+0].y:=h_+Random(h);
          sln_pts_add[i<<1+1].x:=sln_pts_add[i<<1+0].x;
          sln_pts_add[i<<1+1].y:=h_+Random(h);
        end;
    end;}

  {for i:=0 to Trunc(sln_pts_cnt_add/2)-1 do
    begin
      sln_pts_add[i<<1+0].x:=w_+Random(w);
      sln_pts_add[i<<1+0].y:=h_+Random(h);
      sln_pts_add[i<<1+1].x:=w_+Random(w);
      sln_pts_add[i<<1+1].y:=sln_pts_add[i<<1+0].y;
    end;}

  {for i:=0 to Trunc(sln_pts_cnt_add/2)-1 do
    begin
      sln_pts_add[i<<1+0].x:=w_+Random(w);
      sln_pts_add[i<<1+0].y:=h_+Random(h);
      sln_pts_add[i<<1+1].x:=sln_pts_add[i<<1+0].x;
      sln_pts_add[i<<1+1].y:=h_+Random(h);
    end;}

  {for i:=0 to Trunc(sln_pts_cnt_add/2)-1 do
    begin
      sln_pts_add[i<<1+0].x:=w_;
      sln_pts_add[i<<1+0].y:=h_;
      sln_pts_add[i<<1+1].x:=w_+w;
      sln_pts_add[i<<1+1].y:=h_+h;
    end;}
end; {$endregion}
procedure TCurve.SmpSplinePts      (const spline_ind       :TColor);                                                                                                         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  k1,k2        : double;
  i,m1,m2,m3,m4: integer;
begin
end; {$endregion}
procedure TCurve.FmlSplineInit;                                                                                                                                              {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  FmlSplineObj[0]:=@Cycloid;
  FmlSplineObj[1]:=@Epicycloid;
  FmlSplineObj[2]:=@Rose;
  FmlSplineObj[3]:=@Spiral;
  FmlSplineObj[4]:=@Superellipse;
end; {$endregion}
procedure TCurve.FmlSplinePrev     (const fml_pts_cnt      :TColor; const ln_arr2_clear:boolean=False);                                                                      {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_out   : TPtRect;
  color_info: TColorInfo;
  eds_col_  : TColor;
  i         : integer;
begin
  if down_play_anim_ptr^ then
    Exit;
  with srf_var_ptr^,global_prop do
    begin
      sln_pts_cnt_add:=fml_pts_cnt;
      with PtRct(tex_bmp_rct_pts) do
        if (sln_pts_cnt_add<>0) then
          FmlSplineObj[cur_tlt_dwn_btn_ind](Trunc(world_axis.x+world_axis_shift.x),
                                            Trunc(world_axis.y+world_axis_shift.y));
      sln_pts_cnt_add:=0;
      if ln_arr2_clear then
        begin
          BmpToBmp2(srf_bmp_ptr ,low_bmp_ptr ,srf_bmp.width,low_bmp2.width,inn_wnd_rct,inn_wnd_mrg);
          BmpToBmp2(low_bmp_ptr ,low_bmp2_ptr,srf_bmp.width,low_bmp2.width,inn_wnd_rct,inn_wnd_mrg);
          BmpToBmp2(low_bmp2_ptr,srf_bmp_ptr ,srf_bmp.width,low_bmp2.width,inn_wnd_rct,inn_wnd_mrg);
        end;
      {color_info:=Default(TColorInfo);
      SetColorInfo(SetColorInv(clRed),color_info);}
      with inn_wnd_rct do
        rct_out:=PtRct(left,top,right-1,bottom-1);
      with sel_var.outer_subgraph_img do
        begin
          ArrClr(ln_arr0,rct_out,ln_arr_width);
          if ln_arr2_clear then
            ArrClr(ln_arr2,rct_out);
          ln_arr0_ptr:=Unaligned(@ln_arr0[0]);
          for i:=0 to fml_pts_cnt-2 do
            ClippedLine2
            (
              Trunc(fml_pts[i+0].x),
              Trunc(fml_pts[i+0].y),
              Trunc(fml_pts[i+1].x),
              Trunc(fml_pts[i+1].y),
              rct_out,
              Unaligned(@LinePHL00),
              Unaligned(@LineSHL00),
              Unaligned(@LineSVL00),
              Unaligned(@LinePHL01),
              Unaligned(@LinePHL02)
            );
            {ClippedLine1
            (
              Trunc(fml_pts[i+0].x),
              Trunc(fml_pts[i+0].y),
              Trunc(fml_pts[i+1].x),
              Trunc(fml_pts[i+1].y),
              rct_out,
              Unaligned(@LineSME),
              Nil,
              Nil,
              Nil
            );}
          if cnc_ends then
            ClippedLine2
            (
              Trunc(fml_pts[0            ].x),
              Trunc(fml_pts[0            ].y),
              Trunc(fml_pts[fml_pts_cnt-1].x),
              Trunc(fml_pts[fml_pts_cnt-1].y),
              rct_out,
              Unaligned(@LinePHL00),
              Unaligned(@LineSHL00),
              Unaligned(@LineSVL00),
              Unaligned(@LinePHL01),
              Unaligned(@LinePHL02)
            );
            {ClippedLine1
            (
              Trunc(fml_pts[0            ].x),
              Trunc(fml_pts[0            ].y),
              Trunc(fml_pts[fml_pts_cnt-1].x),
              Trunc(fml_pts[fml_pts_cnt-1].y),
              rct_out,
              Unaligned(@LineSME),
              Nil,
              Nil,
              Nil
            );}
          eds_col_:=eds_col;
          eds_col :=clRed;
          FilBuffer(rct_out);
          eds_col :=eds_col_;
        end;
      {LineABCG
      (
        fml_pts,
        0,
        fml_pts_cnt-1,
        srf_bmp_ptr,
        srf_bmp.width,
        color_info,
        rct,
        PtPos(0,0),
        cnc_ends and (fml_pts_cnt>2)
      );}
      if show_collider then
        begin

          with sel_var.inner_subgraph_img do
            begin
              ArrClr(ln_arr0,rct_out,ln_arr_width);
              if ln_arr2_clear then
                ArrClr(ln_arr2,rct_out);
              ln_arr0_ptr:=Unaligned(@ln_arr0[0]);
              for i:=0 to fml_pts_cnt-1 do
                CircleC
                (
                  Trunc(fml_pts[i].x),
                  Trunc(fml_pts[i].y),
                  10,
                  ln_arr0_ptr,
                  ln_arr_width,
                  rct_out,
                  1
                );
              eds_col_:=eds_col;
              eds_col :=clRed;
              FilBuffer(rct_out);
              eds_col :=eds_col_;
            end;

          {SetColorInfo(clBlue,color_info);
          LineABCE
          (
            fml_pts,
            0,
            fml_pts_cnt-1,
            srf_bmp_ptr,
            srf_bmp.width,
            color_info,
            rct_out,
            PtPos(0,0),
            10,
            cnc_ends and (fml_pts_cnt>2)
          );}

        end;
      if show_world_axis then
        WorldAxisDraw;
      if (not down_play_anim_ptr^) then
        ResInnWndToBmp;
      BmpToBmp2(low_bmp_ptr,srf_bmp_ptr,srf_bmp.width,low_bmp2.width,inn_wnd_rct,inn_wnd_mrg);
    end;
end; {$endregion}
procedure TCurve.Cycloid           (const x,y              :integer);                                                                                                        {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fml_pts_ptr: PPtPosF;
  dt         : double;
  j          : integer;
  n          : integer=000;
  t          : double =0.0;
  a          : double =0.0;
begin
  with global_prop do
    begin
      case cycloid_dir_x of
        mdLeft :
          begin
            case cycloid_dir_y of
              mdUp:
                begin
                  a:=-cycloid_loop_rad/pi;
                  n:=(cycloid_loop_cnt<<1);
                end;
              mdDown:
                begin
                  a:=  cycloid_loop_rad/pi;
                  n:=-(cycloid_loop_cnt<<1);
                end;
            end;
          end;
        mdRight:
          begin
            case cycloid_dir_y of
              mdUp:
                begin
                  a:=- cycloid_loop_rad/pi;
                  n:=-(cycloid_loop_cnt<<1);
                end;
              mdDown:
                begin
                  a:= cycloid_loop_rad/pi;
                  n:=(cycloid_loop_cnt<<1);
                end;
            end;
          end;
      end;
      dt         :=n*pi/sln_pts_cnt_add;
      fml_pts_ptr:=Unaligned(@fml_pts[0]);
      for j:=0 to sln_pts_cnt_add-1 do
        begin
          fml_pts_ptr^.x:=x+a*(t-Sin(t*cycloid_curvature)){x+a*Sin(t) - circle};
          fml_pts_ptr^.y:=y+a*(1-Cos(t*cycloid_curvature)){y+a*Cos(t) - circle};
          Inc(fml_pts_ptr);
          t+=dt;
        end;
    end;
end; {$endregion}
procedure TCurve.Epicycloid        (const x,y              :integer);                                                                                                        {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fml_pts_ptr     : PPtPosF;
  t0,t1,t2,t3,dt,k: double;
  j               : integer;
begin
  with global_prop do
    begin
      dt         :=epicycloid_angle*FULL_ROT/sln_pts_cnt_add;
      k          :=epicycloid_petals_cnt+1;
      case fml_type of
        (sfEpicycloid ): k:=epicycloid_petals_cnt+1;
        (sfHypocycloid): k:=epicycloid_petals_cnt-1;
      end;
      t0         :=epicycloid_rad*0.1;
      t1         :=epicycloid_rot;
      t2         :=epicycloid_rot;
      t3         :=dt*k;
      fml_pts_ptr:=Unaligned(@fml_pts[0]);
      case fml_type of
        (sfEpicycloid):
          for j:=0 to sln_pts_cnt_add-1 do
            begin
              fml_pts_ptr^.x:=x+t0*(k*cos(t1)-Cos(t2));
              fml_pts_ptr^.y:=y+t0*(k*sin(t1)-Sin(t2));
              Inc(fml_pts_ptr);
              t1+=dt;
              t2+=t3;
            end;
        (sfHypocycloid):
          for j:=0 to sln_pts_cnt_add-1 do
            begin
              fml_pts_ptr^.x:=x+t0*(k*cos(t1)+Cos(t2));{t0*((100-64)*Cos(t1)+k*Cos((100-64/64)*t1))}
              fml_pts_ptr^.y:=y+t0*(k*sin(t1)-Sin(t2));{t0*((100-64)*Sin(t1)-k*Sin((100-64/64)*t1))}
              Inc(fml_pts_ptr);
              t1+=dt;
              t2+=t3;
            end;
      end;
    end;
end; {$endregion}
procedure TCurve.Rose              (const x,y              :integer);                                                                                                        {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fml_pts_ptr: PPtPosF;
  t0,t1,dt   : double;
  j          : integer;
begin
  with global_prop do
    begin
      dt         :=rose_angle*FULL_ROT/sln_pts_cnt_add;
      t0         :=rose_rad;
      t1         :=rose_rot;
      fml_pts_ptr:=Unaligned(@fml_pts[0]);
      if (not rose_mobius_grid) then
        for j:=0 to sln_pts_cnt_add-1 do
          begin
            fml_pts_ptr^.x:=x+t0*Sin(rose_petals_cnt*t1)*Cos(t1);
            fml_pts_ptr^.y:=y+t0*Sin(rose_petals_cnt*t1)*Sin(t1);
            Inc(fml_pts_ptr);
            t1+=dt;
          end
      else
        for j:=0 to sln_pts_cnt_add-1 do
          begin
            fml_pts_ptr^.x:=x+t0*Cos(rose_petals_cnt*t1)*Cos(t1);
            fml_pts_ptr^.y:=y+t0*Sin(rose_petals_cnt*t1)*Sin(t1);
            Inc(fml_pts_ptr);
            t1+=dt;
          end;
    end;
end; {$endregion}
procedure TCurve.Spiral            (const x,y              :integer);                                                                                                        {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fml_pts_ptr: PPtPosF;
  t0,t1,t2,dt: double;
  j          : integer;
begin
  with global_prop do
    begin
      dt         :=spiral_angle*FULL_ROT/sln_pts_cnt_add;
      t0         :=spiral_rad*0.1;
      t1         :=spiral_rot;
      fml_pts_ptr:=Unaligned(@fml_pts[0]);
      if (spiral_coil_step=1) then
        for j:=0 to sln_pts_cnt_add-1 do
          begin
            fml_pts_ptr^.x:=x+t0*t1*cos(t1);
            fml_pts_ptr^.y:=y+t0*t1*sin(t1);
            Inc(fml_pts_ptr);
            t1+=dt;
          end
      else
        begin
          if (spiral_coil_step<=0) and (spiral_rot=0) then
            t1:=dt;
          for j:=0 to sln_pts_cnt_add-1 do
            begin
              t2            :=Exp(spiral_coil_step*Ln(t1));
              fml_pts_ptr^.x:=x+t0*t2*cos(t1);
              fml_pts_ptr^.y:=y+t0*t2*sin(t1);
              Inc(fml_pts_ptr);
              t1+=dt;
            end;
        end;
    end;
end; {$endregion}
procedure TCurve.Superellipse      (const x,y              :integer);                                                                                                        {$ifdef Linux}[local];{$endif} {$region -fold}
var
  fml_pts_ptr: PPtPosF;
  t0,t1,dt   : double;
  j          : integer;
begin
  with global_prop do
    begin
      dt         :=superellipse_angle*FULL_ROT/sln_pts_cnt_add;
      t0         :=superellipse_rad;
      t1         :=superellipse_rot;
      fml_pts_ptr:=Unaligned(@fml_pts[0]);
      for j:=0 to sln_pts_cnt_add-1 do
        begin
          fml_pts_ptr^.x:=x+t0*Exp(superellipse_curvature0*Abs(Cos(t1)))*superellipse_curvature2*sign(Cos(t1));
          fml_pts_ptr^.y:=y+t0*Exp(superellipse_curvature1*Abs(Sin(t1)))*superellipse_curvature3*sign(Sin(t1));
          Inc(fml_pts_ptr);
          t1+=dt;
        end;
    end;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_SplineClick                                          (sender:TObject); {$region -fold}
begin
  SB_Draw_Buttons_Button_Bkgnd.Left   :=SB_Spline.Left;
  SB_Draw_Buttons_Button_Bkgnd.Visible:=SB_Spline.Down;
  DrawingPanelsSetVisibility1(down_spline_ptr,P_Draw_Buttons,P_Spline,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_spline_ptr^) then
    Exit;
  AddDocContent(RM_Description,curve_doc_str_arr,curve_doc_font_arr,0);
end; {$endregion}
procedure TF_MainForm.PM_Post_Processing_Add_EffectClose                      (sender:TObject); {$region -fold}
begin
  PM_Post_Processing_Add_Effect.Tag:=0;
end; {$endregion}
procedure TF_MainForm.MI_MonochromeClick                                      (sender:TObject); {$region -fold}
var
  s: string;
begin
  s:=GetEnumName(TypeInfo(TDrawingStyle),Ord((TMenuItem(sender).MenuIndex)));
  Delete(s,1,2);
  s:=' '+s;
  case PM_Post_Processing_Add_Effect.Tag of
    1: L_Spline_Edges_Post_Processing_Add_Effect .Caption:=s;
    2: L_Spline_Points_Post_Processing_Add_Effect.Caption:=s;
  end;
end; {$endregion}
procedure TF_MainForm.AddFX(sb_add_fx:TScrollBox; cb_fx_stl_src:TComboBox; var cb_fx_stl_dst:TComboBox; fx_name:TLabel; fx_val:TSpinEdit; HeaderMouseEnter,HeaderMouseLeave,SplineFXComboBoxClick:TProc14; var sln_fx_pnls_cnt:TColor; var sln_fx_pnls:PPanelArr; var sln_fx_arr:TFX2Arr); {$region -fold}
var
  s: string;
begin
  cb_fx_stl_dst                                        :=TComboBox.Create(Self);
  with cb_fx_stl_dst do
    begin
      Inc(sln_fx_pnls_cnt);
      Parent                                           := sb_add_fx;
      AnchorParallel(akLeft ,2,                           sb_add_fx);
      AnchorParallel(akRight,2,                           sb_add_fx);
      Font.Size                                        := cb_fx_stl_src.Font.Size;
      Color                                            := cb_fx_stl_src.Color;
      Top                                              :=(cb_fx_stl_src.Height+2)*sln_fx_pnls_cnt-
                                                          cb_fx_stl_src.Height;
      ItemHeight                                       := cb_fx_stl_src.ItemHeight;
      Items                                            := cb_fx_stl_src.Items;
      Style                                            :=csDropDownList;
      s                                                :=fx_name.Caption;
      Delete(s,1,1);
      ItemIndex                                        :=GetEnumValue(TypeInfo(TDrawingStyle),'ds'+s){1+Random(Ord(High(TDrawingStyle))-1)};
      sb_add_fx.VertScrollBar.Range                    :=Top-
      cb_fx_stl_src.Height-6;
      cb_fx_stl_dst.OnClick                            :=SplineFXComboBoxClick;
      cb_fx_stl_dst.OnMouseEnter                       :=HeaderMouseEnter;
      cb_fx_stl_dst.OnMouseLeave                       :=HeaderMouseLeave;
      SetLength(sln_fx_pnls,
         Length(sln_fx_pnls)+1);
                sln_fx_pnls
        [Length(sln_fx_pnls)-1]                        :=
      @cb_fx_stl_dst;
       cb_fx_stl_dst.Tag                               :=
         Length(sln_fx_pnls)-1;
      SetLength(sln_fx_arr,
         Length(sln_fx_arr)+1);
                sln_fx_arr
        [Length(sln_fx_arr)-1].nt_fx_prop.cfx_pow0     :=fx_val.Value;
                sln_fx_arr
        [Length(sln_fx_arr)-1].nt_fx_prop.is_fx_visible:=True;
                sln_fx_arr
        [Length(sln_fx_arr)-1].pt_fx_prop.cfx_pow0     :=fx_val.Value;
                sln_fx_arr
        [Length(sln_fx_arr)-1].pt_fx_prop.is_fx_visible:=True;
    end;
end; {$endregion}
{Edges-------}
procedure TF_MainForm.SB_Spline_Edges_ShowClick                               (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Edges_Show,sln_var.global_prop.eds_show);
end; {$endregion}
procedure TF_MainForm.P_Spline_Edges_HeaderClick                              (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Edges_Settings,Shape11);
  if P_Spline_Edges_Settings.Height =P_Spline_Edges_Settings.Constraints.MaxHeight then
     P_Spline_Edges_Settings.Height:=P_Spline_Edges_Shape_Settings.Top+P_Spline_Edges_Shape_Settings.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Edges_HeaderMouseEnter                         (sender:TObject); {$region -fold}
begin
  P_Spline_Edges_Header  .Color:=HighLightLimit(P_Spline_Edges_Header  .Color,16);
  P_Spline_Edges_Settings.Color:=HighLightLimit(P_Spline_Edges_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Edges_HeaderMouseLeave                         (sender:TObject); {$region -fold}
begin
  P_Spline_Edges_Header  .Color:=Darken2(P_Spline_Edges_Header  .Color,16);
  P_Spline_Edges_Settings.Color:=Darken2(P_Spline_Edges_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Edges_Post_Processing_HeaderClick              (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Edges_Post_Processing_Settings,Shape15);
  P_Spline_Edges_Settings.Height:=P_Spline_Edges_Shape_Settings.Top+P_Spline_Edges_Shape_Settings.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Edges_Post_Processing_HeaderMouseEnter         (sender:TObject); {$region -fold}
begin
  P_Spline_Edges_Post_Processing_Header  .Color:=HighLightLimit(P_Spline_Edges_Post_Processing_Header  .Color,16);
  P_Spline_Edges_Post_Processing_Settings.Color:=HighLightLimit(P_Spline_Edges_Post_Processing_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Edges_Post_Processing_HeaderMouseLeave         (sender:TObject); {$region -fold}
begin
  P_Spline_Edges_Post_Processing_Header  .Color:=Darken2(P_Spline_Edges_Post_Processing_Header  .Color,16);
  P_Spline_Edges_Post_Processing_Settings.Color:=Darken2(P_Spline_Edges_Post_Processing_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.SplineEdsFXComboBoxClick                                (sender:TObject); {$region -fold}
begin
  CB_Spline_Edges_Post_Processing_Style_Add_Effect       :=sender as TComboBox;
  SE_Spline_Edges_Post_Processing_Effect_Strength.Enabled:=CB_Spline_Edges_Post_Processing_Style_Add_Effect.ItemIndex in [1..15];
  SB_Spline_Edges_Post_Processing_Color          .Enabled:=CB_Spline_Edges_Post_Processing_Style_Add_Effect.ItemIndex in [0..02];
  SB_Spline_Edges_Post_Processing_Color_Random   .Enabled:=CB_Spline_Edges_Post_Processing_Style_Add_Effect.ItemIndex in [0..02];
  SB_Spline_Edges_Post_Processing_Color_FallOff  .Enabled:=CB_Spline_Edges_Post_Processing_Style_Add_Effect.ItemIndex in [0..02];
end; {$endregion}
procedure TF_MainForm.SplineEdsFXComboBoxSelect                               (sender:TObject); {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.BB_Spline_Edges_Post_Processing_Add_EffectClick         (sender:TObject); {$region -fold}
begin
  AddFX
  (
    SB_Spline_Edges_Post_Processing_Add_Effect,
    CB_Spline_Edges_Post_Processing_Style_Add_Effect,
    CB_Spline_Edges_Post_Processing_Style,
     L_Spline_Edges_Post_Processing_Add_Effect,
    SE_Spline_Edges_Post_Processing_Effect_Strength,
    @P_Spline_Edges_Post_Processing_HeaderMouseEnter,
    @P_Spline_Edges_Post_Processing_HeaderMouseLeave,
    @SplineEdsFXComboBoxClick,
    sln_eds_fx_pnls_cnt,
    sln_eds_fx_pnls,
    sln_eds_fx_arr
  );
end; {$endregion}
procedure TF_MainForm.L_Spline_Edges_Post_Processing_Add_EffectClick          (sender:TObject); {$region -fold}
begin
  PM_Post_Processing_Add_Effect.PopUp;
  PM_Post_Processing_Add_Effect.Tag:=1;
end; {$endregion}
procedure TF_MainForm.P_Spline_Edges_Post_Processing_Add_EffectMouseEnter     (sender:TObject); {$region -fold}
begin
  P_Spline_Edges_Post_Processing_Add_Effect.Color:=HighLightLimit(P_Spline_Edges_Post_Processing_Add_Effect.Color,16);
  L_Spline_Edges_Post_Processing_Add_Effect.Color:=HighLightLimit(L_Spline_Edges_Post_Processing_Add_Effect.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Edges_Post_Processing_Add_EffectMouseLeave     (sender:TObject); {$region -fold}
begin
  P_Spline_Edges_Post_Processing_Add_Effect.Color:=Darken2(P_Spline_Edges_Post_Processing_Add_Effect.Color,16);
  L_Spline_Edges_Post_Processing_Add_Effect.Color:=Darken2(L_Spline_Edges_Post_Processing_Add_Effect.Color,16);
end; {$endregion}
procedure TF_MainForm.CB_Spline_Edges_Post_Processing_StyleSelect             (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.eds_bld_stl:=TDrawingStyle(CB_Spline_Edges_Post_Processing_Style.ItemIndex);
end; {$endregion}
procedure TF_MainForm.SE_Spline_Edges_Post_Processing_Effect_StrengthChange   (sender:TObject); {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.SB_Spline_Edges_Post_Processing_ColorClick              (sender:TObject); {$region -fold}
begin
  CD_Select_Color.Color:=SB_Spline_Edges_Post_Processing_Color.Color;
  CD_Select_Color.Execute;
  with sln_var.global_prop do
    begin
      eds_col             :=CD_Select_Color.Color;
      eds_col_inv         :=SetColorInv(eds_col);
      eds_col_fall_off_inc:=0;
    end;
  SB_Spline_Edges_Post_Processing_Color.Color:=CD_Select_Color.Color;
  SB_Spline_Edges_Post_Processing_Color.Down :=False;
end; {$endregion}
procedure TF_MainForm.SB_Spline_Edges_Post_Processing_Color_RandomClick       (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Edges_Post_Processing_Color_Random,sln_var.global_prop.eds_col_rnd);
end; {$endregion}
procedure TF_MainForm.SB_Spline_Edges_Post_Processing_Color_FallOffClick      (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Edges_Post_Processing_Color_FallOff,sln_var.global_prop.eds_col_fall_off);
end; {$endregion}
procedure TF_MainForm.SB_Spline_Edges_Show_BoundsClick                        (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Edges_Show_Bounds,sln_var.global_prop.rct_eds_show);
end; {$endregion}
procedure TF_MainForm.P_Spline_Edges_Bounds_HeaderClick                       (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Edges_Bounds_Settings,Shape16);
  P_Spline_Edges_Settings.Height:=P_Spline_Edges_Shape_Settings.Top+P_Spline_Edges_Shape_Settings.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Edges_Bounds_HeaderMouseEnter                  (sender:TObject); {$region -fold}
begin
  P_Spline_Edges_Bounds_Header  .Color:=HighLightLimit(P_Spline_Edges_Bounds_Header  .Color,16);
  P_Spline_Edges_Bounds_Settings.Color:=HighLightLimit(P_Spline_Edges_Bounds_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Edges_Bounds_HeaderMouseLeave                  (sender:TObject); {$region -fold}
begin
  P_Spline_Edges_Bounds_Header  .Color:=Darken2(P_Spline_Edges_Bounds_Header  .Color,16);
  P_Spline_Edges_Bounds_Settings.Color:=Darken2(P_Spline_Edges_Bounds_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.CB_Spline_Edges_Bounds_StyleSelect                      (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.rct_eds_bld_stl:=TDrawingStyle(CB_Spline_Edges_Bounds_Style.ItemIndex);
end; {$endregion}
procedure TF_MainForm.SE_Spline_Edges_Bounds_Effect_StrengthChange            (sender:TObject); {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.SB_Spline_Edges_Bounds_ColorClick                       (sender:TObject); {$region -fold}
begin
  CD_Select_Color.Color:=SB_Spline_Edges_Bounds_Color.Color;
  CD_Select_Color.Execute;
  with sln_var.global_prop do
    begin
      rct_eds_col    :=CD_Select_Color.Color;
      rct_eds_col_inv:=SetColorInv(rct_eds_col);
    end;
  SB_Spline_Edges_Bounds_Color.Color:=CD_Select_Color.Color;
  SB_Spline_Edges_Bounds_Color.Down :=False;
end; {$endregion}
procedure TF_MainForm.SB_Spline_Edges_Bounds_Color_RandomClick                (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Edges_Bounds_Color_Random,sln_var.global_prop.rct_eds_col_rnd);
end; {$endregion}
procedure TF_MainForm.SB_Spline_Edges_Bounds_Color_FallOffClick               (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Edges_Bounds_Color_FallOff,sln_var.global_prop.rct_eds_col_fall_off);
end; {$endregion}
procedure TF_MainForm.P_Spline_Edges_Shape_HeaderClick                        (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Edges_Shape_Settings,Shape17);
  P_Spline_Edges_Settings.Height:=P_Spline_Edges_Shape_Settings.Top+P_Spline_Edges_Shape_Settings.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Edges_Shape_HeaderMouseEnter                   (sender:TObject); {$region -fold}
begin
  P_Spline_Edges_Shape_Header  .Color:=HighLightLimit(P_Spline_Edges_Shape_Header  .Color,16);
  P_Spline_Edges_Shape_Settings.Color:=HighLightLimit(P_Spline_Edges_Shape_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Edges_Shape_HeaderMouseLeave                   (sender:TObject); {$region -fold}
begin
  P_Spline_Edges_Shape_Header  .Color:=Darken2(P_Spline_Edges_Shape_Header  .Color,16);
  P_Spline_Edges_Shape_Settings.Color:=Darken2(P_Spline_Edges_Shape_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.CB_Spline_Edges_ShapeSelect                             (sender:TObject); {$region -fold}
begin
  case CB_Spline_Edges_Shape.ItemIndex of
    0:
      begin
        L_Spline_Edges_Width         .Enabled:=True;
        SE_Spline_Edges_Width        .Enabled:=True;
        L_Spline_Edges_Dash_Length   .Enabled:=False;
        SE_Spline_Edges_Dash_Length  .Enabled:=False;
        L_Spline_Edges_Points_Radius .Enabled:=False;
        SE_Spline_Edges_Points_Radius.Enabled:=False;
      end;
    1:
      begin
        L_Spline_Edges_Width         .Enabled:=True;
        SE_Spline_Edges_Width        .Enabled:=True;
        L_Spline_Edges_Dash_Length   .Enabled:=True;
        SE_Spline_Edges_Dash_Length  .Enabled:=True;
        L_Spline_Edges_Points_Radius .Enabled:=False;
        SE_Spline_Edges_Points_Radius.Enabled:=False;
      end;
    2:
      begin
        L_Spline_Edges_Width         .Enabled:=False;
        SE_Spline_Edges_Width        .Enabled:=False;
        L_Spline_Edges_Dash_Length   .Enabled:=False;
        SE_Spline_Edges_Dash_Length  .Enabled:=False;
        L_Spline_Edges_Points_Radius .Enabled:=True;
        SE_Spline_Edges_Points_Radius.Enabled:=True;
      end;
  end;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Edges_WidthChange                             (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.eds_width:=SE_Spline_Edges_Width.value;
  SetEdsWidth(sln_var.global_prop);
end; {$endregion}
procedure TF_MainForm.CB_Spline_Edges_Anti_AliasingChange                     (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.eds_aa:=not sln_var.global_prop.eds_aa;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Connect_EndsChange                            (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.cnc_ends:=not sln_var.global_prop.cnc_ends;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Invert_OrderChange                            (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_ord_inv:=not sln_var.global_prop.pts_ord_inv;
end; {$endregion}
{Points------}
procedure TF_MainForm.SB_Spline_Points_ShowClick                              (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Points_Show,sln_var.global_prop.pts_show);
end; {$endregion}
procedure TF_MainForm.P_Spline_Points_HeaderClick                             (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Points_Settings,Shape10);
  if P_Spline_Points_Settings.Height =P_Spline_Points_Settings.Constraints.MaxHeight then
     P_Spline_Points_Settings.Height:=P_Spline_Points_Shape_Settings.Top+P_Spline_Points_Shape_Settings.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Points_HeaderMouseEnter                        (sender:TObject); {$region -fold}
begin
  P_Spline_Points_Header  .Color:=HighLightLimit(P_Spline_Points_Header  .Color,16);
  P_Spline_Points_Settings.Color:=HighLightLimit(P_Spline_Points_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Points_HeaderMouseLeave                        (sender:TObject); {$region -fold}
begin
  P_Spline_Points_Header  .Color:=Darken2(P_Spline_Points_Header  .Color,16);
  P_Spline_Points_Settings.Color:=Darken2(P_Spline_Points_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Points_Post_Processing_HeaderClick             (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Points_Post_Processing_Settings,Shape12);
  P_Spline_Points_Settings.Height:=P_Spline_Points_Shape_Settings.Top+P_Spline_Points_Shape_Settings.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Points_Post_Processing_HeaderMouseEnter        (sender:TObject); {$region -fold}
begin
  P_Spline_Points_Post_Processing_Header  .Color:=HighLightLimit(P_Spline_Points_Post_Processing_Header  .Color,16);
  P_Spline_Points_Post_Processing_Settings.Color:=HighLightLimit(P_Spline_Points_Post_Processing_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Points_Post_Processing_HeaderMouseLeave        (sender:TObject); {$region -fold}
begin
  P_Spline_Points_Post_Processing_Header  .Color:=Darken2(P_Spline_Points_Post_Processing_Header  .Color,16);
  P_Spline_Points_Post_Processing_Settings.Color:=Darken2(P_Spline_Points_Post_Processing_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.SplinePtsFXComboBoxClick                                (sender:TObject); {$region -fold}
begin
  CB_Spline_Points_Post_Processing_Style_Add_Effect       :=sender as TComboBox;
  SE_Spline_Points_Post_Processing_Effect_Strength.Enabled:=CB_Spline_Points_Post_Processing_Style_Add_Effect.ItemIndex in [1..15];
  SB_Spline_Points_Post_Processing_Color          .Enabled:=CB_Spline_Points_Post_Processing_Style_Add_Effect.ItemIndex in [0..02];
  SB_Spline_Points_Post_Processing_Color_Random   .Enabled:=CB_Spline_Points_Post_Processing_Style_Add_Effect.ItemIndex in [0..02];
  SB_Spline_Points_Post_Processing_Color_FallOff  .Enabled:=CB_Spline_Points_Post_Processing_Style_Add_Effect.ItemIndex in [0..02];
end; {$endregion}
procedure TF_MainForm.SplinePtsFXComboBoxSelect                               (sender:TObject); {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.BB_Spline_Points_Post_Processing_Add_EffectClick        (sender:TObject); {$region -fold}
begin
  AddFX
  (
    SB_Spline_Points_Post_Processing_Add_Effect,
    CB_Spline_Points_Post_Processing_Style_Add_Effect,
    CB_Spline_Points_Post_Processing_Style,
     L_Spline_Points_Post_Processing_Add_Effect,
    SE_Spline_Points_Post_Processing_Effect_Strength,
    @P_Spline_Points_Post_Processing_HeaderMouseEnter,
    @P_Spline_Points_Post_Processing_HeaderMouseLeave,
    @SplinePtsFXComboBoxClick,
    sln_pts_fx_pnls_cnt,
    sln_pts_fx_pnls,
    sln_pts_fx_arr
  );
end; {$endregion}
procedure TF_MainForm.L_Spline_Points_Post_Processing_Add_EffectClick         (sender:TObject); {$region -fold}
begin
  PM_Post_Processing_Add_Effect.PopUp;
  PM_Post_Processing_Add_Effect.Tag:=2;
end; {$endregion}
procedure TF_MainForm.P_Spline_Points_Post_Processing_Add_EffectMouseEnter    (sender:TObject); {$region -fold}
begin
  P_Spline_Points_Post_Processing_Add_Effect.Color:=HighLightLimit(P_Spline_Points_Post_Processing_Add_Effect.Color,16);
  L_Spline_Points_Post_Processing_Add_Effect.Color:=HighLightLimit(L_Spline_Points_Post_Processing_Add_Effect.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Points_Post_Processing_Add_EffectMouseLeave    (sender:TObject); {$region -fold}
begin
  P_Spline_Points_Post_Processing_Add_Effect.Color:=Darken2(P_Spline_Points_Post_Processing_Add_Effect.Color,16);
  L_Spline_Points_Post_Processing_Add_Effect.Color:=Darken2(L_Spline_Points_Post_Processing_Add_Effect.Color,16);
end; {$endregion}
procedure TF_MainForm.CB_Spline_Points_Post_Processing_StyleSelect            (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_bld_stl:=TDrawingStyle(CB_Spline_Points_Post_Processing_Style.ItemIndex);
end; {$endregion}
procedure TF_MainForm.SB_Spline_Points_Post_Processing_ColorClick             (sender:TObject); {$region -fold}
begin
  CD_Select_Color.Color:=SB_Spline_Points_Post_Processing_Color.Color;
  CD_Select_Color.Execute;
  with sln_var.global_prop do
    begin
      pts_col             :=CD_Select_Color.Color;
      pts_col_inv         :=SetColorInv(pts_col);
      pts_col_fall_off_inc:=0;
    end;
  SB_Spline_Points_Post_Processing_Color.Color:=CD_Select_Color.Color;
  SB_Spline_Points_Post_Processing_Color.Down :=False;
end; {$endregion}
procedure TF_MainForm.SB_Spline_Points_Post_Processing_Color_RandomClick      (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Points_Post_Processing_Color_Random,sln_var.global_prop.pts_col_rnd);
end; {$endregion}
procedure TF_MainForm.SB_Spline_Points_Post_Processing_Color_FallOffClick     (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Points_Post_Processing_Color_FallOff,sln_var.global_prop.pts_col_fall_off);
end; {$endregion}
procedure TF_MainForm.SB_Spline_Points_Show_BoundsClick                       (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Points_Show_Bounds,sln_var.global_prop.rct_pts_show);
end; {$endregion}
procedure TF_MainForm.P_Spline_Points_Bounds_HeaderClick                      (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Points_Bounds_Settings,Shape13);
  P_Spline_Points_Settings.Height:=P_Spline_Points_Shape_Settings.Top+P_Spline_Points_Shape_Settings.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Points_Bounds_HeaderMouseEnter                 (sender:TObject); {$region -fold}
begin
  P_Spline_Points_Bounds_Header  .Color:=HighLightLimit(P_Spline_Points_Bounds_Header  .Color,16);
  P_Spline_Points_Bounds_Settings.Color:=HighLightLimit(P_Spline_Points_Bounds_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Points_Bounds_HeaderMouseLeave                 (sender:TObject); {$region -fold}
begin
  P_Spline_Points_Bounds_Header  .Color:=Darken2(P_Spline_Points_Bounds_Header  .Color,16);
  P_Spline_Points_Bounds_Settings.Color:=Darken2(P_Spline_Points_Bounds_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.CB_Spline_Points_Bounds_StyleSelect                     (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.rct_pts_bld_stl:=TDrawingStyle(CB_Spline_Points_Bounds_Style.ItemIndex);
end; {$endregion}
procedure TF_MainForm.SE_Spline_Points_Bounds_Effect_StrengthChange           (sender:TObject); {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.SB_Spline_Points_Bounds_ColorClick                      (sender:TObject); {$region -fold}
begin
  CD_Select_Color.Color:=SB_Spline_Points_Bounds_Color.Color;
  CD_Select_Color.Execute;
  with sln_var.global_prop do
    begin
      rct_pts_col    :=CD_Select_Color.Color;
      rct_pts_col_inv:=SetColorInv(rct_pts_col);
    end;
  SB_Spline_Points_Bounds_Color.Color:=CD_Select_Color.Color;
  SB_Spline_Points_Bounds_Color.Down :=False;
end; {$endregion}
procedure TF_MainForm.SB_Spline_Points_Bounds_Color_RandomClick               (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Points_Bounds_Color_Random,sln_var.global_prop.rct_pts_col_rnd);
end; {$endregion}
procedure TF_MainForm.SB_Spline_Points_Bounds_Color_FallOffClick              (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Spline_Points_Bounds_Color_FallOff,sln_var.global_prop.rct_pts_col_fall_off);
end; {$endregion}
procedure TF_MainForm.P_Spline_Points_Shape_HeaderClick                       (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Points_Shape_Settings,Shape14);
  P_Spline_Points_Settings.Height:=P_Spline_Points_Shape_Settings.Top+P_Spline_Points_Shape_Settings.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Points_Shape_HeaderMouseEnter                  (sender:TObject); {$region -fold}
begin
  P_Spline_Points_Shape_Header      .Color:=HighLightLimit(P_Spline_Points_Shape_Header      .Color,16);
  P_Spline_Points_Shape_Settings    .Color:=HighLightLimit(P_Spline_Points_Shape_Settings    .Color,16);
  P_Spline_Points_Rectangle_Settings.Color:=HighLightLimit(P_Spline_Points_Rectangle_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Points_Shape_HeaderMouseLeave                  (sender:TObject); {$region -fold}
begin
  P_Spline_Points_Shape_Header      .Color:=Darken2(P_Spline_Points_Shape_Header      .Color,16);
  P_Spline_Points_Shape_Settings    .Color:=Darken2(P_Spline_Points_Shape_Settings    .Color,16);
  P_Spline_Points_Rectangle_Settings.Color:=Darken2(P_Spline_Points_Rectangle_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.CB_Spline_Points_ShapeSelect                            (sender:TObject); {$region -fold}
begin
  case CB_Spline_Points_Shape.ItemIndex of
    0:
      begin
        //P_Spline_Points.Visible:=True;

      end;
    1:
      begin
        //P_Spline_Points.Visible:=False;

      end;
    2:
      begin
        //P_Spline_Points.Visible:=False;

      end;
    3:
      begin
        //P_Spline_Points.Visible:=False;

      end;
  end;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Points_Rectangle_Thikness_LeftChange          (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_rct_tns_left:=SE_Spline_Points_Rectangle_Thikness_Left.value;
  SetRctWidth (sln_var.global_prop);
  SetRctValues(sln_var.global_prop);
  SetRctDupId (sln_var.global_prop);
end; {$endregion}
procedure TF_MainForm.SE_Spline_Points_Rectangle_Thikness_TopChange           (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_rct_tns_top:=SE_Spline_Points_Rectangle_Thikness_Top.value;
  SetRctHeight(sln_var.global_prop);
  SetRctValues(sln_var.global_prop);
  SetRctDupId (sln_var.global_prop);
end; {$endregion}
procedure TF_MainForm.SE_Spline_Points_Rectangle_Thikness_RightChange         (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_rct_tns_right:=SE_Spline_Points_Rectangle_Thikness_Right.value;
  SetRctWidth (sln_var.global_prop);
  SetRctValues(sln_var.global_prop);
  SetRctDupId (sln_var.global_prop);
end; {$endregion}
procedure TF_MainForm.SE_Spline_Points_Rectangle_Thikness_BottomChange        (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_rct_tns_bottom:=SE_Spline_Points_Rectangle_Thikness_Bottom.value;
  SetRctHeight(sln_var.global_prop);
  SetRctValues(sln_var.global_prop);
  SetRctDupId (sln_var.global_prop);
end; {$endregion}
procedure TF_MainForm.SE_Spline_Points_Rectangle_Inner_Rectangle_WidthChange  (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_rct_inn_width:=SE_Spline_Points_Rectangle_Inner_Rectangle_Width.value;
  SetRctWidth (sln_var.global_prop);
  SetRctValues(sln_var.global_prop);
  SetRctDupId (sln_var.global_prop);
end; {$endregion}
procedure TF_MainForm.SE_Spline_Points_Rectangle_Inner_Rectangle_HeightChange (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_rct_inn_height:=SE_Spline_Points_Rectangle_Inner_Rectangle_Height.value;
  SetRctHeight(sln_var.global_prop);
  SetRctValues(sln_var.global_prop);
  SetRctDupId (sln_var.global_prop);
end; {$endregion}
{Drawing-----}
procedure PanelToProp;                                                                  inline; {$region -fold}
begin

end; {$endregion}
procedure DrawCanvas;                                                                   inline; {$region -fold}
begin
  with sln_var,srf_var_ptr^ do
    begin
      LowerBmpToMainBmp;
      if show_world_axis then
        WorldAxisDraw;
      if (not down_play_anim_ptr^) then
        ResInnWndToBmp;
    end;
end; {$endregion}
function CycloidRangeCheck     : boolean;                                               inline; {$region -fold}
begin
  with sln_var,global_prop do
    Result:=(cycloid_pts_cnt <2) or
            (cycloid_loop_cnt=0) or
            (cycloid_loop_rad=0);
  if Result then
    DrawCanvas;
end; {$endregion}
function EpicycloidRangeCheck  : boolean;                                               inline; {$region -fold}
begin
  with sln_var,global_prop do
    Result:=((fml_type=(sfEpicycloid )) and (epicycloid_petals_cnt=0)) or
            ((fml_type=(sfHypocycloid)) and (epicycloid_petals_cnt<3)) or
            (epicycloid_pts_cnt<2)                                     or
            (epicycloid_rad    =0)                                     or
            (epicycloid_angle  =0);
  if Result then
    DrawCanvas;
end; {$endregion}
function RoseRangeCheck        : boolean;                                               inline; {$region -fold}
begin
  with sln_var,global_prop do
    Result:=(rose_pts_cnt   <3) or
            (rose_petals_cnt=0) or
            (rose_rad       =0);
  if Result then
    DrawCanvas;
end; {$endregion}
function SpiralRangeCheck      : boolean;                                               inline; {$region -fold}
begin
  with sln_var,global_prop do
    Result:=(spiral_pts_cnt<2) or
            (spiral_rad    =0);
  if Result then
    DrawCanvas;
end; {$endregion}
function SuperellipseRangeCheck: boolean;                                               inline; {$region -fold}
begin
  with sln_var,global_prop do
    Result:=(superellipse_pts_cnt   <2) or
            (superellipse_rad       =0) or
            (superellipse_curvature0=0) or
            (superellipse_curvature1=0);
  if Result then
    DrawCanvas;
end; {$endregion}
procedure SplineModeSelect;                                                             inline; {$region -fold}
begin
  with F_MainForm do
    begin
      L_Spline_Points_Frequency.visible :=((CB_Spline_Mode.ItemIndex=0) or (CB_Spline_Mode.ItemIndex=2));
      SE_Spline_Pts_Freq       .visible :=((CB_Spline_Mode.ItemIndex=0) or (CB_Spline_Mode.ItemIndex=2));
      L_Spline_Spray_Radius    .visible := (CB_Spline_Mode.ItemIndex=2);
      SE_Spline_Spray_Radius   .visible := (CB_Spline_Mode.ItemIndex=2);
      sln_var.global_prop      .sln_mode:=TSplineMode(CB_Spline_Mode.ItemIndex);
    end;
end; {$endregion}
procedure TF_MainForm.P_Spline_Drawing_HeaderClick                            (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Drawing_Settings,Shape7);
  if P_Spline_Drawing_Settings.Height =P_Spline_Drawing_Settings.Constraints.MaxHeight then
     P_Spline_Drawing_Settings.Height:=P_Spline_Drawing_Freehand.Top+P_Spline_Drawing_Freehand.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Drawing_HeaderMouseEnter                       (sender:TObject); {$region -fold}
begin
  P_Spline_Drawing_Header  .Color:=HighLightLimit(P_Spline_Drawing_Header  .Color,16);
  P_Spline_Drawing_Settings.Color:=HighLightLimit(P_Spline_Drawing_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Drawing_HeaderMouseLeave                       (sender:TObject); {$region -fold}
begin
  P_Spline_Drawing_Header  .Color:=Darken2(P_Spline_Drawing_Header  .Color,16);
  P_Spline_Drawing_Settings.Color:=Darken2(P_Spline_Drawing_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Drawing_Spline_Type_HeaderClick                (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Drawing_Spline_Type_Settings,Shape8);
  P_Spline_Drawing_Settings.Height:=P_Spline_Drawing_Freehand.Top+P_Spline_Drawing_Freehand.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Drawing_Spline_Type_HeaderMouseEnter           (sender:TObject); {$region -fold}
begin
  P_Spline_Drawing_Spline_Type_Header  .Color:=HighLightLimit(P_Spline_Drawing_Spline_Type_Header  .Color,16);
  P_Spline_Drawing_Spline_Type_Settings.Color:=HighLightLimit(P_Spline_Drawing_Spline_Type_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Drawing_Spline_Type_HeaderMouseLeave           (sender:TObject); {$region -fold}
begin
  P_Spline_Drawing_Spline_Type_Header  .Color:=Darken2(P_Spline_Drawing_Spline_Type_Header  .Color,16);
  P_Spline_Drawing_Spline_Type_Settings.Color:=Darken2(P_Spline_Drawing_Spline_Type_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Drawing_Settings_HeaderClick                   (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Drawing_Freehand,Shape9);
  P_Spline_Drawing_Settings.Height:=P_Spline_Drawing_Freehand.Top+P_Spline_Drawing_Freehand.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Drawing_Settings_HeaderMouseEnter              (sender:TObject); {$region -fold}
begin
  P_Spline_Drawing_Settings_Header  .Color:=HighLightLimit(P_Spline_Drawing_Settings_Header  .Color,16);
  P_Spline_Drawing_Freehand         .Color:=HighLightLimit(P_Spline_Drawing_Freehand         .Color,16);
  P_Spline_Drawing_Formula_Templates.Color:=HighLightLimit(P_Spline_Drawing_Formula_Templates.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Drawing_Settings_HeaderMouseLeave              (sender:TObject); {$region -fold}
begin
  P_Spline_Drawing_Settings_Header  .Color:=Darken2(P_Spline_Drawing_Settings_Header  .Color,16);
  P_Spline_Drawing_Freehand         .Color:=Darken2(P_Spline_Drawing_Freehand         .Color,16);
  P_Spline_Drawing_Formula_Templates.Color:=Darken2(P_Spline_Drawing_Formula_Templates.Color,16);
end; {$endregion}
procedure TF_MainForm.CB_Spline_TypeSelect                                    (sender:TObject); {$region -fold}
var
  b0,b1,b2,b3,b4: boolean;
begin
  if down_play_anim_ptr^ then
    Exit;
  with sln_var,global_prop do
    begin
      b0:=(CB_Spline_Type.ItemIndex=0);
      b1:=(CB_Spline_Type.ItemIndex=1);
      b2:=(CB_Spline_Type.ItemIndex=2);
      b3:=(CB_Spline_Type.ItemIndex=3);
      b4:=b0 or b2 or b3;
      sln_type:=TSplineType(CB_Spline_Type.ItemIndex);
      if (not (b0 or b2)) and (cur_tlt_dwn_btn_ind<>-1) then
        L_Spline_Templates_Name.Caption:=' '+sln_tlt_name_arr1[cur_tlt_dwn_btn_ind];
      case cur_tlt_dwn_btn_ind of
        0: P_Spline_Cycloid     .Visible:=not b4;
        1: P_Spline_Epicycloid  .Visible:=not b4;
        2: P_Spline_Rose        .Visible:=not b4;
        3: P_Spline_Spiral      .Visible:=not b4;
        4: P_Spline_Superellipse.Visible:=not b4;
      end;
      //P_Spline_Drawing_Freehand.Visible:=b0;
      P_Spline_Drawing_Formula_Templates.Visible:=b1 or b2 or b3;
      BB_Spline_Templates_Left  .Visible:=b1;
      P_Spline_Template_List1   .Visible:=b1;
      BB_Spline_Templates_Right .Visible:=b1;
      L_Spline_Points_Count     .Visible:=b2;
      SE_Spline_Points_Count    .Visible:=b2;
      SB_Spline_Load            .Visible:=b3;
      SB_Spline_Save            .Visible:=b3;
      if (b2 or b3) then
        L_Spline_Templates_Name.Caption:='';
      if b4 then
        srf_var_ptr^.EventGroupsCalc(calc_arr,[{30}])
      else
        if (cur_tlt_dwn_btn_ind<>-1) then
          case cur_tlt_dwn_btn_ind of
            0:
              begin
                if CycloidRangeCheck then
                  Exit;
                SetLength    (fml_pts,cycloid_pts_cnt);
                FmlSplinePrev(        cycloid_pts_cnt,True);
              end;
            1:
              begin
                if EpicycloidRangeCheck then
                  Exit;
                SetLength    (fml_pts,epicycloid_pts_cnt);
                FmlSplinePrev(        epicycloid_pts_cnt,True);
              end;
            2:
              begin
                if RoseRangeCheck then
                  Exit;
                SetLength    (fml_pts,rose_pts_cnt);
                FmlSplinePrev(        rose_pts_cnt,True);
              end;
            3:
              begin
                if SpiralRangeCheck then
                  Exit;
                SetLength    (fml_pts,spiral_pts_cnt);
                FmlSplinePrev(        spiral_pts_cnt,True);
              end;
            4:
              begin
                if SuperellipseRangeCheck then
                  Exit;
                SetLength    (fml_pts,superellipse_pts_cnt);
                FmlSplinePrev(        superellipse_pts_cnt,True);
              end;
          end;
    end;
  VisibilityChange(b4);
end; {$endregion}
procedure TF_MainForm.P_Spline_FreehandMouseEnter                             (sender:TObject); {$region -fold}
begin
  P_Spline_Drawing_Freehand.Color:=HighLightLimit(P_Spline_Drawing_Freehand.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_FreehandMouseLeave                             (sender:TObject); {$region -fold}
begin
  P_Spline_Drawing_Freehand.Color:=Darken2(P_Spline_Drawing_Freehand.Color,16);
end; {$endregion}
procedure TF_MainForm.CB_Spline_ModeSelect                                    (sender:TObject); {$region -fold}
begin
  SplineModeSelect;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Pts_FreqChange                                (sender:TObject); {$region -fold}
begin
  if (SE_Spline_Pts_Freq.value<=1) then
      SE_Spline_Pts_Freq.value:=1;
  sln_var.global_prop.sln_pts_frq:=SE_Spline_Pts_Freq.value;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Pts_FreqEnter                                 (sender:TObject); {$region -fold}
begin
  KeysDisable0;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Pts_FreqExit                                  (sender:TObject); {$region -fold}
begin
  KeysEnable0;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Pts_FreqMouseDown                             (sender:TObject; button:TMouseButton; shift:TShiftState; x,y:integer); {$region -fold}
begin
  KeysDisable3;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Spray_RadiusChange                            (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.spray_rad:=SE_Spline_Spray_Radius.value;
end; {$endregion}
procedure TF_MainForm.BB_Spline_Templates_LeftClick                           (sender:TObject); {$region -fold}
begin
  ButtonMoveToPrevPos(P_Spline_Template_List,SB_Spline_Template_Superellipse,100,SB_Spline_Template_Superellipse.width,0,ptLeft);
end; {$endregion}
procedure TF_MainForm.BB_Spline_Templates_RightClick                          (sender:TObject); {$region -fold}
begin
  ButtonMoveToSuccPos(P_Spline_Template_List,SB_Spline_Template_Cycloid,000,SB_Spline_Template_Cycloid.width,0,ptLeft);
end; {$endregion}
procedure TF_MainForm.P_Spline_Template_ListMouseWheelUp                      (sender:TObject; shift:TShiftState; mousepos:TPoint; var Handled:boolean); {$region -fold}
begin
  //P_Spline.VertScrollBar.Position:=0;
  P_Spline.VertScrollBar.Visible:=False;
  ButtonMoveToPrevPos(P_Spline_Template_List,SB_Spline_Template_Superellipse,100,SB_Spline_Template_Superellipse.width,0,ptLeft);
end; {$endregion}
procedure TF_MainForm.P_Spline_Template_ListMouseWheelDown                    (sender:TObject; shift:TShiftState; mousepos:TPoint; var Handled:boolean); {$region -fold}
begin
  //P_Spline.VertScrollBar.Position:=0;
  P_Spline.VertScrollBar.Visible:=False;
  ButtonMoveToSuccPos(P_Spline_Template_List,SB_Spline_Template_Cycloid,000,SB_Spline_Template_Cycloid.width,0,ptLeft);
end; {$endregion}
procedure TF_MainForm.P_Spline_Template_ListPaint                             (sender:TObject); {$region -fold}
begin
  ButtonColorize(P_Spline_Template_List);
end; {$endregion}
procedure TF_MainForm.SplinesTemplatesNamesInit                             (sln_var_:TCurve ); {$region -fold}
begin
  with sln_var_ do
    begin
      sln_tlt_name_arr1[0]:='Cycloid';
      sln_tlt_name_arr1[1]:='Epicycloid';
      sln_tlt_name_arr1[2]:='Rose';
      sln_tlt_name_arr1[3]:='Spiral';
      sln_tlt_name_arr1[4]:='Superellipse';
      sln_tlt_name_arr2[0]:=@SB_Spline_Template_Cycloid     .Down;
      sln_tlt_name_arr2[1]:=@SB_Spline_Template_Epicycloid  .Down;
      sln_tlt_name_arr2[2]:=@SB_Spline_Template_Rose        .Down;
      sln_tlt_name_arr2[3]:=@SB_Spline_Template_Spiral      .Down;
      sln_tlt_name_arr2[4]:=@SB_Spline_Template_Superellipse.Down;
    end;
end; {$endregion}
procedure TF_MainForm.SB_Spline_TemplateClick                                 (sender:TObject); {$region -fold}
type
  PPanel=^TPanel;
var
  panel_arr: array[0..4] of PPanel;
  i        : integer;

  procedure PanelsVisible; {$region -fold}
  var
    j: integer;
  begin
    for j:=0 to 4 do
      panel_arr[j]^.visible:=False;
  end; {$endregion}

begin
  panel_arr[0]:=@P_Spline_Cycloid;
  panel_arr[1]:=@P_Spline_Epicycloid;
  panel_arr[2]:=@P_Spline_Rose;
  panel_arr[3]:=@P_Spline_Spiral;
  panel_arr[4]:=@P_Spline_Superellipse;
  DefocusControl(ActiveControl,True);
  with sln_var do
    begin
      cur_tlt_dwn_btn_ind:=-1;
      for i:=0 to P_Spline_Template_List.ControlCount-1 do
        if sln_tlt_name_arr2[i]^ then
          begin
            cur_tlt_dwn_btn_ind:=i;
            Break;
          end;
      if (cur_tlt_dwn_btn_ind<>-1) then
        begin
          L_Spline_Templates_Name.Caption:=' '+sln_tlt_name_arr1[cur_tlt_dwn_btn_ind];
          PanelsVisible;
          panel_arr[cur_tlt_dwn_btn_ind]^.visible:=True;
          case cur_tlt_dwn_btn_ind of
            0:
              begin
                global_prop.fml_type:=sfCycloid;
                if CycloidRangeCheck then
                  Exit;
                SetLength    (fml_pts,global_prop.cycloid_pts_cnt);
                FmlSplinePrev(        global_prop.cycloid_pts_cnt,True);
              end;
            1:
              begin
                if not CB_Spline_Epicycloid_Hypocycloid.Checked then
                  global_prop.fml_type:=sfEpicycloid
                else
                  global_prop.fml_type:=sfHypocycloid;
                if EpicycloidRangeCheck then
                  Exit;
                SetLength    (fml_pts,global_prop.epicycloid_pts_cnt);
                FmlSplinePrev(        global_prop.epicycloid_pts_cnt,True);
              end;
            2:
              begin
                global_prop.fml_type:=sfRose;
                if RoseRangeCheck then
                  Exit;
                SetLength    (fml_pts,global_prop.rose_pts_cnt);
                FmlSplinePrev(        global_prop.rose_pts_cnt,True);
              end;
            3:
              begin
                global_prop.fml_type:=sfSpiral;
                if SpiralRangeCheck then
                  Exit;
                SetLength    (fml_pts,global_prop.spiral_pts_cnt);
                FmlSplinePrev(        global_prop.spiral_pts_cnt,True);
              end;
            4:
              begin
                global_prop.fml_type:=sfSuperellipse;
                if SuperellipseRangeCheck then
                  Exit;
                SetLength    (fml_pts,global_prop.superellipse_pts_cnt);
                FmlSplinePrev(        global_prop.superellipse_pts_cnt,True);
              end;
          end;
        end
      else
        begin
          L_Spline_Templates_Name.Caption:='';
          sln_pts_cnt_add                :=0;
          PanelsVisible;
          srf_var_ptr^.EventGroupsCalc(calc_arr,[30]);
        end;
    end;
end; {$endregion}
procedure TF_MainForm.P_Spline_Templates_PropertiesMouseEnter                 (sender:TObject); {$region -fold}
begin
  P_Spline_Templates_Properties.Color  :=HighLightLimit(P_Spline_Templates_Properties.Color,16);
  L_Spline_Templates_Name      .Color  :=HighLightLimit(L_Spline_Templates_Name      .Color,16);
  P_Spline.VertScrollBar       .Visible:=True;
end; {$endregion}
procedure TF_MainForm.P_Spline_Templates_PropertiesMouseLeave                 (sender:TObject); {$region -fold}
begin
  P_Spline_Templates_Properties.Color:=Darken2(P_Spline_Templates_Properties.Color,16);
  L_Spline_Templates_Name      .Color:=Darken2(L_Spline_Templates_Name      .Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Template_ListMouseEnter                        (sender:TObject); {$region -fold}
begin
  //vert_sc_bar_pos:=SB_Drawing.VertScrollBar.Position;
  //SB_Drawing.OnMouseWheelDown:=Nil;
  //SB_Drawing.OnMouseWheelUp:=Nil;
  //SB_Drawing.VertScrollBar.Position:=SB_Drawing.VertScrollBar.Position+10;
  //SB_Drawing.VertScrollBar.Visible:=False;
  P_Spline_Template_List.Color   :=HighLightLimit(P_Spline_Template_List.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Template_ListMouseLeave                        (sender:TObject); {$region -fold}
begin
  //SB_Drawing.VertScrollBar.Visible:=True;
  P_Spline_Template_List.Color:=Darken2(P_Spline_Template_List.Color,16);
end; {$endregion}
procedure TF_MainForm.BB_Spline_GenerateClick                                 (sender:TObject); {$region -fold}
begin
  with sln_var,srf_var_ptr^,global_prop do
    begin
      if (not show_spline) then
        Exit;
      case CB_Spline_Type.ItemIndex of
        1:
          begin
            if (cur_tlt_dwn_btn_ind=-1) then
              Exit;
            case cur_tlt_dwn_btn_ind of
              0:
                begin
                  if CycloidRangeCheck then
                    Exit;
                  sln_pts_cnt_add:=cycloid_pts_cnt;
                end;
              1:
                begin
                  if EpicycloidRangeCheck then
                    Exit;
                  sln_pts_cnt_add:=epicycloid_pts_cnt;
                end;
              2:
                begin
                  if RoseRangeCheck then
                    Exit;
                  sln_pts_cnt_add:=rose_pts_cnt;
                end;
              3:
                begin
                  if SpiralRangeCheck then
                    Exit;
                  sln_pts_cnt_add:=spiral_pts_cnt;
                end;
              4:
                begin
                  if SuperellipseRangeCheck then
                    Exit;
                  sln_pts_cnt_add:=superellipse_pts_cnt;
                end;
            end;
            FmlSplineObj[cur_tlt_dwn_btn_ind](Trunc(world_axis.x),Trunc(world_axis.y));
            Inc(sln_pts_cnt,sln_pts_cnt_add);
            sln_pts_add:=fml_pts;
          end;
        2:
          begin
            if (pts_cnt_val=0) then
              Exit;
            RndSplineObj(PtPos(world_axis),512{256},512{256});
          end;
      end;
      EventGroupsCalc(calc_arr,[12,21,30,31,33,40,41,48,52,55]);
    end;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Cycloid_Points_CountChange                    (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      cycloid_pts_cnt:=SE_Spline_Cycloid_Points_Count.value;
      if CycloidRangeCheck then
        Exit;
      SetLength(fml_pts,cycloid_pts_cnt);
      FmlSplinePrev(cycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Cycloid_Loops_CountChange                     (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      cycloid_loop_cnt:=SE_Spline_Cycloid_Loops_Count.value;
      if CycloidRangeCheck then
        Exit;
      FmlSplinePrev(cycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Cycloid_RadiusChange                         (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      cycloid_loop_rad:=FSE_Spline_Cycloid_Radius.value;
      if CycloidRangeCheck then
        Exit;
      FmlSplinePrev(cycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Cycloid_CurvatureChange                      (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      cycloid_curvature:=FSE_Spline_Cycloid_Curvature.value;
      FmlSplinePrev(cycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Cycloid_Direction_XSelect                     (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      cycloid_dir_x:=TMovingDirection(CB_Spline_Cycloid_Direction_X.ItemIndex);
      FmlSplinePrev(cycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Cycloid_Direction_YSelect                     (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      cycloid_dir_y:=TMovingDirection(CB_Spline_Cycloid_Direction_Y.ItemIndex+2);
      FmlSplinePrev(cycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Epicycloid_Points_CountChange                 (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      epicycloid_pts_cnt:=SE_Spline_Epicycloid_Points_Count.value;
      if EpicycloidRangeCheck then
        Exit;
      SetLength    (fml_pts,epicycloid_pts_cnt);
      FmlSplinePrev(        epicycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Epicycloid_Petals_CountChange                (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      epicycloid_petals_cnt:=FSE_Spline_Epicycloid_Petals_Count.value;
      if EpicycloidRangeCheck then
        Exit;
      FmlSplinePrev(epicycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Epicycloid_RadiusChange                      (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      epicycloid_rad:=FSE_Spline_Epicycloid_Radius.value;
      if EpicycloidRangeCheck then
        Exit;
      FmlSplinePrev(epicycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Epicycloid_RotationChange                    (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      epicycloid_rot:=FSE_Spline_Epicycloid_Rotation.value;
      FmlSplinePrev(epicycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Epicycloid_AngleChange                       (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      epicycloid_angle:=FSE_Spline_Epicycloid_Angle.value;
      if EpicycloidRangeCheck then
        Exit;
      FmlSplinePrev(epicycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Epicycloid_HypocycloidChange                  (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      if CB_Spline_Epicycloid_Hypocycloid.Checked then
        fml_type:=sfHypocycloid
      else
        fml_type:=sfEpicycloid;
      if EpicycloidRangeCheck then
        Exit;
      FmlSplinePrev(epicycloid_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Rose_Points_CountChange                       (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      rose_pts_cnt:=SE_Spline_Rose_Points_Count.value;
      if RoseRangeCheck then
        Exit;
      SetLength    (fml_pts,rose_pts_cnt);
      FmlSplinePrev(        rose_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Rose_Petals_CountChange                      (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      rose_petals_cnt:=FSE_Spline_Rose_Petals_Count.value;
      if RoseRangeCheck then
        Exit;
      FmlSplinePrev(rose_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Rose_RadiusChange                            (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      rose_rad:=FSE_Spline_Rose_Radius.value;
      if RoseRangeCheck then
        Exit;
      FmlSplinePrev(rose_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Rose_RotationChange                          (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      rose_rot:=FSE_Spline_Rose_Rotation.value;
      FmlSplinePrev(rose_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Rose_AngleChange                             (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      rose_angle:=FSE_Spline_Rose_Angle.value;
      FmlSplinePrev(rose_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Rose_Mobius_GridChange                        (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      rose_mobius_grid:=CB_Spline_Rose_Mobius_Grid.Checked;
      FmlSplinePrev(rose_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Spiral_Points_CountChange                     (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      spiral_pts_cnt:=SE_Spline_Spiral_Points_Count.value;
      if SpiralRangeCheck then
        Exit;
      SetLength    (fml_pts,spiral_pts_cnt);
      FmlSplinePrev(        spiral_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Spiral_Coil_StepChange                       (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      spiral_coil_step:=FSE_Spline_Spiral_Coil_Step.value;
      FmlSplinePrev(spiral_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Spiral_RadiusChange                          (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      spiral_rad:=FSE_Spline_Spiral_Radius.value;
      if SpiralRangeCheck then
        Exit;
      FmlSplinePrev(spiral_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Spiral_RotationChange                        (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      spiral_rot:=FSE_Spline_Spiral_Rotation.value;
      FmlSplinePrev(spiral_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Spiral_AngleChange                           (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      spiral_angle:=FSE_Spline_Spiral_Angle.value;
      FmlSplinePrev(spiral_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Superellipse_Points_CountChange               (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      superellipse_pts_cnt:=SE_Spline_Superellipse_Points_Count.value;
      if SuperellipseRangeCheck then
        Exit;
      SetLength    (fml_pts,superellipse_pts_cnt);
      FmlSplinePrev(        superellipse_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Superellipse_Curvature0Change                (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      superellipse_curvature0:=FSE_Spline_Superellipse_Curvature0.value;
      if SuperellipseRangeCheck then
        Exit;
      FmlSplinePrev(superellipse_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Superellipse_Curvature1Change                (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      superellipse_curvature1:=FSE_Spline_Superellipse_Curvature1.value;
      if SuperellipseRangeCheck then
        Exit;
      FmlSplinePrev(superellipse_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Superellipse_Curvature2Change                (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      superellipse_curvature2:=FSE_Spline_Superellipse_Curvature2.value;

      FmlSplinePrev(superellipse_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Superellipse_Curvature3Change                (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      superellipse_curvature3:=FSE_Spline_Superellipse_Curvature3.value;
      FmlSplinePrev(superellipse_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Superellipse_RadiusChange                    (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      superellipse_rad:=FSE_Spline_Superellipse_Radius.value;
      if SuperellipseRangeCheck then
        Exit;
      FmlSplinePrev(superellipse_pts_cnt);
    end;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Points_CountChange                            (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.pts_cnt_val:=SE_Spline_Points_Count.Value;
end; {$endregion}
procedure TF_MainForm.SB_Spline_LoadClick                                     (sender:TObject); {$region -fold}
var
  sln_pts_add_ptr                       : PPtPosF;
  i,line_cnt,pts_coord_start_pos,pts_cnt: integer;
  file_import                           : text;
  file_path,file_line                   : string;
  x_start,y_start                       : boolean;
label
  label0;
begin
  SB_Spline_Load.Down   :=False;
  OD_Spline_Load.Options:=OD_Spline_Load.Options+[ofFileMustExist];
  if (not OD_Spline_Load.Execute) then
    Exit;
  try
    file_path:=OD_Spline_Load.Filename;
    AssignFile(file_import,file_path);
    Reset     (file_import);
    line_cnt:=0;
    pts_cnt :=0;
    while (not EOF(file_import)) do
      begin
        ReadLn(file_import,file_line);
        Inc(line_cnt);
        for i:=0 to Length(file_line)-1 do
          if (file_line[i+0]='p') and
             (file_line[i+1]='o') and
             (file_line[i+2]='i') and
             (file_line[i+3]='n') and
             (file_line[i+4]='t') and
             (file_line[i+5]='s') and
             (file_line[i+6]=#61) and
             (file_line[i+7]=#34) then
            begin
              pts_coord_start_pos:=i+8;
              Break;
            end;
        for i:=pts_coord_start_pos to Length(file_line)-1 do
          begin
            if (file_line[i]=#32) then
              Continue
            else
            if (file_line[i]=#34) then
              goto label0
            else
            if (file_line[i] in [#48..#57]) and ((file_line[i-1]=#32) or (file_line[i-1]=#34)) then
              Inc(pts_cnt);
          end;
      end;
    label0:
    pts_cnt:=pts_cnt>>1;
    Reset(file_import);
    for i:=0 to line_cnt-1 do
      ReadLn(file_import,file_line);
    with sln_var do
      begin
        sln_pts_cnt_add:=global_prop.pts_cnt;
        Inc(sln_pts_cnt,sln_pts_cnt_add);
        SetLength(sln_pts_add,0);
        SetLength(sln_pts_add,sln_pts_cnt_add);
        sln_pts_add_ptr:=Unaligned(@sln_pts_add[0]);
        for i:=pts_coord_start_pos to Length(file_line)-1 do
          begin
            if (file_line[i] in [#48..#57]) and ((file_line[i-1]=#32) or (file_line[i-1]=#34)) then
              begin
                if not y_start then
                  sln_pts_add_ptr^.x:=Ord(file_line[i]);
                //
              end;
          end;
      end;
  except
    on E: Exception do
      MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
  end;
end; {$endregion}
procedure TF_MainForm.SB_Spline_SaveClick                                     (sender:TObject); {$region -fold}
begin
  {TODO}
end; {$endregion}
{Optimization}
procedure TF_MainForm.P_Spline_Optimization_HeaderClick                       (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Optimization_Settings,Shape6);
  if P_Spline_Optimization_Settings.Height =P_Spline_Optimization_Settings.Constraints.MaxHeight then
     P_Spline_Optimization_Settings.Height:=P_Spline_Optimization_Memory_Management_Settings.Top+P_Spline_Optimization_Memory_Management_Settings.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_HeaderMouseEnter                  (sender:TObject); {$region -fold}
begin
  P_Spline_Optimization_Header  .Color:=HighLightLimit(P_Spline_Optimization_Header  .Color,16);
  P_Spline_Optimization_Settings.Color:=HighLightLimit(P_Spline_Optimization_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_HeaderMouseLeave                  (sender:TObject); {$region -fold}
begin
  P_Spline_Optimization_Header  .Color:=Darken2(P_Spline_Optimization_Header  .Color,16);
  P_Spline_Optimization_Settings.Color:=Darken2(P_Spline_Optimization_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_General_HeaderClick               (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Optimization_General_Settings,Shape1);
  P_Spline_Optimization_Settings.Height:=P_Spline_Optimization_Memory_Management_Settings.Top+P_Spline_Optimization_Memory_Management_Settings.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_General_HeaderMouseEnter          (sender:TObject); {$region -fold}
begin
  P_Spline_Optimization_General_Header  .Color:=HighLightLimit(P_Spline_Optimization_General_Header  .Color,16);
  P_Spline_Optimization_General_Settings.Color:=HighLightLimit(P_Spline_Optimization_General_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_General_HeaderMouseLeave          (sender:TObject); {$region -fold}
begin
  P_Spline_Optimization_General_Header  .Color:=Darken2(P_Spline_Optimization_General_Header  .Color,16);
  P_Spline_Optimization_General_Settings.Color:=Darken2(P_Spline_Optimization_General_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_Compression_HeaderClick           (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Optimization_Compression_Settings,Shape2);
  P_Spline_Optimization_Settings.Height:=P_Spline_Optimization_Memory_Management_Settings.Top+P_Spline_Optimization_Memory_Management_Settings.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_Compression_HeaderMouseEnter      (sender:TObject); {$region -fold}
begin
  P_Spline_Optimization_Compression_Header  .Color:=HighLightLimit(P_Spline_Optimization_Compression_Header  .Color,16);
  P_Spline_Optimization_Compression_Settings.Color:=HighLightLimit(P_Spline_Optimization_Compression_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_Compression_HeaderMouseLeave      (sender:TObject); {$region -fold}
begin
  P_Spline_Optimization_Compression_Header  .Color:=Darken2(P_Spline_Optimization_Compression_Header  .Color,16);
  P_Spline_Optimization_Compression_Settings.Color:=Darken2(P_Spline_Optimization_Compression_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_Grid_Clipping_HeaderClick         (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Optimization_Grid_Clipping_Settings,Shape3);
  P_Spline_Optimization_Settings.Height:=P_Spline_Optimization_Memory_Management_Settings.Top+P_Spline_Optimization_Memory_Management_Settings.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_Grid_Clipping_HeaderMouseEnter    (sender:TObject); {$region -fold}
begin
  P_Spline_Optimization_Grid_Clipping_Header  .Color:=HighLightLimit(P_Spline_Optimization_Grid_Clipping_Header  .Color,16);
  P_Spline_Optimization_Grid_Clipping_Settings.Color:=HighLightLimit(P_Spline_Optimization_Grid_Clipping_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_Grid_Clipping_HeaderMouseLeave    (sender:TObject); {$region -fold}
begin
  P_Spline_Optimization_Grid_Clipping_Header  .Color:=Darken2(P_Spline_Optimization_Grid_Clipping_Header  .Color,16);
  P_Spline_Optimization_Grid_Clipping_Settings.Color:=Darken2(P_Spline_Optimization_Grid_Clipping_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_LOD_HeaderClick                   (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Optimization_LOD_Settings,Shape4);
  P_Spline_Optimization_Settings.Height:=P_Spline_Optimization_Memory_Management_Settings.Top+P_Spline_Optimization_Memory_Management_Settings.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_LOD_HeaderMouseEnter              (sender:TObject); {$region -fold}
begin
  P_Spline_Optimization_LOD_Header  .Color:=HighLightLimit(P_Spline_Optimization_LOD_Header  .Color,16);
  P_Spline_Optimization_LOD_Settings.Color:=HighLightLimit(P_Spline_Optimization_LOD_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_LOD_HeaderMouseLeave              (sender:TObject); {$region -fold}
begin
  P_Spline_Optimization_LOD_Header  .Color:=Darken2(P_Spline_Optimization_LOD_Header  .Color,16);
  P_Spline_Optimization_LOD_Settings.Color:=Darken2(P_Spline_Optimization_LOD_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_Memory_Management_HeaderClick     (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Spline_Optimization_Memory_Management_Settings,Shape5);
  P_Spline_Optimization_Settings.Height:=P_Spline_Optimization_Memory_Management_Settings.Top+P_Spline_Optimization_Memory_Management_Settings.Height+4;
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_Memory_Management_HeaderMouseEnter(sender:TObject); {$region -fold}
begin
  P_Spline_Optimization_Memory_Management_Header  .Color:=HighLightLimit(P_Spline_Optimization_Memory_Management_Header  .Color,16);
  P_Spline_Optimization_Memory_Management_Settings.Color:=HighLightLimit(P_Spline_Optimization_Memory_Management_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_Memory_Management_HeaderMouseLeave(sender:TObject); {$region -fold}
begin
  P_Spline_Optimization_Memory_Management_Header  .Color:=Darken2(P_Spline_Optimization_Memory_Management_Header  .Color,16);
  P_Spline_Optimization_Memory_Management_Settings.Color:=Darken2(P_Spline_Optimization_Memory_Management_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_SettingsMouseEnter                (sender:TObject); {$region -fold}
begin
  P_Spline_Optimization_Settings.Color:=HighLightLimit(P_Spline_Optimization_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Optimization_SettingsMouseLeave                (sender:TObject); {$region -fold}
begin
  P_Spline_Optimization_Settings.Color:=Darken2(P_Spline_Optimization_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.CB_Spline_Edges_LODChange                               (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.eds_lod            :=not sln_var.global_prop.eds_lod;
  CB_Spline_Edges_LOD_On_Create  .Enabled:=CB_Spline_Edges_LOD.Checked;
  FSE_Spline_Simplification_Angle.Enabled:=CB_Spline_Edges_LOD.Checked;
  L_Spline_Simplification_Angle  .Enabled:=CB_Spline_Edges_LOD.Checked;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Edges_LOD_On_CreateChange                     (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.eds_lod_on_create:=not sln_var.global_prop.eds_lod_on_create;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Simplification_AngleChange                   (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.eds_simpl_angle:=FSE_Spline_Simplification_Angle.Value;
end; {$endregion}
procedure TF_MainForm.FSE_Spline_Simplification_AngleEditingDone              (sender:TObject); {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.CB_Spline_Hidden_Line_EliminationChange                 (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.hid_ln_elim:=not sln_var.global_prop.hid_ln_elim;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Best_Ends_QualityChange                       (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.best_ends_quality:=not sln_var.global_prop.best_ends_quality;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Best_PrecisionChange                          (sender:TObject); {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.CB_Spline_Lazy_RepaintChange                            (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.lazy_repaint:=not sln_var.global_prop.lazy_repaint;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Byte_ModeChange                               (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.byte_mode     :=not sln_var.global_prop.byte_mode;
  CB_Spline_Better_Quality.Enabled  :=CB_Spline_Byte_Mode.Checked;
  sln_var.global_prop.better_quality:=CB_Spline_Better_Quality.Checked and sln_var.global_prop.byte_mode;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Better_QualityChange                          (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.better_quality:=not sln_var.global_prop.better_quality;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Grid_Clipping_PointsChange                    (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      grid_clipping_pts                           :=not grid_clipping_pts;
      SE_Spline_Grid_Clipping_Grid_Density.Enabled:=    grid_clipping_pts and (not grid_clipping_adaptive);
      CB_Spline_Grid_Clipping_Adaptive    .Enabled:=    grid_clipping_pts;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Grid_Clipping_AdaptiveChange                  (sender:TObject); {$region -fold}
begin
  with sln_var,global_prop do
    begin
      grid_clipping_adaptive                      :=not grid_clipping_adaptive;
      SE_Spline_Grid_Clipping_Grid_Density.Enabled:=not grid_clipping_adaptive;
    end;
end;{$endregion}
procedure TF_MainForm.SE_Spline_Grid_Clipping_Grid_DensityChange              (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.grd_pts_dns:=SE_Spline_Grid_Clipping_Grid_Density.value;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Grid_Clipping_Grid_DensityEnter               (sender:TObject); {$region -fold}
begin
  KeysDisable0;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Grid_Clipping_Grid_DensityExit                (sender:TObject); {$region -fold}
begin
  KeysEnable0;
end; {$endregion}
procedure TF_MainForm.SE_Spline_Grid_Clipping_Grid_DensityMouseDown           (sender:TObject; button:TMouseButton; shift:TShiftState; x,y:integer); {$region -fold}
begin
  KeysDisable3;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Free_On_Out_Of_WindowChange                   (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.free_mem_on_out_of_wnd:=not sln_var.global_prop.free_mem_on_out_of_wnd;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Free_On_Scale_DownChange                      (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.free_mem_on_scale_down:=not sln_var.global_prop.free_mem_on_scale_down;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Reallocate_MemoryChange                       (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.realloc_mem:=not sln_var.global_prop.realloc_mem;
end; {$endregion}
procedure TF_MainForm.CB_Spline_Remove_BrunchingChange                        (sender:TObject); {$region -fold}
begin
  with sln_var.global_prop do
    remove_brunching:=not remove_brunching;
end; {$endregion}
{Dynamics----}
procedure TF_MainForm.CB_Spline_Dynamics_StyleSelect                          (sender:TObject); {$region -fold}
begin
  sln_var.global_prop.dyn_stl:=TDynamicsStyle(CB_Spline_Dynamics_Style.ItemIndex);
end; {$endregion}
procedure TF_MainForm.P_Spline_Dynamics_PropMouseEnter                        (sender:TObject); {$region -fold}
begin
  P_Spline_Dynamics_Prop.Color:=HighLightLimit(P_Spline_Dynamics_Prop.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Dynamics_PropMouseLeave                        (sender:TObject); {$region -fold}
begin
  P_Spline_Dynamics_Prop.Color:=Darken2(P_Spline_Dynamics_Prop.Color,16);
end; {$endregion}
{Save/Load---}
procedure TF_MainForm.P_Spline_Save_PropMouseEnter                            (sender:TObject); {$region -fold}
begin
  P_Spline_Save_Prop.Color:=HighLightLimit(P_Spline_Save_Prop.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Spline_Save_PropMouseLeave                            (sender:TObject); {$region -fold}
begin
  P_Spline_Save_Prop.Color:=Darken2(P_Spline_Save_Prop.Color,16);
end; {$endregion}
{$endregion}

// (Select Points/Items) Выделение точек/обьектов:
{LI} {$region -fold}
constructor TSelIts.Create(const w,h:TColor);                                                                                                          {$ifdef Linux}[local];{$endif} {$region -fold}

  procedure SelLocalProp(var img:TFastLine; const col:TColor); inline; {$region -fold}
  begin
    with img,local_prop do
      begin
        local_prop :=curve_default_prop;
        eds_col    :=col;
        eds_col_inv:=SetColorInv(eds_col);
        eds_aa     :=True;
        eds_bld_stl:=dsAlphablend;
        clp_stl    :=csRemoveEdges;
        SetColorInfo(eds_col,color_info);
        with args do
          begin
            alpha:=127{016};
            pow  :=016;
            d    :=016;
          end;
      end;
  end; {$endregion}

begin

  srf_var_ptr         :=@srf_var;

  OuterSubgraphProc[0]:=@OuterSubgraphCalc0;
  OuterSubgraphProc[1]:=@OuterSubgraphCalc1;
  OuterSubgraphProc[2]:=@OuterSubgraphCalc2;

  InnerSubgraphProc[0]:=@InnerSubgraphCalc0;
  InnerSubgraphProc[1]:=@InnerSubgraphCalc1;
  InnerSubgraphProc[2]:=@InnerSubgraphCalc2;

  WholeSubgraphProc[0]:=@WholeSubgraphDraw0;
  WholeSubgraphProc[1]:=@WholeSubgraphDraw1;
  WholeSubgraphProc[2]:=@WholeSubgraphDraw2;

  // outer subgraph:
  outer_subgraph_img:=TFastLine.Create;
  SelLocalProp(outer_subgraph_img,$00A5AE51);

  // inner subgraph:
  inner_subgraph_img:=TFastLine.Create;
  SelLocalProp(inner_subgraph_img,clLime);

  // selected points:
  sel_pts_img:=TFastLine.Create;
  SelLocalProp(sel_pts_img,$0011EEE9);

  // selection:
  selection_img:=TFastLine.Create;
  with selection_img,local_prop do
    begin
      //rct_clp           :=PtRct(0,0,bkgnd_width,bkgnd_height);
      //rct_clp_ptr       :=@rct_clp;
      selection_prop    :=selit_default_prop;
      local_prop        :=curve_default_prop;
      eds_col           :=clGreen;
      eds_col_inv       :=SetColorInv(eds_col);
      eds_aa            :=True;
      eds_bld_stl       :=dsAdditive;
      pts_col           :=$0011EEE9;
      pts_col_inv       :=SetColorInv(pts_col);
      SetColorInfo(eds_col,color_info);
      with args do
        begin
          alpha:=016;
          pow  :=016;
          d    :=016;
        end;
      BuffersInit(w,h,False,True,False,False);
      SetBkgnd   (srf_var_ptr^.srf_bmp_ptr,srf_var_ptr^.srf_bmp.width,srf_var_ptr^.srf_bmp.height,@srf_var_ptr^.inn_wnd_rct{rct_clp_ptr});
    end;

  // selected points bounds:
  with selection_bounds_prop do
    begin
      selection_bounds_prop:=curve_default_prop;
      pts_bld_stl          :=dsInverse;
      pts_col              :=clBlue;
      pts_col_inv          :=SetColorInv(pts_col);
      pts_rct_tns_left     :=1;
      pts_rct_tns_top      :=1;
      pts_rct_tns_right    :=1;
      pts_rct_tns_bottom   :=1;
    end;

  sel_pts_rct_mrgn          :=32;
  bucket_rct.Width          :=8;
  bucket_rct.Height         :=8;
  is_not_abst_obj_kind_after:=True;
  sel_only_pts_vis_sln      :=True;
  sel_only_pts_sel_sln      :=True;

end; {$endregion}
destructor  TSelIts.Destroy;                                                                                                                           {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure TSelIts.BucketSizeChange(chng_val:integer);                                                                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,m1,m2   : integer;
  bucket_mul: integer=4;
begin
  with srf_var_ptr^ do
    begin
      bucket_rct.Width :=Trunc(sqrt(sel_pts_rct.width*sel_pts_rct.height*chng_val)/(10*bucket_mul));
      bucket_rct.Height:=Trunc(sqrt(sel_pts_rct.width*sel_pts_rct.height*chng_val)/(10*bucket_mul));
      ncs_adv_clip_rect:=NCSRectCalc(sel_pts_rct,
                                     bucket_rct.width,
                                     bucket_rct.height);
      LowerBmpToMainBmp;
      with srf_bmp.Canvas do
        begin
          Pen.Color:=bucket_rct_color;
          m1:=Trunc(ncs_adv_clip_rect.width /bucket_rct.width )-2;
          m2:=Trunc(ncs_adv_clip_rect.height/bucket_rct.height)-2;
          for i:=0 to m1 do
            Line(Trunc(ncs_adv_clip_rect.left)+bucket_rct.width*(i+1),
                 Trunc(ncs_adv_clip_rect.top ),
                 Trunc(ncs_adv_clip_rect.left)+bucket_rct.width*(i+1),
                 Trunc(ncs_adv_clip_rect.top )+Trunc(ncs_adv_clip_rect.height));
          for i:=0 to m2 do
            Line(Trunc(ncs_adv_clip_rect.left),
                 Trunc(ncs_adv_clip_rect.top )+bucket_rct.height*(i+1),
                 Trunc(ncs_adv_clip_rect.left)+Trunc(ncs_adv_clip_rect.width),
                 Trunc(ncs_adv_clip_rect.top )+bucket_rct.height*(i+1));
        end;
      InvalidateInnerWindow;

      {$ifdef Windows}
      Sleep(2);
      {$endif}

    end;
end; {$endregion}
procedure TSelIts.IsObjColorAMaskColor;                                                                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (outer_subgraph_img.local_prop.eds_col =clBlack) then
    begin
      outer_subgraph_img.local_prop.eds_col:=$01;
      F_MainForm.CD_Select_Color.Color     :=$01;
    end;
  if (inner_subgraph_img.local_prop.eds_col =clBlack) then
    begin
      inner_subgraph_img.local_prop.eds_col:=$01;
      F_MainForm.CD_Select_Color.Color     :=$01;
    end;
  if (sel_pts_img.local_prop.eds_col        =clBlack) then
    begin
      sel_pts_img.local_prop.eds_col       :=$01;
      F_MainForm.CD_Select_Color.Color     :=$01;
    end;
  if (selection_img.local_prop.eds_col      =clBlack) then
    begin
      selection_img.local_prop.eds_col     :=$01;
      F_MainForm.CD_Select_Color.Color     :=$01;
    end;
end; {$endregion}
procedure TSelIts.FillSelBmpAndSelPtsBRectDraw;                                                                                                inline; {$ifdef linux}[local];{$endif} {$region -fold}
begin
  if exp0 then
    if show_spline then
      with srf_var_ptr^,sln_var,pvt_var do
        begin
          LowerBmpToMainBmp;
          if outer_subgraph_img.local_prop.eds_show then
            OuterSubgraphDraw(Trunc(pvt_var.pvt_pos.X),
                              Trunc(pvt_var.pvt_pos.Y),
                              pvt_var.pvt_pos,
                              sln_pts,
                              srf_bmp_ptr,
                              inn_wnd_rct);
          if inner_subgraph_img.local_prop.eds_show and (not IsRct1OutOfRct2(sel_var.sel_pts_rct,inn_wnd_rct)) then
            InnerSubgraphDraw(Trunc(pvt_var.pvt_pos.X),
                              Trunc(pvt_var.pvt_pos.Y),
                              pvt_var.pvt_pos,
                              sln_pts,
                              srf_bmp_ptr,
                              ClippedRct(inn_wnd_rct,sel_pts_rct));
          if sel_pts_img.local_prop.eds_show        and (not IsRct1OutOfRct2(sel_var.sel_pts_rct,inn_wnd_rct)) then
            SelPtsDraw       (Trunc(pvt_var.pvt_pos.X),
                              Trunc(pvt_var.pvt_pos.Y),
                              pvt_var.pvt_pos,
                              sln_pts,
                              srf_bmp_ptr,
                              inn_wnd_rct);
          if selection_bounds_prop.rct_eds_show then
            SelPtsBnds       (Trunc(pvt_var.pvt_pos.X),
                              Trunc(pvt_var.pvt_pos.Y),
                              pvt_var.pvt_pos,
                              sln_pts,
                              srf_bmp_ptr,
                              inn_wnd_rct);
          if (not down_play_anim_ptr^) then
            ResInnWndToBmp;
        end;
end; {$endregion}
constructor TCrcSel.Create;                                                                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  srf_var_ptr :=@srf_var;
  crc_sel_col :=clGreen;
  crc_rad     :=10;
  crc_rad_sqr :=crc_rad*crc_rad;
  draw_crc_sel:=True;

  {Create Sprite---------} {$region -fold}
  with sel_var.selection_img,local_prop do
    begin
      SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
      sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
      (
        bmp_dst_ptr,
        bmp_dst_width,
        bmp_dst_height,
        rct_clp_ptr^,
        rct_vis,
        0
      );
      crc_sel_ind:=Length(sprite_sheet_arr)-1;
    end; {$endregion}

end; {$endregion}
destructor  TCrcSel.Destroy;                                                                                                                           {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure TCrcSel.CircleSelection        (x,y:integer; const sel_draw:boolean=True);                                                                   {$ifdef Linux}[local];{$endif} {$region -fold}
type
  TProc=procedure(i,j:integer) is nested;
var
  color_info           : TColorInfo;
  obj_arr_ptr          : PObjProp;
  m1,m2,m3,m4          : integer;
  w_a_s_x,w_a_s_y      : integer;
  draw_sel_pt_proc_ind : integer;
  pts_col_inv,v,w      : TColor;
  DrawSelectedPointProc: array[0..1] of TProc;

  procedure DrawSelectedPoint0(i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
  end; {$endregion}

  procedure DrawSelectedPoint1(i,j:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    with sln_var do
      begin
        v:=Trunc(sln_pts[j].x)+w_a_s_x;
        w:=Trunc(sln_pts[j].y)+w_a_s_y;
        Rectangle(v,
                  w,
                  srf_var_ptr^.low_bmp2_ptr,
                  srf_var_ptr^.low_bmp2.width,
                  srf_var_ptr^.low_bmp2.height,
                  srf_var_ptr^.inn_wnd_rct,
                  pts_img_arr[i].local_prop);
       {Point(v,
              w,
              srf_var_ptr^.low_bmp2_ptr,
              srf_var_ptr^.low_bmp2.width,
              srf_var_ptr^.inn_wnd_rct,
              color_info);}
      end;
  end; {$endregion}

  procedure CircleSelection0;                        {$ifdef Linux}[local];{$endif} {$region -fold}
  var
    i,j: integer;
  begin
    with sel_var,sln_var do
      for i:=0 to sln_obj_cnt-1 do
        if RctCrcInt(pts_img_arr[i].rct_vis,x,y,crc_rad) then
          begin
            obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_obj_ind[partial_pts_sum[i]]]]);
            if (((obj_arr_ptr^.obj_show and %00000011) in [1,3]) or (not sel_only_pts_vis_sln)) and
                ((obj_var.sel_cnt=0) or F_MainForm.TV_Scene_Tree.Items[obj_arr_ptr^.t_ind].Selected) then
              begin
                w_a_s_x                              :=Trunc(obj_arr_ptr^.world_axis_shift.x);
                w_a_s_y                              :=Trunc(obj_arr_ptr^.world_axis_shift.y);
                pts_col_inv                          :=pts_img_arr[i].local_prop.pts_col_inv;
                pts_img_arr[i].local_prop.pts_col_inv:=selection_img .local_prop.pts_col_inv;
                for j:=partial_pts_sum[i] to partial_pts_sum[i]+sln_obj_pts_cnt[i]-1 do
                  if (sqr(Trunc(sln_pts[j].x)+w_a_s_x-x)+
                      sqr(Trunc(sln_pts[j].y)+w_a_s_y-y)<crc_rad_sqr) and
                     (not is_point_selected[j]) then
                    begin
                      is_point_selected[j]     :=True;
                      sel_pts_inds[sel_pts_cnt]:=j;
                      Inc(sel_pts_cnt);
                      Inc(sln_sel_pts_cnt[i]);
                      DrawSelectedPointProc[draw_sel_pt_proc_ind](i,j);
                    end;
                pts_img_arr[i].local_prop.pts_col_inv:=pts_col_inv;
              end;
          end;
  end; {$endregion}

  procedure CircleSelection1;                        {$ifdef Linux}[local];{$endif} {$region -fold}
  var
    i,j: integer;
  begin
    with sel_var,sln_var do
      for i:=0 to sln_obj_cnt-1 do
        if RctCrcInt(pts_img_arr[i].rct_vis,x,y,crc_rad) then
          begin
            obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_obj_ind[partial_pts_sum[i]]]]);
            if (((obj_arr_ptr^.obj_show and %00000011) in [1,3]) or (not sel_only_pts_vis_sln)) and
                ((obj_var.sel_cnt=0) or F_MainForm.TV_Scene_Tree.Items[obj_arr_ptr^.t_ind].Selected) then
              begin
                w_a_s_x                              :=Trunc(obj_arr_ptr^.world_axis_shift.x);
                w_a_s_y                              :=Trunc(obj_arr_ptr^.world_axis_shift.y);
                pts_col_inv                          :=pts_img_arr[i].local_prop.pts_col_inv;
                pts_img_arr[i].local_prop.pts_col_inv:=selection_img .local_prop.pts_col_inv;
                for j:=partial_pts_sum[i] to partial_pts_sum[i]+sln_obj_pts_cnt[i]-1 do
                  if (          sln_pts[j].x +w_a_s_x>m1)             and
                     (          sln_pts[j].x +w_a_s_x<m3)             and
                     (          sln_pts[j].y +w_a_s_y>m2)             and
                     (          sln_pts[j].y +w_a_s_y<m4)             and
                     (sqr(Trunc(sln_pts[j].x)+w_a_s_x-x)+
                      sqr(Trunc(sln_pts[j].y)+w_a_s_y-y)<crc_rad_sqr) and
                     (not is_point_selected[j])                      then
                    begin
                      is_point_selected[j]     :=True;
                      sel_pts_inds[sel_pts_cnt]:=j;
                      Inc(sel_pts_cnt);
                      Inc(sln_sel_pts_cnt[i]);
                      DrawSelectedPointProc[draw_sel_pt_proc_ind](i,j);
                    end;
                pts_img_arr[i].local_prop.pts_col_inv:=pts_col_inv;
              end;
          end;
  end; {$endregion}

  procedure CircleSelection2;                        {$ifdef Linux}[local];{$endif} {$region -fold}
  var
    i,j: integer;
  begin
    with sel_var,sln_var do
      for i:=0 to sln_obj_cnt-1 do
        if RctCrcInt(pts_img_arr[i].rct_vis,x,y,crc_rad) then
          begin
            obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_obj_ind[partial_pts_sum[i]]]]);
            if (((obj_arr_ptr^.obj_show and %00000011) in [1,3]) or (not sel_only_pts_vis_sln)) and
                ((obj_var.sel_cnt=0) or F_MainForm.TV_Scene_Tree.Items[obj_arr_ptr^.t_ind].Selected) then
              for j:=partial_pts_sum[i] to partial_pts_sum[i]+sln_obj_pts_cnt[i]-1 do
                if (sqr(Trunc(sln_pts[j].x)+obj_arr_ptr^.world_axis_shift.x-x)+
                    sqr(Trunc(sln_pts[j].y)+obj_arr_ptr^.world_axis_shift.y-y)<crc_rad_sqr) and
                   (not is_point_selected[j]) then
                  begin
                    is_point_selected[j]     :=True;
                    sel_pts_inds[sel_pts_cnt]:=j;
                    Inc(sel_pts_cnt);
                    Inc(sln_sel_pts_cnt[i]);
                    DrawSelectedPointProc[draw_sel_pt_proc_ind](i,j);
                  end;
          end;
  end; {$endregion}

  procedure CircleSelection3;                        {$ifdef Linux}[local];{$endif} {$region -fold}
  var
    i,j: integer;
  begin
    with sel_var,sln_var do
      for i:=0 to sln_obj_cnt-1 do
        if RctCrcInt(pts_img_arr[i].rct_vis,x,y,crc_rad) then
          begin
            obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_obj_ind[partial_pts_sum[i]]]]);
            if (((obj_arr_ptr^.obj_show and %00000011) in [1,3]) or (not sel_only_pts_vis_sln)) and
                ((obj_var.sel_cnt=0) or F_MainForm.TV_Scene_Tree.Items[obj_arr_ptr^.t_ind].Selected) then
              begin
                w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
                w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
                for j:=partial_pts_sum[i] to partial_pts_sum[i]+sln_obj_pts_cnt[i]-1 do
                  if (          sln_pts[j].x +w_a_s_x>m1)             and
                     (          sln_pts[j].x +w_a_s_x<m3)             and
                     (          sln_pts[j].y +w_a_s_y>m2)             and
                     (          sln_pts[j].y +w_a_s_y<m4)             and
                     (sqr(Trunc(sln_pts[j].x)+w_a_s_x-x)+
                      sqr(Trunc(sln_pts[j].y)+w_a_s_y-y)<crc_rad_sqr) and
                     (not is_point_selected[j])                      then
                    begin
                      is_point_selected[j]     :=True;
                      sel_pts_inds[sel_pts_cnt]:=j;
                      Inc(sel_pts_cnt);
                      Inc(sln_sel_pts_cnt[i]);
                      DrawSelectedPointProc[draw_sel_pt_proc_ind](i,j);
                    end;
              end;
          end;
  end; {$endregion}

begin

  {Proc. Init. Part---------------------} {$region -fold}
  DrawSelectedPointProc[0]:=@DrawSelectedPoint0;
  DrawSelectedPointProc[1]:=@DrawSelectedPoint1; {$endregion}

  {Set Bounding Rectangle---------------} {$region -fold}
  with srf_var_ptr^,inn_wnd_rct do
    begin
      m1:=left  +inn_wnd_mrg;
      m2:=top   +inn_wnd_mrg;
      m3:=right -inn_wnd_mrg;
      m4:=bottom-inn_wnd_mrg;
    end; {$endregion}

  {Drawing Of Selected Points Rectangles} {$region -fold}
  with sel_var,sln_var do
    begin
      if sel_draw then
        begin
          //SetColorInfo2(clRed,color_info);
          selection_img.bmp_dst_ptr :=srf_var_ptr^.srf_bmp_ptr;
          selection_img.ln_arr_width:=srf_var_ptr^.srf_bmp_rct.Width;
          if ((X-crc_rad>m1)  and
              (X+crc_rad<m3)  and
              (Y-crc_rad>m2)  and
              (Y+crc_rad<m4)) then
            begin
              draw_sel_pt_proc_ind:=1;
              CircleSelection0;
            end
          else
            begin
              draw_sel_pt_proc_ind:=1;
              CircleSelection1;
            end;
        end
      else
        begin
          if ((X-crc_rad>m1)  and
              (X+crc_rad<m3)  and
              (Y-crc_rad>m2)  and
              (Y+crc_rad<m4)) then
            begin
              draw_sel_pt_proc_ind:=0;
              CircleSelection2;
            end
          else
            begin
              draw_sel_pt_proc_ind:=0;
              CircleSelection3;
            end;
        end
    end; {$endregion}

end; {$endregion}
procedure TCrcSel.CircleSelectionModeDraw(x,y:integer);                                                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with srf_var_ptr^ do
    if IsPtInRct(x,y,PtRct(inn_wnd_rct.left  +crc_rad,
                           inn_wnd_rct.top   +crc_rad,
                           inn_wnd_rct.right -crc_rad,
                           inn_wnd_rct.bottom-crc_rad)) then
      Circle (x,y,crc_rad,srf_bmp_ptr,            srf_bmp.width,crc_sel_col)
    else
      CircleC(x,y,crc_rad,srf_bmp_ptr,srf_bmp.width,inn_wnd_rct,crc_sel_col);
end; {$endregion}
procedure TCrcSel.ResizeCircleSelectionModeDraw;                                                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  sel_pos: TPtPos;
begin
  GetCursorPos(TPoint(sel_pos));
  sel_pos           :=TPtPos(F_MainForm.ScreenToClient(TPoint(sel_pos)));
  srf_var_ptr^.SetPtPosToResInnWndPos(sel_pos.x,sel_pos.y);
  crc_sel_rct.left  :=sel_pos.x-crc_rad;
  crc_sel_rct.top   :=sel_pos.y-crc_rad;
  crc_sel_rct.width :=crc_rad<<1;
  crc_sel_rct.height:=crc_rad<<1;
end; {$endregion}
constructor TBrsSel.Create;                                                                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  srf_var_ptr :=@srf_var;
  draw_brs_sel:=False;
end; {$endregion}
destructor  TBrsSel.Destroy;                                                                                                                           {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
constructor TRctSel.Create;                                                                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  srf_var_ptr:=@srf_var;
  rct_width  :=10;
end; {$endregion}
destructor  TRctSel.Destroy;                                                                                                                           {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure TSelIts.ChangeSelectionMode(item_ind:TColor);                                                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  crc_sel_var.draw_crc_sel     :=item_ind in [0..1];
  brs_sel_var.draw_brs_sel     :=False;
  selection_prop.selection_mode:=TSelectionMode(item_ind);
  case selection_prop.selection_mode of
    smCircle,smBrush:
      with crc_sel_var do
        begin
          ResizeCircleSelectionModeDraw;
          AddCircleSelection;
          CrtCircleSelection;
          FilSelPtsObj(crc_sel_rct.left,crc_sel_rct.top);
        end;
  end;
end; {$endregion}
procedure TSelIts.AddCircleSelection;                                                                                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,x0,y0: integer;
begin
  with selection_img,local_prop,crc_sel_var do
    begin
      Circle(crc_rad+1,crc_rad+1,crc_rad,ln_arr1_ptr,ln_arr_width,1);
      if (selection_prop.selection_mode=smBrush) then
        begin
          Circle(crc_rad+0001,crc_rad+0001,crc_rad-06,ln_arr1_ptr,ln_arr_width,1);
         {LineH (000000000002,crc_rad+0001,0000000006,ln_arr1_ptr,ln_arr_width,1);
          LineH (crc_rad<<1-5,crc_rad+0001,crc_rad<<1,ln_arr1_ptr,ln_arr_width,1);
          LineV (crc_rad+0001,000000000002,0000000006,ln_arr1_ptr,ln_arr_width,1);
          LineV (crc_rad+0001,crc_rad<<1-5,crc_rad<<1,ln_arr1_ptr,ln_arr_width,1);}
         {for i:=0 to {sqr}(crc_rad*4) do
            begin
              x0:=Random(crc_rad);
              y0:=Random(crc_rad);
              if PtDistSqr(x0,y0,0,0)<sqr(crc_rad) then
                (ln_arr1_ptr+(crc_rad+1)+(crc_rad+1)*ln_arr_width+(1-2*Random(2))*x0+(1-2*Random(2))*y0*ln_arr_width)^:=1;
            end;}
        end;
    end;
end; {$endregion}
procedure TSelIts.PrimitiveComp(const pmt_img_ptr:PFastLine; pmt_bld_stl:TDrawingStyle; fast_image_ptr:PFastImageItem);                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with pmt_img_ptr^,local_prop,fast_image_ptr^,fast_image_data,fast_image_proc_var do
    begin
      with rct_vis do
        SetRctPos
        (
          left,
          top
        );
      SetValInfo
      (
        ln_arr1_ptr,
        ln_arr1_ptr,
        ln_arr1_ptr,
        ln_arr_width,
        ln_arr_height
      );
      SetBkgnd
      (
        bmp_dst_ptr,
        bmp_dst_width,
        bmp_dst_height,
        pmt_img_ptr^.rct_clp_ptr^
      );
      bmp_src_rct_clp:=rct_vis;
      img_kind       :={1}5;
      pix_drw_type   :=001;
      fx_cnt         :=002;
      with fx_arr[1] do
        begin
          with nt_fx_prop do
            begin
              cfx_pow0    :=200;
              rep_cnt     :=001;
              pix_srf_type:=001;
              pix_cfx_type:=GetEnumVal(pmt_bld_stl);
            end;
          pt_fx_prop:=nt_fx_prop;
        end;

      CmpProc[11];
      SdrProcInd(fast_image_data);

      {Edges Anti-Aliasing---} {$region -fold}
      if eds_aa then
        begin

          fast_image_data_ptr0:=@fast_image_data;

          {Calc. Anti-Aliased Border----------} {$region -fold}
          {ArrClear    (aa_arr1,
                       PtRct(rct_vis),
                       ln_arr_width);}
          {Fast_Primitives.}
          //ArrClear(srf_var_ptr^.test_bmp_ptr,srf_var_ptr^.inn_wnd_rct,srf_var_ptr^.test_bmp.width,1,1,1,1);

          BorderCalc1 (ln_arr1,
                       aa_arr1,
                       ln_arr_width,
                       ln_arr_width,
                       rct_vis{,
                       aa_nz_arr_items_count});
          //ArrFill (aa_arr1,srf_var_ptr^.test_bmp_ptr,srf_var_ptr^.test_bmp.width,srf_var_ptr^.test_bmp.height,srf_var_ptr^.inn_wnd_rct,False);
          {bmp_alpha_ptr2_:=bmp_alpha_ptr2;
          bmp_alpha_ptr2:=@aa_arr1[0];
          CrtPTCountArrB;
          CrtPTShiftArrB;
          CrtPTCntIndArr;
          bmp_alpha_ptr2:=bmp_alpha_ptr2_;}
          BorderCalc20(ln_arr1,
                       aa_arr1,
                       aa_arr2,
                       ln_arr_width,
                       ln_arr_width,
                       rct_vis,
                       aa_line_cnt);
          {ArrFill (aa_arr1,srf_var_ptr^.test_bmp_ptr,srf_var_ptr^.test_bmp.width,srf_var_ptr^.test_bmp.height,srf_var_ptr^.inn_wnd_rct,False);
          F_MainForm.Memo1.Lines.Text:=IntToStr(2 or 3){IntToStr(nt_pix_cnt)+';'+IntToStr(pt_pix_cnt)+';'+IntToStr(pt_pix_intr_cnt_arr[1])};} {$endregion}

          {Clear Buffer-----------------------} {$region -fold}
          FilNTValueArrA(ln_arr1,ln_arr_width); {$endregion}

          {Fill Anti-Aliased Border-----------} {$region -fold}
          BorderFill(aa_arr2,
                     0,
                     0,
                     ln_arr1_ptr,
                     ln_arr_width,
                     aa_line_cnt,
                     eds_col,
                     args); {$endregion}

          {Compress Anti-Aliased Alpha Channel} {$region -fold}
          CrtPTCountBmpO;
          CrtPTShiftBmpO;
          CrtPTCntIndArr;
          StrPTAlphaArrO; {$endregion}

          {Clear Buffer-----------------------} {$region -fold}
          FilPTValueArrA(ln_arr1,ln_arr_width);
          FilPTValueArrB(aa_arr1,ln_arr_width); {$endregion}

        end; {$endregion}

      SetRctPos (bmp_src_rct_clp);
      SdrTypeCng(fast_image_data_ptr0,
                 fast_image_data);
    end;
end; {$endregion}
procedure TSelIts.CrtCircleSelection;                                                                                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with selection_img,local_prop,sprite_sheet_arr[crc_sel_var.crc_sel_ind],fast_image_proc_var do
    begin

      fast_image_data_ptr0:=@fast_image_data;

      {Set Bounding Rectangle} {$region -fold}
      with rct_vis do
        begin
          left  :=0;
          top   :=0;
          right :=crc_sel_var.crc_rad<<1+3;
          bottom:=right;
          width :=right-left;
          height:=bottom-top;
        end; {$endregion}

      {Create Sprite---------} {$region -fold}
     {if (fast_image=Nil) then
          fast_image:=TFastImageItem.Create
        (
          bmp_dst_ptr,
          bmp_dst_width,
          bmp_dst_height,
          rct_clp_ptr^,
          rct_vis,
          0
        );} {$endregion}

      {Compress Sprite-------} {$region -fold}
      // clear buffers:
      ClrArr({%0000011111111111}%0000000011111111);

      // set color of spline edges:
      SetPPInfo(eds_col);

      // compress edges sprite:
      PrimitiveComp(@selection_img,eds_bld_stl,@sprite_sheet_arr[crc_sel_var.crc_sel_ind]); {$endregion}

    end;
end; {$endregion}
procedure TSelIts.FilSelPtsObj(const x,y:integer);                                                                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with selection_img,sprite_sheet_arr[crc_sel_var.crc_sel_ind],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_arr[0].monochrome_val:=fast_image_data.monochrome_val;
      SdrProc[sdr_proc_ind](x,y,@fast_image_data);
    end;
end; {$endregion}
procedure TSelIts.MinimizeCircleSelection;                                                                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with crc_sel_var do
    begin
      crc_rad     :=10;
      crc_rad_sqr :=crc_rad*crc_rad;
      ResizeCircleSelectionModeDraw;
      AddCircleSelection;
      CrtCircleSelection;
      FilSelPtsObj(crc_sel_rct.left,crc_sel_rct.top);
    end;
end; {$endregion}
procedure TSelIts.SelectAllPts(const pts_cnt,eds_cnt:TColor);                                                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TSelIts.SubgraphCalc(var has_sel_pts:T1Byte1Arr; const pts:TPtPosFArr; const fst_lst_sln_obj_pts:TEnum0Arr; const obj_ind:TWordArr; const sln_obj_cnt:TColor; const sln_pts_cnt:TColor); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  outer_subgraph1_ptr        : PEdge;
  outer_subgraph2_ptr        : PEdge;
  outer_subgraph3_ptr        : PEdge;
  inner_subgraph__ptr        : PEdge;
  sl_pt_subgraph__ptr        : PSlPt;
  obj_ind_ptr                : PWord{PInteger};
  sel_pts_inds_ptr           : PInteger;
  is_point_selected_ptr      : PByteBool;
  out_or_inn_subgraph_pts_ptr: PByte;
  fst_lst_sln_obj_pts_ptr    : PByte;
  has_sel_pts_ptr            : PByte;
  f_arr                      : TColorArr;
  i,c                        : integer;
  b                          : integer;
begin

  {Misc. Precalc.-------------------------------} {$region -fold}
  c:=Min(2*sel_pts_cnt,sln_pts_cnt); {$endregion}

  {Clear Arrays---------------------------------} {$region -fold}
 {SetLength(outer_subgraph1,0);
  SetLength(outer_subgraph2,0);
  SetLength(outer_subgraph3,0);
  SetLength(inner_subgraph_,0);
  SetLength(sl_pt_subgraph_,0);}
  FillByte(has_sel_pts[0],Length(has_sel_pts),0); {$endregion}

  {Create Arrays--------------------------------} {$region -fold}
  if (c          >Length(outer_subgraph1)) then
               SetLength(outer_subgraph1,c          );
  if (c          >Length(outer_subgraph2)) then
               SetLength(outer_subgraph2,c          );
  if (c          >Length(outer_subgraph3)) then
               SetLength(outer_subgraph3,c          );
  if (sel_pts_cnt>Length(inner_subgraph_)) then
               SetLength(inner_subgraph_,sel_pts_cnt);
  if (sel_pts_cnt>Length(sl_pt_subgraph_)) then
               SetLength(sl_pt_subgraph_,sel_pts_cnt); {$endregion}

  {Outer, Inner Subgraph and Single Points Calc.} {$region -fold}
  obj_ind_ptr                :=Unaligned(@obj_ind                [0]);
  fst_lst_sln_obj_pts_ptr    :=Unaligned(@fst_lst_sln_obj_pts    [0]);
  is_point_selected_ptr      :=Unaligned(@is_point_selected      [0]);
  has_sel_pts_ptr            :=Unaligned(@has_sel_pts            [0]);
  sel_pts_inds_ptr           :=Unaligned(@sel_pts_inds           [0]);
  outer_subgraph1_ptr        :=Unaligned(@outer_subgraph1        [0]);
  outer_subgraph2_ptr        :=Unaligned(@outer_subgraph2        [0]);
  outer_subgraph3_ptr        :=Unaligned(@outer_subgraph3        [0]);
  inner_subgraph__ptr        :=Unaligned(@inner_subgraph_        [0]);
  sl_pt_subgraph__ptr        :=Unaligned(@sl_pt_subgraph_        [0]);
  out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
  for i:=0 to sel_pts_cnt-1 do
    begin
      case (fst_lst_sln_obj_pts_ptr+sel_pts_inds_ptr^)^ of
        0: {Inner  Spline Object Point} {$region -fold}
          begin
            if (is_point_selected_ptr+sel_pts_inds_ptr^-1)^ then
              begin
                {Inner Subgraph Calc.}
              //{--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^-1)^:= 2;
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:= 2;
                {--------------------}inner_subgraph__ptr^.first_point                  := 00000000000+sel_pts_inds_ptr^-1;
                {--------------------}inner_subgraph__ptr^.last_point                   := 00000000000+sel_pts_inds_ptr^+0;
                {--------------------}inner_subgraph__ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                case (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^ of
                  0: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=2;
                  1: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=3;
                  2: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=2;
                  3: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=3;
                end;
                Inc(inner_subgraph__ptr);
                if (not (is_point_selected_ptr+sel_pts_inds_ptr^+1)^) then
                  begin
                    {Outer Subgraph 3 Calc.}
                    {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+1)^:= 1;
                    {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:= 1;
                    {--------------------}outer_subgraph3_ptr^.first_point                  := 00000000000+sel_pts_inds_ptr^+1;
                    {--------------------}outer_subgraph3_ptr^.last_point                   := 00000000000+sel_pts_inds_ptr^+0;
                    {--------------------}outer_subgraph3_ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                    case (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^ of
                      0: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=1;
                      1: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=1;
                      2: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=3;
                      3: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=3;
                    end;
                    Inc(outer_subgraph3_ptr);
                  end;
              end
            else
              begin
                if (is_point_selected_ptr+sel_pts_inds_ptr^+1)^ then
                  begin
                    {Outer Subgraph 3 Calc.}
                    {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^-1)^:= 1;
                    {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:= 1;
                    {--------------------}outer_subgraph3_ptr^.first_point                  := 00000000000+sel_pts_inds_ptr^-1;
                    {--------------------}outer_subgraph3_ptr^.last_point                   := 00000000000+sel_pts_inds_ptr^+0;
                    {--------------------}outer_subgraph3_ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                    case (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^ of
                      0: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=1;
                      1: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=1;
                      2: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=3;
                      3: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=3;
                    end;
                    Inc(outer_subgraph3_ptr);
                  end
                else
                  begin
                    {Outer Subgraph 1,2 Calc.}
                    {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^-1)^:= 1;
                    {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:= 1;
                    {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+1)^:= 1;
                    {--------------------}outer_subgraph1_ptr^.first_point                  := 00000000000+sel_pts_inds_ptr^-1;
                    {--------------------}outer_subgraph1_ptr^.last_point                   := 00000000000+sel_pts_inds_ptr^+0;
                    {--------------------}outer_subgraph1_ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                    {--------------------}outer_subgraph2_ptr^.first_point                  := 00000000000+sel_pts_inds_ptr^+1;
                    {--------------------}outer_subgraph2_ptr^.last_point                   := 00000000000+sel_pts_inds_ptr^+0;
                    {--------------------}outer_subgraph2_ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                    case (has_sel_pts_ptr+outer_subgraph2_ptr^.obj_ind)^ of
                      0: (has_sel_pts_ptr+outer_subgraph2_ptr^.obj_ind)^:=1;
                      1: (has_sel_pts_ptr+outer_subgraph2_ptr^.obj_ind)^:=1;
                      2: (has_sel_pts_ptr+outer_subgraph2_ptr^.obj_ind)^:=3;
                      3: (has_sel_pts_ptr+outer_subgraph2_ptr^.obj_ind)^:=3;
                    end;
                    Inc(outer_subgraph1_ptr);
                    Inc(outer_subgraph2_ptr);
                  end;
              end;
          end; {$endregion}
        1: {First  Spline Object Point} {$region -fold}
          begin
            if (not (is_point_selected_ptr+sel_pts_inds_ptr^+1)^) then
              begin
                {Outer Subgraph 3 Calc.}
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+1)^:= 1;
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:= 1;
                {--------------------}outer_subgraph3_ptr^.first_point                  := 00000000000+sel_pts_inds_ptr^+1;
                {--------------------}outer_subgraph3_ptr^.last_point                   := 00000000000+sel_pts_inds_ptr^+0;
                {--------------------}outer_subgraph3_ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                case (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^ of
                  0: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=1;
                  1: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=1;
                  2: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=3;
                  3: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=3;
                end;
                Inc(outer_subgraph3_ptr);
              end
            else
              begin
                {Inner Subgraph Calc.}
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+1)^:= 2;
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:= 2;
                {--------------------}inner_subgraph__ptr^.first_point                  := 00000000000+sel_pts_inds_ptr^+0;
                {--------------------}inner_subgraph__ptr^.last_point                   := 00000000000+sel_pts_inds_ptr^+1;
                {--------------------}inner_subgraph__ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                case (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^ of
                  0: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=2;
                  1: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=3;
                  2: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=2;
                  3: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=3;
                end;
                Inc(inner_subgraph__ptr);
              end;
          end; {$endregion}
        2: {Last   Spline Object Point} {$region -fold}
          begin
            if (is_point_selected_ptr+sel_pts_inds_ptr^-1)^ then
              begin
                {Inner Subgraph Calc.}
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^-1)^:=2;
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:=2;
                {--------------------}inner_subgraph__ptr^.first_point                  :=000000000000+sel_pts_inds_ptr^-1;
                {--------------------}inner_subgraph__ptr^.last_point                   :=000000000000+sel_pts_inds_ptr^+0;
                {--------------------}inner_subgraph__ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                case (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^ of
                  0: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=2;
                  1: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=3;
                  2: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=2;
                  3: (has_sel_pts_ptr+inner_subgraph__ptr^.obj_ind)^:=3;
                end;
                Inc(inner_subgraph__ptr);
              end
            else
              begin
                {Outer Subgraph 3 Calc.}
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^-1)^:=1;
                {--------------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:=1;
                {--------------------}outer_subgraph3_ptr^.first_point                  :=000000000000+sel_pts_inds_ptr^-1;
                {--------------------}outer_subgraph3_ptr^.last_point                   :=000000000000+sel_pts_inds_ptr^+0;
                {--------------------}outer_subgraph3_ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^+0)^;
                case (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^ of
                  0: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=1;
                  1: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=1;
                  2: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=3;
                  3: (has_sel_pts_ptr+outer_subgraph3_ptr^.obj_ind)^:=3;
                end;
                Inc(outer_subgraph3_ptr);
              end;
          end; {$endregion}
        3: {Single Spline Object Point} {$region -fold}
          begin
             {--------------}(out_or_inn_subgraph_pts_ptr+sel_pts_inds_ptr^+0)^:=2;
             {--------------}sl_pt_subgraph__ptr^.point                        :=000000000000+sel_pts_inds_ptr^;
             {--------------}sl_pt_subgraph__ptr^.obj_ind                      :=(obj_ind_ptr+sel_pts_inds_ptr^)^;
            (has_sel_pts_ptr+sl_pt_subgraph__ptr^.obj_ind)^:=4;
            Inc(sl_pt_subgraph__ptr);
          end; {$endregion}
      end;
      Inc(sel_pts_inds_ptr);
    end; {$endregion}

  {Edges Count----------------------------------} {$region -fold}
  outer_subgraph1_eds_cnt:=PEdge(outer_subgraph1_ptr)-PEdge(@outer_subgraph1[0]);
  outer_subgraph2_eds_cnt:=PEdge(outer_subgraph2_ptr)-PEdge(@outer_subgraph2[0]);
  outer_subgraph3_eds_cnt:=PEdge(outer_subgraph3_ptr)-PEdge(@outer_subgraph3[0]);
  inner_subgraph__eds_cnt:=PEdge(inner_subgraph__ptr)-PEdge(@inner_subgraph_[0]);
  sl_pt_subgraph__eds_cnt:=PSlPt(sl_pt_subgraph__ptr)-PSlPt(@sl_pt_subgraph_[0]); {$endregion}

  {Count of Splines with Selected Points--------} {$region -fold}
  sln_with_sel_pts_cnt:=ArrNzItCnt(has_sel_pts,4); {$endregion}

  {Selected Points Rectangle Calc.--------------} {$region -fold}
  sel_pts_rct:=obj_var.PtsRngIndsRctCalc(pts,sel_pts_inds,sel_pts_cnt);
  with sel_pts_rct do
    begin
      left  :=sel_pts_rct.left  -sel_pts_rct_mrgn;
      top   :=sel_pts_rct.top   -sel_pts_rct_mrgn;
      right :=sel_pts_rct.right +sel_pts_rct_mrgn;
      bottom:=sel_pts_rct.bottom+sel_pts_rct_mrgn;
      width :=right-left;
      height:=bottom-top;
    end; {$endregion}

  {Minimal Index of Selected Spline-------------} {$region -fold}
  f_arr:=Nil;
  f_arr:=TColorArr.Create
  (
    obj_var.Min9(obj_var.curve_inds_obj_arr,outer_subgraph1,obj_var.obj_cnt-1,outer_subgraph1_eds_cnt),
    obj_var.Min9(obj_var.curve_inds_obj_arr,outer_subgraph2,obj_var.obj_cnt-1,outer_subgraph2_eds_cnt),
    obj_var.Min9(obj_var.curve_inds_obj_arr,outer_subgraph3,obj_var.obj_cnt-1,outer_subgraph3_eds_cnt),
    obj_var.Min9(obj_var.curve_inds_obj_arr,inner_subgraph_,obj_var.obj_cnt-1,inner_subgraph__eds_cnt),
    obj_var.Min9(obj_var.curve_inds_obj_arr,sl_pt_subgraph_,obj_var.obj_cnt-1,sl_pt_subgraph__eds_cnt)
  );
  sel_obj_min_ind:=Min5(f_arr,obj_var.obj_cnt-1,5); {$endregion}

end; {$endregion}
procedure TSelIts.UnselectedPtsCalc0(const fst_lst_sln_obj_pts:TEnum0Arr; var pts:TPtPosFArr; const pvt_pos_curr,pvt_pos_prev:TPtPosF);        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                : PPtPosF;
  selected_pts_inds_ptr  : PInteger;
  fst_lst_sln_obj_pts_ptr: PByte;
  is_pt_selected_ptr     : PByteBool;
  i,n1,n2                : integer;
begin

  {Misc. Precalc.----------------------------------------} {$region -fold}
  n1:=Trunc(pvt_pos_curr.x)-Trunc(pvt_pos_prev.x);
  n2:=Trunc(pvt_pos_curr.y)-Trunc(pvt_pos_prev.y); {$endregion}

  {Calculation Of Inner Subgraph Points On Unselect Pivot} {$region -fold}
  pts_ptr                :=Unaligned(@pts                [0]);
  fst_lst_sln_obj_pts_ptr:=Unaligned(@fst_lst_sln_obj_pts[0]);
  is_pt_selected_ptr     :=Unaligned(@is_point_selected  [0]);
  selected_pts_inds_ptr  :=Unaligned(@sel_pts_inds       [0]);
  {if {inner_subgraph_img.local_prop.eds_show or}
    (inner_subgraph_img.local_prop.eds_show and (not outer_subgraph_img.local_prop.eds_show)) then}
    for i:=0 to sel_pts_cnt-1 do
      begin
        case (fst_lst_sln_obj_pts_ptr+selected_pts_inds_ptr^)^ of
         {0: {Inner  Spline Object Point} {$region -fold}
            if (is_pt_selected_ptr+selected_pts_inds_ptr^-1)^ and
               (is_pt_selected_ptr+selected_pts_inds_ptr^+1)^ then
              begin
                (pts_ptr+selected_pts_inds_ptr^)^.x+=n1;
                (pts_ptr+selected_pts_inds_ptr^)^.y+=n2;
              end; {$endregion}
          1: {First  Spline Object Point} {$region -fold}
            if (is_pt_selected_ptr+selected_pts_inds_ptr^+1)^ then
              begin
                (pts_ptr+selected_pts_inds_ptr^)^.x+=n1;
                (pts_ptr+selected_pts_inds_ptr^)^.y+=n2;
              end; {$endregion}
          2: {Last   Spline Object Point} {$region -fold}
            if (is_pt_selected_ptr+selected_pts_inds_ptr^-1)^ then
              begin
                (pts_ptr+selected_pts_inds_ptr^)^.x+=n1;
                (pts_ptr+selected_pts_inds_ptr^)^.y+=n2;
              end; {$endregion}
         }3: {Single Spline Object Point} {$region -fold}
            begin
              (pts_ptr+selected_pts_inds_ptr^)^.x+=n1;
              (pts_ptr+selected_pts_inds_ptr^)^.y+=n2;
            end; {$endregion}
        end;
        Inc(selected_pts_inds_ptr);
      end
  {else
    for i:=0 to sel_pts_cnt-1 do
      begin
        case (fst_lst_sln_obj_pts_ptr+selected_pts_inds_ptr^)^ of
          0: {Inner  Spline Object Point} {$region -fold}
            if (is_pt_selected_ptr+selected_pts_inds_ptr^-1)^ and
               (is_pt_selected_ptr+selected_pts_inds_ptr^+1)^ then
              begin
                (pts_ptr+selected_pts_inds_ptr^)^.x+=n1;
                (pts_ptr+selected_pts_inds_ptr^)^.y+=n2;
              end; {$endregion}
          1: {First  Spline Object Point} {$region -fold}
            if (is_pt_selected_ptr+selected_pts_inds_ptr^+1)^ then
              begin
                (pts_ptr+selected_pts_inds_ptr^)^.x+=n1;
                (pts_ptr+selected_pts_inds_ptr^)^.y+=n2;
              end; {$endregion}
          2: {Last   Spline Object Point} {$region -fold}
            if (is_pt_selected_ptr+selected_pts_inds_ptr^-1)^ then
              begin
                (pts_ptr+selected_pts_inds_ptr^)^.x+=n1;
                (pts_ptr+selected_pts_inds_ptr^)^.y+=n2;
              end; {$endregion}
          3: {Single Spline Object Point} {$region -fold}
            begin
              (pts_ptr+selected_pts_inds_ptr^)^.x+=n1;
              (pts_ptr+selected_pts_inds_ptr^)^.y+=n2;
            end; {$endregion}
        end;
        Inc(selected_pts_inds_ptr);
      end}; {$endregion}

end; {$endregion}
procedure TSelIts.UnselectedPtsCalc1(const fst_lst_sln_obj_pts:TEnum0Arr; var pts:TPtPosFArr; const pvt_pos_curr,pvt_pos_prev:TPtPosF);        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  outer_subgraph1_ptr        : PEdge;
  outer_subgraph3_ptr        : PEdge;
  inner_subgraph__ptr        : PEdge;
  out_or_inn_subgraph_pts_ptr: PByte;
  pts_f3,pts_l3              : TPtPosF;
  pts_ptr                    : PPtPosF;
  i,n1,n2                    : integer;
begin

  {Misc. Precalc.----------------------------------------} {$region -fold}
  n1:=Trunc(pvt_pos_curr.x)-Trunc(pvt_pos_prev.x);
  n2:=Trunc(pvt_pos_curr.y)-Trunc(pvt_pos_prev.y); {$endregion}

  {Calculation Of Inner Subgraph Points On Unselect Pivot} {$region -fold}
  pts_ptr:=Unaligned(@pts[0]);
  if (not (outer_subgraph_img.local_prop.eds_show  and (not inner_subgraph_img.local_prop.eds_show))) then
    begin
      if (outer_subgraph1_eds_cnt>0) then
        begin
          outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
          for i:=0 to  outer_subgraph1_eds_cnt-1 do
            begin
              is_point_pos_calc[outer_subgraph1_ptr^.last_point]:=True;
              (pts_ptr+outer_subgraph1_ptr^.last_point)^.x+=n1;
              (pts_ptr+outer_subgraph1_ptr^.last_point)^.y+=n2;
              Inc     (outer_subgraph1_ptr);
            end;
        end;
      if (outer_subgraph3_eds_cnt>0) then
        begin
          outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
          for i:=0 to  outer_subgraph3_eds_cnt-1 do
            begin
              is_point_pos_calc[outer_subgraph3_ptr^.last_point]:=True;
              (pts_ptr+outer_subgraph3_ptr^.last_point)^.x+=n1;
              (pts_ptr+outer_subgraph3_ptr^.last_point)^.y+=n2;
              Inc     (outer_subgraph3_ptr);
            end;
        end;
    end
  else
    begin
      if (outer_subgraph1_eds_cnt>0) then
        begin
          outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
          for i:=0 to  outer_subgraph1_eds_cnt-1 do
            begin
              is_point_pos_calc[outer_subgraph1_ptr^.last_point]:=True;
              Inc              (outer_subgraph1_ptr);
            end;
        end;
      if (outer_subgraph3_eds_cnt>0) then
        begin
          outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
          for i:=0 to  outer_subgraph3_eds_cnt-1 do
            begin
              is_point_pos_calc[outer_subgraph3_ptr^.last_point]:=True;
              Inc              (outer_subgraph3_ptr);
            end;
        end;
    end;
  {if (outer_subgraph_img.local_prop.eds_show  and (not inner_subgraph_img.local_prop.eds_show)) then
    begin
      n1:=Trunc(pvt_pos_curr.x)-Trunc(pvt_var.pvt_origin.x);
      n2:=Trunc(pvt_pos_curr.y)-Trunc(pvt_var.pvt_origin.y);
    end;}
  if (outer_subgraph3_eds_cnt>0) then
    begin
      out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
      inner_subgraph__ptr        :=Unaligned(@inner_subgraph_        [0]);
      for i:=0 to  inner_subgraph__eds_cnt-1 do
        begin
          pts_f3:=(pts_ptr+inner_subgraph__ptr^.first_point)^;
          pts_l3:=(pts_ptr+inner_subgraph__ptr^.last_point )^;
          if ((out_or_inn_subgraph_pts_ptr+inner_subgraph__ptr^.first_point)^=2) then
            if (not is_point_pos_calc[inner_subgraph__ptr^.first_point]) then
              begin
                pts_f3.x+=n1;
                pts_f3.y+=n2;
                is_point_pos_calc[inner_subgraph__ptr^.first_point]:=True;
              end;
          if ((out_or_inn_subgraph_pts_ptr+inner_subgraph__ptr^.last_point )^=2) then
            if (not is_point_pos_calc[inner_subgraph__ptr^.last_point]) then
              begin
                pts_l3.x+=n1;
                pts_l3.y+=n2;
                is_point_pos_calc[inner_subgraph__ptr^.last_point]:=True;
              end;
          (pts_ptr+inner_subgraph__ptr^.first_point)^:=pts_f3;
          (pts_ptr+inner_subgraph__ptr^.last_point )^:=pts_l3;
          Inc(inner_subgraph__ptr);
        end;
     end; {$endregion}

  SelPtsIndsToFalse2;

end; {$endregion}
procedure TSelIts.SelPtsIndsToFalse1;                                                                                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  selected_pts_inds_ptr      : PInteger;
  is_point_selected_ptr      : PByteBool;
  is_point_pos_calc_ptr      : PByteBool;
  out_or_inn_subgraph_pts_ptr: PByte;
  i                          : integer;
begin
  is_point_selected_ptr:=Unaligned(@is_point_selected[0]);
  is_point_pos_calc_ptr:=Unaligned(@is_point_pos_calc[0]);
  selected_pts_inds_ptr:=Unaligned(@sel_pts_inds     [0]);
  out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
  for i:=0 to sel_pts_cnt-1 do
    begin
      (out_or_inn_subgraph_pts_ptr+selected_pts_inds_ptr^)^:=0;
      (is_point_selected_ptr      +selected_pts_inds_ptr^)^:=False;
      (is_point_pos_calc_ptr      +selected_pts_inds_ptr^)^:=False;
      Inc(selected_pts_inds_ptr);
    end;
end; {$endregion}
procedure TSelIts.SelPtsIndsToFalse2;                                                                                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  selected_pts_inds_ptr: PInteger;
  is_point_pos_calc_ptr: PByteBool;
  i                    : integer;
begin
  is_point_pos_calc_ptr:=Unaligned(@is_point_pos_calc[0]);
  selected_pts_inds_ptr:=Unaligned(@sel_pts_inds     [0]);
  for i:=0 to sel_pts_cnt-1 do
    begin
      (is_point_pos_calc_ptr+selected_pts_inds_ptr^)^:=False;
      Inc(selected_pts_inds_ptr);
    end;
end; {$endregion}
procedure TSelIts.DuplicatedPtsCalc;                                                                                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure TSelIts.AdvancedClipCalc(pts:TPtPosFArr; pts_cnt:TColor; is_pt_marked:TBool1Arr);                                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure TSelIts.DuplicatedPtsToBmp;                                                                                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {TODO}
end; {$endregion}
procedure TSelIts.OuterSubgraphCalc0(x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct_clp  :TPtRect);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr            : PPtPosF;
  outer_subgraph1_ptr: PEdge;
  outer_subgraph3_ptr: PEdge;
  i                  : integer;
begin

  if (outer_subgraph1_eds_cnt=0) and
     (outer_subgraph3_eds_cnt=0) then
    Exit;

  if fill_bmp_only then
    Exit;

  {Drawing Of Outer Subgraph Lines} {$region -fold}
  if (outer_subgraph1_eds_cnt>0) then
    begin
      pts_ptr            :=Unaligned(@pts            [0]);
      outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
      for i:=0 to outer_subgraph1_eds_cnt-1 do
        begin
          is_point_pos_calc[outer_subgraph1_ptr^.last_point]:=True;
          (pts_ptr+outer_subgraph1_ptr^.last_point)^.x+=pvt_var.pos_dif.x;
          (pts_ptr+outer_subgraph1_ptr^.last_point)^.y+=pvt_var.pos_dif.y;
          Inc(outer_subgraph1_ptr);
        end;
    end;
  if (outer_subgraph3_eds_cnt>0) then
    begin
      pts_ptr            :=Unaligned(@pts            [0]);
      outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
      for i:=0 to outer_subgraph3_eds_cnt-1 do
        begin
          is_point_pos_calc[outer_subgraph3_ptr^.last_point]:=True;
          (pts_ptr+outer_subgraph3_ptr^.last_point)^.x+=pvt_var.pos_dif.x;
          (pts_ptr+outer_subgraph3_ptr^.last_point)^.y+=pvt_var.pos_dif.y;
          Inc(outer_subgraph3_ptr);
        end;
    end; {$endregion}

end; {$endregion}
procedure TSelIts.OuterSubgraphCalc1(x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct_clp  :TPtRect);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr            : PPtPosF;
  outer_subgraph1_ptr: PEdge;
  outer_subgraph3_ptr: PEdge;
  i                  : integer;
begin

  if (outer_subgraph1_eds_cnt=0) and
     (outer_subgraph3_eds_cnt=0) then
    Exit;

  if fill_bmp_only then
    Exit;

  if (pvt_var.scl_dir=sdNone) then
    Exit;

  {Drawing Of Outer Subgraph Lines} {$region -fold}
  if (outer_subgraph1_eds_cnt>0) then
    begin
      pts_ptr            :=Unaligned(@pts            [0]);
      outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
      for i:=0 to outer_subgraph1_eds_cnt-1 do
        with outer_subgraph1_ptr^ do
          begin
            is_point_pos_calc[last_point]:=True;
            (pts_ptr+         last_point)^.x*=pvt_var.pvt_scl.x;
            (pts_ptr+         last_point)^.x+=pvt_var.scl_dif.x;
            (pts_ptr+         last_point)^.y*=pvt_var.pvt_scl.y;
            (pts_ptr+         last_point)^.y+=pvt_var.scl_dif.y;
            Inc(outer_subgraph1_ptr);
          end;
    end;
  if (outer_subgraph3_eds_cnt>0) then
    begin
      pts_ptr            :=Unaligned(@pts            [0]);
      outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
      for i:=0 to outer_subgraph3_eds_cnt-1 do
        with outer_subgraph3_ptr^ do
          begin
            is_point_pos_calc[last_point]:=True;
            (pts_ptr+         last_point)^.x*=pvt_var.pvt_scl.x;
            (pts_ptr+         last_point)^.x+=pvt_var.scl_dif.x;
            (pts_ptr+         last_point)^.y*=pvt_var.pvt_scl.y;
            (pts_ptr+         last_point)^.y+=pvt_var.scl_dif.y;
            Inc(outer_subgraph3_ptr);
          end;
    end; {$endregion}

end; {$endregion}
procedure TSelIts.OuterSubgraphCalc2(x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct_clp  :TPtRect);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr            : PPtPosF;
  outer_subgraph1_ptr: PEdge;
  outer_subgraph3_ptr: PEdge;
  i                  : integer;
begin
  {Rotation: TODO}
end; {$endregion}
procedure TSelIts.OuterSubgraphDraw (x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct_clp  :TPtRect);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr1       : PObjProp;
  obj_arr_ptr2       : PObjProp;
  rct                : TPtRect;
  pts_ptr            : PPtPosF;
  pts_f1,pts_l1      : TPtPosF;
  pts_f2,pts_l2      : TPtPosF;
  pts_f3,pts_l3      : TPtPosF;
  outer_subgraph1_ptr: PEdge;
  outer_subgraph2_ptr: PEdge;
  outer_subgraph3_ptr: PEdge;
  i,m1,m2,m3,m4      : integer;
label
  lbl_flood_fill_only;
begin

  if (outer_subgraph1_eds_cnt=0) and
     (outer_subgraph3_eds_cnt=0) then
    Exit;

  outer_subgraph_img.bmp_dst_ptr:=bmp_dst_ptr;

  if fill_bmp_only then
    goto lbl_flood_fill_only;

  {Set Drawing Bounds(Inner Window)--} {$region -fold}
  with rct_clp do
    begin
      m1:=left  +grid_pt_rad;
      m2:=top   +grid_pt_rad;
      m3:=right -grid_pt_rad-1;
      m4:=bottom-grid_pt_rad-1;
    end;
  rct:=PtRct(m1,m2,m3,m4); {$endregion}

  {Clear Arrays----------------------} {$region -fold}
  with outer_subgraph_img do
    begin
      ArrClr(ln_arr0,rct_clp,ln_arr_width);
      ArrClr(ln_arr2,rct_clp);
    end; {$endregion}

  {Drawing Of Outer Subgraph Lines---} {$region -fold}
  with outer_subgraph_img do
    case local_prop.clp_stl of
      (csClippedEdges1 ): {Clipped Edges 1(Slow  )} {$region -fold}
        begin
          {Drawing Of Outer Subgraph 1,2} {$region -fold}
          if (outer_subgraph1_eds_cnt>0) then
            begin
              pts_ptr            :=Unaligned(@pts            [0]);
              outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
              outer_subgraph2_ptr:=Unaligned(@outer_subgraph2[0]);
              for i:=0 to outer_subgraph1_eds_cnt-1 do
                begin
                  if (sln_var.has_edge[Min(outer_subgraph1_ptr^.first_point,outer_subgraph1_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph1_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph1_ptr^.last_point ]]]);
                      ClippedLine1(Trunc((pts_ptr+outer_subgraph1_ptr^.first_point)^.x+obj_arr_ptr1^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph1_ptr^.first_point)^.y+obj_arr_ptr1^.world_axis_shift.y),
                                   Trunc((pts_ptr+outer_subgraph1_ptr^.last_point )^.x+obj_arr_ptr2^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph1_ptr^.last_point )^.y+obj_arr_ptr2^.world_axis_shift.y),
                                   rct,
                                   Unaligned(@LineSME),
                                   Nil,
                                   Nil,
                                   Nil);
                    end;
                  if (sln_var.has_edge[Min(outer_subgraph2_ptr^.first_point,outer_subgraph2_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph2_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph2_ptr^.last_point ]]]);
                      ClippedLine1(Trunc((pts_ptr+outer_subgraph2_ptr^.first_point)^.x+obj_arr_ptr1^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph2_ptr^.first_point)^.y+obj_arr_ptr1^.world_axis_shift.y),
                                   Trunc((pts_ptr+outer_subgraph2_ptr^.last_point )^.x+obj_arr_ptr2^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph2_ptr^.last_point )^.y+obj_arr_ptr2^.world_axis_shift.y),
                                   rct,
                                   Unaligned(@LineSME),
                                   Nil,
                                   Nil,
                                   Nil);
                    end;
                  Inc(outer_subgraph1_ptr);
                  Inc(outer_subgraph2_ptr);
                end;
            end; {$endregion}
          {Drawing Of Outer Subgraph 3  } {$region -fold}
          if (outer_subgraph3_eds_cnt>0) then
            begin
              pts_ptr            :=Unaligned(@pts            [0]);
              outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
              for i:=0 to outer_subgraph3_eds_cnt-1 do
                begin
                  if (sln_var.has_edge[Min(outer_subgraph3_ptr^.first_point,outer_subgraph3_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph3_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph3_ptr^.last_point ]]]);
                      ClippedLine1(Trunc((pts_ptr+outer_subgraph3_ptr^.first_point)^.x+obj_arr_ptr1^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph3_ptr^.first_point)^.y+obj_arr_ptr1^.world_axis_shift.y),
                                   Trunc((pts_ptr+outer_subgraph3_ptr^.last_point )^.x+obj_arr_ptr2^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph3_ptr^.last_point )^.y+obj_arr_ptr2^.world_axis_shift.y),
                                   rct,
                                   Unaligned(@LineSME),
                                   Nil,
                                   Nil,
                                   Nil);
                    end;
                  Inc(outer_subgraph3_ptr);
                end;
            end; {$endregion}
        end; {$endregion}
      (csClippedEdges2 ): {Clipped Edges 2(Slow  )} {$region -fold}
        begin
          {Drawing Of Outer Subgraph 1,2} {$region -fold}
          if (outer_subgraph1_eds_cnt>0) then
            begin
              pts_ptr            :=Unaligned(@pts            [0]);
              outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
              outer_subgraph2_ptr:=Unaligned(@outer_subgraph2[0]);
              for i:=0 to outer_subgraph1_eds_cnt-1 do
                begin
                  if (sln_var.has_edge[Min(outer_subgraph1_ptr^.first_point,outer_subgraph1_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph1_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph1_ptr^.last_point ]]]);
                      ClippedLine2(Trunc((pts_ptr+outer_subgraph1_ptr^.first_point)^.x+obj_arr_ptr1^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph1_ptr^.first_point)^.y+obj_arr_ptr1^.world_axis_shift.y),
                                   Trunc((pts_ptr+outer_subgraph1_ptr^.last_point )^.x+obj_arr_ptr2^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph1_ptr^.last_point )^.y+obj_arr_ptr2^.world_axis_shift.y),
                                   rct,
                                   Unaligned(@LineSME),
                                   Nil,
                                   Nil,
                                   Nil);
                    end;
                  if (sln_var.has_edge[Min(outer_subgraph2_ptr^.first_point,outer_subgraph2_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph2_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph2_ptr^.last_point ]]]);
                      ClippedLine2(Trunc((pts_ptr+outer_subgraph2_ptr^.first_point)^.x+obj_arr_ptr1^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph2_ptr^.first_point)^.y+obj_arr_ptr1^.world_axis_shift.y),
                                   Trunc((pts_ptr+outer_subgraph2_ptr^.last_point )^.x+obj_arr_ptr2^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph2_ptr^.last_point )^.y+obj_arr_ptr2^.world_axis_shift.y),
                                   rct,
                                   Unaligned(@LineSME),
                                   Nil,
                                   Nil,
                                   Nil);
                    end;
                  Inc(outer_subgraph1_ptr);
                  Inc(outer_subgraph2_ptr);
                end;
            end; {$endregion}
          {Drawing Of Outer Subgraph 3  } {$region -fold}
          if (outer_subgraph3_eds_cnt>0) then
            begin
              pts_ptr            :=Unaligned(@pts            [0]);
              outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
              for i:=0 to outer_subgraph3_eds_cnt-1 do
                begin
                  if (sln_var.has_edge[Min(outer_subgraph3_ptr^.first_point,outer_subgraph3_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph3_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph3_ptr^.last_point ]]]);
                      ClippedLine2(Trunc((pts_ptr+outer_subgraph3_ptr^.first_point)^.x+obj_arr_ptr1^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph3_ptr^.first_point)^.y+obj_arr_ptr1^.world_axis_shift.y),
                                   Trunc((pts_ptr+outer_subgraph3_ptr^.last_point )^.x+obj_arr_ptr2^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph3_ptr^.last_point )^.y+obj_arr_ptr2^.world_axis_shift.y),
                                   rct,
                                   Unaligned(@LineSME),
                                   Nil,
                                   Nil,
                                   Nil);
                    end;
                  Inc(outer_subgraph3_ptr);
                end;
            end; {$endregion}
        end; {$endregion}
      (csRemoveEdges   ): {Remove Edges---(Fast  )} {$region -fold}
        begin
          {Drawing Of Outer Subgraph 1,2} {$region -fold}
          if (outer_subgraph1_eds_cnt>0) then
            begin
              pts_ptr            :=Unaligned(@pts            [0]);
              outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
              outer_subgraph2_ptr:=Unaligned(@outer_subgraph2[0]);
              for i:=0 to outer_subgraph1_eds_cnt-1 do
                begin
                  pts_f1      :=(pts_ptr+outer_subgraph1_ptr^.first_point)^;
                  pts_l1      :=(pts_ptr+outer_subgraph1_ptr^.last_point )^;
                  obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph1_ptr^.first_point]]]);
                  obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph1_ptr^.last_point ]]]);
                  if IsPtInRct(PtPosF(pts_f1.x+obj_arr_ptr1^.world_axis_shift.x,pts_f1.y+obj_arr_ptr1^.world_axis_shift.y),rct) and
                     IsPtInRct(PtPosF(pts_l1.x+obj_arr_ptr2^.world_axis_shift.x,pts_l1.y+obj_arr_ptr2^.world_axis_shift.y),rct) and
                     (sln_var.has_edge[Min(outer_subgraph1_ptr^.first_point,outer_subgraph1_ptr^.last_point)]=0)               then
                    LineSMN(Trunc(pts_f1.x+obj_arr_ptr1^.world_axis_shift.x),
                            Trunc(pts_f1.y+obj_arr_ptr1^.world_axis_shift.y),
                            Trunc(pts_l1.x+obj_arr_ptr2^.world_axis_shift.x),
                            Trunc(pts_l1.y+obj_arr_ptr2^.world_axis_shift.y));
                  pts_f2      :=(pts_ptr+outer_subgraph2_ptr^.first_point)^;
                  pts_l2      :=(pts_ptr+outer_subgraph2_ptr^.last_point )^;
                  obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph2_ptr^.first_point]]]);
                  obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph2_ptr^.last_point ]]]);
                  if IsPtInRct(PtPosF(pts_f2.x+obj_arr_ptr1^.world_axis_shift.x,pts_f2.y+obj_arr_ptr1^.world_axis_shift.y),rct) and
                     IsPtInRct(PtPosF(pts_l2.x+obj_arr_ptr2^.world_axis_shift.x,pts_l2.y+obj_arr_ptr2^.world_axis_shift.y),rct) and
                     (sln_var.has_edge[Min(outer_subgraph2_ptr^.first_point,outer_subgraph2_ptr^.last_point)]=0)               then
                    LineSMN(Trunc(pts_f2.x+obj_arr_ptr1^.world_axis_shift.x),
                            Trunc(pts_f2.y+obj_arr_ptr1^.world_axis_shift.y),
                            Trunc(pts_l2.x+obj_arr_ptr2^.world_axis_shift.x),
                            Trunc(pts_l2.y+obj_arr_ptr2^.world_axis_shift.y));
                  Inc(outer_subgraph1_ptr);
                  Inc(outer_subgraph2_ptr);
                end;
            end; {$endregion}
          {Drawing Of Outer Subgraph 3  } {$region -fold}
          if (outer_subgraph3_eds_cnt>0) then
            begin
              pts_ptr            :=Unaligned(@pts            [0]);
              outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
              for i:=0 to outer_subgraph3_eds_cnt-1 do
                begin
                  pts_f3      :=(pts_ptr+outer_subgraph3_ptr^.first_point)^;
                  pts_l3      :=(pts_ptr+outer_subgraph3_ptr^.last_point )^;
                  obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph3_ptr^.first_point]]]);
                  obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph3_ptr^.last_point ]]]);
                  if IsPtInRct(PtPosF(pts_f3.x+obj_arr_ptr1^.world_axis_shift.x,pts_f3.y+obj_arr_ptr1^.world_axis_shift.y),rct) and
                     IsPtInRct(PtPosF(pts_l3.x+obj_arr_ptr2^.world_axis_shift.x,pts_l3.y+obj_arr_ptr2^.world_axis_shift.y),rct) and
                     (sln_var.has_edge[Min(outer_subgraph3_ptr^.first_point,outer_subgraph3_ptr^.last_point)]=0)   then
                    LineSMN(Trunc(pts_f3.x+obj_arr_ptr1^.world_axis_shift.x),
                            Trunc(pts_f3.y+obj_arr_ptr1^.world_axis_shift.y),
                            Trunc(pts_l3.x+obj_arr_ptr2^.world_axis_shift.x),
                            Trunc(pts_l3.y+obj_arr_ptr2^.world_axis_shift.y));
                Inc(outer_subgraph3_ptr);
              end;
            end; {$endregion}
        end; {$endregion}
      (csResilientEdges): {Resilient Edges(Unreal)} {$region -fold}
        begin
          {Drawing Of Outer Subgraph 1,2} {$region -fold}
          if (outer_subgraph1_eds_cnt>0) then
            begin
              pts_ptr            :=Unaligned(@pts            [0]);
              outer_subgraph1_ptr:=Unaligned(@outer_subgraph1[0]);
              outer_subgraph2_ptr:=Unaligned(@outer_subgraph2[0]);
              for i:=0 to outer_subgraph1_eds_cnt-1 do
                begin
                  if (sln_var.has_edge[Min(outer_subgraph1_ptr^.first_point,outer_subgraph1_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph1_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph1_ptr^.last_point ]]]);
                      ClippedLine2(Trunc((pts_ptr+outer_subgraph1_ptr^.first_point)^.x+obj_arr_ptr1^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph1_ptr^.first_point)^.y+obj_arr_ptr1^.world_axis_shift.y),
                                   Trunc((pts_ptr+outer_subgraph1_ptr^.last_point )^.x+obj_arr_ptr2^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph1_ptr^.last_point )^.y+obj_arr_ptr2^.world_axis_shift.y),
                                   rct);
                      LineR0(ln_pos.x0,
                             ln_pos.y0,
                             ln_pos.x1,
                             ln_pos.y1,
                             bmp_dst_ptr,
                             ln_arr_width,
                             rct_clp,
                             color_info,
                             16);
                    end;
                  if (sln_var.has_edge[Min(outer_subgraph2_ptr^.first_point,outer_subgraph2_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph2_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph2_ptr^.last_point ]]]);
                      ClippedLine2(Trunc((pts_ptr+outer_subgraph2_ptr^.first_point)^.x+obj_arr_ptr1^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph2_ptr^.first_point)^.y+obj_arr_ptr1^.world_axis_shift.y),
                                   Trunc((pts_ptr+outer_subgraph2_ptr^.last_point )^.x+obj_arr_ptr2^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph2_ptr^.last_point )^.y+obj_arr_ptr2^.world_axis_shift.y),
                                   rct);
                      LineR0(ln_pos.x0,
                             ln_pos.y0,
                             ln_pos.x1,
                             ln_pos.y1,
                             bmp_dst_ptr,
                             ln_arr_width,
                             rct_clp,
                             color_info,
                             16);
                    end;
                  Inc(outer_subgraph1_ptr);
                  Inc(outer_subgraph2_ptr);
                end;
            end; {$endregion}
          {Drawing Of Outer Subgraph 3  } {$region -fold}
          if (outer_subgraph3_eds_cnt>0) then
            begin
              pts_ptr            :=Unaligned(@pts            [0]);
              outer_subgraph3_ptr:=Unaligned(@outer_subgraph3[0]);
              for i:=0 to outer_subgraph3_eds_cnt-1 do
                begin
                  if (sln_var.has_edge[Min(outer_subgraph3_ptr^.first_point,outer_subgraph3_ptr^.last_point)]=0) then
                    begin
                      obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph3_ptr^.first_point]]]);
                      obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[outer_subgraph3_ptr^.last_point ]]]);
                      ClippedLine2(Trunc((pts_ptr+outer_subgraph3_ptr^.first_point)^.x+obj_arr_ptr1^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph3_ptr^.first_point)^.y+obj_arr_ptr1^.world_axis_shift.y),
                                   Trunc((pts_ptr+outer_subgraph3_ptr^.last_point )^.x+obj_arr_ptr2^.world_axis_shift.x),
                                   Trunc((pts_ptr+outer_subgraph3_ptr^.last_point )^.y+obj_arr_ptr2^.world_axis_shift.y),
                                   rct);
                      LineR0(ln_pos.x0,
                             ln_pos.y0,
                             ln_pos.x1,
                             ln_pos.y1,
                             bmp_dst_ptr,
                             ln_arr_width,
                             rct_clp,
                             color_info,
                             16);
                    end;
                  Inc(outer_subgraph3_ptr);
                end;
            end; {$endregion}
          Exit;
        end; {$endregion}
      (csAdvancedClip  ): {Advanced Clip--(Turbo )} {$region -fold}
        begin
          {TODO}
          {n:=CheckDensity1(outer_subgraph_f_ln_var.f_ln_arr0,
                            outer_subgraph_f_ln_var.f_ln_arr2,
                            rect_clp.Width,
                            rect_clp.Height);}
        end; {$endregion}
    end; {$endregion}

  {Restore Pointer to Drawing Sufrace} {$region -fold}
  with outer_subgraph_img do
    ln_arr0_ptr:=Unaligned(@ln_arr0[0]); {$endregion}

  lbl_flood_fill_only:

  {Fill Subgraph Lines---------------} {$region -fold}
  outer_subgraph_img.FilBuffer(rct_clp);{$endregion}

end; {$endregion}
procedure TSelIts.InnerSubgraphCalc0(x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct_clp  :TPtRect);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                    : PPtPosF;
  pts_f3,pts_l3              : TPtPosF;
  inner_subgraph_ptr         : PEdge;
  out_or_inn_subgraph_pts_ptr: PByte;
  i                          : integer;
begin

  if (inner_subgraph__eds_cnt=0) then
    Exit;

  if fill_bmp_only then
    Exit;

  {Calculation Of Inner Subgraph Lines Position} {$region -fold}
  pts_ptr                    :=Unaligned(@pts                    [0]);
  inner_subgraph_ptr         :=Unaligned(@inner_subgraph_        [0]);
  out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
  for i:=0 to inner_subgraph__eds_cnt-1 do
    with inner_subgraph_ptr^ do
      begin
        pts_f3:=(pts_ptr+first_point)^;
        pts_l3:=(pts_ptr+last_point )^;
        if ((out_or_inn_subgraph_pts_ptr+first_point)^=2) then
          if (not is_point_pos_calc     [first_point]) then
            begin
              pts_f3.x+=pvt_var.pos_dif.x;
              pts_f3.y+=pvt_var.pos_dif.y;
              is_point_pos_calc[first_point]:=True;
            end;
        if ((out_or_inn_subgraph_pts_ptr+last_point )^=2) then
          if (not is_point_pos_calc     [last_point]) then
            begin
              pts_l3.x+=pvt_var.pos_dif.x;
              pts_l3.y+=pvt_var.pos_dif.y;
              is_point_pos_calc[last_point]:=True;
            end;
        (pts_ptr+first_point)^:=pts_f3;
        (pts_ptr+last_point )^:=pts_l3;
        Inc(inner_subgraph_ptr);
      end; {$endregion}

end; {$endregion}
procedure TSelIts.InnerSubgraphCalc1(x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct_clp  :TPtRect);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                    : PPtPosF;
  pts_f3,pts_l3              : TPtPosF;
  inner_subgraph_ptr         : PEdge;
  out_or_inn_subgraph_pts_ptr: PByte;
  i                          : integer;
begin

  if (inner_subgraph__eds_cnt=0) then
    Exit;

  if fill_bmp_only then
    Exit;

  if (pvt_var.scl_dir=sdNone) then
    Exit;

  {Calculation Of Inner Subgraph Lines Position} {$region -fold}
  pts_ptr                    :=Unaligned(@pts                    [0]);
  inner_subgraph_ptr         :=Unaligned(@inner_subgraph_        [0]);
  out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
  for i:=0 to inner_subgraph__eds_cnt-1 do
    with inner_subgraph_ptr^ do
      begin
        pts_f3:=(pts_ptr+first_point)^;
        pts_l3:=(pts_ptr+last_point )^;
        if ((out_or_inn_subgraph_pts_ptr+first_point)^=2) then
          if (not is_point_pos_calc     [first_point]) then
            begin
              pts_f3.x*=pvt_var.pvt_scl.x;
              pts_f3.x+=pvt_var.scl_dif.x;
              pts_f3.y*=pvt_var.pvt_scl.y;
              pts_f3.y+=pvt_var.scl_dif.y;
              is_point_pos_calc[first_point]:=True;
            end;
        if ((out_or_inn_subgraph_pts_ptr+last_point )^=2) then
          if (not is_point_pos_calc     [last_point]) then
            begin
              pts_l3.x*=pvt_var.pvt_scl.x;
              pts_l3.x+=pvt_var.scl_dif.x;
              pts_l3.y*=pvt_var.pvt_scl.y;
              pts_l3.y+=pvt_var.scl_dif.y;
              is_point_pos_calc[last_point]:=True;
            end;
        (pts_ptr+first_point)^:=pts_f3;
        (pts_ptr+last_point )^:=pts_l3;
        Inc(inner_subgraph_ptr);
      end; {$endregion}

end; {$endregion}
procedure TSelIts.InnerSubgraphCalc2(x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct_clp  :TPtRect);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr                    : PPtPosF;
  pts_f3,pts_l3              : TPtPosF;
  inner_subgraph_ptr         : PEdge;
  out_or_inn_subgraph_pts_ptr: PByte;
  i                          : integer;
  n1,n2                      : double;
begin
  {Rotation: TODO}
end; {$endregion}
procedure TSelIts.InnerSubgraphDraw (x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct_clp  :TPtRect);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr1               : PObjProp;
  obj_arr_ptr2               : PObjProp;
  rct                        : TPtRect;
  pts_ptr                    : PPtPosF;
  pts_f3,pts_l3              : TPtPosF;
  inner_subgraph_ptr         : PEdge;
  out_or_inn_subgraph_pts_ptr: PByte;
  i,m1,m2,m3,m4              : integer;
label
  lbl_flood_fill_only;
begin

  if (inner_subgraph__eds_cnt=0) then
    Exit;

  if IsRct1OutOfRct2(rct_clp,srf_var_ptr^.inn_wnd_rct) then
    Exit;

  if fill_bmp_only then
    goto lbl_flood_fill_only;

  {Set Drawing Bounds(Inner Window)--} {$region -fold}
  with rct_clp do
    begin
      m1:=left  +grid_pt_rad;
      m2:=top   +grid_pt_rad;
      m3:=right -grid_pt_rad-1;
      m4:=bottom-grid_pt_rad-1;
    end;
  rct:=PtRct(m1,m2,m3,m4); {$endregion}

  {Clear Arrays----------------------} {$region -fold}
  with inner_subgraph_img do
    begin
      ArrClr(ln_arr0,rct_clp,ln_arr_width);
      ArrClr(ln_arr2,rct_clp);
    end; {$endregion}

  {Drawing Of Inner Subgraph Lines---} {$region -fold}
  with inner_subgraph_img do
    case local_prop.clp_stl of
      (csClippedEdges1 ): {Clipped Edges 1(Slow  )} {$region -fold}
        if (inner_subgraph__eds_cnt>0) then
          begin
            pts_ptr                    :=Unaligned(@pts                    [0]);
            inner_subgraph_ptr         :=Unaligned(@inner_subgraph_        [0]);
            out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
            for i:=0 to inner_subgraph__eds_cnt-1 do
              begin
                if (sln_var.has_edge[Min(inner_subgraph_ptr^.first_point,inner_subgraph_ptr^.last_point)]=0) then
                  begin
                    pts_f3      :=(pts_ptr+inner_subgraph_ptr^.first_point)^;
                    pts_l3      :=(pts_ptr+inner_subgraph_ptr^.last_point )^;
                    obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[inner_subgraph_ptr^.first_point]]]);
                    obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[inner_subgraph_ptr^.last_point ]]]);
                    ClippedLine1(Trunc(pts_f3.x+obj_arr_ptr1^.world_axis_shift.x),
                                 Trunc(pts_f3.y+obj_arr_ptr1^.world_axis_shift.y),
                                 Trunc(pts_l3.x+obj_arr_ptr2^.world_axis_shift.x),
                                 Trunc(pts_l3.y+obj_arr_ptr2^.world_axis_shift.y),
                                 rct,
                                 Unaligned(@LineSME),
                                 Nil,
                                 Nil,
                                 Nil);
                  end;
                Inc(inner_subgraph_ptr);
              end;
          end; {$endregion}
      (csClippedEdges2 ): {Clipped Edges 2(Slow  )} {$region -fold}
        if (inner_subgraph__eds_cnt>0) then
          begin
            pts_ptr                    :=Unaligned(@pts                    [0]);
            inner_subgraph_ptr         :=Unaligned(@inner_subgraph_        [0]);
            out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
            for i:=0 to inner_subgraph__eds_cnt-1 do
              begin
                if (sln_var.has_edge[Min(inner_subgraph_ptr^.first_point,inner_subgraph_ptr^.last_point)]=0) then
                  begin
                    pts_f3      :=(pts_ptr+inner_subgraph_ptr^.first_point)^;
                    pts_l3      :=(pts_ptr+inner_subgraph_ptr^.last_point )^;
                    obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[inner_subgraph_ptr^.first_point]]]);
                    obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[inner_subgraph_ptr^.last_point ]]]);
                    ClippedLine2(Trunc(pts_f3.x+obj_arr_ptr1^.world_axis_shift.x),
                                 Trunc(pts_f3.y+obj_arr_ptr1^.world_axis_shift.y),
                                 Trunc(pts_l3.x+obj_arr_ptr2^.world_axis_shift.x),
                                 Trunc(pts_l3.y+obj_arr_ptr2^.world_axis_shift.y),
                                 rct,
                                 Unaligned(@LineSME),
                                 Nil,
                                 Nil,
                                 Nil);
                  end;
                Inc(inner_subgraph_ptr);
              end;
          end; {$endregion}
      (csRemoveEdges   ): {Remove Edges---(Fast  )} {$region -fold}
        if (inner_subgraph__eds_cnt>0) then
          begin
            pts_ptr                    :=Unaligned(@pts                    [0]);
            inner_subgraph_ptr         :=Unaligned(@inner_subgraph_        [0]);
            out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
            for i:=0 to inner_subgraph__eds_cnt-1 do
              begin
                pts_f3      :=(pts_ptr+inner_subgraph_ptr^.first_point)^;
                pts_l3      :=(pts_ptr+inner_subgraph_ptr^.last_point )^;
                obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[inner_subgraph_ptr^.first_point]]]);
                obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[inner_subgraph_ptr^.last_point ]]]);
                if ((pts_f3.x+obj_arr_ptr1^.world_axis_shift.x>m1) and
                    (pts_f3.x+obj_arr_ptr1^.world_axis_shift.x<m3) and
                    (pts_f3.y+obj_arr_ptr1^.world_axis_shift.y>m2) and
                    (pts_f3.y+obj_arr_ptr1^.world_axis_shift.y<m4))
                  then
                    if ((pts_l3.x+obj_arr_ptr2^.world_axis_shift.x>m1) and
                        (pts_l3.x+obj_arr_ptr2^.world_axis_shift.x<m3) and
                        (pts_l3.y+obj_arr_ptr2^.world_axis_shift.y>m2) and
                        (pts_l3.y+obj_arr_ptr2^.world_axis_shift.y<m4))
                      then
                        if (sln_var.has_edge[Min(inner_subgraph_ptr^.first_point,inner_subgraph_ptr^.last_point)]=0) then
                          LineSMN(Trunc(pts_f3.x+obj_arr_ptr1^.world_axis_shift.x),
                                  Trunc(pts_f3.y+obj_arr_ptr1^.world_axis_shift.y),
                                  Trunc(pts_l3.x+obj_arr_ptr2^.world_axis_shift.x),
                                  Trunc(pts_l3.y+obj_arr_ptr2^.world_axis_shift.y));
                Inc(inner_subgraph_ptr);
              end;
          end; {$endregion}
      (csResilientEdges): {Resilient Edges(Unreal)} {$region -fold}
        if (inner_subgraph__eds_cnt>0) then
          begin
            pts_ptr                    :=Unaligned(@pts                    [0]);
            inner_subgraph_ptr         :=Unaligned(@inner_subgraph_        [0]);
            out_or_inn_subgraph_pts_ptr:=Unaligned(@out_or_inn_subgraph_pts[0]);
            for i:=0 to inner_subgraph__eds_cnt-1 do
              begin
                pts_f3      :=(pts_ptr+inner_subgraph_ptr^.first_point)^;
                pts_l3      :=(pts_ptr+inner_subgraph_ptr^.last_point )^;
                obj_arr_ptr1:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[inner_subgraph_ptr^.first_point]]]);
                obj_arr_ptr2:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_var.sln_obj_ind[inner_subgraph_ptr^.last_point ]]]);
                ClippedLine2(Trunc(pts_f3.x+obj_arr_ptr1^.world_axis_shift.x),
                             Trunc(pts_f3.y+obj_arr_ptr1^.world_axis_shift.y),
                             Trunc(pts_l3.x+obj_arr_ptr2^.world_axis_shift.x),
                             Trunc(pts_l3.y+obj_arr_ptr2^.world_axis_shift.y),
                             rct);
                if not((not IsPtInRct(PtPos(ln_pos.x0,ln_pos.y0),rct))  and
                       (not IsPtInRct(PtPos(ln_pos.x1,ln_pos.y1),rct))) then
                  if (sln_var.has_edge[Min(inner_subgraph_ptr^.first_point,inner_subgraph_ptr^.last_point)]=0) then
                    LineR0(ln_pos.x0,
                           ln_pos.y0,
                           ln_pos.x1,
                           ln_pos.y1,
                           bmp_dst_ptr,
                           ln_arr_width,
                           rct_clp,
                           color_info,
                           16);
                Inc(inner_subgraph_ptr);
              end;
          end; {$endregion}
      (csAdvancedClip  ): {Advanced Clip--(Turbo )} {$region -fold}
        begin
          {n:=CheckDensity1(outer_subgraph_f_ln_var.f_ln_arr0,
                            outer_subgraph_f_ln_var.f_ln_arr2,
                            rect_clp.Width,
                            rect_clp.Height);}
        end; {$endregion}
    end; {$endregion}

  {Restore Pointer to Drawing Sufrace} {$region -fold}
  with inner_subgraph_img do
    ln_arr0_ptr:=Unaligned(@ln_arr0[0]); {$endregion}

  lbl_flood_fill_only:

  {Fill Subgraph Lines---------------} {$region -fold}
  inner_subgraph_img.FilBuffer(rct_clp);{$endregion}

end; {$endregion}
procedure TSelIts.SinglePtGraphCalc0(x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct_clp  :TPtRect);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr            : PPtPosF;
  sl_pt_subgraph__ptr: PSlPt;
  i                  : integer;
begin

  if (sl_pt_subgraph__eds_cnt=0) then
    Exit;

  if fill_bmp_only then
    Exit;

  {Calculation Of Single Points Position} {$region -fold}
  pts_ptr            :=Unaligned(@pts            [0]);
  sl_pt_subgraph__ptr:=Unaligned(@sl_pt_subgraph_[0]);
  for i:=0 to sl_pt_subgraph__eds_cnt-1 do
    begin
      (pts_ptr+sl_pt_subgraph__ptr^.point)^.x+=pvt_var.pos_dif.x;
      (pts_ptr+sl_pt_subgraph__ptr^.point)^.y+=pvt_var.pos_dif.y;
      Inc(sl_pt_subgraph__ptr);
    end; {$endregion}

end; {$endregion}
procedure TSelIts.SinglePtGraphCalc1(x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct_clp  :TPtRect);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr            : PPtPosF;
  sl_pt_subgraph__ptr: PSlPt;
  i                  : integer;
begin

  if (sl_pt_subgraph__eds_cnt=0) then
    Exit;

  if fill_bmp_only then
    Exit;

  if (pvt_var.scl_dir=sdNone) then
    Exit;

  {Calculation Of Single Points Position} {$region -fold}
  pts_ptr            :=Unaligned(@pts            [0]);
  sl_pt_subgraph__ptr:=Unaligned(@sl_pt_subgraph_[0]);
  for i:=0 to sl_pt_subgraph__eds_cnt-1 do
    begin
      (pts_ptr+sl_pt_subgraph__ptr^.point)^.x*=pvt_var.pvt_scl.x;
      (pts_ptr+sl_pt_subgraph__ptr^.point)^.x+=pvt_var.scl_dif.x;
      (pts_ptr+sl_pt_subgraph__ptr^.point)^.y*=pvt_var.pvt_scl.y;
      (pts_ptr+sl_pt_subgraph__ptr^.point)^.y+=pvt_var.scl_dif.y;
      Inc(sl_pt_subgraph__ptr);
    end; {$endregion}

end; {$endregion}
procedure TSelIts.SinglePtGraphCalc2(x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct_clp  :TPtRect);         {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr            : PPtPosF;
  sl_pt_subgraph__ptr: PSlPt;
  i                  : integer;
begin
end; {$endregion}
procedure TSelIts.SelPtsCalc        (x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct_clp  :TPtRect);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TSelIts.SelPtsDraw        (x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct_clp  :TPtRect);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TSelIts.SelPtsBnds(x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct_clp  :TPtRect);         {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with selection_bounds_prop do
    begin
      pts_rct_inn_width :=Trunc(sel_pts_rct.width );
      pts_rct_inn_height:=Trunc(sel_pts_rct.height);
      SetRctWidth (selection_bounds_prop);
      SetRctHeight(selection_bounds_prop);
      SetRctValues(selection_bounds_prop);
      Fast_Graphics.Rectangle(Trunc(sel_pts_rct.left+pvt_var.pos_dif.x)+Trunc(sel_pts_rct.width )>>1-pts_rct_width__odd,
                              Trunc(sel_pts_rct.top +pvt_var.pos_dif.y)+Trunc(sel_pts_rct.height)>>1-pts_rct_height_odd,
                              bmp_dst_ptr,
                              selection_img.bmp_dst_width,
                              selection_img.bmp_dst_height,
                              rct_clp,
                              selection_bounds_prop);
    end;
end; {$endregion}
procedure TSelIts.WholeSubgraphDraw0(x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct1,rct2:TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Drawing of Outer Subgraph--------} {$region fold}
  OuterSubgraphCalc0(x,y,pvt,pts,bmp_dst_ptr,rct1);
  if outer_subgraph_img.local_prop.eds_show then
    OuterSubgraphDraw(x,y,pvt,pts,bmp_dst_ptr,rct1); {$endregion}

  {Drawing of Inner Subgraph--------} {$region fold}
  InnerSubgraphCalc0(x,y,pvt,pts,bmp_dst_ptr,rct2);
  if inner_subgraph_img.local_prop.eds_show then
    InnerSubgraphDraw(x,y,pvt,pts,bmp_dst_ptr,rct2); {$endregion}

  {Drawing of Single Point Graph----} {$region fold}
  SinglePtGraphCalc0(x,y,pvt,pts,bmp_dst_ptr,rct2); {$endregion}

  {Drawing of Selected Points-------} {$region fold}
  if selection_img.local_prop.eds_show then
    begin
      SelPtsCalc(x,y,pvt,pts,bmp_dst_ptr,rct1);
      SelPtsDraw(x,y,pvt,pts,bmp_dst_ptr,rct1);
    end; {$endregion}

  {Drawing of Selected Points Bounds} {$region fold}
  if selection_bounds_prop.rct_eds_show then
    SelPtsBnds(x,y,pvt,pts,bmp_dst_ptr,rct1); {$endregion}

  SelPtsIndsToFalse2;

end; {$endregion}
procedure TSelIts.WholeSubgraphDraw1(x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct1,rct2:TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Drawing of Outer Subgraph--------} {$region fold}
  OuterSubgraphCalc1(x,y,pvt,pts,bmp_dst_ptr,rct1);
  if outer_subgraph_img.local_prop.eds_show then
    OuterSubgraphDraw(x,y,pvt,pts,bmp_dst_ptr,rct1); {$endregion}

  {Drawing of Inner Subgraph--------} {$region fold}
  InnerSubgraphCalc1(x,y,pvt,pts,bmp_dst_ptr,rct1);
  if inner_subgraph_img.local_prop.eds_show then
    InnerSubgraphDraw(x,y,pvt,pts,bmp_dst_ptr,rct1); {$endregion}

  {Drawing of Single Point Graph----} {$region fold}
  SinglePtGraphCalc1(x,y,pvt,pts,bmp_dst_ptr,rct2); {$endregion}

  {Drawing of Selected Points-------} {$region fold}
  if selection_img.local_prop.eds_show then
    begin
      SelPtsCalc(x,y,pvt,pts,bmp_dst_ptr,rct1);
      SelPtsDraw(x,y,pvt,pts,bmp_dst_ptr,rct1);
    end; {$endregion}

  {Drawing of Selected Points Bounds} {$region fold}
  if selection_bounds_prop.rct_eds_show then
    SelPtsBnds(x,y,pvt,pts,bmp_dst_ptr,rct1); {$endregion}

  SelPtsIndsToFalse2;

end; {$endregion}
procedure TSelIts.WholeSubgraphDraw2(x,y:integer; const pvt:TPtPosF; var pts:TPtPosFArr; const bmp_dst_ptr:PInteger; const rct1,rct2:TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  {Drawing of Outer Subgraph--------} {$region fold}
  OuterSubgraphCalc2(x,y,pvt,pts,bmp_dst_ptr,rct1);
  if outer_subgraph_img.local_prop.eds_show then
    OuterSubgraphDraw(x,y,pvt,pts,bmp_dst_ptr,rct1); {$endregion}

  {Drawing of Inner Subgraph--------} {$region fold}
  InnerSubgraphCalc2(x,y,pvt,pts,bmp_dst_ptr,rct1);
  if inner_subgraph_img.local_prop.eds_show then
    InnerSubgraphDraw(x,y,pvt,pts,bmp_dst_ptr,rct1); {$endregion}

  {Drawing of Single Point Graph----} {$region fold}
  SinglePtGraphCalc2(x,y,pvt,pts,bmp_dst_ptr,rct2); {$endregion}

  {Drawing of Selected Points-------} {$region fold}
  if selection_img.local_prop.eds_show then
    begin
      SelPtsCalc(x,y,pvt,pts,bmp_dst_ptr,rct1);
      SelPtsDraw(x,y,pvt,pts,bmp_dst_ptr,rct1);
    end; {$endregion}

  {Drawing of Selected Points Bounds} {$region fold}
  if selection_bounds_prop.rct_eds_show then
    SelPtsBnds(x,y,pvt,pts,bmp_dst_ptr,rct1); {$endregion}

  SelPtsIndsToFalse2;

end; {$endregion}
procedure TSelIts.SelPvtAndSplineEdsToBmp;                                                                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TSelIts.SelPtsIndsToBmp(var pts:TPtPosFArr);                                                                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_Select_ItemsClick                               (sender:TObject); {$region -fold}
begin
  SB_Draw_Buttons_Button_Bkgnd.Left   :=SB_Select_Items.Left;
  SB_Draw_Buttons_Button_Bkgnd.Visible:=SB_Select_Items.Down;
  DrawingPanelsSetVisibility1(down_select_items_ptr,P_Draw_Buttons,P_Select_Items,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_select_items_ptr^) then
    Exit;
end; {$endregion}
{Outer Subgraph}
procedure TF_MainForm.SB_Select_Items_Outer_Subgraph_ShowClick           (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Select_Items_Outer_Subgraph_Show,sel_var.outer_subgraph_img.local_prop.eds_show);
  with sel_var do
    begin
      fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      fill_bmp_only:=False;
    end;
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Outer_Subgraph_HeaderClick          (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Select_Items_Outer_Subgraph_Settings,Shape21);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Outer_Subgraph_HeaderMouseEnter     (sender:TObject); {$region -fold}
begin
  P_Select_Items_Outer_Subgraph_Header  .Color:=HighLightLimit(P_Select_Items_Outer_Subgraph_Header  .Color,16);
  P_Select_Items_Outer_Subgraph_Settings.Color:=HighLightLimit(P_Select_Items_Outer_Subgraph_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Outer_Subgraph_HeaderMouseLeave     (sender:TObject); {$region -fold}
begin
  P_Select_Items_Outer_Subgraph_Header  .Color:=Darken2(P_Select_Items_Outer_Subgraph_Header  .Color,16);
  P_Select_Items_Outer_Subgraph_Settings.Color:=Darken2(P_Select_Items_Outer_Subgraph_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Outer_Subgraph_SettingsMouseEnter   (sender:TObject); {$region -fold}
begin
  P_Select_Items_Outer_Subgraph_Settings.Color:=HighLightLimit(P_Select_Items_Outer_Subgraph_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Outer_Subgraph_SettingsMouseLeave   (sender:TObject); {$region -fold}
begin
  P_Select_Items_Outer_Subgraph_Settings.Color:=Darken2(P_Select_Items_Outer_Subgraph_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Outer_Subgraph_Line_StyleSelect    (sender:TObject); {$region -fold}
begin
  with sel_var,outer_subgraph_img,local_prop do
    begin
      eds_bld_stl:=TDrawingStyle(CB_Select_Items_Outer_Subgraph_Line_Style.ItemIndex);
      with args do
        begin
          alpha:=016;
          pow  :=016;
          d    :=016;
          case CB_Select_Items_Outer_Subgraph_Line_Style.ItemIndex of
            0   : alpha:=016;
            2   : alpha:=127;
            4..5: pow  :=064;
            6..8: d    :=064;
          end;
        end;
      pp_dec_2_proc_ind:=GetEnumVal(eds_bld_stl);
      if (eds_bld_stl=dsMonochrome) then
        pp_dec_2_proc_ind:=2;
      fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      fill_bmp_only:=False;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Outer_Subgraph_Clip_StyleSelect    (sender:TObject); {$region -fold}
begin
  with sel_var,outer_subgraph_img,local_prop do
    begin
      clp_stl      :=TClipStyle(CB_Select_Items_Outer_Subgraph_Clip_Style.ItemIndex);
      fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      fill_bmp_only:=False;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Outer_Subgraph_Anti_AliasingChange (sender:TObject); {$region -fold}
begin
  with sel_var,outer_subgraph_img,local_prop do
    begin
      eds_aa       :=not eds_aa;
      fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      fill_bmp_only:=False;
    end;
end; {$endregion}
procedure TF_MainForm.SB_Select_Items_Outer_Subgraph_ColorClick          (sender:TObject); {$region -fold}
begin
  CD_Select_Color.Color:=SB_Select_Items_Outer_Subgraph_Color.Color;
  CD_Select_Color.Execute;
  with sel_var do
    begin
      IsObjColorAMaskColor;
      with outer_subgraph_img,local_prop do
        begin
          eds_col:=CD_Select_Color.Color;
          if (clp_stl=csResilientEdges) then
            SetColorInfo2(eds_col,color_info);
          fill_bmp_only:=True;
          FillSelBmpAndSelPtsBRectDraw;
          fill_bmp_only:=False;
        end;
    end;
  SB_Select_Items_Outer_Subgraph_Color.Color:=CD_Select_Color.Color;
  SB_Select_Items_Outer_Subgraph_Color.Down :=False;
end; {$endregion}
{Inner Subgraph}
procedure TF_MainForm.SB_Select_Items_Inner_Subgraph_ShowClick           (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Select_Items_Inner_Subgraph_Show,sel_var.inner_subgraph_img.local_prop.eds_show);
  with sel_var do
    begin
      fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      fill_bmp_only:=False;
    end;
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Inner_Subgraph_HeaderClick          (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Select_Items_Inner_Subgraph_Settings,Shape20);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Inner_Subgraph_HeaderMouseEnter     (sender:TObject); {$region -fold}
begin
  P_Select_Items_Inner_Subgraph_Header  .Color:=HighLightLimit(P_Select_Items_Inner_Subgraph_Header  .Color,16);
  P_Select_Items_Inner_Subgraph_Settings.Color:=HighLightLimit(P_Select_Items_Inner_Subgraph_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Inner_Subgraph_HeaderMouseLeave     (sender:TObject); {$region -fold}
begin
  P_Select_Items_Inner_Subgraph_Header  .Color:=Darken2(P_Select_Items_Inner_Subgraph_Header  .Color,16);
  P_Select_Items_Inner_Subgraph_Settings.Color:=Darken2(P_Select_Items_Inner_Subgraph_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Inner_Subgraph_SettingsMouseEnter   (sender:TObject); {$region -fold}
begin
  P_Select_Items_Inner_Subgraph_Settings.Color:=HighLightLimit(P_Select_Items_Inner_Subgraph_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Inner_Subgraph_SettingsMouseLeave   (sender:TObject); {$region -fold}
begin
  P_Select_Items_Inner_Subgraph_Settings.Color:=Darken2(P_Select_Items_Inner_Subgraph_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Inner_Subgraph_Line_StyleSelect    (sender:TObject); {$region -fold}
begin
  with sel_var,inner_subgraph_img,local_prop do
    begin
      eds_bld_stl:=TDrawingStyle(CB_Select_Items_Inner_Subgraph_Line_Style.ItemIndex);
      with args do
        begin
          alpha:=016;
          pow  :=016;
          d    :=016;
          case CB_Select_Items_Inner_Subgraph_Line_Style.ItemIndex of
            0   : alpha:=016;
            2   : alpha:=127;
            4..5: pow  :=064; 
            6..8: d    :=064;
          end;
        end;
      pp_dec_2_proc_ind:=GetEnumVal(eds_bld_stl);
      if (eds_bld_stl=dsMonochrome) then
        pp_dec_2_proc_ind:=2;
      fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      fill_bmp_only:=False;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Inner_Subgraph_Clip_StyleSelect    (sender:TObject); {$region -fold}
begin
  with sel_var,inner_subgraph_img,local_prop do
    begin
      clp_stl      :=TClipStyle(CB_Select_Items_Inner_Subgraph_Clip_Style.ItemIndex);
      fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      fill_bmp_only:=False;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Inner_Subgraph_Anti_AliasingChange (sender:TObject); {$region -fold}
begin
  with sel_var,inner_subgraph_img,local_prop do
    begin
      eds_aa       :=not eds_aa;
      fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      fill_bmp_only:=False;
    end;
end; {$endregion}
procedure TF_MainForm.SB_Select_Items_Inner_Subgraph_ColorClick          (sender:TObject); {$region -fold}
begin
  CD_Select_Color.Color:=SB_Select_Items_Inner_Subgraph_Color.Color;
  CD_Select_Color.Execute;
  with sel_var do
    begin
      IsObjColorAMaskColor;
      with inner_subgraph_img,local_prop do
        begin
          eds_col:=CD_Select_Color.Color;
          if (clp_stl=csResilientEdges) then
            SetColorInfo2(eds_col,color_info);
          fill_bmp_only:=True;
          FillSelBmpAndSelPtsBRectDraw;
          fill_bmp_only:=False;
        end;
    end;
  SB_Select_Items_Inner_Subgraph_Color.Color:=CD_Select_Color.Color;
  SB_Select_Items_Inner_Subgraph_Color.Down :=False;
end; {$endregion}
{Selected Points}
procedure TF_MainForm.SB_Select_Items_Selected_Points_ShowClick          (sender:TObject); {$region -fold}
begin
  BtnColAndDown(SB_Select_Items_Selected_Points_Show,sel_var.sel_pts_img.local_prop.eds_show);
  with sel_var do
    begin
      fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      fill_bmp_only:=False;
    end;
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Selected_Points_HeaderClick         (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Select_Items_Selected_Points_Settings,Shape22);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Selected_Points_HeaderMouseEnter    (sender:TObject); {$region -fold}
begin
  P_Select_Items_Selected_Points_Header  .Color:=HighLightLimit(P_Select_Items_Selected_Points_Header  .Color,16);
  P_Select_Items_Selected_Points_Settings.Color:=HighLightLimit(P_Select_Items_Selected_Points_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Selected_Points_HeaderMouseLeave    (sender:TObject); {$region -fold}
begin
  P_Select_Items_Selected_Points_Header  .Color:=Darken2(P_Select_Items_Selected_Points_Header  .Color,16);
  P_Select_Items_Selected_Points_Settings.Color:=Darken2(P_Select_Items_Selected_Points_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Selected_Points_SettingsMouseEnter  (sender:TObject); {$region -fold}
begin
  P_Select_Items_Selected_Points_Settings.Color:=HighLightLimit(P_Select_Items_Selected_Points_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Selected_Points_SettingsMouseLeave  (sender:TObject); {$region -fold}
begin
  P_Select_Items_Selected_Points_Settings.Color:=Darken2(P_Select_Items_Selected_Points_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Selected_Points_Line_StyleSelect   (sender:TObject); {$region -fold}
begin
  with sel_var,sel_pts_img,local_prop do
    begin
      eds_bld_stl:=TDrawingStyle(CB_Select_Items_Selected_Points_Line_Style.ItemIndex);
      with args do
        begin
          alpha:=016;
          pow  :=016;
          d    :=016;
          case CB_Select_Items_Selected_Points_Line_Style.ItemIndex of
            0   : alpha:=016;
            2   : alpha:=127;
            4..5: pow  :=064;
            6..8: d    :=064;
          end;
        end;
      pp_dec_2_proc_ind:=GetEnumVal(eds_bld_stl);
      if (eds_bld_stl=dsMonochrome) then
        pp_dec_2_proc_ind:=2;
      fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      fill_bmp_only:=False;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Selected_Points_Show_BoundsChange  (sender:TObject); {$region -fold}
begin
  with sel_var,selection_bounds_prop do
    begin
      rct_eds_show :=not rct_eds_show;
      fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      fill_bmp_only:=False;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Selected_Points_Anti_AliasingChange(sender:TObject); {$region -fold}
begin
  with sel_var,sel_pts_img,local_prop do
    begin
      eds_aa       :=not eds_aa;
      fill_bmp_only:=True;
      FillSelBmpAndSelPtsBRectDraw;
      fill_bmp_only:=False;
    end;
end; {$endregion}
procedure TF_MainForm.SB_Select_Items_Selected_Points_ColorClick         (sender:TObject); {$region -fold}
begin
  CD_Select_Color.Color:=SB_Select_Items_Selected_Points_Color.Color;
  CD_Select_Color.Execute;
  with sel_var do
    begin
      IsObjColorAMaskColor;
      with sel_pts_img,local_prop do
        begin
          eds_col:=CD_Select_Color.Color;
          with selection_img,local_prop do
            begin
              pts_col    :=CD_Select_Color.Color;
              pts_col_inv:=SetColorInv(pts_col);
            end;
          if (clp_stl=csResilientEdges) then
            SetColorInfo2(eds_col,color_info);
          fill_bmp_only:=True;
          FillSelBmpAndSelPtsBRectDraw;
          fill_bmp_only:=False;
        end;
    end;
  SB_Select_Items_Selected_Points_Color.Color:=CD_Select_Color.Color;
  SB_Select_Items_Selected_Points_Color.Down :=False;
end; {$endregion}
{Selection-----}
procedure TF_MainForm.P_Select_Items_Selection_HeaderClick               (sender:TObject); {$region -fold}
begin
  PanelDropDownSettings(P_Select_Items_Selection_Settings,Shape23);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Selection_HeaderMouseEnter          (sender:TObject); {$region -fold}
begin
  P_Select_Items_Selection_Header  .Color:=HighLightLimit(P_Select_Items_Selection_Header  .Color,16);
  P_Select_Items_Selection_Settings.Color:=HighLightLimit(P_Select_Items_Selection_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Selection_HeaderMouseLeave          (sender:TObject); {$region -fold}
begin
  P_Select_Items_Selection_Header  .Color:=Darken2(P_Select_Items_Selection_Header  .Color,16);
  P_Select_Items_Selection_Settings.Color:=Darken2(P_Select_Items_Selection_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Selection_SettingsMouseEnter        (sender:TObject); {$region -fold}
begin
  P_Select_Items_Selection_Settings.Color:=HighLightLimit(P_Select_Items_Selection_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.P_Select_Items_Selection_SettingsMouseLeave        (sender:TObject); {$region -fold}
begin
  P_Select_Items_Selection_Settings.Color:=Darken2(P_Select_Items_Selection_Settings.Color,16);
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Selection_Background_StyleSelect   (sender:TObject); {$region -fold}
begin
  sel_var.srf_var_ptr^.bg_style:=TBackgroundStyle(CB_Select_Items_Selection_Background_Style.ItemIndex);
  bkg_pp_calc                  :=                (CB_Select_Items_Selection_Background_Style.ItemIndex in [0..2]) xor
                                                 (CB_Select_Items_Selection_Background_Style.ItemIndex=3);
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Selection_Selection_ModeSelect     (sender:TObject); {$region -fold}
begin
  sel_var.ChangeSelectionMode(CB_Select_Items_Selection_Selection_Mode.ItemIndex);
end; {$endregion}
procedure TF_MainForm.CB_Select_Items_Selection_Only_VisibleChange       (sender:TObject); {$region -fold}
begin
  sel_var.sel_only_pts_vis_sln:=not sel_var.sel_only_pts_vis_sln;
end; {$endregion}
procedure TF_MainForm.SB_Select_Items_Selection_ColorClick               (sender:TObject); {$region -fold}
begin
  CD_Select_Color.Color:=SB_Select_Items_Selection_Color.Color;
  CD_Select_Color.Execute;
  with sel_var,selection_img,local_prop,sprite_sheet_arr[crc_sel_var.crc_sel_ind],fast_image_proc_var do
    begin
      eds_col             :=CD_Select_Color.Color;
      fast_image_data_ptr0:=@fast_image_data;
      SetPPInfo(eds_col);
    end;
  SB_Select_Items_Selection_Color.Color:=CD_Select_Color.Color;
  SB_Select_Items_Selection_Color.Down :=False;
end; {$endregion}
{$endregion}

// (Local Pivot) Локальная ось:
{LI} {$region -fold}
constructor TPivot.Create(w,h:TColor);                                                                                 {$ifdef Linux}[local];{$endif} {$region -fold}
begin

  srf_var_ptr         :=@srf_var;

  SelPtsCalcProc   [0]:=@SelPtsPosCalc;
  SelPtsCalcProc   [1]:=@SelPtsSclCalc;
  SelPtsCalcProc   [2]:=@SelPtsRotCalc;

  SelPtsRctCalcProc[0]:=@SelPtsRctPosCalc;
  SelPtsRctCalcProc[1]:=@SelPtsRctSclCalc;
  SelPtsRctCalcProc[2]:=@SelPtsRctRotCalc;

  {Miscellaneous Settings-------} {$region -fold}
  snap_mode            :=Default(TSnapMode);
  move_pvt_to_pt_button:=True;
  pvt_exists           :=0;
  pvt_scl              :=PtPosF(DEFAULT_SCL_MUL,
                                DEFAULT_SCL_MUL); {$endregion}

  {Create Pivot Icon------------} {$region -fold}
  LocalAxisCreate; {$endregion}

  {Create Selection Tools Marker} {$region -fold}
  SelectionToolsMarkerCreate; {$endregion}

end; {$endregion}
destructor  TPivot.Destroy;                                                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure TPivot.LocalAxisCreate;                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // Create Local Axis Icon:
  SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
  with srf_var_ptr^ do
    sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
    (
      srf_bmp_ptr,
      srf_bmp.width,
      srf_bmp.height,
      inn_wnd_rct,
      max_sprite_w_h_rct,
      Application.Location+LOCAL_AXIS_ICON,
      @F_MainForm.IL_Local_Axis.GetBitmap,
      0,
      False,//////
      Nil,  //////
      True  //////
    );
  local_axis_bmp_ind:=Length(sprite_sheet_arr)-1;
  with sprite_sheet_arr[local_axis_bmp_ind],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      SetPPInfo (clRed           );
      SetGradVec(0,rct_ent.height);
      SetGradCol(0,255           );

      {FX Settings} {$region -fold}
      fx_cnt      :=002;
      pix_drw_type:={000}002;

      with fx_arr[0] do
        begin
          pt_as_nt:=False;
          with nt_fx_prop do
            begin
              //if (img_kind=3{<>4}) then
                cfx_pow0  :=180;
              rep_cnt     :=001;
              pix_cfx_type:=002;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;

      with fx_arr[1] do
        begin
          pt_as_nt:=False;
          with nt_fx_prop do
            begin
              is_fx_gradvec:=False{True};
              cfx_pow0     :=001;
              rep_cnt      :=001;
              pix_cfx_type :=004;
              pix_cng_type :=001;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;

      SdrTypeCng(fast_image_data_ptr0,
                 fast_image_data); {$endregion}

    end;
end; {$endregion}
procedure TPivot.LocalAxisDraw     (const x,y:integer);                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sprite_sheet_arr[local_axis_bmp_ind],fast_image_data,fast_image_proc_var do
    SdrProc[sdr_proc_ind](x-bmp_ftimg_width_origin >>1,
                          y-bmp_ftimg_height_origin>>1,
                          @fast_image_data);
end; {$endregion}
procedure TPivot.LocalAxisHighLight(const x,y:integer);                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sprite_sheet_arr[local_axis_bmp_ind],fast_image_data,fast_image_proc_var do
    begin

      with fx_arr[1] do
        begin
          with nt_fx_prop do
            begin
              cfx_pow0    :=100;
              pix_cfx_type:=004; //must be in range of [0..255]
            end;
          with pt_fx_prop do
            begin
              cfx_pow0    :=100;
              pix_cfx_type:=004; //must be in range of [0..255]
            end;
        end;

      LocalAxisDraw(x,y);

      with fx_arr[1] do
        begin
          with nt_fx_prop do
            begin
              cfx_pow0    :=000;
              pix_cfx_type:=002; //must be in range of [0..255]
            end;
          with pt_fx_prop do
            begin
              cfx_pow0    :=000;
              pix_cfx_type:=002; //must be in range of [0..255]
            end;
        end;

    end;
end; {$endregion}
procedure TPivot.SelectionToolsMarkerCreate;                                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
  sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
  (
    srf_var_ptr^.srf_bmp_ptr,
    srf_var_ptr^.srf_bmp.width,
    srf_var_ptr^.srf_bmp.height,
    srf_var_ptr^.inn_wnd_rct,
    max_sprite_w_h_rct,
    Application.Location+SELECTION_TOOLS_MARKER_ICON,
    @F_MainForm.IL_Select_Points.GetBitmap,
    0
  );
  sel_tls_mrk_ind:=Length(sprite_sheet_arr)-1;
  // Drawing Settings:
  with sprite_sheet_arr[sel_tls_mrk_ind],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;

      {FX Settings} {$region -fold}
      fx_cnt      :=001;
      pix_drw_type:=000;

      with fx_arr[0] do
        begin
          with nt_fx_prop do
            begin
              //if (img_kind=3{<>4}) then
                cfx_pow0  :=150;
              rep_cnt     :=001;
              pix_cfx_type:=002;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;

      SdrTypeCng(fast_image_data_ptr0,
                 fast_image_data); {$endregion}

    end;
end; {$endregion}
procedure TPivot.SelectionToolsMarkerDraw(const x,y:integer);                                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with sprite_sheet_arr[sel_tls_mrk_ind],fast_image_data,fast_image_proc_var do
    SdrProc[sdr_proc_ind](x-bmp_ftimg_width_origin >>1,
                          y-bmp_ftimg_height_origin>>1,
                          @fast_image_data);
end; {$endregion}
procedure TPivot.SetPivotAxisRect(const pt_rct:TPtRect; const margin:TColor=10);                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  pvt_axis_rect:=PtRct(pt_rct.left  +margin,
                       pt_rct.top   +margin,
                       pt_rct.right -margin,
                       pt_rct.bottom-margin);
end; {$endregion}
procedure TPivot.PivotCalc(const pts:TPtPosFArr; const sel_pts_inds:TColorArr; const sel_pts_cnt:TColor);              {$ifdef Linux}[local];{$endif} {$region -fold}
var
  sel_pts_inds_ptr: PInteger;
  p               : TPtPosF;
  i,j,sel_obj_ind : integer;
  sel_obj_pts_cnt : integer;
begin
  p               :=Default(TPtPosF);
  pvt_pos         :=Default(TPtPosF);
  sel_pts_inds_ptr:=Unaligned(@sel_pts_inds[0]);
  for i:=0 to sel_pts_cnt-1 do
    begin
      p.x+=pts[sel_pts_inds_ptr^].x;
      p.y+=pts[sel_pts_inds_ptr^].y;
      Inc(sel_pts_inds_ptr);
    end;
  j                 :=0;
  weighted_pvt_shift:=Default(TPtPosF);
  while (j<sel_pts_cnt) do
    begin
      sel_obj_pts_cnt:=0;
      sel_obj_ind    :=sln_var.sln_obj_ind[sel_pts_inds[j]];
      while (j<sel_pts_cnt) do
        begin
          if (sln_var.sln_obj_ind[sel_pts_inds[j]]=sel_obj_ind) then
            begin
              Inc(j);
              Inc(sel_obj_pts_cnt);
            end
          else
            Break;
        end;
      weighted_pvt_shift.x+=sel_obj_pts_cnt*obj_var.obj_arr[obj_var.curve_inds_obj_arr[sel_obj_ind]].world_axis_shift.x;
      weighted_pvt_shift.y+=sel_obj_pts_cnt*obj_var.obj_arr[obj_var.curve_inds_obj_arr[sel_obj_ind]].world_axis_shift.y;
    end;
  pvt_pos.x    :=(p.x+weighted_pvt_shift.x)/sel_pts_cnt;
  pvt_pos.y    :=(p.y+weighted_pvt_shift.y)/sel_pts_cnt;
  pvt_origin   :=pvt_pos;
  pvt_pos_first:=pvt_pos;
end; {$endregion}
procedure TPivot.AlignPivotOnX(var x,y:integer; shift:TShiftState);                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if need_align_pivot_x then
    y:=align_pivot.y;
  if (shift=[ssCtrl]) then
    begin
      need_align_pivot_y:=False;
      if (not need_align_pivot_x) then
        align_pivot.y:=y;
      need_align_pivot_x:=True;
    end
  else
    need_align_pivot_x:=False;
end; {$endregion}
procedure TPivot.AlignPivotOnY(var x,y:integer; shift:TShiftState);                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if need_align_pivot_y then
    x:=align_pivot.x;
  if (shift=[ssShift]) then
    begin
      need_align_pivot_x:=False;
      if (not need_align_pivot_y) then
        align_pivot.x:=x;
      need_align_pivot_y:=True;
    end
  else
    need_align_pivot_y:=False;
end; {$endregion}
procedure TPivot.AlignPivotOnP(var x,y:integer; shift:TShiftState);                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (shift=[ssAlt]) then
    PivotToPoint(x,y,False);
end; {$endregion}
procedure TPivot.PivotToPoint     (x,y:integer);                                                                       {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr               : PPtPosF;
  obj_arr_ptr           : PObjProp;
  is_point_in_circle_ptr: PByteBool;
  v,inf,sup             : double;
  i,j,ind_of_min        : integer;
begin
  with sel_var,sln_var,crc_sel_var do
    begin
      inf                   :=0;
      sup                   :=crc_rad_sqr;
      ind_of_min            :=0;
      snap_to_pt            :=False;
      pts_ptr               :=Unaligned(@sln_pts           [0]);
      is_point_in_circle_ptr:=Unaligned(@is_point_in_circle[0]);
      for i:=0 to sln_obj_cnt-1 do
        begin
          obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]]);
          for j:=0 to sln_obj_pts_cnt[i]-1 do
            begin
              v:=sqr(pts_ptr^.x-x+obj_arr_ptr^.world_axis_shift.x)+
                 sqr(pts_ptr^.y-y+obj_arr_ptr^.world_axis_shift.y);
              if (v<=crc_rad_sqr) then
                begin
                  if (not is_point_in_circle_ptr^) then
                    begin
                      is_point_in_circle_ptr^:=True;
                      if (v<=sup-inf) then
                        begin
                          inf       :=sup-v;
                          ind_of_min:=partial_pts_sum[i]+j;
                        end;
                    end;
                  if is_point_in_circle_ptr^ then
                     is_point_in_circle_ptr^:=False;
                end;
              Inc(pts_ptr);
              Inc(is_point_in_circle_ptr);
            end;
        end;
      snap_to_pt:=sqr(sln_pts[ind_of_min].x-x+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_obj_ind[ind_of_min]]].world_axis_shift.x)+
                  sqr(sln_pts[ind_of_min].y-y+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_obj_ind[ind_of_min]]].world_axis_shift.y)<=crc_rad_sqr;
      if snap_to_pt then
        begin
          pvt_pos.x:=sln_pts[ind_of_min].x+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_obj_ind[ind_of_min]]].world_axis_shift.x;
          pvt_pos.y:=sln_pts[ind_of_min].y+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_obj_ind[ind_of_min]]].world_axis_shift.y;
        end
      else
        begin
          pos_dif.x:=x-pvt_pos.x;
          pos_dif.y:=y-pvt_pos.y;
        end;
      pvt_to_pt_draw_pt:=snap_to_pt;
    end;
end; {$endregion}
procedure TPivot.PivotToPoint     (x,y:integer; b:boolean);                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pts_ptr               : PPtPosF;
  prev_pvt_pos          : TPtPosF;
  obj_arr_ptr           : PObjProp;
  is_point_in_circle_ptr: PByteBool;
  is_point_selected_ptr : PByteBool;
  v,inf,sup             : double;
  i,j,ind_of_min        : integer;
begin
  with sel_var,sln_var,crc_sel_var do
    begin
      inf                   :=0;
      sup                   :=crc_rad_sqr;
      ind_of_min            :=0;
      snap_to_pt            :=False;
      pts_ptr               :=Unaligned(@sln_pts           [0]);
      is_point_in_circle_ptr:=Unaligned(@is_point_in_circle[0]);
      is_point_selected_ptr :=Unaligned(@is_point_selected [0]);
      for i:=0 to sln_obj_cnt-1 do
        begin
          obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]]);
          for j:=0 to sln_obj_pts_cnt[i]-1 do
            begin
              v:=sqr(pts_ptr^.x-x+obj_arr_ptr^.world_axis_shift.x)+
                 sqr(pts_ptr^.y-y+obj_arr_ptr^.world_axis_shift.y);
              if (v<=crc_rad_sqr) and (not is_point_selected_ptr^) then
                begin
                  if (not is_point_in_circle_ptr^) then
                    begin
                      is_point_in_circle_ptr^:=True;
                      if (v<=sup-inf) then
                        begin
                          inf       :=sup-v;
                          ind_of_min:=partial_pts_sum[i]+j;
                        end;
                    end;
                  if is_point_in_circle_ptr^ then
                     is_point_in_circle_ptr^:=False;
                end;
              Inc(pts_ptr);
              Inc(is_point_in_circle_ptr);
              Inc(is_point_selected_ptr);
            end;
        end;
      snap_to_pt:=sqr(sln_pts[ind_of_min].x-x+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_obj_ind[ind_of_min]]].world_axis_shift.x)+
                  sqr(sln_pts[ind_of_min].y-y+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_obj_ind[ind_of_min]]].world_axis_shift.y)<=crc_rad_sqr;
      prev_pvt_pos:=pvt_pos;
      if snap_to_pt then
        begin
          pvt_pos.x:=sln_pts[ind_of_min].x+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_obj_ind[ind_of_min]]].world_axis_shift.x;
          pvt_pos.y:=sln_pts[ind_of_min].y+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_obj_ind[ind_of_min]]].world_axis_shift.y;
          if (snap_mode.first_time_snap=0) then
            begin
              snap_mode.first_time_snap:=1;
              pos_dif.x                :=pvt_pos.x-prev_pvt_pos.x;
              pos_dif.y                :=pvt_pos.y-prev_pvt_pos.y;
            end
          else
            begin
              snap_mode.first_time_snap:=2;
              pos_dif.x                :=0;
              pos_dif.y                :=0;
            end;
        end
      else
        begin
          snap_mode.first_time_snap:=0;
          pos_dif.x:=x-pvt_pos.x;
          pos_dif.y:=y-pvt_pos.y;
          pvt_pos.x:=x;
          pvt_pos.y:=y;
        end;
      pvt_to_pt_draw_pt:=snap_to_pt;
    end;
end; {$endregion}
procedure TPivot.PivotToPoint     (x,y:integer; density:TColor);                                                       {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt         : TPtPos;
  a,b,b2,c,m : double;
  i,d,pts_ind: integer;
begin
  {
    TLnPos=packed record
      x0,y0,x1,y1: integer;
    end;

    TPtPos=packed record
      x,y: integer;
    end;

    srf_var_ptr       - target drawing surface;
    srf_bmp           - target drawing surface(bitmap);
    srf_bmp_ptr       - pointer to target drawing surface(srf_bmp);
    rct_clp           - target drawing rectangular area;
    crc_rad           - circle radius;
    mos_mot_vec       - mouse motion vector;
    mos_mot_vec       : TLnPos;
    pvt_prev          - previous pivot;
    pvt_prev          : TPtPos;
    pvt               - pivot;
    pvt               : TPtPos;
    pvt_to_pt_draw_pt - checks if pivot needs to be drawn;
  }
  with sel_var,sln_var,crc_sel_var do
    begin
      snap_to_pt    :=False;
      density       :=Min(density,crc_rad); // density between circles;
      mos_mot_vec.x1:=x;
      mos_mot_vec.y1:=y;
      for i:=1 to Trunc(crc_rad/density) do
        begin
          d:=density*i;
          if IsPtInRct(x,y,PtRct(srf_var_ptr^.inn_wnd_rct.left  +d,
                                 srf_var_ptr^.inn_wnd_rct.top   +d,
                                 srf_var_ptr^.inn_wnd_rct.right -d,
                                 srf_var_ptr^.inn_wnd_rct.bottom-d)) then
            begin
              if CircleW(x,y,d,dup_pts_arr,srf_var_ptr^.srf_bmp.width,pvt_pos) then // drawing of regular circle(wave)
                begin
                  snap_to_pt:=True;
                  Break;
                end;
            end
          else
            begin
              if CircleWC(x,y,d,dup_pts_arr,srf_var_ptr^.srf_bmp.width,srf_var_ptr^.inn_wnd_rct,pvt_pos) then // drawing of clipped circle(wave)
                begin
                  snap_to_pt:=True;
                  Break;
                end;
            end;
        end;
      pt       :=PtPos(pvt_pos);
      pts_ind  :=dup_pts_arr[pt.x+pt.y*pts_big_img.ln_arr_width].pts_ind;
      pvt_pos.x:=sln_pts[pts_ind].x+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_obj_ind[pts_ind]]].world_axis_shift.x;
      pvt_pos.y:=sln_pts[pts_ind].y+obj_var.obj_arr[obj_var.curve_inds_obj_arr[sln_obj_ind[pts_ind]]].world_axis_shift.y;
      if snap_to_pt then
        begin
          //4*(m^2):=2*(b^2+c^2)-a^2;
          m :=  sqrt(sqr(mos_mot_vec.x0-mos_mot_vec.x1)+sqr(mos_mot_vec.y0-mos_mot_vec.y1));
          a :=2*sqrt(sqr(pvt_prev.x    -pvt_pos.x)     +sqr(pvt_prev.y    -pvt_pos.y));
          b :=  sqrt(sqr(mos_mot_vec.x1-pvt_pos.x)     +sqr(mos_mot_vec.y1-pvt_pos.y));
          b2:=  sqrt(sqr(pvt_pos.x     +pvt_prev.x     -    mos_mot_vec.x0-mos_mot_vec.x1)+
                     sqr(pvt_pos.y     +pvt_prev.y     -    mos_mot_vec.y0-mos_mot_vec.y1));
          c :=  sqrt(((4*m*m+a*a)/2)-b*b);
          if (Trunc(b2)=Max(Trunc(b),Trunc(c))) then
            begin
              pvt_pos.x:=pvt_prev.x;
              pvt_pos.y:=pvt_prev.y;
            end;
          pvt_prev.x:=pvt_pos.x;
          pvt_prev.y:=pvt_pos.y;
        end
      else
        begin
          pvt_pos.x:=x;
          pvt_pos.y:=y;
        end;
      pvt_to_pt_draw_pt:=snap_to_pt;
      FilSelPtsObj(x-crc_rad,y-crc_rad);
      {if IsPtInRct(x,y,PtRct(rct_clp.left  +crc_rad,
                              rct_clp.top   +crc_rad,
                              rct_clp.right -crc_rad,
                              rct_clp.bottom-crc_rad)) then
        Circle (x,y,crc_rad,srf_var_ptr^.srf_bmp_ptr,srf_var_ptr^.srf_bmp.width,clBlue)
      else
        CircleC(x,y,crc_rad,srf_var_ptr^.srf_bmp_ptr,srf_var_ptr^.srf_bmp.width,srf_var_ptr^.inn_wnd_rct,clBlue);}
      mos_mot_vec.x0:=mos_mot_vec.x1;
      mos_mot_vec.y0:=mos_mot_vec.y1;
    end;
end; {$endregion}
procedure TPivot.SclSettings      (x,y:integer);                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  curr_mouse_pos:=PtPosF(x,y);
  scl_dir       :=GetDir2(prev_mouse_pos,curr_mouse_pos,pvt_pos                );
                  SetMul (prev_mouse_pos,curr_mouse_pos,pvt_pos,pvt_scl,scl_dir);
  prev_mouse_pos:=curr_mouse_pos;
end; {$endregion}
procedure TPivot.SelPtsPosCalc    (x,y:integer);                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if snap_mode.snap_event then
    Exit;
  pos_dif.x:=x-{Trunc(}pvt_pos.x{)};
  pos_dif.y:=y-{Trunc(}pvt_pos.y{)};
end; {$endregion}
procedure TPivot.SelPtsSclCalc    (x,y:integer);                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if snap_mode.snap_event then
    Exit;
  scl_dif.x:=(pvt_pos.x-(weighted_pvt_shift.x/sel_var.sel_pts_cnt))*(1-pvt_scl.x);
  scl_dif.y:=(pvt_pos.y-(weighted_pvt_shift.y/sel_var.sel_pts_cnt))*(1-pvt_scl.y);
end; {$endregion}
procedure TPivot.SelPtsRotCalc    (x,y:integer);                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if snap_mode.snap_event then
    Exit;
  // TODO
end; {$endregion}
procedure TPivot.SelPtsRctPosCalc (x,y:integer; var sel_pts_rect:TPtRectF);                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if snap_mode.snap_event then
    Exit;
  with sel_pts_rect do
    begin
      Left  +=x-Trunc(pvt_pos.x);
      Top   +=y-Trunc(pvt_pos.y);
      Right +=x-Trunc(pvt_pos.x);
      Bottom+=y-Trunc(pvt_pos.y);
    end;
  pvt_pos:=PtPosF(x,y);
end; {$endregion}
procedure TPivot.SelPtsRctSclCalc (x,y:integer; var sel_pts_rect:TPtRectF);                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if snap_mode.snap_event then
    Exit;
  PtsScl(pvt_pos,sel_pts_rect,pvt_scl,scl_dir);
end; {$endregion}
procedure TPivot.SelPtsRctRotCalc (x,y:integer; var sel_pts_rect:TPtRectF);                                    inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if snap_mode.snap_event then
    Exit;
end; {$endregion}
procedure TPivot.IsPivotOutOfInnerWindow(var custom_rect:TPtRect; const pvt_:TPtPosF);                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  m1,m2,m3,m4: integer;
  x0,y0,x1,y1: integer;
  k,b,d:       integer;
begin

  begin
    pvt_marker_draw  :=False;
    pvt_marker_left  :=False;
    pvt_marker_top   :=False;
    pvt_marker_right :=False;
    pvt_marker_bottom:=False;
  end;

  with srf_var_ptr^ do
    begin
      m1:=custom_rect.Left;
      m2:=custom_rect.Top;
      m3:=custom_rect.Right;
      m4:=custom_rect.Bottom;
    end;

  x0:=Trunc((m1+m3)/2);
  y0:=Trunc((m2+m4)/2);
  x1:=Trunc(pvt_pos.x);
  y1:=Trunc(pvt_pos.y);

  k:=y1-y0;
  b:=y0*x1-y1*x0;
  d:=x1-x0;

  {Сверху-слева}
  if (pvt_pos.x<m1) and
     (pvt_pos.y<m2) then
    begin
      if ((k*m1+b)/d>m2) then
        begin
          pvt_marker_draw:=True;
          pvt_marker_left:=True;
          pvt_marker.x:=m1;
          pvt_marker.y:=(k*m1+b) div d;
        end
      else
        begin
          pvt_marker_draw:=True;
          pvt_marker_top :=True;
          pvt_marker.x:=(d*m2-b) div k;
          pvt_marker.y:=m2;
        end;
      Exit;
    end

  {Сверху}
  else
  if (pvt_pos.x>m1) and
     (pvt_pos.x<m3) and
     (pvt_pos.y<m2) then
    begin
      pvt_marker_draw:=True;
      pvt_marker_top :=True;
      pvt_marker.x:=(d*m2-b) div k;
      pvt_marker.y:=m2;
      Exit;
    end

  {Сверху-справа}
  else
  if (pvt_pos.x>m3) and
     (pvt_pos.y<m2) then
    begin
      if ((k*m3+b)/d>m2) then
        begin
          pvt_marker_draw :=True;
          pvt_marker_right:=True;
          pvt_marker.x:=m3;
          pvt_marker.y:=(k*m3+b) div d;
        end
      else
        begin
          pvt_marker_draw:=True;
          pvt_marker_top :=True;
          pvt_marker.x:=(d*m2-b) div k;
          pvt_marker.y:=m2;
        end;
      Exit;
    end

  {Слева}
  else
  if (pvt_pos.y>m2) and
     (pvt_pos.y<m4) and
     (pvt_pos.x<m1) then
    begin
      pvt_marker_draw:=True;
      pvt_marker_left:=True;
      pvt_marker.x:=m1;
      pvt_marker.y:=(k*m1+b) div d;
      Exit;
    end

  {Справа}
  else
  if (pvt_pos.y>m2) and
     (pvt_pos.y<m4) and
     (pvt_pos.x>m3) then
    begin
      pvt_marker_draw :=True;
      pvt_marker_right:=True;
      pvt_marker.x:=m3;
      pvt_marker.y:=(k*m3+b) div d;
      Exit;
    end

  {Снизу-слева}
  else
  if (pvt_pos.x<m1) and
     (pvt_pos.y>m4) then
    begin
      if ((k*m1+b)/d<m4) then
        begin
          pvt_marker_draw:=True;
          pvt_marker_left:=True;
          pvt_marker.x:=m1;
          pvt_marker.y:=(k*m1+b) div d;
        end
      else
        begin
          pvt_marker_draw  :=True;
          pvt_marker_bottom:=True;
          pvt_marker.x:=(d*m4-b) div k;
          pvt_marker.y:=m4;
        end;
      Exit;
    end

  {Снизу}
  else
  if (pvt_pos.x>m1) and
     (pvt_pos.x<m3) and
     (pvt_pos.y>m4) then
    begin
      pvt_marker_draw  :=True;
      pvt_marker_bottom:=True;
      pvt_marker.x:=(d*m4-b) div k;
      pvt_marker.y:=m4;
      Exit;
    end

  {Снизу-справа}
  else
  if (pvt_pos.x>m3) and
     (pvt_pos.y>m4) then
    begin
      if ((k*m3+b)/d<m4) then
        begin
          pvt_marker_draw:=True;
          pvt_marker_right:=True;
          pvt_marker.x:=m3;
          pvt_marker.y:=(k*m3+b) div d;
        end
      else
        begin
          pvt_marker_draw  :=True;
          pvt_marker_bottom:=True;
          pvt_marker.x:=(d*m4-b) div k;
          pvt_marker.y:=m4;
        end;
      Exit;
    end

  else
    pvt_marker_draw:=False;

end; {$endregion}
procedure TPivot.PivotToPointDraw(cnv_dst:TCanvas);                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with cnv_dst do
    begin
      Pen.Mode   :=pmcopy;
      Pen.Color  :=clRed;
      Brush.Style:=bsClear;
      Rectangle(Trunc(pvt_pos.x)-4,
                Trunc(pvt_pos.y)-4,
                Trunc(pvt_pos.x)+5,
                Trunc(pvt_pos.y)+5);
    end;
end; {$endregion}
procedure TPivot.PivotModeDraw   (cnv_dst:TCanvas);                                                            inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with cnv_dst do
    case pvt_mode of
      (pmPivotMove):
        begin
          Pen.Mode :=pmMerge;
          Pen.Color:=clRed;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-18,
                    Trunc(pvt_pos.x)+18,Trunc(pvt_pos.y));
          Pen.Width:=2;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-24,
                    Trunc(pvt_pos.x)+24,Trunc(pvt_pos.y));
          {
          Pen.Color:=clGreen;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y),
                    Trunc(pvt_pos.x)+60,Trunc(pvt_pos.y));
          LineTo   (Trunc(pvt_pos.x)+50,Trunc(pvt_pos.y)-2);
          LineTo   (Trunc(pvt_pos.x)+50,Trunc(pvt_pos.y)+2);
          LineTo   (Trunc(pvt_pos.x)+60,Trunc(pvt_pos.y));
          Pen.Color:=clBlue;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y),
                    Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-60);
          LineTo   (Trunc(pvt_pos.x)-2, Trunc(pvt_pos.y)-50);
          LineTo   (Trunc(pvt_pos.x)+2, Trunc(pvt_pos.y)-50);
          LineTo   (Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-60);
          }
          Pen.Width:=1;
        end;
      (pmPivotScale):
        begin
          Pen.Mode :=pmMerge;
          Pen.Color:=clRed;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-18,
                    Trunc(pvt_pos.x)+18,Trunc(pvt_pos.y)-18);
          Line     (Trunc(pvt_pos.x)+18,Trunc(pvt_pos.y)-18,
                    Trunc(pvt_pos.x)+18,Trunc(pvt_pos.y));
          Pen.Width:=2;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-24,
                    Trunc(pvt_pos.x)+24,Trunc(pvt_pos.y)-24);
          Line     (Trunc(pvt_pos.x)+24,Trunc(pvt_pos.y)-24,
                    Trunc(pvt_pos.x)+24,Trunc(pvt_pos.y));
          {
          Pen.Color:=clGreen;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y),
                    Trunc(pvt_pos.x)+60,Trunc(pvt_pos.y));
          LineTo   (Trunc(pvt_pos.x)+50,Trunc(pvt_pos.y)-2);
          LineTo   (Trunc(pvt_pos.x)+50,Trunc(pvt_pos.y)+2);
          LineTo   (Trunc(pvt_pos.x)+60,Trunc(pvt_pos.y));
          Pen.Color:=clBlue;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y),
                    Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-60);
          LineTo   (Trunc(pvt_pos.x)-2, Trunc(pvt_pos.y)-50);
          LineTo   (Trunc(pvt_pos.x)+2, Trunc(pvt_pos.y)-50);
          LineTo   (Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-60);
          }
          Pen.Width:=1;
        end;
      (pmPivotRotate):
        begin
          Brush.Style:=bsClear;
          Pen.Mode :=pmMerge;
          Pen.Color  :=clRed;
          Pen.Width  :=2;
          RadialPie(Trunc(pvt_pos.x)-24,Trunc(pvt_pos.y)+24,
                    Trunc(pvt_pos.x)+24,Trunc(pvt_pos.y)-24,3,-1440);
          Pen.Width  :=1;
          RadialPie(Trunc(pvt_pos.x)-18,Trunc(pvt_pos.y)+18,
                    Trunc(pvt_pos.x)+18,Trunc(pvt_pos.y)-18,3,-1440);
          {
          Pen.Color:=clGreen;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y),
                    Trunc(pvt_pos.x)+60,Trunc(pvt_pos.y));
          LineTo   (Trunc(pvt_pos.x)+50,Trunc(pvt_pos.y)-2);
          LineTo   (Trunc(pvt_pos.x)+50,Trunc(pvt_pos.y)+2);
          LineTo   (Trunc(pvt_pos.x)+60,Trunc(pvt_pos.y));
          Pen.Color:=clBlue;
          Line     (Trunc(pvt_pos.x),   Trunc(pvt_pos.y),
                    Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-60);
          LineTo   (Trunc(pvt_pos.x)-2, Trunc(pvt_pos.y)-50);
          LineTo   (Trunc(pvt_pos.x)+2, Trunc(pvt_pos.y)-50);
          LineTo   (Trunc(pvt_pos.x),   Trunc(pvt_pos.y)-60);
          }
          Brush.Style:=bsSolid;
          Pen.Width:=1;
        end;
    end;
end; {$endregion}
procedure TPivot.PivotAxisDraw0  (cnv_dst:TCanvas; const custom_rct:TPtRect; const shift:TPtPos);              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with cnv_dst do
    begin

      Pen.Width:=3;
      {
      Pen.Mode :=pmMerge;
      Pen.Color:=clGreen;
      Pen.Style:=psSolid;
      {$ifdef Windows}
      MoveTo(custom_rct.left ,Trunc(pvt_pos.y)+shift.y);
      Windows.LineTo(Handle  ,Trunc(pvt_pos.x)+shift.x-10,
                              Trunc(pvt_pos.y)+shift.y);
      MoveTo(custom_rct.right,Trunc(pvt_pos.y)+shift.y);
      Windows.LineTo(Handle  ,Trunc(pvt_pos.x)+shift.x+10,
                              Trunc(pvt_pos.y)+shift.y);
      MoveTo(                 Trunc(pvt_pos.x)+shift.x,custom_rct.top   );
      Windows.LineTo(Handle  ,Trunc(pvt_pos.x)+shift.x,
                              Trunc(pvt_pos.y)+shift.y-10);
      MoveTo(                 Trunc(pvt_pos.x)+shift.x,custom_rct.bottom);
      Windows.LineTo(Handle  ,Trunc(pvt_pos.x)+shift.x,
                              Trunc(pvt_pos.y)+shift.y+10);
      {$else}
      Line(custom_rct.left ,Trunc(pvt_pos.y)+shift.y,
                            Trunc(pvt_pos.x)+shift.x-10,
                            Trunc(pvt_pos.y)+shift.y);
      Line(custom_rct.right,Trunc(pvt_pos.y)+shift.y,
                            Trunc(pvt_pos.x)+shift.x+10,
                            Trunc(pvt_pos.y)+shift.y);
      Line(                 Trunc(pvt_pos.x)+shift.x,custom_rect.top   ,
                            Trunc(pvt_pos.x)+shift.x,
                            Trunc(pvt_pos.y)+shift.y-10);
      Line(                 Trunc(pvt_pos.x)+shift.x,custom_rect.bottom,
                            Trunc(pvt_pos.x)+shift.x,
                            Trunc(pvt_pos.y)+shift.y+10);
      {$endif}
      }
      Pen.Mode :=pmMerge{pmCopy};
      Pen.Color:=clLime;
      Pen.Style:=psDash;
      {$ifdef Windows}
      MoveTo(custom_rct.left ,Trunc(pvt_pos.y)+shift.y);
      Windows.LineTo(Handle  ,Trunc(pvt_pos.x)+shift.x-10,
                              Trunc(pvt_pos.y)+shift.y);
      MoveTo(custom_rct.right,Trunc(pvt_pos.y)+shift.y);
      Windows.LineTo(Handle  ,Trunc(pvt_pos.x)+shift.x+10,
                              Trunc(pvt_pos.y)+shift.y);
      MoveTo(                 Trunc(pvt_pos.x)+shift.x,custom_rct.top   );
      Windows.LineTo(Handle  ,Trunc(pvt_pos.x)+shift.x,
                              Trunc(pvt_pos.y)+shift.y-10);
      MoveTo(                 Trunc(pvt_pos.x)+shift.x,custom_rct.bottom);
      Windows.LineTo(Handle  ,Trunc(pvt_pos.x)+shift.x,
                              Trunc(pvt_pos.y)+shift.y+10);
      {$else}
      Line(custom_rct.left ,Trunc(pvt_pos.y)+shift.y,
                            Trunc(pvt_pos.x)+shift.x-10,
                            Trunc(pvt_pos.y)+shift.y);
      Line(custom_rct.right,Trunc(pvt_pos.y)+shift.y,
                            Trunc(pvt_pos.x)+shift.x+10,
                            Trunc(pvt_pos.y)+shift.y);
      Line(                 Trunc(pvt_pos.x)+shift.x,custom_rct.top   ,
                            Trunc(pvt_pos.x)+shift.x,
                            Trunc(pvt_pos.y)+shift.y-10);
      Line(                 Trunc(pvt_pos.x)+shift.x,custom_rct.bottom,
                            Trunc(pvt_pos.x)+shift.x,
                            Trunc(pvt_pos.y)+shift.y+10);
      {$endif}

      Pen.Width:=1;
      Pen.Mode :=pmCopy;
      Pen.Style:=psSolid;

    end;
end; {$endregion}
procedure TPivot.PivotAxisDraw1  (cnv_dst:TCanvas; const custom_rct:TPtRect; const shift:TPtPos; x,y:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  color_info: TColorInfo;
begin
  SetColorInfo($007889E9,color_info);
  LineAC(Trunc(pvt_origin.x),Trunc(pvt_origin.y),x,y,srf_var_ptr^.srf_bmp_ptr,srf_var_ptr^.srf_bmp.width,custom_rct,color_info);
end; {$endregion}
procedure TPivot.PivotBoundsDraw;                                                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  //
end; {$endregion}
procedure TPivot.PivotAngleDraw;                                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  //
end; {$endregion}
procedure TPivot.PivotDraw(const shift:TPtPos; x,y:integer);                                                   inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with srf_var_ptr^.srf_bmp do
    begin
      PivotModeDraw (Canvas);
      PivotAxisDraw0(Canvas,pvt_axis_rect,shift);
      PivotAxisDraw1(Canvas,pvt_axis_rect,shift,x,y);
      if (pvt_mode<>pmPivotMove) then
        SelectionToolsMarkerDraw(x,y);
      LocalAxisDraw (Trunc(pvt_pos.x),Trunc(pvt_pos.y));
    end;
end; {$endregion}
{$endregion}

// (Select Background Region) Выделить область фона:
{LI} {$region -fold}
procedure TF_MainForm.SB_Select_Background_RegionClick(sender:TObject); {$region -fold}
begin
  SB_Draw_Buttons_Button_Bkgnd.Left   :=SB_Select_Background_Region.Left;
  SB_Draw_Buttons_Button_Bkgnd.Visible:=SB_Select_Background_Region.Down;
  DrawingPanelsSetVisibility1(down_select_texture_region_ptr,P_Draw_Buttons,P_Select_Texture_Region,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_select_texture_region_ptr^) then
    Exit;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
{$endregion}

// (Tilemap) Тайловая карта:
{LI} {$region -fold}
constructor TTlMap.Create;                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  srf_var_ptr  :=@srf_var;
  show_tile_map:=True;
  TileMapSpriteDefaultIconCreate;
end; {$endregion}
destructor  TTlMap.Destroy;                                                           {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure TTlMap.TileMapSpriteDefaultIconCreate;                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // Create Mask Template Sprite Icon:
  SetLength(tilemap_sprite_inds_arr,Length(tilemap_sprite_inds_arr)+1);
  SetLength(sprite_sheet_arr       ,Length(sprite_sheet_arr       )+1);
  with srf_var_ptr^ do
    sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
    (
      srf_bmp_ptr,
      srf_bmp.width,
      srf_bmp.height,
      inn_wnd_rct,
      max_sprite_w_h_rct,
      Application.Location+DEFAULT_TILE_MAP_SPRITE_ICON,
      @F_MainForm.IL_Default_Tile_Map_Sprite_Icon.GetBitmap,
      0
    );
  tilemap_sprite_inds_arr[Length(tilemap_sprite_inds_arr)-1]:=Length(sprite_sheet_arr)-1;
  with sprite_sheet_arr[tilemap_sprite_inds_arr[Length(tilemap_sprite_inds_arr)-1]],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      SetPPInfo (clRed           );
      SetGradVec(0,rct_ent.height);
      SetGradCol(0,255           );

      {FX Settings} {$region -fold}
      fx_cnt      :=001;
      pix_drw_type:=000;

      with fx_arr[0] do
        begin
          pt_as_nt:=False;
          with nt_fx_prop do
            begin
              //if (img_kind=3{<>4}) then
                cfx_pow0  :=064;
              rep_cnt     :=001;
              pix_cfx_type:=000;
              pix_cng_type:=000;
              pix_srf_type:=001;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;

      with fx_arr[1] do
        begin
          pt_as_nt:=False;
          with nt_fx_prop do
            begin
              cfx_pow0    :=032;
              rep_cnt     :=001;
              pix_cfx_type:=000;
              pix_cng_type:=000;
              pix_srf_type:=001;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;

      SdrTypeCng(fast_image_data_ptr0,
                 fast_image_data); {$endregion}

    end;
end; {$endregion}
procedure TTlMap.AddTileMapObj;                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(tilemap_inds_arr,Length(tilemap_inds_arr)+1);
  SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
  with srf_var_ptr^ do
    sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
    (
      srf_bmp_ptr,
      srf_bmp.width,
      srf_bmp.height,
      obj_var.obj_arr[obj_var.tlmap_inds_obj_arr[obj_var.tlmap_cnt-1]].rct_clp_ptr^,
      max_sprite_w_h_rct,
      F_MainForm.OPD_Add_TileMap.Filename,
      @F_MainForm.IL_Default_Tile_Map_Icon.GetBitmap,
      0,
      True{,
      Nil,
      True}
    );
  tilemap_inds_arr[Length(tilemap_inds_arr)-1]:=Length(sprite_sheet_arr)-1;
  with sprite_sheet_arr[tilemap_inds_arr[Length(tilemap_inds_arr)-1]],fast_image_data do
    begin
      if (Length(tilemap_sprite_inds_arr)<>0) then
        tilemap_sprite_ind:=                       tilemap_sprite_inds_arr[Length(tilemap_sprite_inds_arr)-1];
        tilemap_sprite_w_h:=PtPos(sprite_sheet_arr[tilemap_sprite_ind].fast_image_data.bmp_ftimg_width_origin,
                                  sprite_sheet_arr[tilemap_sprite_ind].fast_image_data.bmp_ftimg_height_origin);
    end;
end; {$endregion}
procedure TTlMap.AddTileMapSpriteObj;                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SetLength(tilemap_sprite_inds_arr,Length(tilemap_sprite_inds_arr)+1);
  SetLength(sprite_sheet_arr       ,Length(sprite_sheet_arr       )+1);
  with srf_var_ptr^ do
    sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
    (
      srf_bmp_ptr,
      srf_bmp.width,
      srf_bmp.height,
      inn_wnd_rct{obj_var.obj_arr[obj_var.tlmap_inds_obj_arr[obj_var.tlmap_cnt-1]].rct_clp_ptr^},
      max_sprite_w_h_rct,
      F_MainForm.OPD_Add_TileMap_Sprite.Filename,
      Nil,
      0
    );
                        tilemap_sprite_inds_arr[Length(tilemap_sprite_inds_arr)-1]:=Length(sprite_sheet_arr)-1;
  with sprite_sheet_arr[tilemap_sprite_inds_arr[Length(tilemap_sprite_inds_arr)-1]],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      SetPPInfo (clRed           );
      SetGradVec(0,rct_ent.height);
      SetGradCol(0,255           );

      {FX Settings} {$region -fold}
      fx_cnt      :=001;
      pix_drw_type:=000;

      with fx_arr[0] do
        begin
          pt_as_nt:=False;
          with nt_fx_prop do
            begin
              //if (img_kind=3{<>4}) then
                cfx_pow0  :=255;
              rep_cnt     :=001;
              pix_cfx_type:=000;
              pix_cng_type:=000;
              pix_srf_type:=001;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;

      with fx_arr[1] do
        begin
          pt_as_nt:=False;
          with nt_fx_prop do
            begin
              cfx_pow0    :=032;
              rep_cnt     :=001;
              pix_cfx_type:=000;
              pix_cng_type:=000;
              pix_srf_type:=001;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;

      SdrTypeCng(fast_image_data_ptr0,
                 fast_image_data); {$endregion}

    end;
end; {$endregion}
procedure TTlMap.AddTileMapPreview;                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TTlMap.AddTileMapSpritePreview;                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
end; {$endregion}
procedure TTlMap.TileMapDraw  (const tlmap_ind:TColor; rct_clp_ptr_:PPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr: PObjProp;
begin
  if show_tile_map then
    with srf_var_ptr^,sprite_sheet_arr[tilemap_inds_arr[tlmap_ind]],fast_image_data,fast_image_proc_var do
      begin
        fast_image_data_ptr1:=@fast_image_data;
        fast_image_data_ptr2:=@sprite_sheet_arr[tilemap_sprite_ind].fast_image_data;
        fast_image_data_ptr0:=fast_image_data_ptr1;
        obj_arr_ptr         :=@obj_var.obj_arr[obj_var.tlmap_inds_obj_arr[tlmap_ind]];
        SetRctPos (Trunc(world_axis.x)+Trunc(obj_arr_ptr^.world_axis_shift.x)-(bmp_ftimg_width_origin *tilemap_sprite_w_h.x)>>1,
                   Trunc(world_axis.y)+Trunc(obj_arr_ptr^.world_axis_shift.y)-(bmp_ftimg_height_origin*tilemap_sprite_w_h.y)>>1);
        SetRctPosF(      world_axis.x +      obj_arr_ptr^.world_axis_shift.x -(bmp_ftimg_width_origin *tilemap_sprite_w_h.x)>>1,
                         world_axis.y +      obj_arr_ptr^.world_axis_shift.y -(bmp_ftimg_height_origin*tilemap_sprite_w_h.y)>>1);
        SetBkgnd
        (
          obj_arr_ptr^.bkgnd_ptr,
          obj_arr_ptr^.bkgnd_width,
          obj_arr_ptr^.bkgnd_height,
          rct_clp_ptr_^
        );
        fast_image_data_ptr0:=fast_image_data_ptr2;
        SetBkgnd
        (
          obj_arr_ptr^.bkgnd_ptr,
          obj_arr_ptr^.bkgnd_width,
          obj_arr_ptr^.bkgnd_height,
          rct_clp_ptr_^
        );
        fast_image_data_ptr0:=fast_image_data_ptr1;
        if grid_draw_after then
          FilTileMap1;
        if grid_visible then
          Grid(rct_ent.left,
               rct_ent.top ,
               obj_arr_ptr^.bkgnd_ptr,
               obj_arr_ptr^.bkgnd_width,
               rct_clp_ptr_^,
               grid_color_info,
               tilemap_sprite_w_h.x,
               tilemap_sprite_w_h.y,
               bmp_ftimg_width_origin,
               bmp_ftimg_height_origin);
        if (not grid_draw_after) then
          FilTileMap1;
      end;
end; {$endregion}
procedure TTlMap.FilTileMapObj(const tlmap_ind:TColor);                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  TileMapDraw(tlmap_ind,obj_var.obj_arr[obj_var.tlmap_inds_obj_arr[tlmap_ind]].rct_clp_ptr);
end; {$endregion}
procedure TTlMap.MovTileMapObj(const tlmap_ind:TColor);                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  TileMapDraw(tlmap_ind,obj_var.obj_arr[obj_var.tlmap_inds_obj_arr[tlmap_ind]].rct_dst_ptr);
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_Add_TilemapClick       (sender:TObject); {$region -fold}
begin
  SB_Draw_Buttons_Button_Bkgnd.Left   :=SB_Add_Tilemap.Left;
  SB_Draw_Buttons_Button_Bkgnd.Visible:=SB_Add_Tilemap.Down;
  DrawingPanelsSetVisibility1(down_tlmap_ptr,P_Draw_Buttons,P_Add_Tilemap,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_tlmap_ptr^) then
    Exit;
end; {$endregion}
procedure TF_MainForm.BB_Add_TileMapClick       (sender:TObject); {$region -fold}
begin
  with tlm_var,srf_var_ptr^ do
    begin
              OPD_Add_TileMap.Options:=
              OPD_Add_TileMap.Options+[ofFileMustExist];
      if (not OPD_Add_TileMap.Execute) then
        Exit;
      try
        EventGroupsCalc(calc_arr,[21,30,37,39,41,48]);
      except
        on E: Exception do
          MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
      end;
      AddTileMapPreview;
    end;
end; {$endregion}
procedure TF_MainForm.BB_Add_TileMap_SpriteClick(sender:TObject); {$region -fold}
{var
  exec_time: integer;}
begin
  with tlm_var,srf_var_ptr^ do
    begin
              OPD_Add_TileMap_Sprite.Options:=
              OPD_Add_TileMap_Sprite.Options+[ofFileMustExist];
      if (not OPD_Add_TileMap_Sprite.Execute) then
        Exit;
      try
        begin

          //exec_timer.Start;

          AddTileMapSpriteObj;

          {exec_timer.Stop;

          exec_time:=Trunc(exec_timer.Delay*1000);
          M_Test_Log.Lines.Text:=IntToStr(exec_time);}

          EventGroupsCalc(calc_arr,[21,30,37,41,48]);

        end;
      except
        on E: Exception do
          MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
      end;
      AddTileMapSpritePreview;
    end;
end; {$endregion}
{$endregion}

// (Screen Space Post-processing) Экранная постобработка:
{LI} {$region -fold}
constructor TPProc.Create;                                                            {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  srf_var_ptr:=@srf_var;
end; {$endregion}
destructor  TPProc.Destroy;                                                           {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  inherited Destroy;
end; {$endregion}
procedure   TPProc.AddPProcObj;                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with obj_var do
    begin
      has_blur:=True;
      Inc(blur_layers_cnt);
      cmr_var.mov_dir:=mdNone;
    end;
end; {$endregion}
procedure   TPProc.PProcDraw  (const pproc_ind:TColor; rct_clp_ptr_:PPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_arr_ptr   : PObjProp;
  rct1,rct2,rct3: TPtRect;
  i,j           : integer;
  proc_ind_     : byte=3;
  color_info    : TColorInfo;
begin
  obj_arr_ptr:=Unaligned(@obj_var.obj_arr[obj_var.pproc_inds_obj_arr[pproc_ind]]);
  with obj_arr_ptr^ do
    begin

      {
      if is_low_lr_obj and (proc_ind_=12) then
        with rct_clp_ptr_^ do
          case cmr_var.mov_dir of
            mdLeft :
              begin
                rct1:=PtRct(right+0,top+1,right+1,bottom-1);
                rct2:=PtRct(left +1,top+1,right-0,bottom-1);
                PPBlur     (bkgnd_ptr,bkgnd_width,rct1,@BlurRGB9);
                PPBlurLeft (bkgnd_ptr,bkgnd_width,rct2,@BlurRGB9);
              end;
            mdRight:
              begin
                rct1:=PtRct(left-1,top+1,left +0,bottom-1);
                rct2:=PtRct(left+0,top+1,right-1,bottom-1);
                PPBlur     (bkgnd_ptr,bkgnd_width,rct1,@BlurRGB9);
                PPBlurRight(bkgnd_ptr,bkgnd_width,rct2,@BlurRGB9);
              end;
            mdUp   :
              begin
                rct1:=PtRct(left+1,bottom+0,right-1,bottom+1);
                rct2:=PtRct(left+1,top   +1,right-1,bottom-0);
                PPBlur     (bkgnd_ptr,bkgnd_width,rct1,@BlurRGB9);
                PPBlurUp   (bkgnd_ptr,bkgnd_width,rct2,@BlurRGB9);
              end;
            mdDown :
              begin
                rct1:=PtRct(left+1,top-1,right-1,top   +0);
                rct2:=PtRct(left+1,top+0,right-1,bottom-1);
                PPBlur     (bkgnd_ptr,bkgnd_width,rct1,@BlurRGB9);
                PPBlurDown (bkgnd_ptr,bkgnd_width,rct2,@BlurRGB9);
              end;
            otherwise
              begin
                rct2:=PtRct(left+1,top+1,right-1,bottom-1);
                PPBlur     (bkgnd_ptr,bkgnd_width,rct2,@BlurRGB4{9});
              end;
          end
      else
        begin

          if (proc_ind_=12) then
            with rct_clp_ptr_^ do
              rct2:=PtRct(left+1,top+1,right-1,bottom-1)
          else
              rct2:=rct_clp_ptr_^;

          {with color_info do
            case proc_ind_ of
              01,02,10:
                begin
                  pix_col        :=SetColorInv(clGreen);
                end;
              03:
                begin
                  pix_col        :=SetColorInv(clGreen);
                  alpha1         :=010;
                end;
              05,06:
                begin
                  alpha1         :=010;
                end;
              11:
                begin
                  //PPRandNoiseProc:=@RandNoise0;
                  alpha1         :=003;
                  alpha2         :=003;
                end;
              12:
                begin
                  //PPBlurProc     :=@BlurRGB4;
                end;
            end;
          case proc_ind_ of
            01: PPFloodFillMT (bkgnd_ptr,bkgnd_width,rct2,                color_info.pix_col,                                    usable_threads_cnt);
            02: PPAdditiveMT  (bkgnd_ptr,bkgnd_width,rct2,                color_info.pix_col,                                    usable_threads_cnt);
            03: PPAlphaBlendMT(bkgnd_ptr,bkgnd_width,rct2,                color_info.pix_col,color_info.alpha1,                  usable_threads_cnt);
            04: PPInverseMT   (bkgnd_ptr,bkgnd_width,rct2,                                                                       usable_threads_cnt);
            05: PPHighlightMT (bkgnd_ptr,bkgnd_width,rct2,                                   color_info.alpha1,                  usable_threads_cnt);
            06: PPDarkenMT    (bkgnd_ptr,bkgnd_width,rct2,                                   color_info.alpha1,                  usable_threads_cnt);
            07: PPGrayscaleRMT(bkgnd_ptr,bkgnd_width,rct2,                                                                       usable_threads_cnt);
            08: PPGrayscaleGMT(bkgnd_ptr,bkgnd_width,rct2,                                                                       usable_threads_cnt);
            09: PPGrayscaleBMT(bkgnd_ptr,bkgnd_width,rct2,                                                                       usable_threads_cnt);
            10: PPMonoNoiseMT (bkgnd_ptr,bkgnd_width,rct2,                color_info.pix_col,                                    usable_threads_cnt);
            11:{PPRandNoiseMT (bkgnd_ptr,bkgnd_width,rct2,PPRandNoiseProc,                   color_info.alpha1,color_info.alpha2,usable_threads_cnt)};
            12:{PPBlurMT      (bkgnd_ptr,bkgnd_width,rct2,PPBlurProc,                                                                       )};
          end;}

          for i:=0 to usable_threads_cnt-1 do
            thread_obj_arr[i]:=TThreadObj.Create
            (
              usable_threads_cnt,
              i,
              proc_ind_,
              bkgnd_ptr,
              bkgnd_width,
              bkgnd_height,
              rct2
            );
          with TThreadObj,color_info do
            case proc_ind of
              01,02,10:
                begin
                  pix_col        :=SetColorInv(clGreen);
                end;
              03:
                begin
                  pix_col        :=SetColorInv(clGreen);
                  alpha1         :=010;
                end;
              05,06:
                begin
                  alpha1         :=010;
                end;
              11:
                begin
                  PPRandNoiseProc:=@RandNoise0;
                  alpha1         :=003;
                  alpha2         :=003;
                end;
              12:
                begin
                  PPBlurProc     :=@BlurRGB4;
                end;
            end;
          for i:=0 to usable_threads_cnt-1 do
            begin
              thread_obj_arr[i].WaitFor;
              thread_obj_arr[i].Free;
            end;

        end;
      }

      with rct_clp_ptr_^ do
        rct2:=PtRct  (left+150,top+150,right-150,bottom-150);
     {ArrClr         (srf_var_ptr^.low_bmp3_ptr,                                                  rct_clp_ptr_^,bkgnd_width,0,False,False);
      BitBlt1        (bkgnd_ptr                ,srf_var_ptr^.low_bmp3_ptr,bkgnd_width,bkgnd_width,rct_clp_ptr_^.left,rct_clp_ptr_^.top,rct_clp_ptr_^);
      PPTest         (srf_var_ptr^.low_bmp3_ptr,srf_var_ptr^.low_bmp3_ptr,bkgnd_width,bkgnd_width,                                     rct_clp_ptr_^);
      BitBlt1        (srf_var_ptr^.low_bmp3_ptr,bkgnd_ptr                ,bkgnd_width,bkgnd_width,rct_clp_ptr_^.left,rct_clp_ptr_^.top,rct_clp_ptr_^);}
    //PPTest0        (bkgnd_ptr                ,bkgnd_ptr                ,bkgnd_width,bkgnd_width,                                rct2{rct_clp_ptr_^});
    {for i:=0 to 8-1 do
      PPBlur         (bkgnd_ptr,bkgnd_width,rct2,@BlurRGB4);}
    //TestArrInit(bkgnd_ptr,bkgnd_width,rct2);
    for i:=4-1 downto 0 do
      PPTest2(bkgnd_ptr,bkgnd_width,rct2,SetRct(i,rct2,4){rct2},15,255,0);
    for i:=4-1 downto 0 do
      PPTest2(bkgnd_ptr,bkgnd_width,rct2,SetRct(i,rct2,4){rct2},15,255,1);
    PPAlphaBlend(bkgnd_ptr,bkgnd_width,rct2,SetColorInv($003F4F3C),180);
    {for i:=0 to 4-1 do
      begin
        rct3:=SetRct(i,rct2,4);
        {for j:=0 to 8-1 do
        PPBlur(bkgnd_ptr,
               bkgnd_width,
               {rct2}PtRct(rct3.left,
                           rct3.bottom-7,
                           rct3.right,
                           rct3.bottom+3),
               @BlurRGB4);}
        PPTest1(bkgnd_ptr,bkgnd_width,rct2,{rct2}PtRct(rct3.left,
                                                       rct3.bottom-9,
                                                       rct3.right,
                                                       rct3.bottom+02),19,200);
      end;}
    {for i:=0 to 4-1 do
      begin
        rct3:=SetRct(i,rct2,4);
        PPAlphaBlend(bkgnd_ptr,
                     bkgnd_width,
                     rct3{PtRct(rct3.left,
                           rct3.bottom,
                           rct3.right,
                           rct3.bottom)},
                     Random($00FFFFFF){SetColorInv($00638E33)},
                     08);
      end;}
    {for i:=0 to 2-1 do
      PPBlur         (bkgnd_ptr,bkgnd_width,rct2,@BlurRGB4);
    PPAlphaBlend(bkgnd_ptr,bkgnd_width,rct2,SetColorInv($00638E33),180);}
    //PPBlur         (bkgnd_ptr,bkgnd_width,rct2,@BlurRGB4);

    end;
end; {$endregion}
procedure   TPProc.FilPProcObj(const pproc_ind:TColor);                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PProcDraw(pproc_ind,obj_var.obj_arr[obj_var.pproc_inds_obj_arr[pproc_ind]].rct_clp_ptr);
end; {$endregion}
procedure   TPProc.MovPProcObj(const pproc_ind:TColor);                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  PProcDraw(pproc_ind,obj_var.obj_arr[obj_var.pproc_inds_obj_arr[pproc_ind]].rct_dst_ptr);
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_Post_ProcessingClick       (sender:TObject); {$region -fold}
begin
  SB_Draw_Buttons_Button_Bkgnd.Left   :=SB_Post_Processing.Left;
  SB_Draw_Buttons_Button_Bkgnd.Visible:=SB_Post_Processing.Down;
  DrawingPanelsSetVisibility1(down_pproc_ptr,P_Draw_Buttons,P_Post_Processing,P_Draw_Custom_Panel,prev_panel_draw,curr_panel_draw);
  DrawingPanelsSetVisibility2;
  RM_Description.Lines.Text:='';
  if (not down_pproc_ptr^) then
    Exit;
end; {$endregion}
procedure TF_MainForm.BB_Post_Processing_Add_FXClick(sender:TObject); {$region -fold}
begin
  with ppr_var,srf_var_ptr^ do
    begin
      AddPProcObj;
      EventGroupsCalc(calc_arr,[11,21,30,37,41,48]);
    end;
end; {$endregion}
{$endregion}

// (Buttons Cursors) Курсоры для кнопок:
{LI} {$region -fold}
procedure CursorInit(constref cur_ind,im_lst_ind:integer; constref location:string; constref ImgLstGetBmp:TProc1); {$region -fold}
var
  bmp_alpha,bmp_color: Graphics.TBitmap;
  icon_info          : TIconInfo;
begin
  if FileExists(location) then
    begin
      bmp_alpha:=CrtTPicInstFromHDDSrc(location).Bitmap;
      bmp_color:=CrtTPicInstFromHDDSrc(location).Bitmap;
    end
  else
    begin
      bmp_alpha:=CrtTBmpInstFromImgLst(ImgLstGetBmp,im_lst_ind);
      bmp_color:=CrtTBmpInstFromImgLst(ImgLstGetBmp,im_lst_ind);
    end;
  with icon_info do
    begin
      fIcon   :=false;
      xHotspot:=8;
      yHotspot:=22;
      hbmMask :=bmp_alpha.Handle;
      hbmColor:=bmp_color.Handle;
    end;
  Screen.Cursors[cur_ind]:=CreateIconIndirect(@icon_info);
  bmp_alpha.Free;
  bmp_color.Free;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.LockCursorToWindow; inline; {$region -fold}
var
  cur_to_mid_wnd_line: TLnPosF;
  rct_dst            : TRect;
  x0,y0,x1,y1        : integer;
  cur_pos_speed_sign : integer;
begin
  GetCursorPos (cur_pos_);
  x0:=          cur_pos_.x;
  y0:=          cur_pos_.y;
  GetWindowRect(Self.Handle,rct_dst);
  x1:=(rct_dst.left  +      rct_dst.right )>>1;
  y1:=(rct_dst.top   +      rct_dst.bottom)>>1;
       rct_dst.left  :=     rct_dst.left  +22;
       rct_dst.top   :=     rct_dst.top   +38;
       rct_dst.right :=     rct_dst.right -25;
       rct_dst.bottom:=     rct_dst.bottom-25;
  {$ifdef Windows}
  ClipCursor(@rct_dst);
  {$else}
  if not PtInRect(rct_dst,cur_pos_) then
    begin
      {if (cur_pos_.x>=cur_pos_prev.x) then
          cur_pos_speed_sign:=-1
      else
          cur_pos_speed_sign:=+1;}
      //cur_to_mid_wnd_line:=LineS(x0,y0,x1,y1,{cur_pos_speed_sign*}cur_pos_speed);
      LineC(x0,y0,x1,y1,PtRct(rct_dst));
      SetCursorPos(x0{Trunc(cur_to_mid_wnd_line.x0)},y0{Trunc(cur_to_mid_wnd_line.y0)});
    end;
  {$endif}
  cur_pos_speed:=sqrt(sqr(cur_pos_prev.x-x0)+sqr(cur_pos_prev.y-y0)){Max2(Abs(cur_pos_prev.x-x0),Abs(cur_pos_prev.y-y0))};
end; {$endregion}
procedure TF_MainForm.UnLockCursor;       inline; {$region -fold}
begin
  {$ifdef Windows}
  ClipCursor   (Nil);
  {$endif}
end; {$endregion}
{$endregion}

// (Animation) Анимация:
{LI} {$region -fold}
procedure TimeLineButtonsCreate;                                  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin

  // Create Buttons Positions  Array:
  SetLength(btn_pos_arr,Length(btn_pos_arr)+6);

  // Create Buttons Icons:
  SetLength(tmln_btn_inds_arr,6);
  with srf_var do
    for i:=0 to 5 do
      begin
        SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
        sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
        (
          srf_bmp_ptr,
          srf_bmp.width,
          srf_bmp.height,
          inn_wnd_rct,
          max_sprite_w_h_rct,
          Application.Location+TIMELINE_BUTTON_ICON_PREFIX+IntToStr(i)+'.png',
          @F_MainForm.IL_Butons_Icons.GetBitmap,
          i
        );
        tmln_btn_inds_arr[i]:=Length(sprite_sheet_arr)-1;
      end;

  // Create Button Background:
  SetLength(bckgd_btn_inds_arr,4);
  with srf_var do
    for i:=0 to 3 do
      begin
        SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
        sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
        (
          srf_bmp_ptr,
          srf_bmp.width,
          srf_bmp.height,
          inn_wnd_rct,
          max_sprite_w_h_rct,
          Application.Location+TIMELINE_BUTTON_ICON_PREFIX+IntToStr(6+i)+'.png',
          @F_MainForm.IL_Buttons_Background.GetBitmap,
          i
        );
        bckgd_btn_inds_arr[i]:=Length(sprite_sheet_arr)-1;
      end;

  // Drawing Settings: Buttons Icons:
  for i in [0,1,2,3,4,5] do
    with sprite_sheet_arr[tmln_btn_inds_arr[i]],fast_image_data,fast_image_proc_var do
      begin
        fast_image_data_ptr0:=@fast_image_data;
        SetPPInfo($0036261D);

        {FX Settings} {$region -fold}
        fx_cnt      :=003;
        pix_drw_type:=001;

        with fx_arr[0] do
          begin
            pt_as_nt:=False;
            with nt_fx_prop do
              begin
                //if (img_kind=3{<>4}) then
                  cfx_pow0  :=000;
                rep_cnt     :=001;
                pix_cfx_type:=000;
                pix_cng_type:=000;
              end;
            pt_fx_prop:=nt_fx_prop;
          end;

        with fx_arr[1] do
          begin
            pt_as_nt:=False;
            with nt_fx_prop do
              begin
                cfx_pow0    :=200;
                rep_cnt     :=001;
                pix_cfx_type:=010;
                pix_cng_type:=000;
              end;
            pt_fx_prop:=nt_fx_prop;
          end;

        with fx_arr[2] do
          begin
            pt_as_nt:=False;
            with nt_fx_prop do
              begin
                cfx_pow0    :=064;
                rep_cnt     :=001;
                pix_cfx_type:=004;
                pix_cng_type:=001;
              end;
            pt_fx_prop:=nt_fx_prop;
          end;

        SdrTypeCng(fast_image_data_ptr0,
                   fast_image_data); {$endregion}

      end;

  with sprite_sheet_arr[bckgd_btn_inds_arr[1]],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      SetPPInfo(clDkGray);

      {FX Settings} {$region -fold}
      fx_cnt      :=002;
      pix_drw_type:=002;

      with fx_arr[0] do
        begin
          pt_as_nt:=False;
          with nt_fx_prop do
            begin
              //if (img_kind=3{<>4}) then
                cfx_pow0  :=200;
              rep_cnt     :=001;
              pix_cfx_type:=005;
              pix_cng_type:=001;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;

      with fx_arr[1] do
        begin
          pt_as_nt:=False;
          with nt_fx_prop do
            begin
              cfx_pow0     :=255;
              rep_cnt      :=003;
              pix_cfx_type :=015;
              pix_cng_type :=001;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;

      SdrTypeCng(fast_image_data_ptr0,
                 fast_image_data); {$endregion}

    end;

end; {$endregion}
procedure CursorsCreate;                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  // Create Cursors Array:
  SetLength(cursors_inds_arr,Length(cursors_inds_arr)+1);
  SetLength(sprite_sheet_arr,Length(sprite_sheet_arr)+1);
  // Create Cursor Icon:
  with srf_var do
    sprite_sheet_arr[Length(sprite_sheet_arr)-1]:=TFastImageItem.Create
    (
      srf_bmp_ptr,
      srf_bmp.width,
      srf_bmp.height,
      inn_wnd_rct,
      max_sprite_w_h_rct,
      Application.Location+DEFAULT_CURSOR_ICON,
      @F_MainForm.IL_Cursors_Icons.GetBitmap,
      0
    );
  cursors_inds_arr[Length(cursors_inds_arr)-1]:=Length(sprite_sheet_arr)-1;
  with sprite_sheet_arr[cursors_inds_arr[Length(cursors_inds_arr)-1]],fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      SetPPInfo (clRed           );
      SetGradVec(0,rct_ent.height);
      SetGradCol(0,255           );

      {FX Settings} {$region -fold}
      fx_cnt                   :=002;
      pix_drw_type             :=000;

      with fx_arr[0] do
        begin
          pt_as_nt:=False;
          with nt_fx_prop do
            begin
              //if (img_kind=3{<>4}) then
                cfx_pow0  :=200;
              rep_cnt     :=001;
              pix_cfx_type:=002;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;

      with fx_arr[1] do
        begin
          pt_as_nt:=False;
          with nt_fx_prop do
            begin
              cfx_pow0    :=064;
              rep_cnt     :=001;
              pix_cfx_type:=026;
            end;
          pt_fx_prop:=nt_fx_prop;
        end;

      SdrTypeCng(fast_image_data_ptr0,
                 fast_image_data); {$endregion}

    end;
end; {$endregion}
procedure TimeLineButtonsDraw(const x,y:integer);                 inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  {x:=F_MainForm.S_Splitter2.Top-40;
  y:=F_MainForm.S_Splitter2.Width>>1-16+4;}
  btn_pos_arr[0].x:=y-80;
  btn_pos_arr[0].y:=x;
  btn_pos_arr[1].x:=y-40;
  btn_pos_arr[1].y:=x;
  btn_pos_arr[2].x:=y;
  btn_pos_arr[2].y:=x;
  btn_pos_arr[3].x:=y;
  btn_pos_arr[3].y:=x;
  btn_pos_arr[4].x:=y+40;
  btn_pos_arr[4].y:=x;
  btn_pos_arr[5].x:=y+80;
  btn_pos_arr[5].y:=x;
  for i in [0,1,2,4,5] do
    with sprite_sheet_arr[bckgd_btn_inds_arr[1]],fast_image_data,fast_image_proc_var do
      SdrProc[sdr_proc_ind](btn_pos_arr[i].x,
                            btn_pos_arr[i].y,
                            @fast_image_data);
  for i in [0,1,2,4,5] do
    with sprite_sheet_arr[tmln_btn_inds_arr[i]],fast_image_data,fast_image_proc_var do
      SdrProc[sdr_proc_ind](btn_pos_arr[i].x,
                            btn_pos_arr[i].y,
                            @fast_image_data);
  for i in [0,1,2,4,5] do
    with sprite_sheet_arr[bckgd_btn_inds_arr[3]],fast_image_data,fast_image_proc_var do
      SdrProc[sdr_proc_ind](btn_pos_arr[i].x,
                            btn_pos_arr[i].y,
                            @fast_image_data);
end; {$endregion}
procedure CursorDraw(const x,y:integer; const cur_ind:integer=0); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  tlmap_ind  : TColor;
  obj_arr_ptr: PObjProp;
begin

  {with srf_var,obj_var do
    if (tlmap_cnt<>0) then
      begin
        tlmap_ind:=obj_arr[obj_inds_arr[Length(tlm_var.tilemap_inds_arr)-1]].k_ind;
        with sprite_sheet_arr[tlm_var.tilemap_inds_arr[tlmap_ind]],fast_image_data,fast_image_proc_var do
          begin
            fast_image_data_ptr0:=@fast_image_data;
            obj_arr_ptr         :=@obj_arr[tlmap_inds_obj_arr[tlmap_ind]];
            if {not} CollisionTest1(Trunc(world_axis.x)+Trunc(obj_arr_ptr^.world_axis_shift_centrify.x),
                                    Trunc(world_axis.y)+Trunc(obj_arr_ptr^.world_axis_shift_centrify.y),
                                    x,
                                    y).coll_det then
              Exit;
          end;
      end;}
  {with srf_var,obj_var do
    if (tlmap_cnt<>0) then
      begin
        tlmap_ind:=obj_arr[obj_inds_arr[Length(tlm_var.tilemap_inds_arr)-1]].k_ind;
        with sprite_sheet_arr[tlm_var.tilemap_inds_arr[tlmap_ind]],fast_image_data,fast_image_proc_var do
          begin
            fast_image_data_ptr0:=@fast_image_data;
            obj_arr_ptr         :=@obj_arr[tlmap_inds_obj_arr[tlmap_ind]];
            if {not} CollisionTest2(world_axis.x+obj_arr_ptr^.world_axis_shift_centrify.x,
                                    world_axis.y+obj_arr_ptr^.world_axis_shift_centrify.y,
                                    x,
                                    y).coll_det then
              Exit;
          end;
      end;}
  {with srf_var,obj_var do
    if (tlmap_cnt<>0) then
      begin
        tlmap_ind:=obj_arr[obj_inds_arr[Length(tlm_var.tilemap_inds_arr)-1]].k_ind;
        with sprite_sheet_arr[tlm_var.tilemap_inds_arr[tlmap_ind]],fast_image_data,fast_image_proc_var do
          begin
            fast_image_data_ptr0:=@fast_image_data;
            obj_arr_ptr         :=@obj_arr[tlmap_inds_obj_arr[tlmap_ind]];
            if {not} CollisionTest3(world_axis.x+obj_arr_ptr^.world_axis_shift_centrify.x,
                                    world_axis.y+obj_arr_ptr^.world_axis_shift_centrify.y,
                                    x,
                                    y).coll_det then
              Exit;
          end;
      end;}

  with sprite_sheet_arr[cursors_inds_arr[cur_ind]],fast_image_data,fast_image_proc_var do
    SdrProc[sdr_proc_ind](x-bmp_ftimg_width_origin >>1,
                          y-bmp_ftimg_height_origin>>1,
                          @fast_image_data);

end; {$endregion}
procedure CursorDraw;                                             inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  color_info: TColorInfo;
begin
  with srf_var do
    begin
      GetCursorPos(cur_pos);
      cur_pos  :=F_MainForm.ScreenToClient(cur_pos);
      {cur_pos.x:=Trunc((orgn_wnd_res.x/rszd_wnd_res.x)*cur_pos.x);
      cur_pos.y:=Trunc((orgn_wnd_res.y/rszd_wnd_res.y)*cur_pos.y);}
      SetPtPosToResInnWndPos(cur_pos.x,cur_pos.y);
      //if IsPtInRct       (cur_pos.x,cur_pos.y,inn_wnd_rct) then
        begin
          color_info        :=Default(TColorInfo);
          color_info.pix_col:=SetColorInv(clWhite);
         {CircleHighlight004(cur_pos.x,cur_pos.y,
                             srf_bmp_ptr,
                             inn_wnd_rct,
                             srf_bmp.width,
                             color_info,
                             64,
                             255);}
          CursorDraw        (cur_pos.x,
                             cur_pos.y);
          CircleHighlight003(cur_pos.x,
                             cur_pos.y,
                             srf_bmp_ptr,
                             srf_bmp.width,
                             inn_wnd_rct,
                             color_info,
                             20,
                             64);
         {CircleC           (cur_pos.x,
                             cur_pos.y,
                             32,
                             srf_bmp_ptr,
                             srf_bmp.width,
                             inn_wnd_rct,
                             color_info.pix_col);}
        end
      {else
        F_MainForm.cursor:=crNone};
    end;
end; {$endregion}
procedure SnapGLCanvas;                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with srf_var,F_MainForm.OGLC_GPU_Canvas do
    if down_play_anim_ptr^ then
      begin
        MainBmpRectCalc1;
        AnchorParallel(akLeft  ,0,Nil);
        AnchorParallel(akTop   ,0,Nil);
        AnchorParallel(akRight ,0,Nil);
        AnchorParallel(akBottom,0,Nil);
        left  :=inn_wnd_rct1.left  ;
        top   :=inn_wnd_rct1.top   ;
        width :=inn_wnd_rct1.width ;
        height:=inn_wnd_rct1.height;
      end
    {else
      begin
        AnchorParallel(akLeft  ,0,F_MainForm.S_Splitter1);
        AnchorParallel(akTop   ,0,F_MainForm            );
        AnchorParallel(akRight ,0,F_MainForm.S_Splitter3);
        AnchorParallel(akBottom,0,F_MainForm.S_Splitter2);
      end};
end; {$endregion}
// Test:
function CollisionTest0(const x,y        :integer): boolean;      inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  tlmap_ind      : TColor;
  arr_pos_x,
  arr_pos_y      : integer;
  arr_cell_width,
  arr_cell_height: TColor;
  tlmap_width,
  tlmap_height   : TColor;
  line_coef      : TPtPosF;
  x0,x1,y0,y1    : integer;
  x0_clp,x1_clp,y0_clp,y1_clp: integer;
  seg_cnt        : TColor;
  color_info2    : TColorInfo;
  obj_arr_ptr    : PObjProp;
  rct_pts_arr    : array[0..5] of integer;
  coll_pt        : TPtPosF;
  coll_cell_ind  : TPtPos;
  line_clp       : boolean;
  coll_det       : boolean=False;
  coll_ed_type   : byte=0;
  {
    0: left   edge  ; // pt0 is out    of array cells;
    1: top    edge  ; // pt0 is out    of array cells;
    2: right  edge  ; // pt0 is out    of array cells;
    3: bottom edge  ; // pt0 is out    of array cells;
    4: left   edge  ; // pt0 is inside of array cells;
    5: top    edge  ; // pt0 is inside of array cells;
    6: right  edge  ; // pt0 is inside of array cells;
    7: bottom edge  ; // pt0 is inside of array cells;
    8: no collisions; // pt0 is out    of array cells;
    9: no collisions; // pt0 is inside of array cells;
  }

  procedure DrawRctEdge0      (left,top:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; clp_rct_:TPtRect); {$region -fold}
  begin
    SetColorInfo(clRed,color_info2);
    LineAC(
      arr_pos_x+arr_cell_width *(left  ),
      arr_pos_y+arr_cell_height*(top   ),
      arr_pos_x+arr_cell_width *(left+1),
      arr_pos_y+arr_cell_height*(top   ),
      bmp_dst_ptr,
      bmp_dst_width,
      clp_rct_,
      color_info2);
  end; {$endregion}

  procedure DrawRctEdge1      (left,top:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; clp_rct_:TPtRect); {$region -fold}
  var
    pix_col: TColor=clBlue;
    pow    : byte=190;
  begin
    SetColorInfo(clRed,color_info2);
    LineAC(
      arr_pos_x+arr_cell_width *(left  ),
      arr_pos_y+arr_cell_height*(top   ),
      arr_pos_x+arr_cell_width *(left  ),
      arr_pos_y+arr_cell_height*(top +1),
      bmp_dst_ptr,
      bmp_dst_width,
      clp_rct_,
      color_info2);
  end; {$endregion}

  procedure DrawRct           (left,top:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; clp_rct_:TPtRect); {$region -fold}
  var
    pix_col: TColor=clBlue;
    pow    : byte=190;
  begin
    {PPAdditiveDec}PPInverseDec(
      bmp_dst_ptr,
      bmp_dst_width,
      ClippedRct(
        clp_rct_,
        PtRct(
          arr_pos_x+arr_cell_width *(left  ),
          arr_pos_y+arr_cell_height*(top   ),
          arr_pos_x+arr_cell_width *(left+1),
          arr_pos_y+arr_cell_height*(top +1))),
      //SetColorInv(pix_col),
      255-pow);
    SetColorInfo(clWhite{clRed},color_info2);
    LineAC(
      arr_pos_x+arr_cell_width *(left  ),
      arr_pos_y+arr_cell_height*(top   ),
      arr_pos_x+arr_cell_width *(left+1),
      arr_pos_y+arr_cell_height*(top   ),
      bmp_dst_ptr,
      bmp_dst_width,
      clp_rct_,
      color_info2);
    SetColorInfo(clWhite{clGreen},color_info2);
    LineAC(
      arr_pos_x+arr_cell_width *(left+1),
      arr_pos_y+arr_cell_height*(top   ),
      arr_pos_x+arr_cell_width *(left+1),
      arr_pos_y+arr_cell_height*(top +1),
      bmp_dst_ptr,
      bmp_dst_width,
      clp_rct_,
      color_info2);
    SetColorInfo($800000{clBlue},color_info2);
    LineAC(
      arr_pos_x+arr_cell_width *(left  ),
      arr_pos_y+arr_cell_height*(top +1),
      arr_pos_x+arr_cell_width *(left+1),
      arr_pos_y+arr_cell_height*(top +1),
      bmp_dst_ptr,
      bmp_dst_width,
      clp_rct_,
      color_info2);
    SetColorInfo($800000{clWhite},color_info2);
    LineAC(
      arr_pos_x+arr_cell_width *(left  ),
      arr_pos_y+arr_cell_height*(top   ),
      arr_pos_x+arr_cell_width *(left  ),
      arr_pos_y+arr_cell_height*(top +1),
      bmp_dst_ptr,
      bmp_dst_width,
      clp_rct_,
      color_info2);
  end; {$endregion}

  procedure DrawLineOnGrid0   (x0_,y0_,x1_,y1_:integer); {$region -fold}
  var
    line_start_pos,line_end_pos: TPtPos;
    r,t                        : integer;

    function GetArrCellInd(const _x_,_y_:integer): TPtPos; {$region -fold}
    begin
      Result.x:=(_x_-arr_pos_x) div arr_cell_width ;
      Result.y:=(_y_-arr_pos_y) div arr_cell_height;
    end; {$endregion}

    procedure DrawLineLoop(const param0,param1,param2,param3:integer); {$region -fold}
    var
      point_on_rct_edge: double;
      prod0,prod1,i,j,k: integer;
    begin
      prod0:=param0*arr_cell_width;
      prod1:=param1*arr_cell_height;
          i:=0;
          j:=0;
      for k:=0 to Abs(line_end_pos.x-line_start_pos.x)+Abs(line_end_pos.y-line_start_pos.y) do
        begin
          {DrawRct(line_start_pos.x+param0*i,
                  line_start_pos.y+param1*j);}
          if     (line_start_pos.x+param0*i=line_end_pos.x) then
            if   (line_start_pos.x+param0*i=param2        ) then
              if (line_start_pos.y+param1*j=line_end_pos.y) then
                Break;
          if     (line_start_pos.y+param1*j=line_end_pos.y) then
            if   (line_start_pos.y+param1*j=param3        ) then
              if (line_start_pos.x+param0*i=line_end_pos.x) then
                Break;
          point_on_rct_edge:=line_coef.x*r+line_coef.y;
          if (point_on_rct_edge>=t                ) and
             (point_on_rct_edge< t+arr_cell_height) then
            begin
              Inc(i);
              Inc(r,prod0);
            end
          else
            begin
              Inc(j);
              Inc(t,prod1);
            end;
        end;
    end; {$endregion}

  begin
    if (x0_=x1_) and
       (y0_=y1_) then
      Exit;
    line_start_pos:=GetArrCellInd(x0_,y0_);
    line_end_pos  :=GetArrCellInd(x1_,y1_);
    r             :=arr_pos_x+arr_cell_width *line_start_pos.x;
    t             :=arr_pos_y+arr_cell_height*line_start_pos.y;
    if (x0_=r) and (y0_=t) then
      Inc(x0_);
    line_coef:=LnCoef(x0_,y0_,x1_,y1_);
    if (x1_>=x0_) then
      begin
        r:=arr_pos_x+arr_cell_width*(line_start_pos.x+1);
        if (y1_>=y0_) then
          DrawLineLoop( 1, 1,tlmap_width-1,tlmap_height-1)
        else
          DrawLineLoop( 1,-1,tlmap_width-1,00000000000000);
      end
    else
      begin
        r:=arr_pos_x+arr_cell_width*(line_start_pos.x+0);
        if (y1_>=y0_) then
          DrawLineLoop(-1, 1,0000000000000,tlmap_height-1)
        else
          DrawLineLoop(-1,-1,0000000000000,00000000000000);
      end;
  end; {$endregion}

  function  DrawLineOnGrid1   (x0_,y0_,x1_,y1_:integer; arr_src:T1Byte1Arr; line_clp_0,line_clp_1,line_clp_2:boolean; test_filled_cells:boolean=False): TPtPosF; {$region -fold}
  var
    line_start_pos,line_end_pos: TPtPos;
    r,t                        : integer;

    function GetArrCellInd (const _x_,_y_:integer                    ): TPtPos; {$region -fold}
    begin
      Result.x:=(_x_-arr_pos_x) div arr_cell_width ;
      Result.y:=(_y_-arr_pos_y) div arr_cell_height;
    end; {$endregion}

    function  DrawLineLoop0(const param0,param1,param2,param3:integer): TPtPos; {$region -fold}
    var
      point_on_rct_edge: double;
      prod0,prod1,i,j,k: integer;
    begin
      coll_det:=False;
      Result:=Default(TPtPos);
      prod0:=param0*arr_cell_width;
      prod1:=param1*arr_cell_height;
          i:=0;
          j:=0;
      for k:=0 to   Abs(line_end_pos.x-line_start_pos.x)+
                    Abs(line_end_pos.y-line_start_pos.y) do
        begin
          if (arr_src [(line_start_pos.x+param0*i)+
                       (line_start_pos.y+param1*j)*tlmap_width]=1) then
            begin
              Result.x:=line_start_pos.x+param0*i;
              Result.y:=line_start_pos.y+param1*j;
              coll_det:=True;
              Break;
            end;
          {DrawRct(line_start_pos.x+param0*i,
                  line_start_pos.y+param1*j);}
          if     (line_start_pos.x+param0*i=line_end_pos.x) then
            if   (line_start_pos.x+param0*i=param2        ) then
              if (line_start_pos.y+param1*j=line_end_pos.y) then
                Break;
          if     (line_start_pos.y+param1*j=line_end_pos.y) then
            if   (line_start_pos.y+param1*j=param3        ) then
              if (line_start_pos.x+param0*i=line_end_pos.x) then
                Break;
          point_on_rct_edge:=line_coef.x*r+line_coef.y;
          if (point_on_rct_edge>=t                ) and
             (point_on_rct_edge< t+arr_cell_height) then
            begin
              Inc(i);
              Inc(r,prod0);
            end
          else
            begin
              Inc(j);
              Inc(t,prod1);
            end;
        end;
    end; {$endregion}

    function  DrawLineLoop1(const param0,param1,param2,param3:integer): TPtPos; {$region -fold}
    var
      point_on_rct_edge: double;
      prod0,prod1,i,j,k: integer;
    begin
      coll_det:=False;
      Result:=Default(TPtPos);
      prod0:=param0*arr_cell_width;
      prod1:=param1*arr_cell_height;
          i:=0;
          j:=0;
      for k:=0 to   Abs(line_end_pos.x-line_start_pos.x)+
                    Abs(line_end_pos.y-line_start_pos.y) do
        begin
          if (arr_src [(line_start_pos.x+param0*i)+
                       (line_start_pos.y+param1*j)*tlmap_width]=0) then
            begin
              Result.x:=line_start_pos.x+param0*i;
              Result.y:=line_start_pos.y+param1*j;
              coll_det:=True;
              Break;
            end;
          {DrawRct(line_start_pos.x+param0*i,
                  line_start_pos.y+param1*j);}
          if     (line_start_pos.x+param0*i=line_end_pos.x) then
            if   (line_start_pos.x+param0*i=param2        ) then
              if (line_start_pos.y+param1*j=line_end_pos.y) then
                Break;
          if     (line_start_pos.y+param1*j=line_end_pos.y) then
            if   (line_start_pos.y+param1*j=param3        ) then
              if (line_start_pos.x+param0*i=line_end_pos.x) then
                Break;
          point_on_rct_edge:=line_coef.x*r+line_coef.y;
          if (point_on_rct_edge>=t                ) and
             (point_on_rct_edge< t+arr_cell_height) then
            begin
              Inc(i);
              Inc(r,prod0);
            end
          else
            begin
              Inc(j);
              Inc(t,prod1);
            end;
        end;
    end; {$endregion}

    procedure SetCollPt0   (const param0,param1,param2,param3:integer);         {$region -fold}
    var
      d0,d1: double;
      p0,p1: integer;
    begin
      p0:=arr_pos_x+arr_cell_width *(coll_cell_ind.x+param0);
      d0:=arr_pos_y+arr_cell_height* coll_cell_ind.y;
      d1:=line_coef.x*p0+line_coef.y;
      if (x0_=x1_) then
        begin
          Result.x    :=x0_;
          coll_ed_type:=param3*2+1;
          if (y1_>y0_) then
            Result.y:=arr_pos_y+arr_cell_height*(coll_cell_ind.y+0)
          else
            Result.y:=arr_pos_y+arr_cell_height*(coll_cell_ind.y+1);
          Exit;
        end;
      if (d1>=d0                ) and
         (d1< d0+arr_cell_height) then
        begin
          Result.x    :=p0;
          Result.y    :=p0*line_coef.x+line_coef.y;
          coll_ed_type:=param2*2+0;
        end
      else
        begin
          p1          :=arr_pos_y+arr_cell_height*(coll_cell_ind.y+param1);
          Result.x    :=(p1-line_coef.y)/line_coef.x;
          Result.y    := p1;
          coll_ed_type:=param3*2+1;
        end;
    end; {$endregion}

    procedure SetCollPt1   (const param0,param1              :integer);         {$region -fold}
    begin
      {if (x0_=x1_) then
        begin
          coll_ed_type:=param1*2+1;
          Exit;
        end;}
      Result.x:=x0_;
      Result.y:=y0_;
      if (x0_>arr_pos_x) and
         (x0_<arr_pos_x+arr_cell_width*tlmap_width-1) then
        coll_ed_type:=param1*2+1
      else
        coll_ed_type:=param0*2+0;
    end; {$endregion}

  begin
    coll_det      :=False;
    Result        :=Default(TPtPosF);
    line_start_pos:=GetArrCellInd(x0_,y0_);
    line_end_pos  :=GetArrCellInd(x1_,y1_);
    r             :=arr_pos_x+arr_cell_width *line_start_pos.x;
    t             :=arr_pos_y+arr_cell_height*line_start_pos.y;

    {F_MainForm.M_Test_Log.Lines.Text:='';
    F_MainForm.M_Test_Log.Lines.Text:=IntToStr(x0_)+'; '+#13+
                                      IntToStr(y0_)+'; '+#13+
                                      IntToStr(x1_)+'; '+#13+
                                      IntToStr(y1_)+'; '+#13+
                                      IntToStr(arr_src[line_start_pos.x+line_start_pos.y*tlmap_width]);}

    if (x0_=r) and (y0_=t) then
      if not ((arr_src[(line_start_pos.x)+
                       (line_start_pos.y)*tlmap_width]=1) and
               line_clp_0 and
               line_clp_1) then
        Inc(x0_);
    line_coef:=LnCoef(x0_,y0_,x1_,y1_);
    if (arr_src[(line_start_pos.x)+
                (line_start_pos.y)*tlmap_width]=1) then
      begin
        if line_clp_0 then
          begin
            if line_clp_1 then
              begin
                coll_cell_ind:=line_start_pos;
                coll_det     :=True;
                if (x1_>=x0_) then
                  begin
                    if (y1_>=y0_) then
                      SetCollPt1(0,0)
                    else
                      SetCollPt1(0,1);
                  end
                else
                  begin
                    if (y1_>=y0_) then
                      SetCollPt1(1,0)
                    else
                      SetCollPt1(1,1);
                  end;
              end
            else
              begin
                if not test_filled_cells then
                  begin
                    Result.x     :=x0_;
                    Result.y     :=y0_;
                    coll_cell_ind:=line_start_pos;
                    coll_det     :=True;
                    coll_ed_type :=6;
                  end
                else
                  begin
                    if (x1_>=x0_) then
                      begin
                        r:=arr_pos_x+arr_cell_width*(line_start_pos.x+1);
                        if (y1_>=y0_) then
                          begin
                            coll_cell_ind:=DrawLineLoop1( 1, 1,tlmap_width-1,tlmap_height-1);
                            if coll_det then
                              SetCollPt0(0,0,0,0);
                          end
                        else
                          begin
                            coll_cell_ind:=DrawLineLoop1( 1,-1,tlmap_width-1,00000000000000);
                            if coll_det then
                              SetCollPt0(0,1,0,1);
                          end;
                      end
                    else
                      begin
                        r:=arr_pos_x+arr_cell_width*(line_start_pos.x+0);
                        if (y1_>=y0_) then
                          begin
                            coll_cell_ind:=DrawLineLoop1(-1, 1,0000000000000,tlmap_height-1);
                            if coll_det then
                              SetCollPt0(1,0,1,0);
                          end
                        else
                          begin
                            coll_cell_ind:=DrawLineLoop1(-1,-1,0000000000000,00000000000000);
                            if coll_det then
                              SetCollPt0(1,1,1,1);
                          end;
                      end;
                    if line_clp_2 then
                      begin
                        if (coll_cell_ind.x=0            ) or (coll_cell_ind.y=0             ) or
                           (coll_cell_ind.x=tlmap_width-1) or (coll_cell_ind.y=tlmap_height-1) then
                          begin
                            Result.x:=x1_;
                            Result.y:=y1_;
                            coll_det:=True;
                          //coll_cell_ind:=TODO;
                          //coll_ed_type :=TODO;
                          end;
                      end;
                  end;
              end;
          end;
        Exit;
      end;
    if (x1_>=x0_) then
      begin
        r:=arr_pos_x+arr_cell_width*(line_start_pos.x+1);
        if (y1_>=y0_) then
          begin
            coll_cell_ind:=DrawLineLoop0( 1, 1,tlmap_width-1,tlmap_height-1);
            if coll_det then
              SetCollPt0(0,0,0,0);
          end
        else
          begin
            coll_cell_ind:=DrawLineLoop0( 1,-1,tlmap_width-1,00000000000000);
            if coll_det then
              SetCollPt0(0,1,0,1);
          end;
      end
    else
      begin
        r:=arr_pos_x+arr_cell_width*(line_start_pos.x+0);
        if (y1_>=y0_) then
          begin
            coll_cell_ind:=DrawLineLoop0(-1, 1,0000000000000,tlmap_height-1);
            if coll_det then
              SetCollPt0(1,0,1,0);
          end
        else
          begin
            coll_cell_ind:=DrawLineLoop0(-1,-1,0000000000000,00000000000000);
            if coll_det then
              SetCollPt0(1,1,1,1);
          end;
      end;
  end; {$endregion}

  procedure CollisionDetection(constref x0_,y0_,x1_,y1_:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref color_info:TColorInfo; constref seg_cnt_:TColor); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  var
    v,w,dx,dy: double;
    x_,y_    : integer;
    i        : integer;
  begin
    with sprite_sheet_arr[tlm_var.tilemap_inds_arr[0{Length(tlm_var.tilemap_inds_arr)-1}]],fast_image_data,fast_image_proc_var do
      begin
        fast_image_data_ptr0:=@fast_image_data;
        if (seg_cnt_<=1) then
          Exit;
             v:=x0_;
             w:=y0_;
        if (x1_>x0_) then
          begin
            dx:=(x1_-x0_)/seg_cnt_;
            if  (y1_>y0_) then
              begin
                dy:=(y1_-y0_)/seg_cnt_;
                for i:=0 to seg_cnt_-2 do
                  begin
                    v +=dx;
                    w +=dy;
                    x_:=Trunc(v);
                    y_:=Trunc(w);
                    if (tilemap_coll_grid0[((x_-rct_pts_arr[0]) div tilemap_sprite_w_h.x)+bmp_ftimg_width_origin*((y_-rct_pts_arr[1]) div tilemap_sprite_w_h.y)]=1) then
                      begin
                        Break;
                        Exit;
                      end;
                    Point(x_,
                          y_,
                          bmp_dst_ptr,
                          bmp_dst_width,
                          color_info);
                  end;
              end
            else
              begin
                dy:=(y0_-y1_)/seg_cnt_;
                for i:=0 to seg_cnt_-2 do
                  begin
                    v +=dx;
                    w -=dy;
                    x_:=Trunc(v);
                    y_:=Trunc(w);
                    if (tilemap_coll_grid0[((x_-rct_pts_arr[0]) div tilemap_sprite_w_h.x)+bmp_ftimg_width_origin*((y_-rct_pts_arr[1]) div tilemap_sprite_w_h.y)]=1) then
                      begin
                        Break;
                        Exit;
                      end;
                    Point(x_,
                          y_,
                          bmp_dst_ptr,
                          bmp_dst_width,
                          color_info);
                  end;
              end;
          end
        else
          begin
            dx:=(x0_-x1_)/seg_cnt_;
            if  (y1_>y0_) then
              begin
                dy:=(y1_-y0_)/seg_cnt_;
                for i:=0 to seg_cnt_-2 do
                  begin
                    v -=dx;
                    w +=dy;
                    x_:=Trunc(v);
                    y_:=Trunc(w);
                    if (tilemap_coll_grid0[((x_-rct_pts_arr[0]) div tilemap_sprite_w_h.x)+bmp_ftimg_width_origin*((y_-rct_pts_arr[1]) div tilemap_sprite_w_h.y)]=1) then
                      begin
                        Break;
                        Exit;
                      end;
                    Point(x_,
                          y_,
                          bmp_dst_ptr,
                          bmp_dst_width,
                          color_info);
                  end;
              end
            else
              begin
                dy:=(y0_-y1_)/seg_cnt_;
                for i:=0 to seg_cnt_-2 do
                  begin
                    v -=dx;
                    w -=dy;
                    x_:=Trunc(v);
                    y_:=Trunc(w);
                    if (tilemap_coll_grid0[((x_-rct_pts_arr[0]) div tilemap_sprite_w_h.x)+bmp_ftimg_width_origin*((y_-rct_pts_arr[1]) div tilemap_sprite_w_h.y)]=1) then
                      begin
                        Break;
                        Exit;
                      end;
                    Point(x_,
                          y_,
                          bmp_dst_ptr,
                          bmp_dst_width,
                          color_info);
                  end;
              end;
          end;
      end;
  end; {$endregion}

begin
  Result:=False;
  if (obj_var.tlmap_cnt=0) then
    Exit;
  with obj_var do
    tlmap_ind:=obj_arr[obj_inds_arr[Length(tlm_var.tilemap_inds_arr)-1]].k_ind;
  with srf_var,obj_var do
    with sprite_sheet_arr[tlm_var.tilemap_inds_arr[tlmap_ind]],fast_image_data,fast_image_proc_var do
      begin
        fast_image_data_ptr0:=@fast_image_data;
        obj_arr_ptr         :=@obj_arr[tlmap_inds_obj_arr[tlmap_ind]];
        arr_cell_width      :=tilemap_sprite_w_h.x;
        arr_cell_height     :=tilemap_sprite_w_h.y;
        tlmap_width         :=bmp_ftimg_width_origin ;
        tlmap_height        :=bmp_ftimg_height_origin;
        coll_cell_ind       :=Default(TPtPos);
        x0                  :=Trunc(world_axis.x)+{-}Trunc(obj_arr_ptr^.world_axis_shift_centrify.x);
        y0                  :=Trunc(world_axis.y)+{-}Trunc(obj_arr_ptr^.world_axis_shift_centrify.y);
        x1                  :=x;
        y1                  :=y;
        rct_pts_arr[0]      :={x0}Trunc(world_axis.x)+Trunc(obj_arr_ptr^.world_axis_shift.x)-(bmp_ftimg_width_origin *tilemap_sprite_w_h.x)>>1;
        rct_pts_arr[1]      :={y0}Trunc(world_axis.y)+Trunc(obj_arr_ptr^.world_axis_shift.y)-(bmp_ftimg_height_origin*tilemap_sprite_w_h.y)>>1;
        rct_pts_arr[2]      :=rct_pts_arr[0]+arr_cell_width *tlmap_width ;
        rct_pts_arr[3]      :=rct_pts_arr[1]+arr_cell_height*tlmap_height;
        rct_pts_arr[4]      :=(x-rct_pts_arr[0]) div tilemap_sprite_w_h.x;
        rct_pts_arr[5]      :=(y-rct_pts_arr[1]) div tilemap_sprite_w_h.y;
        arr_pos_x           :=rct_pts_arr[0];
        arr_pos_y           :=rct_pts_arr[1];
        x0_clp              :=x0;
        y0_clp              :=y0;
        x1_clp              :=x1;
        y1_clp              :=y1;
        line_clp            :=LineC(
          x0_clp,
          y0_clp,
          x1_clp,
          y1_clp,
          PtRct(
            rct_pts_arr[0],
            rct_pts_arr[1],
            rct_pts_arr[2]-1,
            rct_pts_arr[3]-1));

        if line_clp then
          coll_pt:=DrawLineOnGrid1(
            x0_clp,
            y0_clp,
            x1_clp,
            y1_clp,
            tilemap_coll_grid0,
            line_clp,
            (x0<>x0_clp) or (y0<>y0_clp),
            (x1<>x1_clp) or (y1<>y1_clp),
            True);

        if coll_det then
          begin
            case coll_ed_type of
              0:DrawRctEdge1(
                  Trunc(coll_cell_ind.x+0),
                  Trunc(coll_cell_ind.y+0),
                  srf_bmp_ptr,
                  srf_bmp.width,
                  inn_wnd_rct);
              1:DrawRctEdge0(
                  Trunc(coll_cell_ind.x+0),
                  Trunc(coll_cell_ind.y+0),
                  srf_bmp_ptr,
                  srf_bmp.width,
                  inn_wnd_rct);
              2:DrawRctEdge1(
                  Trunc(coll_cell_ind.x+1),
                  Trunc(coll_cell_ind.y+0),
                  srf_bmp_ptr,
                  srf_bmp.width,
                  inn_wnd_rct);
              3:DrawRctEdge0(
                  Trunc(coll_cell_ind.x+0),
                  Trunc(coll_cell_ind.y+1),
                  srf_bmp_ptr,
                  srf_bmp.width,
                  inn_wnd_rct);
            end;
            SetColorInfo(clBlue,color_info2);
            CircleC(
              Trunc(coll_pt.x),
              Trunc(coll_pt.y),
              7,
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              color_info2.pix_col);
            SetColorInfo2(clRed,color_info2);
          end
        else
          SetColorInfo2(clWhite,color_info2);

        if Length(library_images_inds_arr)<>0 then
          with sprite_sheet_arr[library_images_inds_arr[0]],fast_image_data,fast_image_proc_var do
            SdrProc[sdr_proc_ind](x0-bmp_ftimg_width_origin >>1,
                                  y0-bmp_ftimg_height_origin>>1,
                                  @fast_image_data)
        else
          CircleC(
            x0,
            y0,
            7,
            srf_bmp_ptr,
            srf_bmp.width,
            inn_wnd_rct,
            color_info2.pix_col);
        fast_image_data_ptr0:=@fast_image_data;

        seg_cnt:=Trunc(sqrt(sqr(x1-x0)+sqr(y1-y0))/Min(tilemap_sprite_w_h.x,tilemap_sprite_w_h.y))+1;
        LineR0(
          x0,
          y0,
          x1,
          y1,
          srf_bmp_ptr,
          srf_bmp.width,
          inn_wnd_rct,
          color_info2,
          seg_cnt{32});
        SetColorInfo2(clGreen,color_info2);
        Point(
          x0_clp,
          y0_clp,
          srf_bmp_ptr,
          srf_bmp.width,
          inn_wnd_rct,
          color_info2);
        SetColorInfo2(clYellow,color_info2);
        Point(
          x1_clp,
          y1_clp,
          srf_bmp_ptr,
          srf_bmp.width,
          inn_wnd_rct,
          color_info2);

        {SetColorInfo(clWhite,color_info2);
        CollisionDetection(
          x0,
          y0,
          x1,
          y1,
          srf_bmp_ptr,
          srf_bmp.width,
          color_info2,
          seg_cnt);}

        {SetColorInfo(clGreen,color_info2);
            CircleFloodFill2(
              x0,
              y0,
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              color_info2,
              9,
              015{045});

            SetColorInfo(clBlue,color_info2);
            CircleFloodFill2(
              x1,
              y1,
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              color_info2,
              9,
              015{045});}

        if not IsPtInRct(
          x,
          y,
          rct_pts_arr[0],
          rct_pts_arr[1],
          rct_pts_arr[2],
          rct_pts_arr[3]) then
          Exit;

        Result:=Boolean(tilemap_coll_grid0[rct_pts_arr[4]+bmp_ftimg_width_origin*rct_pts_arr[5]]);

      end;
end; {$endregion}
function CollisionTest1(const x0,y0,x1,y1:integer): TProjectile;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  tlmap_ind      : TColor;
  arr_pos_x,
  arr_pos_y      : integer;
  arr_cell_width,
  arr_cell_height: TColor;
  tlmap_width,
  tlmap_height   : TColor;
  line_coef      : TPtPosF;
  x0_clp,
  x1_clp,
  y0_clp,
  y1_clp         : integer;
  seg_cnt        : TColor;
  color_info2    : TColorInfo;
  obj_arr_ptr    : PObjProp;
  rct_pts_arr    : array[0..3] of integer;
  coll_pt        : TPtPosF=(x:0.0; y:0.0);
  coll_cell_ind  : TPtPos=(x:0; y:0);
  line_clp       : boolean;
  coll_det       : boolean=False;
  coll_ed_type   : byte=0;

  procedure DrawRctEdge0(left,top:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; clp_rct_:TPtRect); {$region -fold}
  begin
    SetColorInfo(clRed,color_info2);
    LineAC(
      arr_pos_x+arr_cell_width *(left  ),
      arr_pos_y+arr_cell_height*(top   ),
      arr_pos_x+arr_cell_width *(left+1),
      arr_pos_y+arr_cell_height*(top   ),
      bmp_dst_ptr,
      bmp_dst_width,
      clp_rct_,
      color_info2);
  end; {$endregion}

  procedure DrawRctEdge1(left,top:integer; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; clp_rct_:TPtRect); {$region -fold}
  begin
    SetColorInfo(clRed,color_info2);
    LineAC(
      arr_pos_x+arr_cell_width *(left  ),
      arr_pos_y+arr_cell_height*(top   ),
      arr_pos_x+arr_cell_width *(left  ),
      arr_pos_y+arr_cell_height*(top +1),
      bmp_dst_ptr,
      bmp_dst_width,
      clp_rct_,
      color_info2);
  end; {$endregion}

  procedure CollisionLineUpdate; {$region -fold}

    function  DrawLineOnGrid1   (x0_,y0_,x1_,y1_:integer; arr_src:T1Byte1Arr; line_clp_0,line_clp_1,line_clp_2:boolean; test_filled_cells:boolean=False): TPtPosF; {$region -fold}
    var
      line_start_pos,line_end_pos: TPtPos;
      r,t                        : integer;

      function GetArrCellInd (const _x_,_y_:integer                    ): TPtPos; {$region -fold}
      begin
        Result.x:=(_x_-arr_pos_x) div arr_cell_width ;
        Result.y:=(_y_-arr_pos_y) div arr_cell_height;
      end; {$endregion}

      function  DrawLineLoop0(const param0,param1,param2,param3:integer): TPtPos; {$region -fold}
      var
        point_on_rct_edge: double;
        prod0,prod1,i,j,k: integer;
      begin
        coll_det:=False;
        Result:=Default(TPtPos);
        prod0:=param0*arr_cell_width;
        prod1:=param1*arr_cell_height;
            i:=0;
            j:=0;
        for k:=0 to   Abs(line_end_pos.x-line_start_pos.x)+
                      Abs(line_end_pos.y-line_start_pos.y) do
          begin
            if (arr_src [(line_start_pos.x+param0*i)+
                         (line_start_pos.y+param1*j)*tlmap_width]=1) then
              begin
                Result.x:=line_start_pos.x+param0*i;
                Result.y:=line_start_pos.y+param1*j;
                coll_det:=True;
                Break;
              end;
            if     (line_start_pos.x+param0*i=line_end_pos.x) then
              if   (line_start_pos.x+param0*i=param2        ) then
                if (line_start_pos.y+param1*j=line_end_pos.y) then
                  Break;
            if     (line_start_pos.y+param1*j=line_end_pos.y) then
              if   (line_start_pos.y+param1*j=param3        ) then
                if (line_start_pos.x+param0*i=line_end_pos.x) then
                  Break;
            point_on_rct_edge:=line_coef.x*r+line_coef.y;
            if (point_on_rct_edge>=t                ) and
               (point_on_rct_edge< t+arr_cell_height) then
              begin
                Inc(i);
                Inc(r,prod0);
              end
            else
              begin
                Inc(j);
                Inc(t,prod1);
              end;
          end;
      end; {$endregion}

      function  DrawLineLoop1(const param0,param1,param2,param3:integer): TPtPos; {$region -fold}
      var
        point_on_rct_edge: double;
        prod0,prod1,i,j,k: integer;
      begin
        coll_det:=False;
        Result:=Default(TPtPos);
        prod0:=param0*arr_cell_width;
        prod1:=param1*arr_cell_height;
            i:=0;
            j:=0;
        for k:=0 to   Abs(line_end_pos.x-line_start_pos.x)+
                      Abs(line_end_pos.y-line_start_pos.y) do
          begin
            if (arr_src [(line_start_pos.x+param0*i)+
                         (line_start_pos.y+param1*j)*tlmap_width]=0) then
              begin
                Result.x:=line_start_pos.x+param0*i;
                Result.y:=line_start_pos.y+param1*j;
                coll_det:=True;
                Break;
              end;
            if     (line_start_pos.x+param0*i=line_end_pos.x) then
              if   (line_start_pos.x+param0*i=param2        ) then
                if (line_start_pos.y+param1*j=line_end_pos.y) then
                  Break;
            if     (line_start_pos.y+param1*j=line_end_pos.y) then
              if   (line_start_pos.y+param1*j=param3        ) then
                if (line_start_pos.x+param0*i=line_end_pos.x) then
                  Break;
            point_on_rct_edge:=line_coef.x*r+line_coef.y;
            if (point_on_rct_edge>=t                ) and
               (point_on_rct_edge< t+arr_cell_height) then
              begin
                Inc(i);
                Inc(r,prod0);
              end
            else
              begin
                Inc(j);
                Inc(t,prod1);
              end;
          end;
      end; {$endregion}

      procedure SetCollPt0   (const param0,param1,param2,param3:integer);         {$region -fold}
      var
        d0,d1: double;
        p0,p1: integer;
      begin
        p0:=arr_pos_x+arr_cell_width *(coll_cell_ind.x+param0);
        d0:=arr_pos_y+arr_cell_height* coll_cell_ind.y;
        d1:=line_coef.x*p0+line_coef.y;
        if (x0_=x1_) then
          begin
            Result.x    :=x0_;
            coll_ed_type:=param3*2+1;
            if (y1_>y0_) then
              Result.y:=arr_pos_y+arr_cell_height*(coll_cell_ind.y+0)
            else
              Result.y:=arr_pos_y+arr_cell_height*(coll_cell_ind.y+1);
            Exit;
          end;
        if (d1>=d0                ) and
           (d1< d0+arr_cell_height) then
          begin
            Result.x    :=p0;
            Result.y    :=p0*line_coef.x+line_coef.y;
            coll_ed_type:=param2*2+0;
          end
        else
          begin
            p1          :=arr_pos_y+arr_cell_height*(coll_cell_ind.y+param1);
            Result.x    :=(p1-line_coef.y)/line_coef.x;
            Result.y    := p1;
            coll_ed_type:=param3*2+1;
          end;
      end; {$endregion}

      procedure SetCollPt1   (const param0,param1              :integer);         {$region -fold}
      begin
        {if (x0_=x1_) then
          begin
            coll_ed_type:=param1*2+1;
            Exit;
          end;}
        Result.x:=x0_;
        Result.y:=y0_;
        if (x0_>arr_pos_x) and
           (x0_<arr_pos_x+arr_cell_width*tlmap_width-1) then
          coll_ed_type:=param1*2+1
        else
          coll_ed_type:=param0*2+0;
      end; {$endregion}

    begin
    coll_det      :=False;
    Result        :=Default(TPtPosF);
    line_start_pos:=GetArrCellInd(x0_,y0_);
    line_end_pos  :=GetArrCellInd(x1_,y1_);
    r             :=arr_pos_x+arr_cell_width *line_start_pos.x;
    t             :=arr_pos_y+arr_cell_height*line_start_pos.y;
    if (x0_=r) and (y0_=t) then
      if not ((arr_src[(line_start_pos.x)+
                       (line_start_pos.y)*tlmap_width]=1) and
               line_clp_0 and
               line_clp_1) then
      begin
        Inc(x0_);
        //coll_cell_ind:=line_start_pos;
        //coll_det     :=True;
        //coll_ed_type :=5;
        //Exit;
      end;
    line_coef:=LnCoef(x0_,y0_,x1_,y1_);
    if (arr_src[(line_start_pos.x)+
                (line_start_pos.y)*tlmap_width]=1) then
      begin
        if line_clp_0 then
          begin
            if line_clp_1 then
              begin
                coll_cell_ind:=line_start_pos;
                coll_det     :=True;
                if (x1_>=x0_) then
                  begin
                    if (y1_>=y0_) then
                      SetCollPt1(0,0)
                    else
                      SetCollPt1(0,1);
                  end
                else
                  begin
                    if (y1_>=y0_) then
                      SetCollPt1(1,0)
                    else
                      SetCollPt1(1,1);
                  end;
              end
            else
              begin
                if not test_filled_cells then
                  begin
                    Result.x     :=x0_;
                    Result.y     :=y0_;
                    coll_cell_ind:=line_start_pos;
                    coll_det     :=True;
                    coll_ed_type :=6;
                  end
                else
                  begin
                    if (x1_>=x0_) then
                      begin
                        r:=arr_pos_x+arr_cell_width*(line_start_pos.x+1);
                        if (y1_>=y0_) then
                          begin
                            coll_cell_ind:=DrawLineLoop1( 1, 1,tlmap_width-1,tlmap_height-1);
                            if coll_det then
                              SetCollPt0(0,0,0,0);
                          end
                        else
                          begin
                            coll_cell_ind:=DrawLineLoop1( 1,-1,tlmap_width-1,00000000000000);
                            if coll_det then
                              SetCollPt0(0,1,0,1);
                          end;
                      end
                    else
                      begin
                        r:=arr_pos_x+arr_cell_width*(line_start_pos.x+0);
                        if (y1_>=y0_) then
                          begin
                            coll_cell_ind:=DrawLineLoop1(-1, 1,0000000000000,tlmap_height-1);
                            if coll_det then
                              SetCollPt0(1,0,1,0);
                          end
                        else
                          begin
                            coll_cell_ind:=DrawLineLoop1(-1,-1,0000000000000,00000000000000);
                            if coll_det then
                              SetCollPt0(1,1,1,1);
                          end;
                      end;
                    if line_clp_2 then
                      begin
                        if (coll_cell_ind.x=0            ) or (coll_cell_ind.y=0             ) or
                           (coll_cell_ind.x=tlmap_width-1) or (coll_cell_ind.y=tlmap_height-1) then
                          begin
                            Result.x:=x1_;
                            Result.y:=y1_;
                            coll_det:=True;
                          //coll_cell_ind:=TODO;
                          //coll_ed_type :=TODO;
                          end;
                      end;
                  end;
              end;
          end;
        Exit;
      end;
    if (x1_>=x0_) then
      begin
        r:=arr_pos_x+arr_cell_width*(line_start_pos.x+1);
        if (y1_>=y0_) then
          begin
            coll_cell_ind:=DrawLineLoop0( 1, 1,tlmap_width-1,tlmap_height-1);
            if coll_det then
              SetCollPt0(0,0,0,0);
          end
        else
          begin
            coll_cell_ind:=DrawLineLoop0( 1,-1,tlmap_width-1,00000000000000);
            if coll_det then
              SetCollPt0(0,1,0,1);
          end;
      end
    else
      begin
        r:=arr_pos_x+arr_cell_width*(line_start_pos.x+0);
        if (y1_>=y0_) then
          begin
            coll_cell_ind:=DrawLineLoop0(-1, 1,0000000000000,tlmap_height-1);
            if coll_det then
              SetCollPt0(1,0,1,0);
          end
        else
          begin
            coll_cell_ind:=DrawLineLoop0(-1,-1,0000000000000,00000000000000);
            if coll_det then
              SetCollPt0(1,1,1,1);
          end;
      end;
  end; {$endregion}

  begin
    with obj_var do
      tlmap_ind:=obj_arr[obj_inds_arr[Length(tlm_var.tilemap_inds_arr)-1]].k_ind;
    with srf_var,obj_var do
      with sprite_sheet_arr[tlm_var.tilemap_inds_arr[tlmap_ind]],fast_image_data,fast_image_proc_var do
        begin
          fast_image_data_ptr0:=@fast_image_data;
          obj_arr_ptr         :=@obj_arr[tlmap_inds_obj_arr[tlmap_ind]];
          x0_clp              :=x0;
          y0_clp              :=y0;
          x1_clp              :=x1;
          y1_clp              :=y1;
          line_clp            :=LineC(
            x0_clp,
            y0_clp,
            x1_clp,
            y1_clp,
            PtRct(
              rct_pts_arr[0],
              rct_pts_arr[1],
              rct_pts_arr[2]-1,
              rct_pts_arr[3]-1));
          coll_cell_ind:=Default(TPtPos);
          if line_clp then
            coll_pt:=DrawLineOnGrid1(
              x0_clp,
              y0_clp,
              x1_clp,
              y1_clp,
              tilemap_coll_grid0,
              line_clp,
              (x0<>x0_clp) or (y0<>y0_clp),
              (x1<>x1_clp) or (y1<>y1_clp){,
              True});
        end;
  end; {$endregion}

begin
  Result:=projectile_default;
  if (obj_var.tlmap_cnt=0) then
    Exit;
  with obj_var do
    tlmap_ind:=obj_arr[obj_inds_arr[Length(tlm_var.tilemap_inds_arr)-1]].k_ind;
  with srf_var,obj_var do
    with sprite_sheet_arr[tlm_var.tilemap_inds_arr[tlmap_ind]],fast_image_data,fast_image_proc_var do
      begin
        fast_image_data_ptr0:=@fast_image_data;
        obj_arr_ptr         :=@obj_arr[tlmap_inds_obj_arr[tlmap_ind]];
        arr_cell_width      :=tilemap_sprite_w_h.x;
        arr_cell_height     :=tilemap_sprite_w_h.y;
        tlmap_width         :=bmp_ftimg_width_origin ;
        tlmap_height        :=bmp_ftimg_height_origin;
        rct_pts_arr[0]      :=Trunc(world_axis.x)+Trunc(obj_arr_ptr^.world_axis_shift.x)-(bmp_ftimg_width_origin *tilemap_sprite_w_h.x)>>1;
        rct_pts_arr[1]      :=Trunc(world_axis.y)+Trunc(obj_arr_ptr^.world_axis_shift.y)-(bmp_ftimg_height_origin*tilemap_sprite_w_h.y)>>1;
        rct_pts_arr[2]      :=    rct_pts_arr[0]+arr_cell_width *tlmap_width ;
        rct_pts_arr[3]      :=    rct_pts_arr[1]+arr_cell_height*tlmap_height;
        arr_pos_x           :=    rct_pts_arr[0];
        arr_pos_y           :=    rct_pts_arr[1];

        Result.pt_c         :=Default(TPtPosF);
        Result.coll_ed_type :=4;
        CollisionLineUpdate;
        Result.pt_c         :=coll_pt;
        Result.coll_ed_type :=coll_ed_type;
        Result.coll_det     :=coll_det;

        {Projectile Drawing---} {$region -fold}
        {if coll_det then
          begin

            case coll_ed_type of
              0:DrawRctEdge1(Trunc(coll_cell_ind.x+0),
                             Trunc(coll_cell_ind.y+0),
                             srf_bmp_ptr,
                             srf_bmp.width,
                             inn_wnd_rct);
              1:DrawRctEdge0(Trunc(coll_cell_ind.x+0),
                             Trunc(coll_cell_ind.y+0),
                             srf_bmp_ptr,
                             srf_bmp.width,
                             inn_wnd_rct);
              2:DrawRctEdge1(Trunc(coll_cell_ind.x+1),
                             Trunc(coll_cell_ind.y+0),
                             srf_bmp_ptr,
                             srf_bmp.width,
                             inn_wnd_rct);
              3:DrawRctEdge0(Trunc(coll_cell_ind.x+0),
                             Trunc(coll_cell_ind.y+1),
                             srf_bmp_ptr,
                             srf_bmp.width,
                             inn_wnd_rct);
            end;
            SetColorInfo(clBlue,color_info2);
            CircleC(Trunc(coll_pt.x),
                    Trunc(coll_pt.y),
                    7,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    inn_wnd_rct,
                    color_info2.pix_col);
            SetColorInfo2(clRed,color_info2);
          end
        else
          SetColorInfo2(clWhite,color_info2);

        if Length(library_images_inds_arr)<>0 then
          with sprite_sheet_arr[library_images_inds_arr[0]],fast_image_data,fast_image_proc_var do
            SdrProc[sdr_proc_ind](x1-bmp_ftimg_width_origin >>1,
                                  y1-bmp_ftimg_height_origin>>1,
                                  @fast_image_data)
        else
          begin
            CircleC(x1,
                    y1,
                    7,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    inn_wnd_rct,
                    color_info2.pix_col);
          end;
        fast_image_data_ptr0:=@fast_image_data;

        seg_cnt:=Trunc(sqrt(sqr(x1-x0)+sqr(y1-y0))/Min(tilemap_sprite_w_h.x,tilemap_sprite_w_h.y))+1;
        LineR0(x0,
               y0,
               x1,
               y1,
               srf_bmp_ptr,
               srf_bmp.width,
               inn_wnd_rct,
               color_info2,
               seg_cnt{32});
        SetColorInfo2(clGreen,color_info2);
        Point(x0_clp,
              y0_clp,
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              color_info2);
        SetColorInfo2(clYellow,color_info2);
        Point(x1_clp,
              y1_clp,
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              color_info2);}
        {$endregion}

      end;
end; {$endregion}
function CollisionTest2(const x0,y0,x1,y1:double ): TProjectile;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  tlmap_ind      : TColor;
  arr_pos_x,
  arr_pos_y      : double;
  arr_cell_width,
  arr_cell_height: TColor;
  tlmap_width,
  tlmap_height   : TColor;
  line_coef      : TPtPosF;
  x0_clp,
  x1_clp,
  y0_clp,
  y1_clp         : double;
  seg_cnt        : TColor;
  color_info2    : TColorInfo;
  obj_arr_ptr    : PObjProp;
  rct_pts_arr    : array[0..3] of double;
  coll_pt        : TPtPosF=(x:0.0; y:0.0);
  coll_cell_ind  : TPtPos =(x:0  ; y:0  );
  line_clp       : boolean;
  coll_det       : boolean=False;
  coll_ed_type   : byte=0;

  procedure DrawRctEdge0(left,top:double; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; clp_rct_:TPtRect); {$region -fold}
  begin
    SetColorInfo(clRed,color_info2);
    LineAC(Trunc(arr_pos_x+arr_cell_width *(left  )),
           Trunc(arr_pos_y+arr_cell_height*(top   )),
           Trunc(arr_pos_x+arr_cell_width *(left+1)),
           Trunc(arr_pos_y+arr_cell_height*(top   )),
           bmp_dst_ptr,
           bmp_dst_width,
           clp_rct_,
           color_info2);
  end; {$endregion}

  procedure DrawRctEdge1(left,top:double; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; clp_rct_:TPtRect); {$region -fold}
  begin
    SetColorInfo(clRed,color_info2);
    LineAC(Trunc(arr_pos_x+arr_cell_width *(left  )),
           Trunc(arr_pos_y+arr_cell_height*(top   )),
           Trunc(arr_pos_x+arr_cell_width *(left  )),
           Trunc(arr_pos_y+arr_cell_height*(top +1)),
           bmp_dst_ptr,
           bmp_dst_width,
           clp_rct_,
           color_info2);
  end; {$endregion}

  procedure DrawRct     (left,top:integer); {$region -fold}
  var
    pix_col: TColor=clBlue;
    pow    : byte=190;
  begin
    with srf_var do
      begin
        {PPAdditiveDec}PPInverseDec(srf_bmp_ptr,
                                    srf_bmp.width,
                                    ClippedRct(inn_wnd_rct,
                                               PtRct(Trunc(arr_pos_x)+arr_cell_width *(left  ),
                                                     Trunc(arr_pos_y)+arr_cell_height*(top   ),
                                                     Trunc(arr_pos_x)+arr_cell_width *(left+1),
                                                     Trunc(arr_pos_y)+arr_cell_height*(top +1))),
                                               //SetColorInv(pix_col),
                                               255-pow);
        SetColorInfo(clWhite{clRed},color_info2);
        LineAC(Trunc(arr_pos_x)+arr_cell_width *(left  ),
               Trunc(arr_pos_y)+arr_cell_height*(top   ),
               Trunc(arr_pos_x)+arr_cell_width *(left+1),
               Trunc(arr_pos_y)+arr_cell_height*(top   ),
               srf_bmp_ptr,
               srf_bmp.width,
               inn_wnd_rct,
               color_info2);
        SetColorInfo(clWhite{clGreen},color_info2);
        LineAC(Trunc(arr_pos_x)+arr_cell_width *(left+1),
               Trunc(arr_pos_y)+arr_cell_height*(top   ),
               Trunc(arr_pos_x)+arr_cell_width *(left+1),
               Trunc(arr_pos_y)+arr_cell_height*(top +1),
               srf_bmp_ptr,
               srf_bmp.width,
               inn_wnd_rct,
               color_info2);
        SetColorInfo($800000{clBlue},color_info2);
        LineAC(Trunc(arr_pos_x)+arr_cell_width *(left  ),
               Trunc(arr_pos_y)+arr_cell_height*(top +1),
               Trunc(arr_pos_x)+arr_cell_width *(left+1),
               Trunc(arr_pos_y)+arr_cell_height*(top +1),
               srf_bmp_ptr,
               srf_bmp.width,
               inn_wnd_rct,
               color_info2);
        SetColorInfo($800000{clWhite},color_info2);
        LineAC(Trunc(arr_pos_x)+arr_cell_width *(left  ),
               Trunc(arr_pos_y)+arr_cell_height*(top   ),
               Trunc(arr_pos_x)+arr_cell_width *(left  ),
               Trunc(arr_pos_y)+arr_cell_height*(top +1),
               srf_bmp_ptr,
               srf_bmp.width,
               inn_wnd_rct,
               color_info2);
      end;
  end; {$endregion}

  procedure CollisionLineUpdate; {$region -fold}

    function  DrawLineOnGrid(x0_,y0_,x1_,y1_:double; arr_src:T1Byte1Arr): TPtPosF; {$region -fold}
    var
      line_start_pos,line_end_pos: TPtPos;
      r,t                        : double;

      function  GetArrCellInd(const _x_,_y_:double                     ): TPtPos; {$region -fold}
      begin
        Result.x:=Trunc((_x_-arr_pos_x)/arr_cell_width );
        Result.y:=Trunc((_y_-arr_pos_y)/arr_cell_height);
      end; {$endregion}

      function  DrawLineLoop (const param0,param1,param2,param3:integer): TPtPos; {$region -fold}
      var
        point_on_rct_edge: double;
        prod0,prod1      : double;
        i,j,k            : integer;
      begin
        coll_det:=False;
        //Result:=Default(TPtPos);
        prod0:=param0*arr_cell_width;
        prod1:=param1*arr_cell_height;
            i:=0;
            j:=0;
        for k:=0 to   Abs(line_end_pos.x-line_start_pos.x)+
                      Abs(line_end_pos.y-line_start_pos.y) do
          begin
            if (arr_src [(line_start_pos.x+param0*i)+
                         (line_start_pos.y+param1*j)*tlmap_width]=1) then
              begin
                Result.x:=line_start_pos.x+param0*i;
                Result.y:=line_start_pos.y+param1*j;
                coll_det:=True;
                Break;
              end;
           {DrawRct(line_start_pos.x+param0*i,
                    line_start_pos.y+param1*j);} //
            if     (line_start_pos.x+param0*i=line_end_pos.x) then
              if   (line_start_pos.x+param0*i=param2        ) then
                if (line_start_pos.y+param1*j=line_end_pos.y) then
                  Break;
            if     (line_start_pos.y+param1*j=line_end_pos.y) then
              if   (line_start_pos.y+param1*j=param3        ) then
                if (line_start_pos.x+param0*i=line_end_pos.x) then
                  Break;
            point_on_rct_edge:=line_coef.x*r+line_coef.y;
            if (point_on_rct_edge>=t-00000000.000001) and
               (point_on_rct_edge< t+arr_cell_height) then
              begin
                Inc(i);
                r+=prod0;
              end
            else
              begin
                Inc(j);
                t+=prod1;
              end;
          end;
      end; {$endregion}

      procedure SetCollPt    (const param0,param1,param2,param3:integer);         {$region -fold}
      var
        d0,d1: double;
        p0,p1: double;
      begin
        p0:=arr_pos_x+arr_cell_width *(coll_cell_ind.x+param0);
        d0:=arr_pos_y+arr_cell_height* coll_cell_ind.y;
        d1:=line_coef.x*p0+line_coef.y;
        if (x0_=x1_) then
          begin
            Result.x    :=x0_;
            coll_ed_type:=param3*2+1;
            if (y1_>y0_) then
              Result.y:=arr_pos_y+arr_cell_height*(coll_cell_ind.y+0)
            else
              Result.y:=arr_pos_y+arr_cell_height*(coll_cell_ind.y+1);
            Exit;
          end;
        if (d1>=d0-00000000.000001) and
           (d1< d0+arr_cell_height) then
          begin
            Result.x    :=p0;
            Result.y    :=p0*line_coef.x+line_coef.y;
            coll_ed_type:=param2*2+0;
          end
        else
          begin
            p1          :=arr_pos_y+arr_cell_height*(coll_cell_ind.y+param1);
            Result.x    :=(p1-line_coef.y)/line_coef.x;
            Result.y    := p1;
            coll_ed_type:=param3*2+1;
          end;
      end; {$endregion}

    begin
    coll_det      :=False;
    //Result        :=Default(TPtPosF);
    line_start_pos:=GetArrCellInd(x0_,y0_);
    line_end_pos  :=GetArrCellInd(x1_,y1_);
    r             :=arr_pos_x+arr_cell_width *line_start_pos.x;
    t             :=arr_pos_y+arr_cell_height*line_start_pos.y;
    line_coef:=LnCoef(x0_,y0_,x1_,y1_);
    if (x1_>=x0_) then
      begin
        r+=arr_cell_width;
        if (y1_>=y0_) then
          begin
            coll_cell_ind:=DrawLineLoop( 1, 1,tlmap_width-1,tlmap_height-1);
            if coll_det then
              SetCollPt(0,0,0,0);
          end
        else
          begin
            coll_cell_ind:=DrawLineLoop( 1,-1,tlmap_width-1,00000000000000);
            if coll_det then
              SetCollPt(0,1,0,1);
          end;
      end
    else
      begin
        if (y1_>=y0_) then
          begin
            coll_cell_ind:=DrawLineLoop(-1, 1,0000000000000,tlmap_height-1);
            if coll_det then
              SetCollPt(1,0,1,0);

          end
        else
          begin
            coll_cell_ind:=DrawLineLoop(-1,-1,0000000000000,00000000000000);
            if coll_det then
              SetCollPt(1,1,1,1);
          end;
      end;
  end; {$endregion}

  begin
    with srf_var,obj_var do
      begin
        tlmap_ind:=obj_arr[obj_inds_arr[Length(tlm_var.tilemap_inds_arr)-1]].k_ind;
        with sprite_sheet_arr[tlm_var.tilemap_inds_arr[tlmap_ind]],fast_image_data,fast_image_proc_var do
          begin
            fast_image_data_ptr0:=@fast_image_data;
            obj_arr_ptr         :=@obj_arr[tlmap_inds_obj_arr[tlmap_ind]];
            x0_clp              :=x0;
            y0_clp              :=y0;
            x1_clp              :=x1;
            y1_clp              :=y1;
            line_clp            :=LineCF(x0_clp,
                                         y0_clp,
                                         x1_clp,
                                         y1_clp,
                                         PtRctF(rct_pts_arr[0],
                                                rct_pts_arr[1],
                                                rct_pts_arr[2]-1,
                                                rct_pts_arr[3]-1));
            coll_cell_ind:=Default(TPtPos);
            if line_clp then
              coll_pt:=DrawLineOnGrid(
                x0_clp,
                y0_clp,
                x1_clp,
                y1_clp,
                tilemap_coll_grid0);
          end;
      end;
  end; {$endregion}

begin
  //Result:=projectile_default;
  if (obj_var.tlmap_cnt=0) then
    Exit;
  with obj_var do
    tlmap_ind:=obj_arr[obj_inds_arr[Length(tlm_var.tilemap_inds_arr)-1]].k_ind;
  with srf_var,obj_var do
    with sprite_sheet_arr[tlm_var.tilemap_inds_arr[tlmap_ind]],fast_image_data,fast_image_proc_var do
      begin
        fast_image_data_ptr0:=@fast_image_data;
        obj_arr_ptr         :=@obj_arr[tlmap_inds_obj_arr[tlmap_ind]];
        arr_cell_width      :=tilemap_sprite_w_h.x;
        arr_cell_height     :=tilemap_sprite_w_h.y;
        tlmap_width         :=bmp_ftimg_width_origin ;
        tlmap_height        :=bmp_ftimg_height_origin;
        rct_pts_arr[0]      :=rct_ent_f.left  ;//world_axis.x+obj_arr_ptr^.world_axis_shift.x-(bmp_ftimg_width_origin *tilemap_sprite_w_h.x)>>1;
        rct_pts_arr[1]      :=rct_ent_f.top   ;//world_axis.y+obj_arr_ptr^.world_axis_shift.y-(bmp_ftimg_height_origin*tilemap_sprite_w_h.y)>>1;
        rct_pts_arr[2]      :=rct_pts_arr[0]+arr_cell_width *tlmap_width ;
        rct_pts_arr[3]      :=rct_pts_arr[1]+arr_cell_height*tlmap_height;
        arr_pos_x           :=rct_ent_f.left  ;//rct_pts_arr[0];
        arr_pos_y           :=rct_ent_f.top   ;//rct_pts_arr[1];

        Result.pt_c         :=Default(TPtPosF);
        //Result.coll_ed_type :=4;
        CollisionLineUpdate;
        Result.pt_c         :=coll_pt;
        Result.coll_ed_type :=coll_ed_type;
        Result.coll_det     :=coll_det;
        {
        {Projectile Drawing---} {$region -fold}
        if coll_det then
          begin

            case coll_ed_type of
              0:DrawRctEdge1(Trunc(coll_cell_ind.x+0),
                             Trunc(coll_cell_ind.y+0),
                             srf_bmp_ptr,
                             srf_bmp.width,
                             inn_wnd_rct);
              1:DrawRctEdge0(Trunc(coll_cell_ind.x+0),
                             Trunc(coll_cell_ind.y+0),
                             srf_bmp_ptr,
                             srf_bmp.width,
                             inn_wnd_rct);
              2:DrawRctEdge1(Trunc(coll_cell_ind.x+1),
                             Trunc(coll_cell_ind.y+0),
                             srf_bmp_ptr,
                             srf_bmp.width,
                             inn_wnd_rct);
              3:DrawRctEdge0(Trunc(coll_cell_ind.x+0),
                             Trunc(coll_cell_ind.y+1),
                             srf_bmp_ptr,
                             srf_bmp.width,
                             inn_wnd_rct);
            end;
            SetColorInfo(clBlue,color_info2);
            CircleC(Trunc(coll_pt.x),
                    Trunc(coll_pt.y),
                    7,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    inn_wnd_rct,
                    color_info2.pix_col);
            SetColorInfo2(clRed,color_info2);
          end
        else
          SetColorInfo2(clWhite,color_info2);

        {if Length(library_images_inds_arr)<>0 then
          with sprite_sheet_arr[library_images_inds_arr[0]],fast_image_data,fast_image_proc_var do
            SdrProc[sdr_proc_ind](Trunc(x1)-bmp_ftimg_width_origin >>1,
                                  Trunc(y1)-bmp_ftimg_height_origin>>1,
                                  @fast_image_data)
        else
          begin
            CircleC(Trunc(x1),
                    Trunc(y1),
                    7,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    inn_wnd_rct,
                    color_info2.pix_col);
          end;
        fast_image_data_ptr0:=@fast_image_data;}

        seg_cnt:=Trunc(sqrt(sqr(x1-x0)+sqr(y1-y0))/Min(tilemap_sprite_w_h.x,tilemap_sprite_w_h.y))+1;
        LineR0(Trunc(x0),
               Trunc(y0),
               Trunc(x1),
               Trunc(y1),
               srf_bmp_ptr,
               srf_bmp.width,
               inn_wnd_rct,
               color_info2,
               seg_cnt{32});
        SetColorInfo2(clGreen,color_info2);
        Point(Trunc(x0_clp),
              Trunc(y0_clp),
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              color_info2);
        SetColorInfo2(clYellow,color_info2);
        Point(Trunc(x1_clp),
              Trunc(y1_clp),
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              color_info2);
        {$endregion}
        }
      end;
end; {$endregion}
function CollisionTest3(const x0,y0,x1,y1:double ): TProjectile;  inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  tlmap_ind      : TColor;
  arr_pos_x,
  arr_pos_y      : double;
  arr_cell_width,
  arr_cell_height: TColor;
  tlmap_width,
  tlmap_height   : TColor;
  line_coef      : TPtPosF;
  x0_clp,
  x1_clp,
  y0_clp,
  y1_clp         : double;
  seg_cnt        : TColor;
  color_info2    : TColorInfo;
  obj_arr_ptr    : PObjProp;
  rct_pts_arr    : array[0..3] of double;
  coll_pt        : TPtPosF=(x:0.0; y:0.0);
  coll_cell_ind  : TPtPos =(x:0  ; y:0  );
  line_clp       : boolean;
  coll_det       : boolean=False;
  coll_ed_type   : byte=0;

  procedure DrawRctEdge0(left,top:double; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; clp_rct_:TPtRect); {$region -fold}
  begin
    SetColorInfo(clRed,color_info2);
    LineAC(Trunc(arr_pos_x+arr_cell_width *(left  )),
           Trunc(arr_pos_y+arr_cell_height*(top   )),
           Trunc(arr_pos_x+arr_cell_width *(left+1)),
           Trunc(arr_pos_y+arr_cell_height*(top   )),
           bmp_dst_ptr,
           bmp_dst_width,
           clp_rct_,
           color_info2);
  end; {$endregion}

  procedure DrawRctEdge1(left,top:double; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; clp_rct_:TPtRect); {$region -fold}
  begin
    SetColorInfo(clRed,color_info2);
    LineAC(Trunc(arr_pos_x+arr_cell_width *(left  )),
           Trunc(arr_pos_y+arr_cell_height*(top   )),
           Trunc(arr_pos_x+arr_cell_width *(left  )),
           Trunc(arr_pos_y+arr_cell_height*(top +1)),
           bmp_dst_ptr,
           bmp_dst_width,
           clp_rct_,
           color_info2);
  end; {$endregion}

  procedure DrawRct     (left,top:integer); {$region -fold}
  var
    pix_col: TColor=clBlue;
    pow    : byte=190;
  begin
    with srf_var do
      begin
        {PPAdditiveDec}PPInverseDec(srf_bmp_ptr,
                                    srf_bmp.width,
                                    ClippedRct(inn_wnd_rct,
                                               PtRct(Trunc(arr_pos_x)+arr_cell_width *(left  ),
                                                     Trunc(arr_pos_y)+arr_cell_height*(top   ),
                                                     Trunc(arr_pos_x)+arr_cell_width *(left+1),
                                                     Trunc(arr_pos_y)+arr_cell_height*(top +1))),
                                               //SetColorInv(pix_col),
                                               255-pow);
        SetColorInfo(clWhite{clRed},color_info2);
        LineAC(Trunc(arr_pos_x)+arr_cell_width *(left  ),
               Trunc(arr_pos_y)+arr_cell_height*(top   ),
               Trunc(arr_pos_x)+arr_cell_width *(left+1),
               Trunc(arr_pos_y)+arr_cell_height*(top   ),
               srf_bmp_ptr,
               srf_bmp.width,
               inn_wnd_rct,
               color_info2);
        SetColorInfo(clWhite{clGreen},color_info2);
        LineAC(Trunc(arr_pos_x)+arr_cell_width *(left+1),
               Trunc(arr_pos_y)+arr_cell_height*(top   ),
               Trunc(arr_pos_x)+arr_cell_width *(left+1),
               Trunc(arr_pos_y)+arr_cell_height*(top +1),
               srf_bmp_ptr,
               srf_bmp.width,
               inn_wnd_rct,
               color_info2);
        SetColorInfo($800000{clBlue},color_info2);
        LineAC(Trunc(arr_pos_x)+arr_cell_width *(left  ),
               Trunc(arr_pos_y)+arr_cell_height*(top +1),
               Trunc(arr_pos_x)+arr_cell_width *(left+1),
               Trunc(arr_pos_y)+arr_cell_height*(top +1),
               srf_bmp_ptr,
               srf_bmp.width,
               inn_wnd_rct,
               color_info2);
        SetColorInfo($800000{clWhite},color_info2);
        LineAC(Trunc(arr_pos_x)+arr_cell_width *(left  ),
               Trunc(arr_pos_y)+arr_cell_height*(top   ),
               Trunc(arr_pos_x)+arr_cell_width *(left  ),
               Trunc(arr_pos_y)+arr_cell_height*(top +1),
               srf_bmp_ptr,
               srf_bmp.width,
               inn_wnd_rct,
               color_info2);
      end;
  end; {$endregion}

  procedure CollisionLineUpdate; {$region -fold}

    function  DrawLineOnGrid(x0_,y0_,x1_,y1_:double; arr_src:T1Byte1Arr): TPtPosF; {$region -fold}
    var
      line_start_pos,line_end_pos: TPtPos;
      r,t                        : double;

      function  GetArrCellInd(const _x_,_y_:double                     ): TPtPos; {$region -fold}
      begin
        Result.x:=Trunc((_x_-arr_pos_x)/arr_cell_width );
        Result.y:=Trunc((_y_-arr_pos_y)/arr_cell_height);
      end; {$endregion}

      function  DrawLineLoop (const param0,param1,param2,param3:integer): TPtPos; {$region -fold}
      var
        point_on_rct_edge: double;
        prod0,prod1      : double;
        i,j,k            : integer;
      begin
        coll_det:=False;
        prod0:=param0*arr_cell_width;
        prod1:=param1*arr_cell_height;
            i:=0;
            j:=0;
        for k:=0 to   Abs(line_end_pos.x-line_start_pos.x)+
                      Abs(line_end_pos.y-line_start_pos.y) do
          begin
            if (arr_src [(line_start_pos.x+param0*i)+
                         (line_start_pos.y+param1*j)*tlmap_width]=1) then
              begin
                Result.x:=line_start_pos.x+param0*i;
                Result.y:=line_start_pos.y+param1*j;
                coll_det:=True;
                Break;
              end;
           DrawRct(line_start_pos.x+param0*i,
                    line_start_pos.y+param1*j);
            if     (line_start_pos.x+param0*i=line_end_pos.x) then
              if   (line_start_pos.x+param0*i=param2        ) then
                if (line_start_pos.y+param1*j=line_end_pos.y) then
                  Break;
            if     (line_start_pos.y+param1*j=line_end_pos.y) then
              if   (line_start_pos.y+param1*j=param3        ) then
                if (line_start_pos.x+param0*i=line_end_pos.x) then
                  Break;
            point_on_rct_edge:=line_coef.x*r+line_coef.y;
            if (point_on_rct_edge>=t-00000000.000001) and
               (point_on_rct_edge< t+arr_cell_height) then
              begin
                Inc(i);
                r+=prod0;
              end
            else
              begin
                Inc(j);
                t+=prod1;
              end;
          end;
      end; {$endregion}

      procedure SetCollPt    (const param0,param1,param2,param3:integer);         {$region -fold}
      var
        d0,d1: double;
        p0,p1: double;
      begin
        p0:=arr_pos_x+arr_cell_width *(coll_cell_ind.x+param0);
        d0:=arr_pos_y+arr_cell_height* coll_cell_ind.y;
        d1:=line_coef.x*p0+line_coef.y;
        if (x0_=x1_) then
          begin
            Result.x    :=x0_;
            coll_ed_type:=param3*2+1;
            if (y1_>y0_) then
              Result.y:=arr_pos_y+arr_cell_height*(coll_cell_ind.y+0)
            else
              Result.y:=arr_pos_y+arr_cell_height*(coll_cell_ind.y+1);
            Exit;
          end;
        if (d1>=d0-00000000.000001) and
           (d1< d0+arr_cell_height) then
          begin
            Result.x    :=p0;
            Result.y    :=p0*line_coef.x+line_coef.y;
            coll_ed_type:=param2*2+0;
          end
        else
          begin
            p1          :=arr_pos_y+arr_cell_height*(coll_cell_ind.y+param1);
            Result.x    :=(p1-line_coef.y)/line_coef.x;
            Result.y    := p1;
            coll_ed_type:=param3*2+1;
          end;
      end; {$endregion}

    begin
    coll_det      :=False;
    line_start_pos:=GetArrCellInd(x0_,y0_);
    line_end_pos  :=GetArrCellInd(x1_,y1_);
    r             :=arr_pos_x+arr_cell_width *line_start_pos.x;
    t             :=arr_pos_y+arr_cell_height*line_start_pos.y;
    line_coef:=LnCoef(x0_,y0_,x1_,y1_);
    if (x1_>=x0_) then
      begin
        r+=arr_cell_width;
        if (y1_>=y0_) then
          begin
            coll_cell_ind:=DrawLineLoop( 1, 1,tlmap_width-1,tlmap_height-1);
            if coll_det then
              SetCollPt(0,0,0,0);
          end
        else
          begin
            coll_cell_ind:=DrawLineLoop( 1,-1,tlmap_width-1,00000000000000);
            if coll_det then
              SetCollPt(0,1,0,1);
          end;
      end
    else
      begin
        if (y1_>=y0_) then
          begin
            coll_cell_ind:=DrawLineLoop(-1, 1,0000000000000,tlmap_height-1);
            if coll_det then
              SetCollPt(1,0,1,0);

          end
        else
          begin
            coll_cell_ind:=DrawLineLoop(-1,-1,0000000000000,00000000000000);
            if coll_det then
              SetCollPt(1,1,1,1);
          end;
      end;
  end; {$endregion}

  begin
    with srf_var,obj_var do
      begin
        tlmap_ind:=obj_arr[obj_inds_arr[Length(tlm_var.tilemap_inds_arr)-1]].k_ind;
        with sprite_sheet_arr[tlm_var.tilemap_inds_arr[tlmap_ind]],fast_image_data,fast_image_proc_var do
          begin
            fast_image_data_ptr0:=@fast_image_data;
            obj_arr_ptr         :=@obj_arr[tlmap_inds_obj_arr[tlmap_ind]];
            x0_clp              :=x0;
            y0_clp              :=y0;
            x1_clp              :=x1;
            y1_clp              :=y1;
            line_clp            :=LineCF(x0_clp,
                                         y0_clp,
                                         x1_clp,
                                         y1_clp,
                                         PtRctF(rct_pts_arr[0],
                                                rct_pts_arr[1],
                                                rct_pts_arr[2]-1,
                                                rct_pts_arr[3]-1));
            coll_cell_ind:=Default(TPtPos);
            if line_clp then
              coll_pt:=DrawLineOnGrid(
                x0_clp,
                y0_clp,
                x1_clp,
                y1_clp,
                tilemap_coll_grid0);
          end;
      end;
  end; {$endregion}

begin
  with obj_var do
    tlmap_ind:=obj_arr[obj_inds_arr[Length(tlm_var.tilemap_inds_arr)-1]].k_ind;
  with srf_var,obj_var do
    with sprite_sheet_arr[tlm_var.tilemap_inds_arr[tlmap_ind]],fast_image_data,fast_image_proc_var do
      begin
        fast_image_data_ptr0:=@fast_image_data;
        obj_arr_ptr         :=@obj_arr[tlmap_inds_obj_arr[tlmap_ind]];
        arr_cell_width      :=tilemap_sprite_w_h.x;
        arr_cell_height     :=tilemap_sprite_w_h.y;
        tlmap_width         :=bmp_ftimg_width_origin;
        tlmap_height        :=bmp_ftimg_height_origin;
        rct_pts_arr[0]      :=rct_ent_f.left;
        rct_pts_arr[1]      :=rct_ent_f.top;
        rct_pts_arr[2]      :=rct_pts_arr[0]+arr_cell_width *tlmap_width;
        rct_pts_arr[3]      :=rct_pts_arr[1]+arr_cell_height*tlmap_height;
        arr_pos_x           :=rct_ent_f.left;
        arr_pos_y           :=rct_ent_f.top;

        Result.pt_c         :=Default(TPtPosF);
        CollisionLineUpdate;
        Result.pt_c         :=coll_pt;
        Result.coll_ed_type :=coll_ed_type;
        Result.coll_det     :=coll_det;

        {Projectile Drawing---} {$region -fold}
        if coll_det then
          begin

            case coll_ed_type of
              0:DrawRctEdge1(Trunc(coll_cell_ind.x+0),
                             Trunc(coll_cell_ind.y+0),
                             srf_bmp_ptr,
                             srf_bmp.width,
                             inn_wnd_rct);
              1:DrawRctEdge0(Trunc(coll_cell_ind.x+0),
                             Trunc(coll_cell_ind.y+0),
                             srf_bmp_ptr,
                             srf_bmp.width,
                             inn_wnd_rct);
              2:DrawRctEdge1(Trunc(coll_cell_ind.x+1),
                             Trunc(coll_cell_ind.y+0),
                             srf_bmp_ptr,
                             srf_bmp.width,
                             inn_wnd_rct);
              3:DrawRctEdge0(Trunc(coll_cell_ind.x+0),
                             Trunc(coll_cell_ind.y+1),
                             srf_bmp_ptr,
                             srf_bmp.width,
                             inn_wnd_rct);
            end;
            SetColorInfo(clBlue,color_info2);
            CircleC(Trunc(coll_pt.x),
                    Trunc(coll_pt.y),
                    7,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    inn_wnd_rct,
                    color_info2.pix_col);
            SetColorInfo2(clRed,color_info2);
          end
        else
          SetColorInfo2(clWhite,color_info2);

        {if Length(library_images_inds_arr)<>0 then
          with sprite_sheet_arr[library_images_inds_arr[0]],fast_image_data,fast_image_proc_var do
            SdrProc[sdr_proc_ind](Trunc(x1)-bmp_ftimg_width_origin >>1,
                                  Trunc(y1)-bmp_ftimg_height_origin>>1,
                                  @fast_image_data)
        else
          begin
            CircleC(Trunc(x1),
                    Trunc(y1),
                    7,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    inn_wnd_rct,
                    color_info2.pix_col);
          end;
        fast_image_data_ptr0:=@fast_image_data;}

        seg_cnt:=Trunc(sqrt(sqr(x1-x0)+sqr(y1-y0))/Min(tilemap_sprite_w_h.x,tilemap_sprite_w_h.y))+1;
        LineR0(Trunc(x0),
               Trunc(y0),
               Trunc(x1),
               Trunc(y1),
               srf_bmp_ptr,
               srf_bmp.width,
               inn_wnd_rct,
               color_info2,
               seg_cnt{32});
        SetColorInfo2(clGreen,color_info2);
        Point(Trunc(x0_clp),
              Trunc(y0_clp),
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              color_info2);
        SetColorInfo2(clYellow,color_info2);
        Point(Trunc(x1_clp),
              Trunc(y1_clp),
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              color_info2);
        {$endregion}

      end;
end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.OGLC_GPU_CanvasMouseEnter                 (sender:TObject); {$region -fold}
begin
  {if down_play_anim_ptr^ then
    begin
      //drawing_area_enter_calc:=True;
      DefocusControl(ActiveControl,True);
    end;}
end; {$endregion}
procedure TF_MainForm.OGLC_GPU_CanvasMouseLeave                 (sender:TObject); {$region -fold}
begin
  {if down_play_anim_ptr^ then
    begin
      //drawing_area_enter_calc:=False;
    end;}
end; {$endregion}
procedure TF_MainForm.CB_Game_Settings_Fix_ResolutionChange     (sender:TObject); {$region -fold}
begin
  fix_resolution:=not fix_resolution;
end; {$endregion}
procedure TF_MainForm.CB_Game_Settings_Refresh_Lower_LayerChange(sender:TObject); {$region -fold}
begin
  refresh_lower_layer:=not refresh_lower_layer;
  L_Game_Settings_Refresh_Step                .Visible:=refresh_lower_layer;
  SE_Game_Settings_Refresh_Step               .Visible:=refresh_lower_layer;
  L_Game_Settings_Refresh_Step_Frames         .Visible:=refresh_lower_layer;
  L_Game_Settings_Exec_Time_Limit             .Visible:=refresh_lower_layer;
  SE_Game_Settings_Exec_Time_Limit            .Visible:=refresh_lower_layer;
  L_Game_Settings_Exec_Time_Limit_Milliseconds.Visible:=refresh_lower_layer;
end; {$endregion}
procedure TF_MainForm.CB_Game_Settings_Show_World_AxisChange    (sender:TObject); {$region -fold}
begin
  show_world_axis:=not show_world_axis;
  with srf_var do
    EventGroupsCalc(calc_arr,[10,14,18,30,41,52,53,55]);
end; {$endregion}
procedure TF_MainForm.SE_Game_Settings_Canvas_WidthChange       (sender:TObject); {$region -fold}
begin
  with srf_var do
    canvas_rct_width:=SE_Game_Settings_Canvas_Width.Value;
end; {$endregion}
procedure TF_MainForm.SE_Game_Settings_Canvas_HeightChange      (sender:TObject); {$region -fold}
begin
  with srf_var do
    canvas_rct_height:=SE_Game_Settings_Canvas_Height.Value;
end; {$endregion}
procedure TF_MainForm.SE_Game_Settings_Refresh_StepChange       (sender:TObject); {$region -fold}
begin
  refresh_step:=SE_Game_Settings_Refresh_Step.Value;
end; {$endregion}
procedure TF_MainForm.SE_Game_Settings_Exec_Time_LimitChange    (sender:TObject); {$region -fold}
begin
  exec_time_sup:=SE_Game_Settings_Exec_Time_Limit.Value;
end; {$endregion}
procedure TF_MainForm.SE_Game_Settings_Canvas_WidthEditingDone  (sender:TObject); {$region -fold}
begin
  FormChangeSize;
end; {$endregion}
procedure TF_MainForm.SE_Game_Settings_Canvas_HeightEditingDone (sender:TObject); {$region -fold}
begin
  FormChangeSize;
end; {$endregion}
procedure TF_MainForm.SB_Play_AnimClick                         (sender:TObject); {$region -fold}
var
  i,projectile_rnd2: integer;
  key              : char;
begin

  with srf_var do
    if down_play_anim_ptr^ then
      begin
        if down_spline_ptr^ then
          begin
            key:=Char(key_arr[07]);
            FormKeyPress(Self,key);
          end
        else
        if down_select_items_ptr^ then
          begin
            if (sel_var.sel_pts_cnt<>0) then
              Exit;
            key:=Char(key_arr[08]);
            FormKeyPress(Self,key);
          end;
        inn_wnd_rct2                          :=inn_wnd_rct;
        cmr_var.mov_dir                       :=mdNone;
        OnMouseMove                           :=Nil;
        F_Hot_Keys.Visible                    :=False;
        SE_Game_Settings_Canvas_Width .Enabled:=False;
        SE_Game_Settings_Canvas_Height.Enabled:=False;
        KeysDisable2;
        LockCursorToWindow;
      end
    else
      begin
        MainBmpRectCalc1;
        MainBmpRectCalc2;
        OnMouseMove                           :=@FormMouseMove;
        SE_Game_Settings_Canvas_Width .Enabled:=True;
        SE_Game_Settings_Canvas_Height.Enabled:=True;
        KeysEnable2;
        //DrawingPanelsSetVisibility1(down_play_anim_ptr,P_Anim_Buttons,P_Play_Anim,P_Anim_Custom_Panel,prev_panel_draw,curr_panel_draw);
        SB_Play_Anim  .Repaint;
        P_Anim_Buttons.Repaint;
        UnLockCursor;
      end;
  SB_Play_Anim.OnClick:=@SB_Play_AnimClick;
  SB_Play_Anim.Enabled:=True;

  with srf_var do
    begin
      // Get Target Render For OpenGL Output:
      GLBitmapInit(texture_id,srf_bmp,down_play_anim_ptr^);

      {Test} {$region -fold}
      if (texture_test_ptr<>Nil) and (texture_test_ptr2<>Nil) then
        GLBitmapInit(texture_id2,texture_test_ptr2^,down_play_anim_ptr^); {$endregion}

      //if down_play_anim_ptr^ then
      {GetObject(srf_bmp.Handle,SizeOf(buffer),@buffer);}
    end;

  SB_Anim_Buttons_Button_Bkgnd.Left   :=SB_Play_Anim.Left;
  SB_Anim_Buttons_Button_Bkgnd.Visible:=SB_Play_Anim.Down;
  OGLC_GPU_Canvas             .Visible:=down_play_anim_ptr^;
  OGLC_GPU_Canvas             .Enabled:=down_play_anim_ptr^;
  srf_var.orgn_wnd_res                :=PtPos(F_MainForm.width,F_MainForm.height);
  srf_var.rszd_wnd_res                :=PtPos(F_MainForm.width,F_MainForm.height);
  refresh_skip                        :=00;
  rct_src_mrg_inc                     :=00;
  rct_src_mrg_inc_                    :=00;
  session_time                        :=00;

  {Test0: Projectile Movement 1} {$region -fold}
  {
  //LnCoef(projectile_mov_vec);
  SetLength(grid_ln_arr,collision_grid_density.x*collision_grid_density.y);
  SetLength(grid_pt_arr,collision_grid_density.x*collision_grid_density.y);
  with srf_var,projectile_mov_vec do
    begin
      projectile_curr_pos.x       :=world_axis.x;
      projectile_curr_pos.y       :=world_axis.y;
      projectile_rnd              :=1-2*Random(2);//2*(1-Random(2))-1;
      x0                          :=projectile_curr_pos.x;
      y0                          :=projectile_curr_pos.y;
      x1                          :=x0+projectile_rnd*(Random(100)+1);
      y1                          :=y0+projectile_rnd*(Random(100)+1);
      projectile_dir_tick_counter0:=0;
      projectile_dir_tick_counter1:=0;
    end;
  }
  {Spline Simplification}

  collision_detect:=projectile_default;
  with srf_var,projectile_mov_vec do
    begin
      projectile_dir              :=1-2*Random(2);
      projectile_rnd0             :=1-2*Random(2);
      projectile_rnd1             :=1-2*Random(2);
      projectile_curr_pos.x       :=world_axis.x+projectile_rnd0*(Random(64)+1{+0.001});
      projectile_curr_pos.y       :=world_axis.y+projectile_rnd1*(Random(64)+1{+0.001});
                          x0      :=projectile_curr_pos.x;
                          y0      :=projectile_curr_pos.y;
                          x1      :=x0+projectile_rnd0*(Random(128)+1);
                          y1      :=y0+projectile_rnd1*(Random(128)+1);
      projectile_mov_vec2.x0      :=x0;
      projectile_mov_vec2.y0      :=y0;
      projectile_mov_vec2.x1      :=x1;
      projectile_mov_vec2.y1      :=y1;
      projectile_dir_tick_counter0:=projectile_dir_tick_inc0{0};
      projectile_dir_tick_counter1:=projectile_dir_tick_inc1{0};
    end;

  {if (sln_var.sln_pts_cnt>0) then
    SetLength(pt_ind_arr,sln_var.sln_pts_cnt);}
  {$endregion}

  {Test1: Projectile Movement 2} {$region -fold}
  Randomize;
  for i:=0 to Length(br_vec_projectile_arr)-1 do
    begin
           br_vec_projectile_arr[i]:=br_vec_default;
      with br_vec_projectile_arr[i] do
        with srf_var,projectile_mov_vec do
          begin
            projectile_dir              :=1-2*Random(2);
            projectile_rnd0             :=1-2*Random(2);
            projectile_rnd1             :=1-2*Random(2);
            projectile_curr_pos.x       :=world_axis.x+projectile_rnd0*(Random(64)+1{+0.0001});
            projectile_curr_pos.y       :=world_axis.y+projectile_rnd1*(Random(64)+1{+0.0001});
                                x0      :=projectile_curr_pos.x;
                                y0      :=projectile_curr_pos.y;
                                x1      :=x0+projectile_rnd0*(Random(64)+1{+0.0001});
                                y1      :=y0+projectile_rnd1*(Random(64)+1{+0.0001});
            projectile_mov_vec2.x0      :=x0;
            projectile_mov_vec2.y0      :=y0;
            projectile_mov_vec2.x1      :=x1;
            projectile_mov_vec2.y1      :=y1;
            projectile_dir_tick_inc0    *=frame_skip_val;
            projectile_dir_tick_inc1    *=frame_skip_val;
            projectile_dir_tick_counter0:=projectile_dir_tick_inc0;
            projectile_dir_tick_counter1:=projectile_dir_tick_inc1;
          end;
    end;
  {$endregion}

  {Test2-----------------------} {$region -fold}
  {
  n:=1000100{500};
  SetLength(test_pos_arr,n);
  for i:=0 to n-1 do
    begin
      test_pos_arr[i].x:=Random(400{700}{2048}{4096}{32768});
      test_pos_arr[i].y:=Random(200{400}{2048}{4096}{32768});
    end;
  } {$endregion}

  {Test3:Sound Event-----------} {$region -fold}
  if (down_play_anim_ptr^ and FileExists(Application.Location+BKGND_SOUND) and play_bkgnd_sound) then
    begin
      mciSendString(PChar('play "'+Application.Location+BKGND_SOUND+'"'),nil,0,0);
      GifAnim_Background_Sound.Visible:=True;
      GifAnim_Background_Sound.Animate:=True;
    end
  else
    mciSendString(PChar('stop "'+Application.Location+BKGND_SOUND+'"'),nil,0,0);
  //PlaySound(PChar(EGG_SHAKE),0,SND_ASYNC);
  if (not down_play_anim_ptr^) then
    begin
      GifAnim_Background_Sound.Animate:=False;
      GifAnim_Background_Sound.Visible:=False;
    end;
  {$endregion}

  {Test4: Play Video-----------} {$region -fold}
  {
  //LCLVLCPlayer_Intro.AudioDelay :=0;
  //LCLVLCPlayer_Intro.AudioMuted :=true;
  //LCLVLCPlayer_Intro.AudioVolume:=0;
  //LCLVLCPlayer_Intro.Channel    :=0;
  if (down_play_anim_ptr^ and FileExists(Application.Location+INTRO_MOVIE) and play_bkgnd_movie) then
    begin
      Panel1.Enabled:=True;
      Panel1.Visible:=True;
      LCLVLCPlayer_Intro.PlayFile(Application.Location+INTRO_MOVIE)
    end
  else
    begin
      LCLVLCPlayer_Intro.Stop;
      Panel1.Enabled:=False;
      Panel1.Visible:=False;
    end;
  } {$endregion}

  {for i:=0 to 9999 do
    begin
      projectile_arr[i]:=projectile_default;
      with projectile_arr[i] do
        begin
          pt_ind:=-1;
          pt_0  :=PtPosF(srf_var.world_axis.x,
                         srf_var.world_axis.y);
          pt_p  :=pt_0;
          pt_n  :=pt_0;
          //pt_c :=pt_n;
          {v_0  +=Random(12);
          angle+=Random(90);}
          //projectile_arr[i].time-=TIME_DELTA;
        end;
    end;}

  {Test6: Water Wave-----------} {$region -fold}
  frame_counter      :=01;
  fx_inc_check       :=True;
  dy0                :=5;
  dir_               :=mdDown;
  with sln_var do
    Move(sln_pts[0],sln_pts_res[0],sln_pts_cnt<<4);
  {$endregion}

  obj_var.SetRctDstPtr(@srf_var.inn_wnd_rct,0,obj_var.obj_cnt-1);
  obj_var.VisObjArrCrt2;

  with srf_var do
    if (not down_play_anim_ptr^) then
      EventGroupsCalc(calc_arr,[0,1,2,3,4,{10,}17,18,30,31,32,37,41,48,52,53,55])
    else
      EventGroupsCalc(calc_arr,[10,18,30,31,32,41,52,53,55{21,30,41,52,53,55}]);

  with srf_var,sln_var,fast_fluid_var do
    begin
      WaterWaveInit1;
      {if (sln_pts_cnt<>0) then
        WaterWaveInit(sln_pts,
                      sln_pts_cnt-sln_obj_pts_cnt[sln_obj_cnt-1],
                      sln_pts_cnt);}
      {WaterWaveInit(PtPosF(world_axis.x,
                           world_axis.y));}
    end;

  SnapGLCanvas;

  T_Game_Loop.Enabled:=down_play_anim_ptr^;

end; {$endregion}
procedure TF_MainForm.BB_Load_FrameClick                        (sender:TObject); {$region -fold}
var
  button_glyph: Graphics.TBitmap;
begin
  {OpenPictureDialog1.Options:=OpenPictureDialog1.Options+[ofFileMustExist];
  if (not OpenPictureDialog1.Execute) then
    Exit;
  try
    sln_var.tex_on_sln.LoadFromFile(OpenPictureDialog1.Filename);
  except
    on E: Exception do
      MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
  end;
  button_glyph       :=Graphics.TBitmap.Create;
  button_glyph.Width :=50;
  button_glyph.Height:=50;
  button_glyph.PixelFormat:=pf32bit;
  button_glyph.Canvas.StretchDraw(Rect(0,0,
                                       button_glyph.Width,
                                       button_glyph.Height),
                                       sln_var.tex_on_sln.Graphic);
  BB_Load_Bitmap.Glyph:=button_glyph;
  sln_var.tex_on_sln_tmp_bmp:=Graphics.TBitmap.Create;}
end; {$endregion}
procedure TF_MainForm.BB_Use_MagicClick                         (sender:TObject); {$region -fold}
var
  sprite_rect_arr_ptr: PPtPos;
  useless_arr_ptr    : PByte;
  i,v1,v2,c0,c1,c2,c3: integer;
begin
  {
  {if (useless_fld_arr_<>Nil) then
    FillDWord(useless_fld_arr_[0],srf_var.srf_bmp.width*srf_var.srf_bmp.height,0);}
  SetLength  (useless_fld_arr_,srf_var.srf_bmp.width*srf_var.srf_bmp.height);
  ArrClear   (useless_fld_arr_,srf_var.inn_wnd_rct,srf_var.srf_bmp.width);

 {if (useless_arr_<>Nil) then
    FillByte(useless_arr_[0],SE_Count_X.value,0);}
  SetLength (useless_arr_   ,SE_Count_X.value  );
    FillByte(useless_arr_[0],SE_Count_X.value,0);

  {if (sprite_rect_arr_<>Nil) then
    FillQWord(sprite_rect_arr_[0],SE_Count_X.value,0);}
  SetLength  (sprite_rect_arr    ,SE_Count_X.value);
    FillQWord(sprite_rect_arr [0],SE_Count_X.value,0);

  with fast_actor_set_var.d_icon,fast_image_data,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      v1:=Trunc(srf_var.tex_bmp_rct_pts[0].x)-bmp_ftimg_width >>1;
      v2:=Trunc(srf_var.tex_bmp_rct_pts[0].y)-bmp_ftimg_height>>1;
      sprite_rect_arr_ptr:=@sprite_rect_arr[0];
      for i:=0 to SE_Count_X.Value-1 do
        begin
          sprite_rect_arr_ptr^.x:=v1+Random(Trunc(srf_var.tex_bmp_rct_pts[1].x-srf_var.tex_bmp_rct_pts[0].x));
          sprite_rect_arr_ptr^.y:=v2+Random(Trunc(srf_var.tex_bmp_rct_pts[1].y-srf_var.tex_bmp_rct_pts[0].y));
          Inc(sprite_rect_arr_ptr);
        end;

      c0:=0;
      c1:=0;
      c2:=0;
      c3:=0;
      sprite_rect_arr_ptr:=@sprite_rect_arr[SE_Count_X.value-1];
      useless_arr_ptr    :=@useless_arr_   [SE_Count_X.value-1];
      for i:=SE_Count_X.Value-1 downto 0 do
        begin
          SetRctPos(sprite_rect_arr_ptr^.x,
                    sprite_rect_arr_ptr^.y);
          Dec      (sprite_rect_arr_ptr);
          SetRctDst0;
          SetRctSrc;
          NTUselessProc[nt_pix_clp_type](useless_fld_arr_,srf_var.srf_bmp.Width,i);
          PTUselessProc[pt_pix_clp_type](useless_fld_arr_,srf_var.srf_bmp.Width,i);
          useless_arr_ptr^:=Useless;
          case useless_arr_ptr^ of
            0: Inc(c0);
            1: Inc(c1);
            2: Inc(c2);
            3: Inc(c3);
          end;
          Dec(useless_arr_ptr);
        end;
    end;

  {M_Description.Lines.Text:=IntToStr({fast_actor_set_var.d_icon.img_kind}{nt_pix_cnt}c0)+'; '+
                    IntToStr({fast_actor_set_var.d_icon.img_kind}{nt_pix_cnt}c1)+'; '+
                    IntToStr({fast_actor_set_var.d_icon.img_kind}{nt_pix_cnt}c2)+'; '+
                    IntToStr({fast_actor_set_var.d_icon.img_kind}{nt_pix_cnt}c3)+'. ';}
  }
end; {$endregion}
procedure TF_MainForm.I_Frame_ListMouseEnter                    (sender:TObject); {$region -fold}
begin
  with fast_actor_set_var.d_icon,cmr_var,fast_image_proc_var do
    begin
      fast_image_data_ptr0:=@fast_image_data;
      SetBkgnd(img_lst_bmp_ptr,img_lst_bmp.width,img_lst_bmp.height,bmp_rect);
    end;
end; {$endregion}
procedure TF_MainForm.I_Frame_ListMouseDown                     (sender:TObject; button:TMouseButton; shift:TShiftState; x,y:integer); {$region -fold}
begin
  fast_actor_set_var.AddActor(x,y);
  CnvToCnv(PtBounds(0,0,img_lst_bmp.Width,img_lst_bmp.Height),
           I_Frame_List.Canvas,
           img_lst_bmp.Canvas,
           SRCCOPY);
  I_Frame_List.Invalidate;
end; {$endregion}
{$endregion}

// (Game Settings) Игровые настройки:
{UI} {$region -fold}
procedure TF_MainForm.SB_Game_SettingsClick(sender:TObject); {$region -fold}
begin
  SB_Anim_Buttons_Button_Bkgnd.Left   :=SB_Game_Settings.Left;
  SB_Anim_Buttons_Button_Bkgnd.Visible:=SB_Game_Settings.Down;
  DrawingPanelsSetVisibility1(down_game_settings_ptr,P_Anim_Buttons,P_Game_Settings,P_Anim_Custom_Panel,prev_panel_animk,curr_panel_animk);
end; {$endregion}
{$endregion}

// (Add Actor) Добавить персонажа:
{LI} {$region -fold}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_Add_ActorClick(sender:TObject); {$region -fold}
begin
  SB_Anim_Buttons_Button_Bkgnd.Left   :=SB_Add_Actor.Left;
  SB_Anim_Buttons_Button_Bkgnd.Visible:=SB_Add_Actor.Down;
  DrawingPanelsSetVisibility1(down_add_actor_ptr,P_Anim_Buttons,P_Add_Actor,P_Anim_Custom_Panel,prev_panel_animk,curr_panel_animk);
end; {$endregion}
{$endregion}

// (Sound Control) Настройки звука:
{LI} {$region -fold}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.SB_Sound_ControlClick                       (sender:TObject); {$region -fold}
begin
  SB_Anim_Buttons_Button_Bkgnd.Left   :=SB_Sound_Control.Left;
  SB_Anim_Buttons_Button_Bkgnd.Visible:=SB_Sound_Control.Down;
  DrawingPanelsSetVisibility1(down_sound_control_ptr,P_Anim_Buttons,P_Sound_Control,P_Anim_Custom_Panel,prev_panel_animk,curr_panel_animk);
end; {$endregion}
procedure TF_MainForm.CB_Sound_Control_Play_Background_SoundChange(sender:TObject); {$region -fold}
begin
  play_bkgnd_sound:=not play_bkgnd_sound;
end; {$endregion}
{$endregion}

// (F_MainForm) Основные функции формы:
{LI} {$region -fold}
procedure SpeedButtonRepaint; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {F_MainForm.TB_Camera_Speed.width:=137;
  F_MainForm.TB_Camera_Speed.width:=136;
  F_MainForm.P_Inner_Window_Buttons.Refresh;}
end; {$endregion}
procedure FormChangeSize;     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with srf_var,sel_var do
    begin
      {if down_play_anim_ptr^ then
        F_MainForm.T_Game_Loop.Enabled:=False;}
      rszd_wnd_res2:=PtPos(F_MainForm.width,F_MainForm.height);
      form_resized :=True{(rszd_wnd_res2.x<>rszd_wnd_res.x) or
                          (rszd_wnd_res2.y<>rszd_wnd_res.y)};
      if (not form_resize) then
        Exit;
      rszd_wnd_res:=PtPos(F_MainForm.width,F_MainForm.height);
      SplittersPosCalc;
      SnapGLCanvas;
      ContentLibraryImagesListRepaint;
      ObjectTagsListRepaint;
      if (not ({fix_resolution and }down_play_anim_ptr^)) then
        begin
          EventGroupsCalc(calc_arr,[0,1,2,3,4,10,17,18,30,31,32,37,41,48,52,53,55]);
         {SetLength      (useless_fld_arr_,srf_bmp.width*srf_bmp.height);
          ArrClr         (useless_fld_arr_,inn_wnd_rct,  srf_bmp.width);}
        end;
      if down_select_items_ptr^ then
        MinimizeCircleSelection;
      if (not down_play_anim_ptr^) then
        F_MainForm.KeysEnable3;
      form_resize:=False;
      {if down_play_anim_ptr^ then
        F_MainForm.T_Game_Loop.Enabled:=True;}
      if down_play_anim_ptr^ then
        F_MainForm.LockCursorToWindow;
    end;
end; {$endregion}
procedure ButtonKeyPress(sp_btn,bkgnd_btn:TSpeedButton; btn_pnl1,btn_pnl2:TScrollBox; btn_pnl3:TPanel; down_btn_ptr:PByteBool; b:byte; cur1:integer; cur2:integer=crDefault); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  F_MainForm.RM_Description.Lines.Text:='';
  if down_play_anim_ptr^ and (not sp_btn.Down) then
    Exit;
  sp_btn   .Down   :=not sp_btn.Down;
  bkgnd_btn.Left   :=    sp_btn.Left;
  bkgnd_btn.Visible:=    sp_btn.Down;
  case b of
    0:
      begin
        DrawingPanelsSetVisibility1(down_btn_ptr,btn_pnl3,btn_pnl1,btn_pnl2,prev_panel_draw,curr_panel_draw);
        DrawingPanelsSetVisibility2;
      end;
    1:
      begin
        DrawingPanelsSetVisibility1(down_btn_ptr,btn_pnl3,btn_pnl1,btn_pnl2,prev_panel_animk,curr_panel_animk);
      //DrawingPanelsSetVisibility2;
      end;
  end;
  InvalidateInnerWindow;
  if down_btn_ptr^ then
    Screen.Cursor:=cur1
  else
    Screen.Cursor:=cur2;
end; {$endregion}
{$ifdef Windows}
procedure TF_MainForm.OnExitResize(var message:TMessage); {$region -fold}
begin
  inherited;
  srf_var.form_resize:=True;
end; {$endregion}
procedure TF_MainForm.OnMove(var message:TWMMove); {$region -fold}
begin
  if move_with_child_form then
    begin
      F_Hot_Keys.Left:=F_MainForm.Left{+11}-F_Hot_Keys.Width;
      F_Hot_Keys.Top :=F_MainForm.Top {+80};
    end;
  inherited;
end; {$endregion}
{$endif}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.KeysEnableA(                                                const enabled_var:boolean); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  SE_Object_Properties_Parallax_ShiftX.Enabled:=enabled_var;
  SE_Object_Properties_Parallax_ShiftY.Enabled:=enabled_var;
  CB_Object_Properties_Show_In_Editor .Enabled:=enabled_var;
  CB_Object_Properties_Show_In_Game   .Enabled:=enabled_var;
  S_Splitter1                         .Enabled:=enabled_var;
  S_Splitter2                         .Enabled:=enabled_var;
  S_Splitter3                         .Enabled:=enabled_var;
  P_Inner_Window_Buttons              .Enabled:=enabled_var;
  I_Visibility_Panel                  .Enabled:=enabled_var;
  SB_Visibility_Show_All              .Enabled:=enabled_var;
  SB_Visibility_Background            .Enabled:=enabled_var;
  SB_Visibility_Snap_Grid             .Enabled:=enabled_var;
  SB_Visibility_Regular_Grid          .Enabled:=enabled_var;
  SB_Visibility_Spline                .Enabled:=enabled_var;
  SB_Visibility_Actor                 .Enabled:=enabled_var;
  SB_Visibility_Tile_Map              .Enabled:=enabled_var;
  F_Hot_Keys                          .Enabled:=enabled_var;
end; {$endregion}
procedure TF_MainForm.KeysEnableB(const pnl:TPanel; onclick_arr_ptr:PNotifyEvent; const enabled_var:boolean); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to pnl.ControlCount-1 do
    if       (pnl.Controls[i] is TSpeedButton) then // if (not (pnl.Controls[i] is TImage)) then
      begin
        if enabled_var then
             (pnl.Controls[i] as TSpeedButton).OnClick:=(onclick_arr_ptr+i)^
        else
             (pnl.Controls[i] as TSpeedButton).OnClick:=Nil;
             (pnl.Controls[i] as TSpeedButton).Enabled:=enabled_var;
      end;
end; {$endregion}
procedure TF_MainForm.KeysEnableC(const pnl:TPanel; onclick_arr_ptr:PNotifyEvent; const enabled_var:boolean); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  for i:=0 to pnl.ControlCount-1 do
    if       (pnl.Controls[i] is TSpeedButton) then // if (not (pnl.Controls[i] is TImage)) then
      begin
        if enabled_var then
             (pnl.Controls[i] as TSpeedButton).OnClick:=(onclick_arr_ptr+i)^
        else
             (pnl.Controls[i] as TSpeedButton).OnClick:=Nil;
      end;
end; {$endregion}
procedure TF_MainForm.KeysEnable0;                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  OnKeyPress:=@FormKeyPress;
  OnKeyDown :=@FormKeyDown;
  OnKeyUp   :=@FormKeyUp;
end; {$endregion}
procedure TF_MainForm.KeysEnable1;                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  KeysEnableA(True);
end; {$endregion}
procedure TF_MainForm.KeysEnable2;                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  KeysEnableB(P_Draw_Buttons,@P_Draw_Buttons_ClickArr[0],True);
  KeysEnableB(P_Anim_Buttons,@P_Anim_Buttons_ClickArr[0],True);
end; {$endregion}
procedure TF_MainForm.KeysEnable3;                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (sel_var.sel_pts_cnt>0) or sln_var.draw_spline or is_scene_tree_editing then
    Exit;
  KeysEnable2;
end; {$endregion}
procedure TF_MainForm.KeysEnable4;                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  KeysEnableC(P_Draw_Buttons,@P_Draw_Buttons_ClickArr[0],True);
  KeysEnableC(P_Anim_Buttons,@P_Anim_Buttons_ClickArr[0],True);
end; {$endregion}
procedure TF_MainForm.KeysDisable0;                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  OnKeyPress:=Nil;
  OnKeyDown :=Nil;
  OnKeyUp   :=Nil;
end; {$endregion}
procedure TF_MainForm.KeysDisable1;                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  KeysEnableA(False);
end; {$endregion}
procedure TF_MainForm.KeysDisable2;                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  KeysEnableB(P_Draw_Buttons,@P_Draw_Buttons_ClickArr[0],False);
  KeysEnableB(P_Anim_Buttons,@P_Anim_Buttons_ClickArr[0],False);
end; {$endregion}
procedure TF_MainForm.KeysDisable3;                                              inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  if (not ((sel_var.sel_pts_cnt>0) or sln_var.draw_spline or is_scene_tree_editing)) then
    Exit;
  KeysDisable2;
end; {$endregion}
procedure TF_MainForm.TB_Camera_SpeedChange  (sender:TObject);                                                          {$region -fold}
begin
  with cmr_var do
    begin
      spd_mul.x             :=TB_Camera_Speed.Position;
      spd_mul.y             :=TB_Camera_Speed.Position;
      FSE_Camera_Speed.Value:=TB_Camera_Speed.Position;
    end;
end; {$endregion}
procedure TF_MainForm.FSE_Camera_SpeedChange (sender:TObject);                                                          {$region -fold}
begin
  with cmr_var do
    begin
      spd_mul_prev.x:=spd_mul.x;
      spd_mul_prev.y:=spd_mul.y;
      spd_mul     .x:=FSE_Camera_Speed.Value;
      spd_mul     .y:=FSE_Camera_Speed.Value;
      if (Trunc(FSE_Camera_Speed.Value)>=10) then
        TB_Camera_Speed.Position:=10
      else
        TB_Camera_Speed.Position:=Trunc(FSE_Camera_Speed.Value);
    end;
end; {$endregion}
procedure TF_MainForm.FormResize             (sender:TObject);                                                          {$region -fold}
begin
  FormChangeSize;
end; {$endregion}
procedure TF_MainForm.FormMouseMove          (sender:TObject; shift:TShiftState; x,y:integer);                          {$region -fold}
var
  color_info: TColorInfo;
begin

  if down_play_anim_ptr^ then
    begin
      cur_pos_prev:=cur_pos_;
      LockCursorToWindow;
      Exit;
    end;
  srf_var.SetPtPosToResInnWndPos(x,y);

  {Selection} {$region -fold}
  if down_select_items_ptr^ then
    begin

      if cmr_var.is_camera_moving then
        Exit;

      {Pivot Moving---------} {$region -fold}
      with srf_var,sln_var,sel_var,pvt_var do
        if move_pvt then
          begin
            need_repaint:=True;
            LowerBmpToMainBmp;

            {Drawing of Selected Edges, Points and Objects and Pivot} {$region -fold}
            snap_mode.snap_event:=(shift=[ssAlt]);
            case pvt_mode of
              (pmPivotMove  ): {$region -fold}
                begin
                  {Align Pivot on Axis X}
                  AlignPivotOnX(x,y,shift);
                  {Align Pivot on Axis Y}
                  AlignPivotOnY(x,y,shift);
                  {Align Pivot on Points}
                  AlignPivotOnP(x,y,shift);
                end; {$endregion}
              (pmPivotScale ): {$region -fold}
                begin
                  SclSettings  (x,y);
                end; {$endregion}
              (pmPivotRotate): {$region -fold}
                begin
                end; {$endregion}
            end;
            SelPtsCalcProc   [Byte(pvt_mode)](x,y);
            WholeSubgraphProc[Byte(pvt_mode)](x,y,pvt_pos,sln_pts,srf_bmp_ptr,inn_wnd_rct,ClippedRct(inn_wnd_rct,sel_pts_rct));
            SelPtsRctCalcProc[Byte(pvt_mode)](x,y,sel_pts_rct);
            PivotDraw(Ptpos(0,0),x,y); {$endregion}

            if (not down_play_anim_ptr^) then
              ResInnWndToBmp;
            {
            {$ifdef Windows}
            Sleep(32);
            {$endif}
            }
            need_repaint:=False;
            VisibilityChange(False);
            Exit;
          end; {$endregion}

      {Circle Selection Mode} {$region -fold}
      with srf_var,sln_var,sel_var,crc_sel_var,brs_sel_var,pvt_var do
        if draw_crc_sel then
          begin
            need_repaint:=True;
            LowerBmp2ToMainBmp;
            ResizeCircleSelectionModeDraw;
            if (not only_fill) then
              begin
                AddCircleSelection;
                CrtCircleSelection;
                only_fill:=True;
              end;
            FilSelPtsObj(crc_sel_rct.left,crc_sel_rct.top); //CircleSelectionModeDraw(x,y,srf_var);
            if (sel_pts_cnt>0) then
              if (pvt_pos.x<>0) and (pvt_pos.y<>0) then
                if (sqr(pvt_pos.x-x)+
                    sqr(pvt_pos.y-y)<=crc_rad_sqr) then
                  LocalAxisHighLight(Trunc(pvt_pos.x),
                                     Trunc(pvt_pos.y));
            if sel_pts and (pvt_exists in [0,2]) then
              case CB_Select_Items_Selection_Selection_Mode.ItemIndex of
                0: CircleSelection(x,y,True);
                1:
                  begin
                    SetColorInfo    (selection_img.local_prop.eds_col,color_info);
                    CircleFloodFill0(x,y,low_bmp2_ptr,low_bmp2.width,inn_wnd_rct,color_info,crc_rad<<1,120);
                    CircleSelection (x,y,False);
                  end;
              end;
            if (not down_play_anim_ptr^) then
              ResInnWndToBmp;
            {
            {$ifdef Windows}
            Sleep(1);
            {$endif}
            }
            need_repaint:=False;
            VisibilityChange(False);
            Exit;
          end; {$endregion}

      {Pivot To Point-------} {$region -fold}
      with srf_var,sln_var,sel_var,crc_sel_var,pvt_var do
        if pvt_to_pt then
          begin
            need_repaint:=True;
            LowerBmp2ToMainBmp;
            if selection_img.local_prop.eds_show then
              begin
                SelPtsCalc(x,y,pvt_pos,sln_pts,srf_bmp_ptr,inn_wnd_rct);
                SelPtsDraw(x,y,pvt_pos,sln_pts,srf_bmp_ptr,inn_wnd_rct);
              end;
            PivotToPoint  (x,y,1);
            PivotModeDraw (srf_bmp.Canvas);
            PivotAxisDraw0(srf_bmp.Canvas,pvt_axis_rect,PtPos(0,0));
            PivotAxisDraw1(srf_bmp.Canvas,pvt_axis_rect,PtPos(0,0),Trunc(pvt_pos.x),Trunc(pvt_pos.y));
            if pvt_to_pt_draw_pt then
              PivotToPointDraw(srf_bmp.Canvas)
            else
              LocalAxisDraw(Trunc(pvt_pos.x),Trunc(pvt_pos.y));
            if (not down_play_anim_ptr^) then
              ResInnWndToBmp;
            {
            {$ifdef Windows}
            Sleep(6);
            {$endif}
            }
            need_repaint:=False;
            VisibilityChange(False);
            Exit;
          end; {$endregion}

    end; {$endregion}

  {Spline---} {$region -fold}
  with srf_var,sln_var do
    if draw_spline                   and
      ((CB_Spline_Mode.ItemIndex=0)  or
       (CB_Spline_Mode.ItemIndex=2)) then
      begin
        need_repaint:=True;
        if down_play_anim_ptr^ then
          AddPoint
          (
            x,
            y,
            srf_bmp_ptr,
            srf_bmp.width,
            color_info,
            inn_wnd_rct,
            add_spline_calc,
            True
          )
        else
          begin
            AddPoint
            (
              x,
              y,
              srf_bmp_ptr,
              srf_bmp.width,
              color_info,
              inn_wnd_rct,
              add_spline_calc,
              True
            );
            if (not down_play_anim_ptr^) then
              ResInnWndToBmp;
            {
            {$ifdef Windows}
            Sleep(1);
            {$endif}
            }
            need_repaint:=False;
          end;
      end; {$endregion}

end; {$endregion}
procedure TF_MainForm.FormMouseDown          (sender:TObject; button:TMouseButton; shift:TShiftState; x,y:integer);     {$region -fold}
var
  color_info: TColorInfo;
begin

  srf_var.SetPtPosToResInnWndPos(x,y);

  case button of

    (mbLeft):
      begin

        {Animation}
        if down_play_anim_ptr^ then
          begin

          end;

        {Add Actor}
        if down_add_actor_ptr^ then
          begin
            fast_actor_set_var.AddActor(x,y);
            if (not down_play_anim_ptr^) then
              srf_var.ResInnWndToBmp;
            Exit;
          end;

        {Brush}
        if down_brush_ptr^ then
          begin
            draw_brush:=True;
          end;

        {Spray}
        if down_spray_ptr^ then
          begin
            draw_spray:=True;
            SprayDraw(x,y,40,CD_Select_Color.Color);
          end;

        if show_spline then
          begin

            {Spline}
            with Canvas,srf_var,sln_var do
              if down_spline_ptr^ then
                if (CB_Spline_Type.ItemIndex=0) then
                  begin
                    draw_spline         :=not draw_spline;
                    sln_pts_skip_counter:=0;
                    KeysDisable3;
                    KeysDisable1;
                    VisibilityChange(False);
                    case CB_Spline_Mode.ItemIndex of
                      0,2:
                        MoveTo(x,y);
                      1:
                        begin
                          AddPoint
                          (
                            x,
                            y,
                            srf_bmp_ptr,
                            srf_bmp.width,
                            color_info,
                            inn_wnd_rct,
                            add_spline_calc
                          );
                          if (not down_play_anim_ptr^) then
                            ResInnWndToBmp;
                        end;
                    end;
                  end;

            with srf_var,sln_var,sel_var,crc_sel_var,brs_sel_var,pvt_var do
              if down_select_items_ptr^ then
                begin
                  resize_crc_sel:=False;
                  draw_brs_sel  :=False;
                  pvt_to_pt     :=False;

                  {Select Pivot}
                  if need_align_pivot_x then
                    y:=align_pivot.y;
                  if need_align_pivot_y then
                    x:=align_pivot.x;
                  if need_align_pivot_p then
                    begin
                      x:=align_pivot.x;
                      y:=align_pivot.y;
                    end;
                  if (sqr(pvt_pos.x-x)+
                      sqr(pvt_pos.y-y)<=crc_rad_sqr) then
                    begin
                      move_pvt:=(not move_pvt);
                      if show_visibility_panel then
                        VisibilityChange(not move_pvt);
                      if move_pvt then
                        begin
                          if (pvt_mode<>pmPivotMove) then
                            Screen.Cursor:=crDefault;
                          need_repaint:=True;
                          LowerBmp2ToMainBmp;
                          if (not down_play_anim_ptr^) then
                            ResInnWndToBmp;
                          need_repaint  :=False;
                          pvt_origin    :=pvt_pos;
                          pvt_to_pt     :=False;
                          draw_crc_sel  :=False;
                          resize_crc_sel:=False;
                          crc_sel_rct   :=Default(TRect);
                        end
                      else
                        begin
                          if exp0 then
                            begin
                              Screen.Cursor:=crNone;
                              need_repaint :=True;
                              MainBmpToLowerBmp2;
                              fill_bmp_only:=True;
                              FillSelBmpAndSelPtsBRectDraw;
                              fill_bmp_only:=False;
                              PivotDraw(PtPos(0,0),Trunc(pvt_pos.x),Trunc(pvt_pos.y));
                              if (not down_play_anim_ptr^) then
                                ResInnWndToBmp;
                              need_repaint :=False;
                            end;
                          ChangeSelectionMode(CB_Select_Items_Selection_Selection_Mode.ItemIndex);
                        end;
                      Exit;
                    end

                  {Unselect Pivot}
                  else
                    begin
                      Screen.Cursor:=crNone;
                      if exp0 then
                        begin
                          srf_var.EventGroupsCalc(calc_arr,[16,27,30,31,32,50,52,55]);
                          pvt_exists:=1;
                        end
                      else
                        pvt_exists  :=2;
                      sel_pts       :=True;
                      ChangeSelectionMode(CB_Select_Items_Selection_Selection_Mode.ItemIndex);
                      KeysEnable3;
                      KeysEnable1;
                      {TV_Scene_Tree.Items.ClearMultiSelection(True);
                      UnsPnlsCalc;}
                    end;

                  L_Object_Info.Visible:=(not move_pvt) and show_obj_info;

                end;

          end;

      end;

    (mbMiddle):
      begin

        {Original Scene Scale}
        with sel_var,crc_sel_var do
          if (not minimize_crc_sel) then
            if (sel_pts_cnt=0) then
              begin
                SB_Original_Scene_ScaleClick(Self);
                Exit;
              end;

        {Minimize Circle Selection}
        with srf_var,sel_var,crc_sel_var do
          if down_select_items_ptr^ then
            if minimize_crc_sel then
              begin
                LowerBmpToMainBmp;
                need_repaint:=True;
                MinimizeCircleSelection;
                if (not down_play_anim_ptr^) then
                  ResInnWndToBmp;
                need_repaint:=False;
                minimize_crc_sel:=False;
                Exit;
              end;

      end;

    (mbRight):
      begin

        if cmr_var.centrify_camera then
          begin
            SB_Centrify_PictureClick(Self);
            Exit;
          end;

        {Pivot To Point Begin}
        with srf_var,sln_var,pvt_var do
          if down_select_items_ptr^ and
             move_pvt_to_pt_button  and
             (sqr(pvt_pos.x-x)+
              sqr(pvt_pos.y-y)<=crc_sel_var.crc_rad_sqr) then
            begin
              pvt_to_pt:=not pvt_to_pt;
              case CB_Select_Items_Selection_Selection_Mode.ItemIndex of
                0,1:
                  with crc_sel_var do
                    begin
                      draw_crc_sel:=not pvt_to_pt;
                      crc_sel_rct :=Default(TRect);
                    end;
                2:rct_sel_var.rct_sel:=Default(TRect);
              end;
              ArrClr(dup_pts_arr,inn_wnd_rct,srf_bmp.width);
              AddSplineDupPtsAll(0,sln_obj_cnt-1);
              L_Object_Info.Visible:=not pvt_to_pt;
              if I_Visibility_Panel.Visible then
                 I_Visibility_Panel.Visible:=False;
            end;

      end;

  end;

end; {$endregion}
procedure TF_MainForm.FormMouseUp            (sender:TObject; button:TMouseButton; shift:TShiftState; x,y:integer);     {$region -fold}
begin

  srf_var.SetPtPosToResInnWndPos(x,y);

  {Brush------------------} {$region -fold}
  draw_brush:=False; {$endregion}

  {Spray------------------} {$region -fold}
  draw_spray:=False; {$endregion}

  {Add Spline-------------} {$region -fold}
  with obj_var,srf_var,sln_var do
    if show_spline                   and
       down_spline_ptr^              and
      ((CB_Spline_Mode.ItemIndex=0)  or
       (CB_Spline_Mode.ItemIndex=2)) and
       (CB_Spline_Type.ItemIndex=0)  and
       add_spline_calc               then
      begin
        draw_spline:=False;
        KeysEnable3;
        KeysEnable1;
        {EventGroupsCalc(calc_arr,[12,21,30,31,33,40,52,55]+[41+7*Byte(down_select_items_ptr^)]);//}EventGroupsCalc(calc_arr,[12,18,21,30,31,32,33,40,41{,52,55}]+[41+7*Byte(down_select_items_ptr^)]); //
        VisibilityChange(srf_var.inner_window_ui_visible);
        SpeedButtonRepaint;
      end; {$endregion}

  {Finish Points Selection} {$region -fold}
  with srf_var,sln_var,sel_var,crc_sel_var,pvt_var do
    if show_spline            and
       down_select_items_ptr^ and
       sel_pts                and
       (not move_pvt)         then
      begin
        EventGroupsCalc(calc_arr,[6,20,30,41,48,52,55]+[41+Byte(sel_pts_cnt>0)]);
        pvt_exists         :=0;
        sel_pts            :=False;
        need_align_pivot_p2:=True;
        SpeedButtonRepaint;
        KeysDisable3;
        if (sel_pts_cnt>0) then
          KeysDisable1;
      end; {$endregion}

end; {$endregion}
procedure TF_MainForm.FormDblClick           (sender:TObject);                                                          {$region -fold}
begin

  {Add Spline} {$region -fold}
  if show_spline and down_spline_ptr^ and
     (CB_Spline_Mode.ItemIndex=1)     and
     (CB_Spline_Type.ItemIndex=0)    then
    with srf_var,sln_var do
      begin
        Dec(sln_pts_cnt);
        Dec(sln_pts_cnt_add);
        draw_spline:=False;
        KeysEnable3;
        KeysEnable1;
        EventGroupsCalc(calc_arr,[12,21,30,31,33,40,52,53,55]);
        VisibilityChange(show_visibility_panel);
        SpeedButtonRepaint;
      end; {$endregion}

end; {$endregion}
procedure TF_MainForm.FormPaint              (sender:TObject);                                                          {$region -fold}
begin
  with srf_var do
    if (not need_repaint) then
      if (not down_play_anim_ptr^) then
        ResInnWndToBmp;
end; {$endregion}
procedure TF_MainForm.FormMouseWheelDown     (sender:TObject; shift:TShiftState; mousepos:TPoint; var handled:boolean); {$region -fold}
begin
  if drawing_area_enter_calc then
    begin

      if down_play_anim_ptr^ then
        with cmr_var do
          begin
            scene_resize_calc:=True;
            if (scl_dif<scl_min) then
              begin
                scene_resize_calc:=False;
                Exit;
              end;
            scl_dir:=sdDown;
            mov_dir:=mdNone;
          //Dec(scl_dif);
            Exit;
          end;

      {Check Exit-----} {$region -fold}
      if  cmr_var.is_camera_moving       or
          sln_var.draw_spline            or
         (srf_var.inn_wnd_rct.width <=0) or
         (srf_var.inn_wnd_rct.height<=0) or
        ((sel_var.sel_pts_cnt        >0) and
         (shift<>[ssCtrl]))              then
        Exit; {$endregion}
      if (shift<>[ssCtrl]) then
        begin
          with obj_var,cmr_var,srf_var,rgr_var,sgr_var,crc_sel_var do
            begin
              if (scl_dif<scl_min) then
                Exit;
              scl_dir:=sdDown;
              mov_dir:=mdNone;
              Dec(scl_dif);
              if down_select_items_ptr^ then
                crc_sel_rct:=Default(TRect);
              SetRctDstPtr(@inn_wnd_rct,0,obj_cnt-1);
              EventGroupsCalc(calc_arr,[18,19,29,30,32,41,52,55]+[41+7*Byte(down_select_items_ptr^)]);
            end;
        end
      else
        {Resize And Draw Circle Selection}
        if down_select_items_ptr^ then
          with sel_var,crc_sel_var,brs_sel_var do
            begin
              if (crc_rad<11) then
                Exit;
              crc_rad       -=10;
              crc_rad_sqr   :=crc_rad*crc_rad;
              resize_crc_sel:=False;
              draw_crc_sel  :=False;
              draw_brs_sel  :=False;
              case CB_Select_Items_Selection_Selection_Mode.ItemIndex of
                0,1:
                  with srf_var do
                    begin
                      need_repaint:=True;
                      LowerBmp2ToMainBmp;
                      ResizeCircleSelectionModeDraw;
                      AddCircleSelection;
                      CrtCircleSelection;
                      with crc_sel_rct do
                        FilSelPtsObj(left,top);
                      if (not down_play_anim_ptr^) then
                        ResInnWndToBmp;
                      need_repaint      :=False;
                      crc_rad_invalidate:=crc_rad;
                      draw_crc_sel      :=True;
                      resize_crc_sel    :=True;
                    end;
              end;
            end;

    end;
  SpeedButtonRepaint;
end; {$endregion}
procedure TF_MainForm.FormMouseWheelUp       (sender:TObject; shift:TShiftState; mousepos:TPoint; var handled:boolean); {$region -fold}
begin
  if drawing_area_enter_calc then
    begin

      if down_play_anim_ptr^ then
        with cmr_var do
          begin
            scene_resize_calc:=True;
            if (scl_dif>scl_max) then
              begin
                scene_resize_calc:=False;
                Exit;
              end;
            scl_dir:=sdUp;
            mov_dir:=mdNone;
          //Inc(scl_dif);
            Exit;
          end;

      {Check Exit-----} {$region -fold}
      if  cmr_var.is_camera_moving       or
          sln_var.draw_spline            or
         (srf_var.inn_wnd_rct.width <=0) or
         (srf_var.inn_wnd_rct.height<=0) or
        ((sel_var.sel_pts_cnt        >0) and
         (shift<>[ssCtrl]))              then
        Exit; {$endregion}
      if (shift<>[ssCtrl]) then
        begin
          with obj_var,cmr_var,srf_var,rgr_var,sgr_var,crc_sel_var do
            begin
              if (scl_dif>scl_max) then
                Exit;
              scl_dir:=sdUp;
              mov_dir:=mdNone;
              Inc(scl_dif);
              if down_select_items_ptr^ then
                crc_sel_rct:=Default(TRect);
              SetRctDstPtr(@inn_wnd_rct,0,obj_cnt-1);
              EventGroupsCalc(calc_arr,[18,19,29,30,32,41,52,55]+[41+7*Byte(down_select_items_ptr^)]);
            end;
        end
      else
        {Resize And Draw Circle Selection}
        if down_select_items_ptr^ then
          with sel_var,srf_var,crc_sel_var,brs_sel_var do
            begin
              if (crc_rad<<1+20>=Min(inn_wnd_rct.width,inn_wnd_rct.height)) or
                 (crc_rad<<1+20>=00000000000000000000000000000000000004096) then
                Exit;
              crc_rad       +=10;
              crc_rad_sqr   :=crc_rad*crc_rad;
              resize_crc_sel:=False;
              draw_crc_sel  :=False;
              draw_brs_sel  :=False;
              case CB_Select_Items_Selection_Selection_Mode.ItemIndex of
                0,1:
                  begin
                    need_repaint:=True;
                    LowerBmp2ToMainBmp;
                    ResizeCircleSelectionModeDraw;
                    AddCircleSelection;
                    CrtCircleSelection;
                    with crc_sel_rct do
                      FilSelPtsObj(left,top);
                    if (not down_play_anim_ptr^) then
                      ResInnWndToBmp;
                    need_repaint      :=False;
                    crc_rad_invalidate:=crc_rad;
                    draw_crc_sel      :=True;
                    resize_crc_sel    :=True;
                  end;
              end;
            end;

    end;
  SpeedButtonRepaint;
end; {$endregion}
procedure TF_MainForm.FormKeyPress           (sender:TObject; var key:char);                                            {$region -fold}
begin

  {Check Exit--------} {$region -fold}
  if (sel_var.sel_pts_cnt        >0) or
     (sln_var.draw_spline          ) or
     (is_mouse_in_scene_tree       ) or
     (is_scene_tree_editing        ) or
     (srf_var.inn_wnd_rct.width <=0) or
     (srf_var.inn_wnd_rct.height<=0) then
    Exit; {$endregion}

  {Start Game Loop---} {$region -fold}
  if (key=#32{'space'}) then
    if (PC_Scene_Editor.TabIndex=2) then
      begin
        if (down_select_items_ptr^ and (sel_var.sel_pts_cnt<>0)) or (down_spline_ptr^ and sln_var.draw_spline) then
          Exit;
        SB_Play_Anim.Down:=not SB_Play_Anim.Down;
        SB_Play_AnimClick(F_MainForm);
        Exit;
      end; {$endregion}

  {Change Pivot Mode-} {$region -fold}
  if (key=#32{'space'}) then
    if down_select_items_ptr^ then
      with srf_var,sel_var do
        begin
          need_repaint:=True;
          if (sel_pts_cnt>0) then
            with pvt_var do
              begin
                LowerBmpToMainBmp;
                case pvt_mode of
                  (pmPivotMove  ): pvt_mode:=(pmPivotScale );
                  (pmPivotScale ): pvt_mode:=(pmPivotRotate);
                  (pmPivotRotate): pvt_mode:=(pmPivotMove  );
                end;
                Screen.Cursor:=crNone;
                fill_bmp_only:=True;
                FillSelBmpAndSelPtsBRectDraw;
                fill_bmp_only:=False;
                PivotDraw(Ptpos(0,0),Trunc(pvt_pos.x),Trunc(pvt_pos.y));
              end
          else
            begin
              LowerBmp2ToMainBmp;
              if (CB_Select_Items_Selection_Selection_Mode.ItemIndex=CB_Select_Items_Selection_Selection_Mode.Items.Count-1) then
                CB_Select_Items_Selection_Selection_Mode.ItemIndex:=0
              else
                CB_Select_Items_Selection_Selection_Mode.ItemIndex:=CB_Select_Items_Selection_Selection_Mode.ItemIndex+1;
              ChangeSelectionMode(CB_Select_Items_Selection_Selection_Mode.ItemIndex);
            end;
          if (not down_play_anim_ptr^) then
            ResInnWndToBmp;
          need_repaint:=False;
        end; {$endregion}

  {Change Spline Mode} {$region -fold}
  if (key=#32{'space'}) then
    if down_spline_ptr^ then
      with sln_var do
        if (global_prop.sln_type=stFreeHand) then
          begin
            if (CB_Spline_Mode.ItemIndex=CB_Spline_Mode.Items.Count-1) then
              CB_Spline_Mode.ItemIndex:=0
            else
              CB_Spline_Mode.ItemIndex:=CB_Spline_Mode.ItemIndex+1;
            SplineModeSelect;
          end; {$endregion}

  {Switch Buttons----} {$region -fold}
  //RM_Description.Lines.Text:='';
  if (key=Char(key_arr[04])) or (key=Char(key_alt_arr[04]{' '})) then
    begin
      ButtonKeyPress(SB_Text,SB_Draw_Buttons_Button_Bkgnd,P_Text,P_Draw_Custom_Panel,P_Draw_Buttons,down_text_ptr,0,000001);
      if (not down_text_ptr^) then
        Exit;
    end;
  // button 'Brush':
  if (key=Char(key_arr[05])) or (key=Char(key_alt_arr[05]{' '})) then
    begin
      ButtonKeyPress(SB_Brush,SB_Draw_Buttons_Button_Bkgnd,P_Brush,P_Draw_Custom_Panel,P_Draw_Buttons,down_brush_ptr,0,000002);
      if (not down_brush_ptr^) then
        Exit;
    end;
  // button 'Spray':
  if (key=Char(key_arr[06])) or (key=Char(key_alt_arr[06]{' '})) then
    begin
      ButtonKeyPress(SB_Spray,SB_Draw_Buttons_Button_Bkgnd,P_Spray,P_Draw_Custom_Panel,P_Draw_Buttons,down_spray_ptr,0,000003);
      if (not down_spray_ptr^) then
        Exit;
    end;
  // button 'Spline':
  if (key=Char(key_arr[07])) or (key=Char(key_alt_arr[07]{'q'})) then
    begin
      ButtonKeyPress(SB_Spline,SB_Draw_Buttons_Button_Bkgnd,P_Spline,P_Draw_Custom_Panel,P_Draw_Buttons,down_spline_ptr,0,000004);
      if (not down_spline_ptr^) then
        Exit;
      AddDocContent(RM_Description,curve_doc_str_arr,curve_doc_font_arr,0);
    end;
  // button 'Select Items/Points':
  if (key=Char(key_arr[08])) or (key=Char(key_alt_arr[08]{'e'})) then
    begin
      ButtonKeyPress(SB_Select_Items,SB_Draw_Buttons_Button_Bkgnd,P_Select_Items,P_Draw_Custom_Panel,P_Draw_Buttons,down_select_items_ptr,0,crNone);
      if (not down_select_items_ptr^) then
        Exit;
    end;
  // button 'Select Texture Region':
  if (key=Char(key_arr[09])) or (key=Char(key_alt_arr[09]{' '})) then
    begin
      ButtonKeyPress(SB_Select_Background_Region,SB_Draw_Buttons_Button_Bkgnd,P_Select_Texture_Region,P_Draw_Custom_Panel,P_Draw_Buttons,down_select_texture_region_ptr,0,000006);
      if (not down_select_texture_region_ptr^) then
        Exit;
    end;
  // button 'Background':
  if (key=Char(key_arr[10])) or (key=Char(key_alt_arr[10]{' '})) then
    begin
      ButtonKeyPress(SB_Background,SB_Draw_Buttons_Button_Bkgnd,P_Background,P_Draw_Custom_Panel,P_Draw_Buttons,down_bkgnd_ptr,0,000007);
      if (not down_bkgnd_ptr^) then
        Exit;
    end;
  // button 'Post-Process':
  if (key=Char(key_arr[11])) or (key=Char(key_alt_arr[11]{' '})) then
    begin
      ButtonKeyPress(SB_Post_Processing,SB_Draw_Buttons_Button_Bkgnd,P_Post_Processing,P_Draw_Custom_Panel,P_Draw_Buttons,down_pproc_ptr,0,000008);
      if (not down_pproc_ptr^) then
        Exit;
    end;
  // button 'Add Tilemap':
  if (key=Char(key_arr[12])) or (key=Char(key_alt_arr[12]{' '})) then
    begin
      ButtonKeyPress(SB_Add_Tilemap,SB_Draw_Buttons_Button_Bkgnd,P_Add_Tilemap,P_Draw_Custom_Panel,P_Draw_Buttons,down_tlmap_ptr,0,000009);
      if (not down_tlmap_ptr^) then
        Exit;
    end;
  // button 'Snap Grid':
  if (key=Char(key_arr[13])) or (key=Char(key_alt_arr[13]{' '})) then
    begin
      ButtonKeyPress(SB_SGrid,SB_Draw_Buttons_Button_Bkgnd,P_SGrid,P_Draw_Custom_Panel,P_Draw_Buttons,down_sgrid_ptr,0,000010);
      if (not down_sgrid_ptr^) then
        Exit;
    end;
  // button 'Regular Grid':
  if (key=Char(key_arr[14])) or (key=Char(key_alt_arr[14]{' '})) then
    begin
      ButtonKeyPress(SB_RGrid,SB_Draw_Buttons_Button_Bkgnd,P_RGrid,P_Draw_Custom_Panel,P_Draw_Buttons,down_rgrid_ptr,0,000011);
      if (not down_rgrid_ptr^) then
        Exit;
    end;
  // switch 'ToolsPage':
  if (key=Char(key_arr[15])) or (key=Char(key_alt_arr[15]{' '})) then
   begin
     F_MainForm.RM_Description.Lines.Text:='';
     if PC_Scene_Editor.TabIndex=2 then
       PC_Scene_Editor.TabIndex:=0
     else
       PC_Scene_Editor.TabIndex:=PC_Scene_Editor.TabIndex+1;
   end; {$endregion}

end; {$endregion}
procedure TF_MainForm.FormKeyDown            (sender:TObject; var key:word; shift:TShiftState);                         {$region -fold}
begin

  is_active:=True;

  with obj_var,cmr_var,srf_var,sln_var,sel_var,crc_sel_var do
    begin

      if is_mouse_in_scene_tree then
        Exit;

      if (shift=[ssCtrl]) then
        begin
          centrify_camera:=True;
          if down_select_items_ptr^ then
            minimize_crc_sel:=True;
        end;

      case Key of
        {VK_LEFT,VK_RIGHT,VK_UP,VK_DOWN: Key:=0;}
        {#9} VK_TAB:    {$region -fold}
          //if (not down_play_anim_ptr^) then
            begin
              VisibilityChange(True);
            //F_Hot_Keys.Visible             :=True;
              srf_var.inner_window_ui_visible:=True;
              show_visibility_panel          :=True;
            end; {$endregion}
      end;

      {Check Exit-----} {$region -fold}
      if (sel_pts_cnt        >0) or
         (draw_spline          ) or
         (is_scene_tree_editing) or
         (inn_wnd_rct.width <=0) or
         (inn_wnd_rct.height<=0) then
        Exit; {$endregion}

      case Key of
        {#097}{'a'} 65: {$region -fold}
          begin
            is_camera_moving:=True;
            if down_play_anim_ptr^ then
              begin
                dir_a:=True;
                Exit;
              end;
            MovLeft;
            if (spd_mul.x*obj_arr[0].parallax_shift.x<>0) then
              begin
                FilLeft;
                MovScene(0,low_lr_obj_cnt-1);
              end;
          end; {$endregion}
        {#100}{'d'} 68: {$region -fold}
          begin
            is_camera_moving:=True;
            if down_play_anim_ptr^ then
              begin
                dir_d:=True;
                Exit;
              end;
            MovRight;
            if (spd_mul.x*obj_arr[0].parallax_shift.x<>0) then
              begin
                FilRight;
                MovScene(0,low_lr_obj_cnt-1);
              end;
          end; {$endregion}
        {#119}{'w'} 87: {$region -fold}
          begin
            is_camera_moving:=True;
            if down_play_anim_ptr^ then
              begin
                dir_w:=True;
                Exit;
              end;
            MovUp;
            if (spd_mul.y*obj_arr[0].parallax_shift.y<>0) then
              begin
                FilUp;
                MovScene(0,low_lr_obj_cnt-1);
              end;
          end; {$endregion}
        {#115}{'s'} 83: {$region -fold}
          begin
            is_camera_moving:=True;
            if down_play_anim_ptr^ then
              begin
                dir_s:=True;
                Exit;
              end;
            MovDown;
            if (spd_mul.y*obj_arr[0].parallax_shift.y<>0) then
              begin
                FilDown;
                MovScene(0,low_lr_obj_cnt-1);
              end;
          end; {$endregion}
      end;

      case Key of
        65,68,87,83:    {$region -fold}
          with obj_var,srf_var,sgr_var,sel_var,pvt_var do
            begin
              {Spline---------------------} {$region -fold}
              draw_spline:=False;
              sel_pts    :=False; {$endregion}
              {Background Drawing1--------} {$region -fold}
              LowerBmpToMainBmp; {$endregion}
              {Draw Objects of Upper Layer} {$region -fold}
              if (upp_lr_obj_cnt>0) then
                begin
                  SetRctDstPtr(@inn_wnd_rct,low_lr_obj_cnt,obj_cnt-1);
                  MovScene    (             low_lr_obj_cnt,obj_cnt-1);
                end; {$endregion}
              {Hide Panels----------------} {$region -fold}
              VisibilityChange(False);
              {$endregion}
              {Pivot Drawing--------------} {$region -fold}
              if (sel_pts_cnt>0) then
                begin
                  PivotDraw(PtPos(srf_var.world_axis_shift),Trunc(pvt_pos.x),Trunc(pvt_pos.y));
                  IsPivotOutOfInnerWindow(pvt_axis_rect,pvt_pos);
                end; {$endregion}
              {World Axis Drawing---------} {$region -fold}
              if show_world_axis then
                WorldAxisDraw; {$endregion}
              {Inner Window Rectangle-----} {$region -fold}
              if (inn_wnd_mrg>0) then
                InnerWindowDraw($00FF9F66); {$endregion}
              {Reset Some Var.------------} {$region -fold}
              srf_bmp.Canvas.CopyMode:=cmSrcCopy;
              crc_sel_var.crc_sel_rct:=Default(TRect); {$endregion}
              {Background Drawing2--------} {$region -fold}
              if (not down_play_anim_ptr^) then
                ResInnWndToBmp; {$endregion}
            end; {$endregion}
      end;

    end;

end; {$endregion}
procedure TF_MainForm.FormKeyUp              (sender:TObject; var key:word; shift:TShiftState);                         {$region -fold}
begin

  with obj_var,cmr_var,srf_var,sln_var,sel_var,crc_sel_var do
    begin

      if is_mouse_in_scene_tree then
        Exit;

      if centrify_camera then
         centrify_camera:=False;

      if down_select_items_ptr^ then
        begin
          if minimize_crc_sel then
             minimize_crc_sel:=False;
        end;

      case Key of
        {VK_LEFT,VK_RIGHT,VK_UP,VK_DOWN: Key:=0;}
        {#9} VK_TAB: {$region -fold}
          begin
            VisibilityChange(False);
            srf_var.inner_window_ui_visible:=False;
            show_visibility_panel          :=False;
            F_Hot_Keys.Visible             :=False;
            InvalidateInnerWindow;
            crc_sel_var.crc_sel_rct:=Default(TRect);
          end; {$endregion}
      end;

      {Check Exit-----} {$region -fold}
      if (sel_pts_cnt        >0) or
         (draw_spline          ) or
         (is_scene_tree_editing) or
         (inn_wnd_rct.width <=0) or
         (inn_wnd_rct.height<=0) then
        Exit; {$endregion}

      is_active       :=False;
      downtime_counter:=0;

      if down_play_anim_ptr^ then
        begin
          case Key of
            {'a'}65:
              begin
                dir_a  :=False;
                mov_dir:=mdNone;
              end;
            {'d'}68:
              begin
                dir_d  :=False;
                mov_dir:=mdNone;
              end;
            {'w'}87:
              begin
                dir_w  :=False;
                mov_dir:=mdNone;
              end;
            {'s'}83:
              begin
                dir_s  :=False;
                mov_dir:=mdNone;
              end;
          end;
        end;

      case Key of

        65,68,87,83:
          begin
            if (not dir_a) and (not dir_d) and (not dir_w) and (not dir_s) then
              is_camera_moving:=False;
            if (not down_play_anim_ptr^) then
              VisibilityChange(srf_var.inner_window_ui_visible);
            if down_select_items_ptr^ {and (sln_pts_cnt>0)} then
              EventGroupsCalc(calc_arr,[18,30,32,41,52,55]+[41+7*Byte(down_select_items_ptr^)]);
          end;

      end;

      SpeedButtonRepaint;

  end;

end; {$endregion}
procedure TF_MainForm.FormMouseEnter         (sender:TObject);                                                          {$region -fold}
begin
  {Add Actor} {$region -fold}
  //if down_add_actor_ptr^ then
    with srf_var,fast_actor_set_var.d_icon,fast_image_proc_var do
      begin
        fast_image_data_ptr0:=@fast_image_data;
        SetBkgnd (srf_bmp_ptr,
                  srf_bmp.width,
                  srf_bmp.height,
                  inn_wnd_rct);
      end; {$endregion}
  drawing_area_enter_calc:=True;
  DefocusControl(ActiveControl,True);
  {Play Anim} {$region -fold}
  if down_play_anim_ptr^ then
    begin
      Screen.Cursor:=crNone;
      Exit;
    end
  else
    Screen.Cursor:=crDefault; {$endregion}
  KeysEnable3;
  if down_text_ptr^ then
    Screen.Cursor:=1;
  if down_brush_ptr^ then
    Screen.Cursor:=2;
  if down_spray_ptr^ then
    Screen.Cursor:=3;
  if down_spline_ptr^ then
    Screen.Cursor:=4;
  if down_select_items_ptr^ then
    begin
      Screen.Cursor:=crNone;
      if (CB_Select_Items_Selection_Selection_Mode.ItemIndex=1) then
        brs_sel_var.draw_brs_sel:=True;
      crc_sel_var.crc_sel_rct   :=Default(TRect);
      rct_sel_var.rct_sel       :=Default(TRect);
    end;
  if down_select_texture_region_ptr^ then
    Screen.Cursor:=6;
  if down_bkgnd_ptr^ then
    Screen.Cursor:=7;
  if down_pproc_ptr^ then
    Screen.Cursor:=8;
  if down_tlmap_ptr^ then
    Screen.Cursor:=9;
  if down_sgrid_ptr^ then
    Screen.Cursor:=10;
  if down_rgrid_ptr^ then
    Screen.Cursor:=11;
end; {$endregion}
procedure TF_MainForm.FormMouseLeave         (sender:TObject);                                                          {$region -fold}
begin
  drawing_area_enter_calc:=False;
  if down_select_items_ptr^ then
    case CB_Select_Items_Selection_Selection_Mode.ItemIndex of
      0,1:
        with crc_sel_var,brs_sel_var do
          begin
            resize_crc_sel:=False;
            draw_brs_sel  :=False;
            crc_sel_rct   :=Default(TRect);
            InvalidateInnerWindow;
          end;
    end;
  Screen.Cursor:=crDefault;
end; {$endregion}
procedure TF_MainForm.FormCreate             (sender:TObject);                                                          {$region -fold}
var
  app_img         : TImage;
  color_info      : TColorInfo;
  world_axis_shift: TPtPosF;
  i               : integer;
begin

  exec_timer:=TPerformanceTime.Create;

  {SetLength(test_arr,test_arr_width*test_arr_height);
  test_arr_ptr:=@test_arr[0];}

  {Using Shaders---------------} {$region -fold}
  shader_var:=TShaderObject.Create(OGLC_GPU_Canvas); {$endregion}

  {Threads Init.---------------} {$region -fold}
  max_physical_threads_cnt:=CPUCount;
  usable_threads_cnt      :=Min(max_virtual_threads_cnt,usable_threads_cnt);
  ThreadObjArrInit             (max_virtual_threads_cnt); {$endregion}

  {Precalculated Tables Init.--} {$region -fold}
  SqrtArr0Init(width,height);
  SqrtArr1Init;
  RandArrInit;
  PowArrInit; {$endregion}

  {Post-Process  Tables Init.--} {$region -fold}
  PPBlurProcInit;
  PPDec0ProcInit;
  ArrFilProcInit; {$endregion}

  {Default Game Build Icon-----} {$region -fold}
  if fileExists(Application.Location+'GameAppIcon.png') then
    begin
      app_img        :=TImage.Create(Self);
      app_img.Picture:=TPicture.Create;
      app_img.Picture.LoadFromFile(Application.Location+'GameAppIcon.png');
      Application.Icon.Assign(app_img.Picture.Graphic);
      TrayIcon1  .Icon.Assign(app_img.Picture.Graphic);
                  Icon.Assign(app_img.Picture.Graphic);
    end; {$endregion}

  {Documentation---------------} {$region -fold}
  RM_Description.Transparent:=False{True};
  HintsFontArrInit; {$endregion}

  {Fast Image Proc. Var Init.--} {$region -fold}
  fast_image_proc_var:=TFastImageProc.Create; {$endregion}

  {Scene Tree------------------} {$region -fold}
  obj_var:=TSceneTree.Create;
  if (srf_var<>Nil) then
    world_axis_shift:=srf_var.world_axis_shift
  else
    world_axis_shift:=Default(TPtPosF);
  down_play_anim_ptr :=Unaligned(@SB_Play_Anim.Down);
  obj_var.res_var_ptr:=down_play_anim_ptr;
  obj_var.VisObjArrCrt2;
  scene_tree_font_size_counter:=TV_Scene_Tree.Font.Size;
  tree___active:=HighLightLimit(tree_inactive,16); {$endregion}

  {Object Tags-----------------} {$region -fold}
  object_tags_bmp:=CrtTBmpInst(2048{F_MainForm.width },1024{F_MainForm.height},object_tags_bmp_ptr);
  with I_Object_Tags_List do
    begin
      picture.bitmap.width :=object_tags_bmp.width ;
      picture.bitmap.height:=object_tags_bmp.height;
    end; {$endregion}

  {General---------------------} {$region -fold}

    {Window Splitters} {$region -fold}
  //S_Splitter1     .left  :=0;
    S_Splitter1     .width :=splitter_thickness;
    S_Splitter2     .height:=splitter_thickness;
  //S_Splitter3     .left  :=F_MainForm.width;
    S_Splitter3     .width :=splitter_thickness;
    S_Splitter4     .height:=splitter_thickness;
    S_Splitter5     .width :=splitter_thickness;
    S_Splitter6     .height:=splitter_thickness;
  //S_Splitter7     .top   :=(F_MainForm.height+S_Splitter6.top)>>1-18;
    S_Splitter7     .height:=splitter_thickness;
    S_Splitter8     .left  :=460;
    S_Splitter8     .width :=splitter_thickness;
    splitters_arr[1]       :=Unaligned(@S_Splitter1.left);
    splitters_arr[2]       :=Unaligned(@S_Splitter2.top );
    splitters_arr[3]       :=Unaligned(@S_Splitter3.left);
    splitters_arr[4]       :=Unaligned(@S_Splitter4.top );
    splitters_arr[5]       :=Unaligned(@S_Splitter5.left);
    splitters_arr[6]       :=Unaligned(@S_Splitter6.top );
    splitters_arr[7]       :=Unaligned(@S_Splitter7.top );
    splitters_arr[8]       :=Unaligned(@S_Splitter8.left);
    treeview_splitter_shift:=S_Splitter5.Left-S_Splitter3.left; {$endregion}

    {Misc. Settings--} {$region -fold}
    Panel1.ControlStyle:=Panel1.ControlStyle-[csOpaque]+[csParentBackground];
    LE_Content_Library_Images_Find_Image.EditLabel.Caption:='';
    LE_Content_Library_Sounds_Find_Sound.EditLabel.Caption:='';
    //P_Inner_Window_Buttons.ControlStyle:=P_Inner_Window_Buttons.ControlStyle-[csOpaque]+[csParentBackground];
    MaxSpriteWHRctInit(max_sprite_w_h_rct);
    AutoScale;
    bkg_pp_calc              :=False;
    Application.HintPause    :=250;
    Application.HintHidePause:=3000;
    for i:=0 to ComponentCount-1 do
      if (Components[i] is TWinControl) then
         (Components[i] as TWinControl).TabStop:=False;
    F_MainForm.Menu:=Nil;
    //F_MainForm.Menu:=MainMenu1;
    MouseMoveProcInit(P_Draw_Buttons,@P_Draw_ButtonsMouseMove);
    MouseMoveProcInit(P_Anim_Buttons,@P_Anim_ButtonsMouseMove);
    ini_var:=TIniFile.Create(ExtractFilePath(ParamStr(0))+'settings.ini');
    TrayIcon1.Show; {$endregion}

    {Buttons:File----} {$region -fold}
    for i:=0 to SB_Image_List.ControlCount-1 do
      SB_Image_List.Controls[i].Anchors:=[akLeft,akTop,akRight,akBottom]; {$endregion}

    {Buttons:Draw----} {$region -fold}
    SetLength  (P_Draw_Buttons_ClickArr,
                P_Draw_Buttons.ControlCount);
    for i:=0 to P_Draw_Buttons.ControlCount-1 do
      if       (P_Draw_Buttons.Controls[i] is TSpeedButton) then // if (not (P_Draw_Buttons.Controls[i] is TImage)) then
                P_Draw_Buttons_ClickArr[i]:=
               (P_Draw_Buttons.Controls[i] as TSpeedButton).OnClick;
    for i:=0 to TS_Draw.ControlCount-1 do
                TS_Draw.Controls[i].Anchors:=[akLeft,akTop,akRight,akBottom];
    P_Draw_Buttons                 .Anchors:=[akLeft,akTop,akRight];
    P_Draw_Custom_Panel            .Visible:=False;
    prev_panel_draw                        :=P_Draw_Custom_Panel;
    curr_panel_draw                        :=P_Spline; {$endregion}

    {Buttons:Anim----} {$region -fold}
    SetLength  (P_Anim_Buttons_ClickArr,
                P_Anim_Buttons.ControlCount);
    for i:=0 to P_Anim_Buttons.ControlCount-1 do
      if       (P_Anim_Buttons.Controls[i] is TSpeedButton) then // if (not (P_Anim_Buttons.Controls[i] is TImage)) then
                P_Anim_Buttons_ClickArr[i]:=
               (P_Anim_Buttons.Controls[i] as TSpeedButton).OnClick;
    for i:=0 to TS_Anim.ControlCount-1 do
                TS_Anim.Controls[i].Anchors:=[akLeft,akTop,akRight,akBottom];
    P_Anim_Buttons                 .Anchors:=[akLeft,akTop,akRight];
    P_Anim_Custom_Panel            .Visible:=True;
    prev_panel_animk                       :=P_Anim_Custom_Panel;
    curr_panel_animk                       :=P_Game_Settings; {$endregion}

  {$endregion}

  {Visibility Panel------------} {$region -fold}
  visibility_panel_picture                          :=Graphics.TBitmap.Create;
  visibility_panel_picture         .width           :=I_Visibility_Panel.width;
  visibility_panel_picture         .height          :=I_Visibility_Panel.height;
  I_Visibility_Panel.Picture.Bitmap.width           :=I_Visibility_Panel.width;
  I_Visibility_Panel.Picture.Bitmap.height          :=I_Visibility_Panel.height;
  I_Visibility_Panel.Picture.Bitmap.TransparentColor:=clBlack;
  SelectionBoundsRepaint; {$endregion}

  {Buttons Icons---------------} {$region -fold}
  SB_Visibility_Show_All.Glyph:=SB_Spline_Points_Show .Glyph; {$endregion}

  {Camera----------------------} {$region -fold}
  cmr_var:=TCamera.Create(width,height); {$endregion}

  {Main Layer------------------} {$region -fold}
  srf_var                             :=TSurface.Create(width,height);
  SB_Background_Color           .Color:=SetColorInv(srf_var.bg_col);
  down_bkgnd_ptr                      :=Unaligned(@SB_Background.Down);
  L_Object_Info   .Font         .Color:=Integer(Abs($FFFFFFFF-srf_var.bg_col)>>1);
  L_Exec_Time_Info.Font         .Color:=L_Object_Info.Font.Color;
  L_Camera_Speed  .Font         .Color:=L_Object_Info.Font.Color;
  ST_Sprite_Scale .Font         .Color:=L_Object_Info.Font.Color;
  SE_Game_Settings_Canvas_Width .Value:=srf_var.canvas_rct_width;
  SE_Game_Settings_Canvas_Height.Value:=srf_var.canvas_rct_height; {$endregion}

  {Content Library - Images----} {$region -fold}
  library_images_bmp:=CrtTBmpInst(2048{F_MainForm.width },1024{F_MainForm.height},library_images_bmp_ptr);
  with I_Content_Library_Images_List do
    begin
      picture.bitmap.width :=library_images_bmp.width ;
      picture.bitmap.height:=library_images_bmp.height;
    end; {$endregion}

  {Content Library - Sounds----} {$region -fold}
  {$endregion}

  {Snap Grid-------------------} {$region -fold}
  sgr_var             :=TSGrid.Create(width,height);
  SB_SGrid_Color.Color:=SetColorInv(sgr_var.sgrid_col);
  down_sgrid_ptr      :=Unaligned(@SB_SGrid.Down); {$endregion}

  {Grid------------------------} {$region -fold}
  rgr_var             :=TRGrid.Create(width,height);
  SB_RGrid_Color.Color:=SetColorInv(rgr_var.rgrid_col);
  down_rgrid_ptr      :=Unaligned(@SB_RGrid.Down); {$endregion}

  {Text------------------------} {$region -fold}
  txt_var      :=TFText.Create(width,height);
  down_text_ptr:=Unaligned(@SB_Text.Down); {$endregion}

  {Brush-----------------------} {$region -fold}
  CB_Brush_Mode.ItemIndex:=00;
  SE_Brush_Radius.Value  :=10;
  SE_Brush_Hardness.Value:=10;
  down_brush_ptr         :=Unaligned(@SB_Brush.Down); {$endregion}

  {Spray-----------------------} {$region -fold}
  down_spray_ptr:=Unaligned(@SB_Spray.Down); {$endregion}

  {Spline----------------------} {$region -fold}
  CB_Spline_Mode.ItemIndex                         :=0;
  down_spline_ptr                                  :=Unaligned(@SB_Spline.Down);
  sln_var                                          :=TCurve.Create(width,height);
  SplinesTemplatesNamesInit(sln_var);
  SetLength(sln_eds_fx_arr ,1);
  SetLength(sln_eds_fx_pnls,1);
  sln_eds_fx_pnls[0]                               :=@CB_Spline_Edges_Post_Processing_Style;
  CB_Spline_Edges_Post_Processing_Style.OnClick    :=@SplineEdsFXComboBoxClick;
  CB_Spline_Edges_Post_Processing_Style_Add_Effect :=CB_Spline_Edges_Post_Processing_Style;
  SetLength(sln_pts_fx_arr ,1);
  SetLength(sln_pts_fx_pnls,1);
  sln_pts_fx_pnls[0]                               :=@CB_Spline_Points_Post_Processing_Style;
  CB_Spline_Points_Post_Processing_Style.OnClick   :=@SplinePtsFXComboBoxClick;
  CB_Spline_Points_Post_Processing_Style_Add_Effect:=CB_Spline_Points_Post_Processing_Style;
  SB_Spline_Edges_Post_Processing_Color .Color     :=sln_var.global_prop.eds_col;
  SB_Spline_Points_Post_Processing_Color.Color     :=sln_var.global_prop.pts_col; {$endregion}

  {Colliders-------------------} {$region -fold}
  show_collider:=True; {$endregion}

  {Select Items----------------} {$region -fold}
  sel_var:=TSelIts.Create(width,height);
  down_select_items_ptr:=Unaligned(@SB_Select_Items.Down); {$endregion}

  {Select Texture Region-------} {$region -fold}
  down_select_texture_region_ptr:=Unaligned(@SB_Select_Background_Region.Down); {$endregion}

  {Pivot-----------------------} {$region -fold}
  pvt_var:=TPivot.Create(25,25); {$endregion}

  {Circle Selection------------} {$region -fold}
  crc_sel_var:=TCrcSel.Create; {$endregion}

  {Brush Selection-------------} {$region -fold}
  brs_sel_var:=TBrsSel.Create; {$endregion}

  {Rectangle Selection---------} {$region -fold}
  rct_sel_var:=TRctSel.Create; {$endregion}

  {Tile Map -------------------} {$region -fold}
  tlm_var       :=TTlMap.Create;
  down_tlmap_ptr:=Unaligned(@SB_Add_Tilemap.Down); {$endregion}

  {Post-processing-------------} {$region -fold}
  ppr_var       :=TPProc.Create;
  down_pproc_ptr:=Unaligned(@SB_Post_Processing.Down); {$endregion}

  {Game Settings --------------} {$region -fold}
  down_game_settings_ptr:=Unaligned(@SB_Game_Settings.Down); {$endregion}

  {Add Actor-------------------} {$region -fold}
  with srf_var do
    fast_actor_set_var:=TFastActorSet.Create
    (
      srf_bmp_ptr,
      srf_bmp.width,
      srf_bmp.height,
      inn_wnd_rct,
      max_sprite_w_h_rct,
      Application.Location+DEFAULT_ACTOR_ICON,
      @IL_Add_Actor_Default_Icon.GetBitmap
    );
  img_lst_bmp:=CrtTBmpInst(I_Frame_List.width,I_Frame_List.height,img_lst_bmp_ptr);
  SetColorInfo($00957787,color_info);
  PPFloodFill(img_lst_bmp_ptr,img_lst_bmp.width,PtBounds(0,0,img_lst_bmp.Width,img_lst_bmp.height),color_info.pix_col);
  with img_lst_bmp do
    begin
      SetTextInfo   (Canvas);
      Canvas.TextOut(width>>1-80,height>>1-16,'Frame List is Empty');
    end;
  with img_lst_bmp.Canvas do
    begin
      Brush.Style:=bsClear;
      Pen.Mode   :=pmCopy;
      Pen.Color  :=clBlue;
    end;
  img_lst_bmp.Canvas.Rectangle(0,0,img_lst_bmp.width,img_lst_bmp.height);
  CnvToCnv(PtBounds(0,0,img_lst_bmp.width,img_lst_bmp.height),I_Frame_List.Canvas,img_lst_bmp.Canvas,SRCCOPY);
  down_add_actor_ptr:=@SB_Add_Actor.Down;
  show_actor        :=True; {$endregion}

  {Sound Control---------------} {$region -fold}
  down_sound_control_ptr:=Unaligned(@SB_Sound_Control.Down); {$endregion}

  {TimeLine--------------------} {$region -fold}
  TimeLineButtonsCreate; {$endregion}

  {Cursors---------------------} {$region -fold}
  CursorsCreate;
  // 'Text' button cursor init.:
  CursorInit(01,00,Application.Location+TEXT_BUTTON_ICON                 ,@IL_Draw.GetBitmap);
  // 'Brush' button cursor init.:
  CursorInit(02,01,Application.Location+BRUSH_CURSOR_ICON                ,@IL_Draw.GetBitmap);
  // 'Spray' button cursor init.:
  CursorInit(03,02,Application.Location+SPRAY_BUTTON_ICON                ,@IL_Draw.GetBitmap);
  // 'Spline' button cursor init.:
  CursorInit(04,03,Application.Location+SPLINE_BUTTON_ICON               ,@IL_Draw.GetBitmap);
  // 'Select Points' button cursor init.:
  CursorInit(05,04,Application.Location+SELECT_POINTS_BUTTON_ICON        ,@IL_Draw.GetBitmap);
  // 'Select Texture Region' button cursor init.:
  CursorInit(06,05,Application.Location+SELECT_TEXTURE_REGION_BUTTON_ICON,@IL_Draw.GetBitmap);
  // 'Background' button cursor init.:
  CursorInit(07,06,Application.Location+BACKGROUND_BUTTON_ICON           ,@IL_Draw.GetBitmap);
  // 'Post-Process' button cursor init.:
  CursorInit(08,07,Application.Location+POST_PROCESS_BUTTON_ICON         ,@IL_Draw.GetBitmap);
  // 'TileMap' button cursor init.:
  CursorInit(09,08,Application.Location+TILE_MAP_BUTTON_ICON             ,@IL_Draw.GetBitmap);
  // 'Snap Grid' button cursor init.:
  CursorInit(10,09,Application.Location+SNAP_GRID_BUTTON_ICON            ,@IL_Draw.GetBitmap);
  // 'Regular Grid' button cursor init.:
  CursorInit(11,10,Application.Location+REGULAR_GRID_BUTTON_ICON         ,@IL_Draw.GetBitmap);
  {$endregion}

  {Physics---------------------} {$region -fold}
  fast_physics_var:=TCollider.Create(width,height);
  fast_fluid_var  :=TFluid   .Create(0,0); {$endregion}

  {Align Canvas----------------} {$region -fold}
  scale_scene_calc  :=True;
  main_bmp_arrs_calc:=True;
  SB_Change_LayoutClick(F_MainForm);
  scale_scene_calc  :=False;
  main_bmp_arrs_calc:=False; {$endregion}

  {Misc.-----------------------} {$region -fold}

  {with srf_var do
    begin
      SetLength(useless_fld_arr_,srf_bmp.width*srf_bmp.height);
      ArrClr   (useless_fld_arr_,inn_wnd_rct,  srf_bmp.width );
    end;
  SetLength(useless_arr_,1);
  useless_arr_[0]:=1;} {$endregion}

  {Type Info Helpers Init.-----} {$region -fold}
  obj_prop_helper  :=TRecInfo.Create;
  with obj_var,obj_prop_helper do
    begin
      Assign(PTypeInfo(TypeInfo(obj_arr[0])),[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0]);
      if loaded_successfully then
        MaskTo([%00000100,%10000000,%00000001,%00000000]);
    end;
  curve_prop_helper:=TRecInfo.Create;
  {with obj_var,curve_prop_helper do
    begin
      TODO
    end;} {$endregion}

  {Test1: Projectile Movement 2} {$region -fold}
  Randomize;
  SetLength(br_vec_projectile_arr,200*200);
  for i:=0 to Length(br_vec_projectile_arr)-1 do
    br_vec_projectile_arr[i]:=br_vec_default; {$endregion}

end; {$endregion}
procedure TF_MainForm.FormActivate           (sender:TObject);                                                          {$region -fold}
var
  key: char;
begin

  {Misc. Params. Init.-------------------} {$region -fold}
  PC_Scene_Editor.TabIndex   :=1;
  P_Inner_Window_Buttons.left:=F_MainForm.width>>1-
  P_Inner_Window_Buttons.width>>1;
  OnActivate                 :=Nil;
  show_world_axis            :=True;
  with srf_var,inn_wnd_rct do
    world_axis               :=PtPosF((left+right )>>1,
                                      (top +bottom)>>1);
  key                        :=Char(key_arr[07]);
  FormKeyPress                             (Self,key);
  SB_Spline_Edges_ShowClick                (Self);
  SB_Spline_Points_ShowClick               (Self);
  SB_Select_Items_Outer_Subgraph_ShowClick (Self);
  SB_Select_Items_Inner_Subgraph_ShowClick (Self);
  SB_Select_Items_Selected_Points_ShowClick(Self);
  SB_Centrify_PictureClick                 (Self); {$endregion}

  {Hot Keys Panel------------------------} {$region -fold}
  F_Hot_Keys.Left   :=F_MainForm.Left{+11}-F_Hot_Keys.Width;
  F_Hot_Keys.Top    :=F_MainForm.Top {+80};
  F_Hot_Keys.Visible:=True; {$endregion}

  {Content Library-----------------------} {$region -fold}
  ContentLibraryImagesListRepaint; {$endregion}

  {Object Tags---------------------------} {$region -fold}
  ObjectTagsListRepaint; {$endregion}

  {Image Editor--------------------------} {$region -fold}
  {F_Image_Editor.Visible:=True;} {$endregion}

  {OpenGL Window-------------------------} {$region -fold}
  OGLC_GPU_Canvas.Visible:=False;
  OGLC_GPU_Canvas.Enabled:=False; {$endregion}

  {Start the Game When the Program Starts} {$region -fold}
 {SB_Change_LayoutClick   (Self);
  SB_Centrify_PictureClick(Self);
  CB_Sound_Control_Play_Background_Sound.Checked:=not CB_Sound_Control_Play_Background_Sound.Checked;
  PC_Scene_Editor.TabIndex:=2;
  VisibilityChange(False);
  F_Hot_Keys.Visible             :=False;
  srf_var.inner_window_ui_visible:=False;
  show_visibility_panel          :=False;
  key                            :=Char(#32);
  FormKeyPress(Self,key);} {$endregion}

end; {$endregion}
procedure TF_MainForm.FormDestroy            (sender:TObject);                                                          {$region -fold}
begin

  UnLockCursor;

  {Using Shaders} {$region -fold}
  shader_var.Destroy; {$endregion}

end; {$endregion}
procedure TF_MainForm.FormDropFiles          (sender:TObject; const file_names:array of string);                        {$region -fold}
var
  file_name: string;
begin
  {for file_name in file_names do
    try
      srf_var.loaded_picture.LoadFromFile(file_name);
    except
      on E: Exception do
        MessageDlg('Error','Error: '+E.Message,mtError,[mbOk],0);
    end;
  srf_var.LoadTexture;}
end; {$endregion}
procedure TF_MainForm.PC_Scene_EditorChanging(sender:TObject; var allowchange:boolean);                                 {$region -fold}
begin
  RM_Description.Lines.Text:='';
end; {$endregion}
{$endregion}

// (Scene Tree) Иерархия обьектов:
{LI} {$region -fold}
procedure ObjIndsCalc;                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  with F_MainForm,TV_Scene_Tree,obj_var do
    begin
      for i:=0 to Items.Count-1 do
        begin
                  obj_inds_arr[i]       :=PNodeData(Items[i].Data)^.g_ind;
          obj_arr[obj_inds_arr[i]].t_ind:=i;
        end;
      LowLrObjCntCalc1;
      LowLrObjCntCalc2;
    end;
end; {$endregion}
procedure ScTIndsCalc;                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i  : integer;
  i00: integer=-1;
  i01: integer=-1;
  i02: integer=-1;
  i03: integer=-1;
  i04: integer=-1;
  i05: integer=-1;
  i06: integer=-1;
  i07: integer=-1;
  i08: integer=-1;

  procedure SetIndsSctArrVal(var obj_inds_sct_arr:TColorArr; var ind1:integer; constref ind2:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  begin
    Inc(ind1);
    obj_inds_sct_arr[ind1]:=ind2;
  end; {$endregion}

begin
  with F_MainForm.TV_Scene_Tree do
    for i:=0 to Items.Count-1 do
      with obj_var do
        case obj_arr[PNodeData(Items[i].Data)^.g_ind].koo of
          TKindOfObject(00){kooBkgnd}: SetIndsSctArrVal(bkgnd_inds_sct_arr,i00,i);
          TKindOfObject(01){kooRGrid}: SetIndsSctArrVal(rgrid_inds_sct_arr,i01,i);
          TKindOfObject(02){kooSGrid}: SetIndsSctArrVal(sgrid_inds_sct_arr,i02,i);
          TKindOfObject(03){kooGroup}: SetIndsSctArrVal(group_inds_sct_arr,i03,i);
          TKindOfObject(04){kooTlMap}: SetIndsSctArrVal(tlmap_inds_sct_arr,i04,i);
          TKindOfObject(05){kooActor}: SetIndsSctArrVal(actor_inds_sct_arr,i05,i);
          TKindOfObject(06){kooPProc}: SetIndsSctArrVal(pproc_inds_sct_arr,i06,i);
          TKindOfObject(07){kooCurve}: SetIndsSctArrVal(curve_inds_sct_arr,i07,i);
          TKindOfObject(08){kooFtext}: SetIndsSctArrVal(ftext_inds_sct_arr,i08,i);
        end;
end; {$endregion}
procedure CngPnVsCalc;                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,v: integer;

  function HasNotExpandedParent(ind:integer): boolean; {$ifdef Linux}[local];{$endif} {$region -fold}
  var
    j: integer;
  begin
    j:=0;
    Result:=False;
    with F_MainForm,TV_Scene_Tree,P_Object_Tags do
      begin
        Items.BeginUpdate;
        while (Items[ind].GetParentNodeOfAbsoluteLevel(j)<>Items[ind]) do
          begin
            if (not Items[ind].GetParentNodeOfAbsoluteLevel(j).Expanded) then
              begin
                Result:=True;
                Break;
              end;
            Inc(j);
          end;
        Items.EndUpdate;
      end;
  end; {$endregion}

begin
  {with F_MainForm,TV_Scene_Tree,P_Object_Tags do
    begin
      for i:=0 to ControlCount-1 do
        (Controls[i] as TPanel).Visible:=not HasNotExpandedParent(obj_var.obj_arr[i].t_ind);
      v:=0;
      for i:=0 to ControlCount-1 do
        begin
          if (Controls[obj_var.obj_inds_arr[i]] as TPanel).Visible then
            begin
             (Controls[obj_var.obj_inds_arr[i]] as TPanel).Top:=v*(P_TreeView_Attributes_Cells.Height-1)-P_TreeView_Attributes_Cells.Height;
             Inc(v);
            end;
        end;
    end;}
end; {$endregion}
procedure SelPnlsCalc;                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  {with F_MainForm,TV_Scene_Tree,P_Object_Tags,obj_var do
    for i:=0 to ControlCount-1 do
      if (Controls[obj_inds_arr[i]] {as TPanel}).Visible and Items[i].Selected then
         (Controls[obj_inds_arr[i]] {as TPanel}).Color:=$0082804D;}
end; {$endregion}
procedure UnsPnlsCalc;                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  {with F_MainForm,TV_Scene_Tree,P_Object_Tags do
    for i:=0 to ControlCount-1 do
      (Controls[obj_var.obj_inds_arr[i]] {as TPanel}).Color:=$00ABAFA3;}
end; {$endregion}
procedure SelIndsCalc;                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i,j,k,v: integer;
begin
  with F_MainForm,TV_Scene_Tree,obj_var do
    begin

      {if (SelectionCount=0) then
        Exit;}

      j:=-1;
      for i:=0 to Items.Count-1 do
        if Items[i].Selected then
          begin
            Inc(j);
            sel_inds_arr[j]:=i;
            if (j=SelectionCount-1) then
              begin
                last_sel_node_ind:=i;
                Break;
              end;
          end;

      sel_cnt                 :=SelectionCount;
      first_sel_node_ind      :=sel_inds_arr[0];
      single_selected_node_ind:=sel_inds_arr[0];

      i:=00;
      j:=-1;
      k:=00;
      v:=00;
      gr_not_sel_chld_cnt:=0;
      while (i<Items.Count) do
        begin
          v:=0;
          if (Items[i].Selected and Items[i].HasChildren and (obj_arr[PNodeData(Items[i].Data)^.g_ind].koo=kooGroup)) then
            begin
              v:=Items[i].GetLastSubChild.AbsoluteIndex-Items[i].GetFirstChild.AbsoluteIndex;
              for k:=0 to v do
                begin
                  Inc(j);
                  gr_not_sel_chld_inds_arr[j]:=i+k+1;
                end;
              Inc(v);
            end;
          Inc(gr_not_sel_chld_cnt,v);
          Inc(i,v+1);
        end;
      {
      M_Test_Log.Lines.Text:='';
      M_Test_Log.Lines.Add(IntToStr(gr_not_sel_chld_cnt));
      M_Test_Log.Lines.Add(IntToStr(Items.Count));
      for i:=0 to Items.Count-1 do
        begin
          c:=0;
          if Items[i].HasChildren then
            c:=Items[i].GetLastSubChild.AbsoluteIndex-Items[i].GetFirstChild.AbsoluteIndex+1{{GetDirectChildCount}(Items[i].GetFirstChild{GetLastSubChild}{GetNextSibling}.AbsoluteIndex{.Count})};
          M_Test_Log.Lines.Add(IntToStr(i)+'; '+IntToStr(c)+'; '+IntToStr(byte(Items[i].Selected))+'; '+IntToStr(byte(Items[i].HasChildren))+'; '+IntToStr(byte(obj_arr[PNodeData(Items[i].Data)^.g_ind].koo=kooGroup)));
        end;
      }
    end;
end; {$endregion}
procedure ChsDataCalc;                                                               inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  node  : TTreeNode;
  is_odd: boolean=False;
begin
  with F_MainForm,TV_Scene_Tree,obj_var do
    begin
      Items.BeginUpdate;
      node                             :=Items[0];
      PNodeData(node.data)^.chess_state:=is_odd;
      node                             :=node.GetNextVisible;
      visible_nodes_cnt:=1;
      while (node<>Nil) do
        begin
          Inc(visible_nodes_cnt);
          is_odd                           :=not is_odd;
          PNodeData(node.data)^.chess_state:=is_odd;
          node                             :=node.GetNextVisible;
        end;
      Items.EndUpdate;
    end;
end; {$endregion}
procedure SelObjsPosRecalc0;                                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  {if (F_MainForm.TV_Scene_Tree.SelectionCount=0) then
    Exit;
  with F_MainForm.TV_Scene_Tree,obj_var do
    for i:=0 to SelectionCount-1 do
      if obj_arr[obj_inds_arr[sel_inds_arr[i]]].recalc_pos then
        begin
          obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift.x:=Trunc((obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift.x-obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift_centrify.x)/obj_arr[obj_inds_arr[sel_inds_arr[i]]].parallax_shift.x);
          obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift.y:=Trunc((obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift.y-obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift_centrify.y)/obj_arr[obj_inds_arr[sel_inds_arr[i]]].parallax_shift.y);
        end;}
end; {$endregion}
procedure SelObjsPosRecalc1;                                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  i: integer;
begin
  {if (F_MainForm.TV_Scene_Tree.SelectionCount=0) then
    Exit;
  with F_MainForm.TV_Scene_Tree,obj_var do
    for i:=0 to SelectionCount-1 do
      if obj_arr[obj_inds_arr[sel_inds_arr[i]]].recalc_pos then
        begin
          obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift.x:=obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift.x*Trunc(obj_arr[obj_inds_arr[sel_inds_arr[i]]].parallax_shift.x)+obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift_centrify.x;
          obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift.y:=obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift.y*Trunc(obj_arr[obj_inds_arr[sel_inds_arr[i]]].parallax_shift.y)+obj_arr[obj_inds_arr[sel_inds_arr[i]]].world_axis_shift_centrify.y;
        end;}
end; {$endregion}
procedure AreAllObjPropEqual;                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  obj_prop_var: TObjProp;
  s           : string;
begin
  with obj_var,obj_prop_helper do
    begin

      with F_MainForm,TV_Scene_Tree do
        begin
          if (SelectionCount=0) then
            begin
              L_Object_Name                            .Caption:='';
              SE_Object_Properties_Parallax_ShiftX     .Color  :=DEFAULT_MISCELLANEOUS_VALUES_COLOR;
              SE_Object_Properties_Parallax_ShiftY     .Color  :=DEFAULT_MISCELLANEOUS_VALUES_COLOR;
              CB_Object_Properties_Show_In_Editor      .State  :=cbChecked;
              CB_Object_Properties_Show_In_Game        .State  :=cbChecked;
              CB_Object_Properties_Recalculate_Position.State  :=cbUnchecked;
              CB_Object_Properties_Movable             .State  :=cbChecked;
              CB_Object_Properties_Scalable            .State  :=cbChecked;
              CB_Object_Properties_Rotatable           .State  :=cbChecked;
              Exit;
            end;

          with obj_prop_var do
            begin
              koo           :=obj_arr[PNodeData(Items[first_sel_node_ind].data)^.g_ind].koo;
              parallax_shift:=obj_arr[PNodeData(Items[first_sel_node_ind].data)^.g_ind].parallax_shift;
              obj_show      :=obj_arr[PNodeData(Items[first_sel_node_ind].data)^.g_ind].obj_show;
            end;
        end;

      with obj_prop_var do
        if (F_MainForm.TV_Scene_Tree.SelectionCount=1) then
          begin
            s:=GetEnumName(TypeInfo(TKindOfObject2),Ord(koo));
            Delete(s,1,4);
            with F_MainForm,TV_Scene_Tree do
              begin
                L_Object_Name                            .Caption:=' '+s;
                SE_Object_Properties_Parallax_ShiftX     .Color  :=DEFAULT_MISCELLANEOUS_VALUES_COLOR;
                SE_Object_Properties_Parallax_ShiftY     .Color  :=DEFAULT_MISCELLANEOUS_VALUES_COLOR;
                SE_Object_Properties_Parallax_ShiftX     .Value  :=parallax_shift.x;
                SE_Object_Properties_Parallax_ShiftY     .Value  :=parallax_shift.y;
                CB_Object_Properties_Show_In_Editor      .Checked:=(obj_show and %00000001)=%00000001;
                CB_Object_Properties_Show_In_Game        .Checked:=(obj_show and %00000010)=%00000010;
                CB_Object_Properties_Recalculate_Position.Checked:=(obj_show and %00001000)=%00001000;
                CB_Object_Properties_Movable             .Checked:=(obj_show and %00010000)=%00010000;
                CB_Object_Properties_Scalable            .Checked:=(obj_show and %00100000)=%00100000;
                CB_Object_Properties_Rotatable           .Checked:=(obj_show and %01000000)=%01000000;
              end;
            Exit;
          end;

      if loaded_successfully then
        begin
          CmpFil;
          CmpRec1(@obj_arr[0],SizeOf(obj_arr[0]),F_MainForm.TV_Scene_Tree.Items[first_sel_node_ind]);
        end;

      if (cmp_it_arr[15][0]=0) then
        obj_prop_var.koo:=TKindOfObject(09);
      s:=GetEnumName(TypeInfo(TKindOfObject2),Ord(obj_prop_var.koo));
      Delete(s,1,4);

      with F_MainForm,TV_Scene_Tree do
        begin
          L_Object_Name.Caption:=' '+s;

          if (cmp_it_arr[02][0]=0) then
            SE_Object_Properties_Parallax_ShiftX     .Color:=clGray
          else
            SE_Object_Properties_Parallax_ShiftX     .Color:=DEFAULT_MISCELLANEOUS_VALUES_COLOR;

          if (cmp_it_arr[02][1]=0) then
            SE_Object_Properties_Parallax_ShiftY     .Color:=clGray
          else
            SE_Object_Properties_Parallax_ShiftY     .Color:=DEFAULT_MISCELLANEOUS_VALUES_COLOR;

          if (cmp_it_arr[16][0]=0) then
            CB_Object_Properties_Show_In_Editor      .State:=cbGrayed;

          if (cmp_it_arr[16][1]=0) then
            CB_Object_Properties_Show_In_Game        .State:=cbGrayed;

          if (cmp_it_arr[16][3]=0) then
            CB_Object_Properties_Recalculate_Position.State:=cbGrayed;

          if (cmp_it_arr[16][4]=0) then
            CB_Object_Properties_Movable             .State:=cbGrayed;

          if (cmp_it_arr[16][5]=0) then
            CB_Object_Properties_Scalable            .State:=cbGrayed;

          if (cmp_it_arr[16][6]=0) then
            CB_Object_Properties_Rotatable           .State:=cbGrayed;
        end;

    end;
end; {$endregion}
procedure ParallaxShiftChange;                                                       inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with F_MainForm,obj_var do
    begin
      global_prop.parallax_shift.x:=SE_Object_Properties_Parallax_ShiftX.Value;
      global_prop.parallax_shift.y:=SE_Object_Properties_Parallax_ShiftY.Value;
    end;
end; {$endregion}
procedure RecalcPosChange;                                                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with F_MainForm,obj_var do
    global_prop.obj_show:=(global_prop.obj_show and %11110111) or (Byte(CB_Object_Properties_Recalculate_Position.Checked)<<3);
end; {$endregion}
procedure ObjectShowChange;                                                          inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with F_MainForm,obj_var do
    global_prop.obj_show:=(global_prop.obj_show and %11111100) or (Byte(CB_Object_Properties_Show_In_Editor.Checked)<<0+
                                                                   Byte(CB_Object_Properties_Show_In_Game  .Checked)<<1);
end; {$endregion}
procedure SpatialStateChange;                                                        inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  with F_MainForm,obj_var do
    global_prop.obj_show:=(global_prop.obj_show and %10001111) or (Byte(CB_Object_Properties_Movable  .Checked)<<4+
                                                                   Byte(CB_Object_Properties_Scalable .Checked)<<5+
                                                                   Byte(CB_Object_Properties_Rotatable.Checked)<<6);
end; {$endregion}
procedure DeleteSelectedNodes(TV:TTreeView);                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  List: TList;
  i,j : integer;
  f   : boolean;

  function HasAsParent(node,PotentialParent:TTreeNode): boolean; {$region -fold}
  begin
    node:=node.Parent;
    while(node<>Nil) and (node<>PotentialParent) do
      node:=node.Parent;
    Result:=node=PotentialParent;
  end; {$endregion}

begin
  List:=TList.Create;
  try
    List.Capacity:=TV.SelectionCount;
    for i:=0 to TV.SelectionCount-1 do
      begin
        // Ищем, может кого из родителей уже занесли в список на выбывание ;)
        f:=False;
        for j:=0 to List.Count-1 do
          begin
            f:=HasAsParent(TV.Selections[i],TTreeNode(List[j]));
            if f then
              Break;
          end;
        if f then // Родителя удалят, так что текущий узел удалять не нужно
          Continue;
        // Теперь нужно удалить всех детей, которые уже были записаны в список
        for j:=List.Count-1 downto 0 do
          if HasAsParent(TTreeNode(List[j]),TV.Selections[i]) then
            List.Delete(j);
        // Вот теперь можно со спокойной душей добавлять узел в список..
        List.Add(TV.Selections[i])
      end;
      for i:=0 to List.Count-1 do
        TTreeNode(List[i]).Delete;
  finally
    List.Free;
  end;
end; {$endregion}
procedure CreateNode(item_text1,item_text2:ansistring; is_first_node:boolean=False); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  item_text: ansistring;
  ind      : integer;
  node     : TTreeNode;
begin
  with F_MainForm,TV_Scene_Tree,obj_var do
    begin
      Items.BeginUpdate;
      item_text:=item_text1+' '+item_text2;
      if (not is_first_node) then
        begin
          if (Selected=Nil) then
            ind:=Items.AddChild(Nil,item_text).AbsoluteIndex
          else
            begin
              node:=Items.Add(Selected,item_text);
              node.MoveTo(Selected,naAddChild);
              ind:=node.AbsoluteIndex;
            end;
        end
      else
        begin
          Items.AddFirst(Nil,item_text).Expanded:=True;
          ind                                   :=0;
        end;
      CrtNodeData(Items[ind],obj_cnt-1);
      {if Items[ind].Expanded then
        Items[ind].MakeVisible;}
      if (SelectionCount<>0) then
        AddTagPanel(obj_cnt-1)
      else
        AddTagPanel(ind);
      Items.EndUpdate;
    end;
end; {$endregion}
{Object Tags}
procedure AddTagPanel(constref ind:integer);                                         inline; {$ifdef Linux}[local];{$endif} {$region -fold}
begin
  {P_TreeView_Attributes_Cells:=TPanel.Create(Nil);
  with F_MainForm,TV_Scene_Tree,P_TreeView_Attributes_Cells do
    begin
      AnchorParallel(akRight,0,P_Object_Tags);
      BevelColor:=clGray;
      Parent    :=P_Object_Tags;
      Width     :=62;
      Height    :=DefaultItemHeight+1;
      Left      :=1;
      Top       :=Items[ind].Top-Height;
      Color     :=$00ABAFA3;
      Caption   :=IntToStr(ind);
      Font.Color:=clBlue;
      //Tag       :=ind;
    end;}
end; {$endregion}
procedure ObjectTagsListRepaint;                                                     inline; {$ifdef Linux}[local];{$endif} {$region -fold}
var
  target_node  : TTreeNode;
  color_info0  : TColorInfo;
  color_info1  : TColorInfo;
  color_info2  : TColorInfo;
  color_info3  : TColorInfo;
  color_info4  : TColorInfo;
  rct0         : TPtRect;
  rct1         : TPtRect;
  rct2         : TPtRect;
  rct3         : TPtRect;
  rct4         : TPtRect;
  rct5         : TPtRect;
  w0,h0        : integer;
  w1,h1        : integer;
  x ,y         : integer;
  curr_node_ind: integer;
  next_node_ind: integer;
  i            : integer;
  tag_pnl_col  : TColor;

  procedure DrawObjectTagsField(left,top,width,height,node_pos_y:integer); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  var
    div_column_left   : integer;
    div_column_top    : integer;
    div_column_width  : integer;
    div_column_height : integer;
    div_column_right  : integer;
    div_column_bottom : integer;

    procedure DrawBackground(var rct_dst:TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
    begin
      rct3:=PtBounds  (left,top,width,height);
      rct4:=ClippedRct(rct2,rct3);

      {Background-------} {$region -fold}
      PPFloodFill(object_tags_bmp_ptr,
                  object_tags_bmp.width,
                  rct4,
                  tag_pnl_col); {$endregion}

      {Column Separator1} {$region -fold}
      div_column_left  :=left;
      div_column_top   :=top;
      div_column_bottom:=top+height;
      if LineVC(div_column_left,div_column_top,div_column_bottom,rct_dst) then
         LineV (div_column_left,div_column_top,div_column_bottom,object_tags_bmp_ptr,object_tags_bmp.width,color_info3.pix_col); {$endregion}

      {Column Separator2} {$region -fold}
      div_column_left  :=left+17;
      div_column_top   :=top;
      div_column_bottom:=top+height;
      if LineVC(div_column_left,div_column_top,div_column_bottom,rct_dst) then
         LineV (div_column_left,div_column_top,div_column_bottom,object_tags_bmp_ptr,object_tags_bmp.width,HighLight2(color_info1.pix_col,70)); {$endregion}

    end; {$endregion}

    procedure DrawItems;                           inline; {$ifdef Linux}[local];{$endif} {$region -fold}
    begin
      with obj_var do
        begin

          {Bounds} {$region -fold}
          if target_node.Selected then
            SetColorInfo ($009DFD6F  ,color_info4)
          else
            SetColorInfo1(tag_pnl_col,color_info4);
          div_column_left{_}  :=left+18;
          div_column_top{_}   :=top +01;
          div_column_right{_} :=left+18+width;
          div_column_bottom{_}:=top +height-1;
          Rectangle(div_column_left{_},div_column_top{_},div_column_right{_},div_column_bottom{_},object_tags_bmp_ptr,object_tags_bmp.width,rct4,color_info4.pix_col); {$endregion}

          {Circle} {$region -fold}
          case (obj_arr[PNodeData(target_node.data)^.g_ind].obj_show and %00000011) of // visibility: | editor | game
            0: SetColorInfo($004A4A4A,color_info2);                                    //             |        |
            1: SetColorInfo($00B87275,color_info2);                                    //             | +      |
            2: SetColorInfo($004952A0,color_info2);                                    //             |        | +
            3: SetColorInfo($007EAB23,color_info2);                                    //             | +      | +
          end;
          CircleHighlight004(left+8,
                             top +(F_MainForm.TV_Scene_Tree.StateImagesWidth+2)>>1,
                             object_tags_bmp_ptr,
                             object_tags_bmp.width,
                             rct4,
                             color_info2,
                             013,
                             155);
          CircleHighlight001(left+8,
                             top +(F_MainForm.TV_Scene_Tree.StateImagesWidth+2)>>1,
                             object_tags_bmp_ptr,
                             object_tags_bmp.width,
                             rct4,
                             color_info2,
                             015,
                             255);
          CircleHighlight003(left+8,
                             top +(F_MainForm.TV_Scene_Tree.StateImagesWidth+2)>>1,
                             object_tags_bmp_ptr,
                             object_tags_bmp.width,
                             rct4,
                             color_info2,
                             011,
                             150); {$endregion}

        end;
    end; {$endregion}

  begin
    with obj_var do
      begin
        target_node:=F_MainForm.TV_Scene_Tree.GetNodeAt(0,node_pos_y);
        if (target_node<>Nil) then
          begin
            if PNodeData(target_node.data)^.chess_state then
              tag_pnl_col:=color_info0.pix_col
            else
              tag_pnl_col:=color_info1.pix_col;
            DrawBackground(rct4);
            DrawItems;
          end
        else
          begin
            DrawBackground(rct4{0});
          end;
      end;
  end; {$endregion}

begin

  SetColorInfo($0081726B,color_info0);
  SetColorInfo($0074655F,color_info1);
  SetColorInfo($00404040,color_info3);

  w0  :=F_MainForm.I_Object_Tags_List.width;
  h0  :=F_MainForm.I_Object_Tags_List.height;
  w1  :=object_tags_bmp              .width;
  h1  :=object_tags_bmp              .height;
  rct0:=PtBounds  (0,0,Min2(w0,w1),Min2(h0,h1));
  rct1:=PtBounds  (0,0,w1,h1);
  rct2:=ClippedRct(rct1,rct0);

  with F_MainForm.TV_Scene_Tree,obj_var do
    begin

      y          :=0;
      target_node:=GetNodeAt(0,0);
      if (target_node<>Nil) then
        begin
          curr_node_ind:=target_node.AbsoluteIndex;
          next_node_ind:=curr_node_ind;
          while (curr_node_ind=next_node_ind) do
            begin
              Inc(y);
              target_node:=GetNodeAt(0,y);
              if (target_node<>Nil) then
                next_node_ind:=target_node.AbsoluteIndex
              else
                Break;
            end;
        end;

      if (y<>0) then
            DrawObjectTagsField(0,y-      (StateImagesWidth+2),Min2(w0,w1),(StateImagesWidth+2),y-1);
      if (visible_nodes_cnt>1) then
        begin
          for i:=0 to Min2(visible_nodes_cnt-2,                   Trunc(h0/(StateImagesWidth+2)) -1) do
            DrawObjectTagsField(0,y+(i+0)*(StateImagesWidth+2),Min2(w0,w1),(StateImagesWidth+2),y+(i+0)*(StateImagesWidth+2));
            DrawObjectTagsField(0,y+(i+1)*(StateImagesWidth+2),Min2(w0,w1), h0                 ,y+(i+1)*(StateImagesWidth+2));
        end
      else
            DrawObjectTagsField(0,y+(0+0)*(StateImagesWidth+2),Min2(w0,w1), h0                 ,y+(0+0)*(StateImagesWidth+2));
    end;

  CnvToCnv(rct2,F_MainForm.I_Object_Tags_List.Canvas,object_tags_bmp.Canvas,SRCCOPY);
  F_MainForm.I_Object_Tags_List.Invalidate;

end; {$endregion}
{$endregion}
{UI} {$region -fold}
procedure TTreeView  .WMHScroll(var message:TLMHScroll);                                                                                                        {$region -fold}
begin
  inherited  WMHScroll(message);
  F_MainForm.WMHScroll(message);
end; {$endregion}
procedure TTreeView  .WMVScroll(var message:TLMHScroll);                                                                                                        {$region -fold}
begin
  inherited  WMVScroll(message);
  F_MainForm.WMVScroll(message);
end; {$endregion}
procedure TF_MainForm.WMHScroll(var message:TLMHScroll);                                                                                                        {$region -fold}
begin
  T_Editor_Time.Enabled:=True; // ObjectTagsListRepaint;
  //M_Test_Log.Lines.Text:=IntToStr(message.Pos);
end; {$endregion}
procedure TF_MainForm.WMVScroll(var message:TLMHScroll);                                                                                                        {$region -fold}
begin
  T_Editor_Time.Enabled:=True; // ObjectTagsListRepaint;
  //M_Test_Log.Lines.Text:=IntToStr(message.Pos);
end; {$endregion}
constructor TF_MainForm.Create                                       (TheOwner:TComponent);                                                                     {$region -fold}
begin
  inherited Create(TheOwner);
end; {$endregion}
procedure TF_MainForm.MI_Center_Camera_To_Selected_ObjectClick       (sender:TObject);                                                                          {$region -fold}
begin

end; {$endregion}
procedure TF_MainForm.MI_Add_GroupClick                              (sender:TObject);                                                                          {$region -fold}
var
  world_axis_shift: TPtPosF;
begin
  with TV_Scene_Tree,obj_var do
    begin
      if (srf_var<>Nil) then
        world_axis_shift:=srf_var.world_axis_shift
      else
        world_axis_shift:=Default(TPtPosF);
      Add(kooGroup,world_axis_shift);
      Main.CreateNode('Group',IntToStr(group_cnt)+' ');
      ObjIndsCalc;
      ScTIndsCalc;
      ChsDataCalc;
      VisObjArrCrt2;
      ObjectTagsListRepaint;
    end;
  DrawObjectInfo0;
end; {$endregion}
procedure TF_MainForm.MI_Remove_ObjectClick                          (sender:TObject);                                                                          {$region -fold}
begin
  if (TV_Scene_Tree.Selected=Nil) then
    begin
      ShowMessage('Nothing selected');
      Exit;
    end;
  if (TV_Scene_Tree.Selected.Level=0) then
    begin
      ShowMessage('Cant delete the root node');
      Exit;
    end;
  DeleteSelectedNodes(TV_Scene_Tree);
end; {$endregion}
procedure TF_MainForm.MI_Group_ObjectsClick                          (sender:TObject);                                                                          {$region -fold}
var
  j,m: integer;

  function FirstSelectedNode: integer; {$region -fold}
    var
      i,m: integer;
  begin
    m:=0;
    with TV_Scene_Tree do
      //if Items.IsMultiSelection then
        for i:=0 to Items.Count-1 do
          case Items[i].Selected of
            False: Inc(m);
            True : Break;
          end;
    Result:=m;
  end; {$endregion}

begin

  with TV_Scene_Tree,obj_var,srf_var,cmr_var do
    begin

      if (SelectionCount=0) then
        Exit;

      P_Object_Tags.Enabled:=False;
      PopUpMenu            :=Nil;
      OnExpanded           :=Nil;
      OnExpanding          :=Nil;
      OnDragDrop           :=Nil;
      OnDragOver           :=Nil;
      OnEndDrag            :=Nil;
      OnMouseDown          :=Nil;
      OnMouseMove          :=Nil;
      OnMouseWheelDown     :=Nil;
      OnMouseWheelUp       :=Nil;
      OnDblClick           :=Nil;
      OnEditing            :=Nil;
      OnEditingEnd         :=Nil;
      OnKeyDown            :=Nil;
      OnKeyPress           :=Nil;

      m:=FirstSelectedNode;
      Items.BeginUpdate;
      Items.Insert(Items[m{+1}],'Group '+IntToStr(group_cnt+1));
      Add(kooGroup,srf_var.world_axis_shift);
      CrtNodeData(Items[m{+1}],obj_cnt-1);
      AddTagPanel(obj_cnt-1);
      for j:=0 to Items.Count-1 do
        if Items[j].{Multi}Selected then
           Items[j].MoveTo(Items[m{+1}],naAddChild);
      Items[m{+1}].Expanded:=False{True};
      if (Selected<>Nil) then
        Items.ClearMultiSelection(True);
      ObjIndsCalc;
      ScTIndsCalc;
      CngPnVsCalc;
      SelPnlsCalc;
      SelIndsCalc;
      ChsDataCalc;
      VisObjArrCrt2;
      parallax_shift:=obj_var.obj_arr[0].parallax_shift;
      EventGroupsCalc(calc_arr,[18,30,32,41,52,53,55]+[41+7*Byte(down_select_items_ptr^)]);
      Items.EndUpdate;

      P_Object_Tags.Enabled:=True;
      PopUpMenu            :=PM_Scene_Tree;
      OnExpanded           :=@TV_Scene_TreeExpanded      ;
      OnExpanding          :=@TV_Scene_TreeExpanding     ;
      OnDragDrop           :=@TV_Scene_TreeDragDrop      ;
      OnDragOver           :=@TV_Scene_TreeDragOver      ;
      OnEndDrag            :=@TV_Scene_TreeEndDrag       ;
      OnMouseDown          :=@TV_Scene_TreeMouseDown     ;
      OnMouseMove          :=@TV_Scene_TreeMouseMove     ;
      OnMouseWheelDown     :=@TV_Scene_TreeMouseWheelDown;
      OnMouseWheelUp       :=@TV_Scene_TreeMouseWheelUp  ;
      OnDblClick           :=@TV_Scene_TreeDblClick      ;
      OnEditing            :=@TV_Scene_TreeEditing       ;
      OnEditingEnd         :=@TV_Scene_TreeEditingEnd    ;
      OnKeyDown            :=@TV_Scene_TreeKeyDown       ;
      OnKeyPress           :=@TV_Scene_TreeKeyPress      ;

      T_Editor_Time.Enabled:=True; // ObjectTagsListRepaint;
    end;

end; {$endregion}
procedure TF_MainForm.MI_Delete_Without_ChildrenClick                (sender:TObject);                                                                          {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.MI_Delete_All_GroupsClick                      (sender:TObject);                                                                          {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.MI_Select_AllClick                             (sender:TObject);                                                                          {$region -fold}
var
  i: integer;
begin
  with TV_Scene_Tree do
    for i:=0 to Items.Count-1 do
      Items[i].Selected:=True;
  SelPnlsCalc;
  SelIndsCalc;
  ChsDataCalc;
  AreAllObjPropEqual;
  ObjectTagsListRepaint;
end; {$endregion}
procedure TF_MainForm.MI_Unselect_AllClick                           (sender:TObject);                                                                          {$region -fold}
begin
  with TV_Scene_Tree do
    if (SelectionCount<>0) then
      Items.ClearMultiSelection(True);
  UnsPnlsCalc;
  SelIndsCalc;
  ChsDataCalc;
  AreAllObjPropEqual;
  ObjectTagsListRepaint;
end; {$endregion}
procedure TF_MainForm.MI_Fold_AllClick                               (sender:TObject);                                                                          {$region -fold}
var
  i: integer;
begin
  for i:=0 to TV_Scene_Tree.Items.Count-1 do
    TV_Scene_Tree.Items[i].Expanded:=False;
  CngPnVsCalc;
  ChsDataCalc;
  ObjectTagsListRepaint;
end; {$endregion}
procedure TF_MainForm.MI_Unfold_AllClick                             (sender:TObject);                                                                          {$region -fold}
begin
  TV_Scene_Tree.FullExpand;
  CngPnVsCalc;
  ChsDataCalc;
  ObjectTagsListRepaint;
end; {$endregion}
procedure TF_MainForm.MI_Fold_SelectedClick                          (sender:TObject);                                                                          {$region -fold}
var
  i: integer;
begin
  for i:=0 to TV_Scene_Tree.Items.Count-1 do
    if TV_Scene_Tree.Items[i].Selected then
      TV_Scene_Tree.Items[i].Expanded:=False;
  CngPnVsCalc;
  ChsDataCalc;
  ObjectTagsListRepaint;
end; {$endregion}
procedure TF_MainForm.MI_Unfold_SelectedClick                        (sender:TObject);                                                                          {$region -fold}
var
  i: integer;
begin
  for i:=0 to TV_Scene_Tree.Items.Count-1 do
    if TV_Scene_Tree.Items[i].{Multi}Selected then
      TV_Scene_Tree.Items[i].Expanded:=True;
  CngPnVsCalc;
  ChsDataCalc;
  ObjectTagsListRepaint;
end; {$endregion}
procedure TF_MainForm.MI_Goto_First_ObjectClick                      (sender:TObject);                                                                          {$region -fold}
begin
  TV_Scene_Tree.Items.ClearMultiSelection(True);
  TV_Scene_Tree.Items[0].Selected:=True;
  //TV_Scene_Tree.Perform(WM_VSCROLL,MakeWParam(SB_LINEUP,0),0);
  //P_Object_Tags.VertScrollBar.Position:=0;
  SelPnlsCalc;
  SelIndsCalc;
  ChsDataCalc;
  ObjectTagsListRepaint;
  AreAllObjPropEqual;
end; {$endregion}
procedure TF_MainForm.MI_Goto_Last_ObjectClick                       (sender:TObject);                                                                          {$region -fold}
begin
  TV_Scene_Tree.Items.ClearMultiSelection(True);
  TV_Scene_Tree.Items[TV_Scene_Tree.Items.Count-1].Selected:=True;
  //P_Object_Tags.VertScrollBar.Position:=3*TV_Scene_Tree.DefaultItemHeight*(TV_Scene_Tree.Items.Count-1);
  SelPnlsCalc;
  SelIndsCalc;
  ChsDataCalc;
  ObjectTagsListRepaint;
  AreAllObjPropEqual;
end; {$endregion}
procedure TF_MainForm.P_Scene_Tree_HeaderClick                       (sender:TObject);                                                                          {$region -fold}
begin
  MI_Unselect_AllClick(Self);
end; {$endregion}
procedure TF_MainForm.P_Object_TagsMouseWheelDown                    (sender:TObject; shift:TShiftState; mousepos:TPoint; var handled:boolean);                 {$region -fold}
begin
  if (shift=[ssCtrl]) then
    begin
      if (TV_Scene_Tree.StateImagesWidth=10) then
        Exit;
             scene_tree_font_size_counter-=1{0.5};
          TV_Scene_Tree.Font.Size        :=Trunc
            (scene_tree_font_size_counter);
          TV_Scene_Tree.     ImagesWidth :=
          TV_Scene_Tree.     ImagesWidth-2{1};
          TV_Scene_Tree.StateImagesWidth :=
          TV_Scene_Tree.StateImagesWidth-2{1};
      T_Editor_Time.Enabled:=True; // ObjectTagsListRepaint;
    end;
  //TV_Scene_Tree.Perform(WM_VSCROLL,MakeWParam(SB_LINEDOWN,0),0);
end; {$endregion}
procedure TF_MainForm.P_Object_TagsMouseWheelUp                      (sender:TObject; shift:TShiftState; mousepos:TPoint; var handled:boolean);                 {$region -fold}
begin
  if (shift=[ssCtrl]) then
    begin
      if (TV_Scene_Tree.StateImagesWidth=32) then
        Exit;
         scene_tree_font_size_counter+=1{0.5};
      TV_Scene_Tree.Font.Size        :=Trunc
        (scene_tree_font_size_counter);
      TV_Scene_Tree.     ImagesWidth :=
      TV_Scene_Tree.     ImagesWidth+2{1};
      TV_Scene_Tree.StateImagesWidth :=
      TV_Scene_Tree.StateImagesWidth+2{1};
      T_Editor_Time.Enabled:=True; // ObjectTagsListRepaint;
    end;
  //TV_Scene_Tree.Perform(WM_VSCROLL,MakeWParam(SB_LINEUP,0),0);
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeExpanded                          (sender:TObject; node:TTreeNode);                                                          {$region -fold}
begin
  {CngPnVsCalc;
  ChsDataCalc;}
  //ObjectTagsListRepaint;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeExpanding                         (sender:TObject; node:TTreeNode; var allowexpansion:boolean);                              {$region -fold}
begin

end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeDragDrop                          (sender,source:TObject; x,y:integer);                                                      {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeDragOver                          (sender,source:TObject; x,y:integer; state:TDragState; var accept:boolean);                {$region -fold}
begin
  //accept:=True and (sel_var.sel_pts_cnt=0); // If TRUE then accept the draged item
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeEndDrag                           (sender,target:TObject; x,y:integer);                                                      {$region -fold}
var
  source_node,target_node: TTreeNode;
begin
  with TV_Scene_Tree,obj_var,srf_var do
    begin
      if (sel_var.sel_pts_cnt<>0) then
        Exit;
      Items.BeginUpdate;
      source_node:=GetNodeAt(source_node_x,source_node_y);
      target_node:=GetNodeAt(x,y);
      if (target_node<>Nil) then
        begin
          ParallaxShiftChange;
          RecalcPosChange;
          ObjectShowChange;
          SpatialStateChange;
        end
      else
        EndDrag(True);
      if (SelectionCount<>0) then
        begin
          if (target_node<>Nil) then
            source_node.MoveTo(target_node,naAddChild)
          else
            source_node.MoveTo(target_node,naAdd);
          ObjIndsCalc;
          ScTIndsCalc;
          CngPnVsCalc;
          SelPnlsCalc;
          SelIndsCalc;
          ChsDataCalc;
          AreAllObjPropEqual;
          cmr_var.parallax_shift:=obj_var.obj_arr[0].parallax_shift;
          LowLrObjCntCalc1;
          LowLrObjCntCalc2;
          SetRctDstPtr(@inn_wnd_rct,0,obj_cnt-1);
          VisObjArrCrt2;
          if (sel_var.sel_pts_cnt=0) then
            if (source_node_y<>y) then
              EventGroupsCalc(calc_arr,[10,18,30,31,32,41,52,53,55]);
        end;
      //VisObjArrCrt2;
      ObjectTagsListRepaint;
      Items.EndUpdate;
    end;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeMouseDown                         (sender:TObject; button:TMouseButton; shift:TShiftState; x,y:integer);                     {$region -fold}
var
  target_node: TTreeNode;
  shift_name : string;
begin
  with TV_Scene_Tree,obj_var do
    if (button=mbLeft) then
      begin
        ReadOnly     :=False;
        source_node_x:=x;
        source_node_y:=y;
        target_node  :=GetNodeAt(x,y);
        if (target_node<>Nil) then
          begin
            SE_Object_Properties_Parallax_ShiftX     .Value  :=  obj_arr[PNodeData(target_node.data)^.g_ind].parallax_shift.x;
            SE_Object_Properties_Parallax_ShiftY     .Value  :=  obj_arr[PNodeData(target_node.data)^.g_ind].parallax_shift.y;
            CB_Object_Properties_Show_In_Editor      .Checked:=((obj_arr[PNodeData(target_node.data)^.g_ind].obj_show and %00000001)=%00000001);
            CB_Object_Properties_Show_In_Game        .Checked:=((obj_arr[PNodeData(target_node.data)^.g_ind].obj_show and %00000010)=%00000010);
            CB_Object_Properties_Recalculate_Position.Checked:=((obj_arr[PNodeData(target_node.data)^.g_ind].obj_show and %00001000)=%00001000);
            CB_Object_Properties_Movable             .Checked:=((obj_arr[PNodeData(target_node.data)^.g_ind].obj_show and %00010000)=%00010000);
            CB_Object_Properties_Scalable            .Checked:=((obj_arr[PNodeData(target_node.data)^.g_ind].obj_show and %00100000)=%00100000);
            CB_Object_Properties_Rotatable           .Checked:=((obj_arr[PNodeData(target_node.data)^.g_ind].obj_show and %01000000)=%01000000);
            single_selected_node_ind                         :=target_node.AbsoluteIndex;
            shift_name                                       :=GetEnumName(TypeInfo(TShiftStateEnum),Ord(TShiftStateEnum(shift)));
            if (shift_name='ssSuper') then
              begin
                Items.ClearMultiSelection(True);
                target_node.Selected:=True;
              end
            else
            if (shift_name='ssNum') then
              begin
                if target_node.Selected then
                  begin
                    target_node.Selected:=False;
                    if (SelectionCount=1) then
                      L_Object_Name.Caption:='';
                  end;
              end;
            BeginDrag(True);
          end
        else
        if (SelectionCount<>0) then
          begin
            Items.ClearMultiSelection(True);
            FormKeyPress(Self,prev_key);
            L_Object_Name                            .Caption:='';
            SE_Object_Properties_Parallax_ShiftX     .Color  :=DEFAULT_MISCELLANEOUS_VALUES_COLOR;
            SE_Object_Properties_Parallax_ShiftY     .Color  :=DEFAULT_MISCELLANEOUS_VALUES_COLOR;
            CB_Object_Properties_Show_In_Editor      .State  :=TCheckBoxState(Byte((global_prop.obj_show and %00000001)=%00000001));
            CB_Object_Properties_Show_In_Game        .State  :=TCheckBoxState(Byte((global_prop.obj_show and %00000010)=%00000010));
            CB_Object_Properties_Recalculate_Position.State  :=TCheckBoxState(Byte((global_prop.obj_show and %00001000)=%00001000));
            CB_Object_Properties_Movable             .State  :=TCheckBoxState(Byte((global_prop.obj_show and %00010000)=%00010000));
            CB_Object_Properties_Scalable            .State  :=TCheckBoxState(Byte((global_prop.obj_show and %00100000)=%00100000));
            CB_Object_Properties_Rotatable           .State  :=TCheckBoxState(Byte((global_prop.obj_show and %01000000)=%01000000));
          end
        {else
          FormMouseEnter(Self)};
        ReadOnly:=True;
        UnsPnlsCalc;
        //VisObjArrCrt2;
        ObjIndsCalc;
        ScTIndsCalc;
        CngPnVsCalc;
        SelPnlsCalc;
        SelIndsCalc;
        ChsDataCalc;
        ObjectTagsListRepaint;
      end;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeMouseMove                         (sender:TObject; shift:TShiftState; x,y:integer);                                          {$region -fold}
var
  target_node: TTreeNode;
  i          : integer;
begin
  with TV_Scene_Tree do
    begin
      target_node:=GetNodeAt(x,y);
      if (target_node<>Nil) then
        begin
          if (target_node.GetPrev<>Nil) then
            begin
              target_node.GetPrev.NodeEffect:=gdeNormal;
              {if (not target_node.GetPrev.Selected) then
                if (P_Object_Tags.Controls[obj_var.obj_inds_arr[target_node.GetPrev.AbsoluteIndex]]<>Nil) then
                   (P_Object_Tags.Controls[obj_var.obj_inds_arr[target_node.GetPrev.AbsoluteIndex]] as TPanel).Color:=$00ABAFA3;}
            end;
          target_node.NodeEffect:=gdeHighlighted;
          {if (not target_node.Selected) then
            if (P_Object_Tags.Controls[obj_var.obj_inds_arr[target_node.AbsoluteIndex]]<>Nil) then
               (P_Object_Tags.Controls[obj_var.obj_inds_arr[target_node.AbsoluteIndex]] as TPanel).Color:=$00ABC0B4;}
          if (target_node.GetNext<>Nil) then
            begin
              target_node.GetNext.NodeEffect:=gdeNormal;
              {if (not target_node.GetNext.Selected) then
                if (P_Object_Tags.Controls[obj_var.obj_inds_arr[target_node.GetNext.AbsoluteIndex]]<>Nil) then
                   (P_Object_Tags.Controls[obj_var.obj_inds_arr[target_node.GetNext.AbsoluteIndex]] as TPanel).Color:=$00ABAFA3;}
            end;
        end
      else
        for i:=0 to Items.Count-1 do
          begin
            Items[i].NodeEffect:=gdeNormal;
            {if (not Items[i].Selected) then
              if (P_Object_Tags.Controls[obj_var.obj_inds_arr[i]]<>Nil) then
                 (P_Object_Tags.Controls[obj_var.obj_inds_arr[i]] as TPanel).Color:=$00ABAFA3;}
          end;
    end;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeMouseWheelDown                    (sender:TObject; shift:TShiftState; mousepos:TPoint; var handled:boolean);                 {$region -fold}
var
  target_node: TTreeNode;
begin
  with TV_Scene_Tree do
    begin
      target_node:=GetNodeAt(mousepos.x,mousepos.y);
      if (target_node<>Nil) then
          target_node.NodeEffect:=gdeNormal;
    end;
  T_Editor_Time.Enabled:=True; // ObjectTagsListRepaint;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeMouseWheelUp                      (sender:TObject; shift:TShiftState; mousepos:TPoint; var handled:boolean);                 {$region -fold}
var
  target_node: TTreeNode;
begin
  with TV_Scene_Tree do
    begin
      target_node:=GetNodeAt(mousepos.x,mousepos.y);
      if (target_node<>Nil) then
          target_node.NodeEffect:=gdeNormal;
    end;
  T_Editor_Time.Enabled:=True; // ObjectTagsListRepaint;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeMouseEnter                        (sender:TObject);                                                                          {$region -fold}
begin
  TV_Scene_Tree.Color   :=tree___active; //HighLightLimit(TV_Scene_Tree.Color,16);
  is_mouse_in_scene_tree:=True;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeMouseLeave                        (sender:TObject);                                                                          {$region -fold}
var
  i: integer;
begin
  TV_Scene_Tree.Color:=tree_inactive; //Darken2(TV_Scene_Tree.Color,16);
  with TV_Scene_Tree do
    for i:=0 to Items.Count-1 do
      begin
        Items[i].NodeEffect:=gdeNormal;
        {if (not Items[i].Selected) then
          if (P_Object_Tags.Controls[obj_var.obj_inds_arr[i]]<>Nil) then
             (P_Object_Tags.Controls[obj_var.obj_inds_arr[i]] as TPanel).Color:=$00ABAFA3;}
      end;
  is_mouse_in_scene_tree:=False;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeCustomDrawItem                    (sender:TCustomTreeView; node:TTreeNode; state:TCustomDrawState; var DefaultDraw:boolean); {$region -fold}
begin
  TV_Scene_Tree.Items.BeginUpdate;
  with (Sender as TCustomTreeView),{Canvas.Brush,}obj_var do
    case Byte(PNodeData(node.data)^.chess_state) of
      0: BackgroundColor:=$00A7A48F;
      1: BackgroundColor:=$00B0AD99;
    end;
  with (Sender as TCustomTreeView),Canvas.Font,obj_var do
    case (obj_arr[PNodeData(node.data)^.g_ind].obj_show and %00000011) of // visibility: | editor | game
      0: Color:=clGray;                                                   //             |        |
      1: Color:=$0092726D;                                                //             | +      |
      2: Color:=$006D7692;                                                //             |        | +
      3: Color:=$00512F42;                                                //             | +      | +
    end;
  TV_Scene_Tree.Items.EndUpdate;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeDblClick                          (sender:TObject);                                                                          {$region -fold}
begin
  with TV_Scene_Tree do
    if (Selected<>Nil) then
      begin
        Selected.EditText;
        Color:=tree___active;
      end;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeEditing                           (sender:TObject; node:TTreeNode; var allowedit:boolean);                                   {$region -fold}
begin
  is_scene_tree_editing:=True;
  KeysDisable3;
  TV_Scene_Tree.Color:=tree_inactive;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeEditingEnd                        (sender:TObject; node:TTreeNode; cancel:boolean);                                          {$region -fold}

  procedure MultiRename; inline; {$region -fold}
  var
    i: integer;
    s: string;
  begin
    with TV_Scene_Tree,obj_var do
      begin
        s:=Items[sel_inds_arr[0]].Text;
        if (current_node_text_field=s) then
          Exit;
        if MI_Reverse_Order.Checked then
          for i:=0 to SelectionCount-1 do
            Items[sel_inds_arr[i]].Text:=s+' '+IntToStr(SelectionCount-i)+' '
        else
          for i:=0 to SelectionCount-1 do
            Items[sel_inds_arr[i]].Text:=s+' '+IntToStr(i+1)+' ';
      end;
  end; {$endregion}

begin
  is_scene_tree_editing:=False;
  if not down_play_anim_ptr^ then
    KeysEnable3
  else
    KeysEnable4;
  with TV_Scene_Tree do
    begin
      Color:=tree___active;
      if MI_Allow_MultiRename.Checked and (SelectionCount>1) then
        MultiRename;
    end;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeKeyDown                           (sender:TObject; var key:word; shift:TShiftState);                                         {$region -fold}
var
  node: TTreeNode;
  s   : string;
begin
  with obj_var do
    begin
      with TV_Scene_Tree do
        case key of
          38:
            begin
              if (SelectionCount=1) then
                begin
                  node:=Items[single_selected_node_ind].GetPrevVisible;
                  if (node<>Nil) then
                    single_selected_node_ind:=node.AbsoluteIndex
                  else
                    begin
                            single_selected_node_ind:=0;
                      Items[single_selected_node_ind].Selected:=True;
                      Items.ClearMultiSelection(True);
                    end;
                end
              else
                begin
                  single_selected_node_ind:=first_sel_node_ind;
                  node:=Items[single_selected_node_ind].GetPrevVisible;
                  if (node<>Nil) then
                    begin
                      single_selected_node_ind:=node.AbsoluteIndex;
                      first_sel_node_ind:=single_selected_node_ind;
                    end
                  else
                    begin
                            single_selected_node_ind:=0;
                      Items[single_selected_node_ind].Selected:=True;
                    end;
                end;
            end;
          40:
            begin
              if (SelectionCount=1) then
                begin
                  node:=Items[single_selected_node_ind].GetNextVisible;
                  if (node<>Nil) then
                    single_selected_node_ind:=node.AbsoluteIndex
                  else
                    Exit;
                end
              else
                begin
                  single_selected_node_ind:=last_sel_node_ind;
                  node:=Items[single_selected_node_ind].GetNextVisible;
                  if (node<>Nil) then
                    begin
                      single_selected_node_ind:=node.AbsoluteIndex;
                      first_sel_node_ind:=single_selected_node_ind;
                    end
                  else
                    Exit;
                end;
            end;
          37:
            begin
              //F_MainForm.M_Test_Log.Lines.Text:=IntToStr(single_selected_node_ind);
              Items.ClearMultiSelection(True);
              Items[single_selected_node_ind].Selected:=True;
              Items[single_selected_node_ind].Expanded:=False;
              ChsDataCalc;
            end;
          39:
            begin
              //F_MainForm.M_Test_Log.Lines.Text:=IntToStr(single_selected_node_ind);
              Items.ClearMultiSelection(True);
              Items[single_selected_node_ind].Selected:=True;
              Items[single_selected_node_ind].Expanded:=True;
              ChsDataCalc;
            end;
        end;
      case key of
        38,40:
          begin
            with obj_arr[PNodeData(TV_Scene_Tree.Items[single_selected_node_ind].data)^.g_ind] do
              begin
                SE_Object_Properties_Parallax_ShiftX.Value  := parallax_shift.x;
                SE_Object_Properties_Parallax_ShiftY.Value  := parallax_shift.y;
                CB_Object_Properties_Show_In_Editor .Checked:=(obj_show and %00000011) in [1,3];
                CB_Object_Properties_Show_In_Game   .Checked:=(obj_show and %00000011) in [2,3];
                s:=GetEnumName(TypeInfo(TKindOfObject2),Ord   (koo));
              end;
            Delete(s,1,4);
            L_Object_Name.Caption:=' '+s;
          end;
      end;
      case key of
        38,40,37,39:
          T_Editor_Time.Enabled:=True; // ObjectTagsListRepaint;
      end;
    end;
end; {$endregion}
procedure TF_MainForm.TV_Scene_TreeKeyPress                          (sender:TObject; var key:char);                                                            {$region -fold}
var
  s: string;
begin
  with TV_Scene_Tree do
    case key of
      #32:
        if (SelectionCount<>0) then
          //if GetFirstMultiSelected<>Nil then
            begin
              current_node_text_field:=GetFirstMultiSelected.Text;
              GetFirstMultiSelected.EditText;
              Color:=tree___active;
            end;
    end;
  //Mouse_Event
end; {$endregion}
// (Object Properties) Свойства обьекта:
procedure TF_MainForm.SB_Object_PropertiesMouseEnter                 (sender:TObject);                                                                          {$region -fold}
begin
  SB_Object_Properties.Color:=HighLightLimit(SB_Object_Properties.Color,16);
  P_Object_Properties .Color:=HighLightLimit(P_Object_Properties .Color,16);
end; {$endregion}
procedure TF_MainForm.SB_Object_PropertiesMouseLeave                 (sender:TObject);                                                                          {$region -fold}
begin
  SB_Object_Properties.Color:=Darken2(SB_Object_Properties.Color,16);
  P_Object_Properties .Color:=Darken2(P_Object_Properties .Color,16);
end; {$endregion}
procedure TF_MainForm.SE_Object_Properties_Parallax_ShiftXChange     (sender:TObject);                                                                          {$region -fold}
begin
  with TV_Scene_Tree,cmr_var,srf_var,sln_var,sel_var,obj_var do
    begin
      ParallaxShiftChange;
      if (SelectionCount=0) or (is_mouse_in_scene_tree) then
        Exit;
      //SelObjsPosRecalc0;
      WrtNodeData(       global_prop.parallax_shift,
                  PByte (@obj_arr[0].parallax_shift)-
                  PByte (@obj_arr[0]),
                  WrtNodeDataProcArr0[11],
                  WrtNodeDataProcArr1[11]);
      parallax_shift    :=obj_arr[0].parallax_shift;
      //SelObjsPosRecalc1;
      LowLrObjCntCalc1;
      LowLrObjCntCalc2;
      EventGroupsCalc(calc_arr,[10,18,30,31,32,41,52,53,55]);
      TV_Scene_Tree.Invalidate;
    end;
end; {$endregion}
procedure TF_MainForm.SE_Object_Properties_Parallax_ShiftYChange     (sender:TObject);                                                                          {$region -fold}
begin
  with TV_Scene_Tree,cmr_var,srf_var,sln_var,sel_var,obj_var do
    begin
      ParallaxShiftChange;
      if (SelectionCount=0) or (is_mouse_in_scene_tree) then
        Exit;
      //SelObjsPosRecalc0;
      WrtNodeData(       global_prop.parallax_shift,
                  PByte (@obj_arr[0].parallax_shift)-
                  PByte (@obj_arr[0]),
                  WrtNodeDataProcArr0[12],
                  WrtNodeDataProcArr1[12]);
      parallax_shift    :=obj_arr[0].parallax_shift;
      //SelObjsPosRecalc1;
      LowLrObjCntCalc1;
      LowLrObjCntCalc2;
      EventGroupsCalc(calc_arr,[10,18,30,31,32,41,52,53,55]);
      TV_Scene_Tree.Invalidate;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Object_Properties_Show_In_EditorChange      (sender:TObject);                                                                          {$region -fold}
begin
  with TV_Scene_Tree,srf_var,sln_var,sel_var,obj_var do
    begin
      ObjectShowChange;
      if (SelectionCount=0) or (is_mouse_in_scene_tree) then
        Exit;
      bit_mask:=%00000001{%00000101};
      WrtNodeData(      global_prop.obj_show{(global_prop.obj_show and %11111011) or %00000100},
                  PByte(@obj_arr[0].obj_show)-
                  PByte(@obj_arr[0]),
                  WrtNodeDataProcArr0[01],
                  WrtNodeDataProcArr1[01]);
      LowLrObjCntCalc1;
      SetRctDstPtr(@inn_wnd_rct,0,obj_cnt-1);
      VisObjArrCrt2;
      EventGroupsCalc(calc_arr,[10,14,18,30,31,32,41,52,53,55]+[41+7*Byte(down_select_items_ptr^)]);
      TV_Scene_Tree.Invalidate;
      ObjectTagsListRepaint;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Object_Properties_Show_In_GameChange        (sender:TObject);                                                                          {$region -fold}
begin
  with TV_Scene_Tree,srf_var,sln_var,sel_var,obj_var do
    begin
      ObjectShowChange;
      if (SelectionCount=0) or (is_mouse_in_scene_tree) then
        Exit;
      bit_mask:=%00000010{%00000110};
      WrtNodeData(      global_prop.obj_show{(global_prop.obj_show and %11111011) or %00000100},
                  PByte(@obj_arr[0].obj_show)-
                  PByte(@obj_arr[0]),
                  WrtNodeDataProcArr0[01],
                  WrtNodeDataProcArr1[01]);
      LowLrObjCntCalc1;
      SetRctDstPtr(@inn_wnd_rct,0,obj_cnt-1);
      VisObjArrCrt2;
      EventGroupsCalc(calc_arr,[10,14,18,30,31,32,41,52,53,55]);
      TV_Scene_Tree.Invalidate;
      ObjectTagsListRepaint;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Object_Properties_Recalculate_PositionChange(sender:TObject);                                                                          {$region -fold}
begin
  with TV_Scene_Tree,srf_var,sln_var,sel_var,obj_var do
    begin
      RecalcPosChange;
      if (SelectionCount=0) or (is_mouse_in_scene_tree) then
        Exit;
      bit_mask:=%00001000;
      WrtNodeData(      global_prop.obj_show,
                  PByte(@obj_arr[0].obj_show)-
                  PByte(@obj_arr[0]),
                  WrtNodeDataProcArr0[01],
                  WrtNodeDataProcArr1[01]);
      EventGroupsCalc(calc_arr,[10,18,30,31,32,41,52,53,55]);
      TV_Scene_Tree.Invalidate;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Object_Properties_MovableChange             (sender:TObject);                                                                          {$region -fold}
begin
  with TV_Scene_Tree,srf_var,sln_var,sel_var,obj_var do
    begin
      SpatialStateChange;
      if (SelectionCount=0) or (is_mouse_in_scene_tree) then
        Exit;
      bit_mask:=%00010000;
      WrtNodeData(      global_prop.obj_show,
                  PByte(@obj_arr[0].obj_show)-
                  PByte(@obj_arr[0]),
                  WrtNodeDataProcArr0[01],
                  WrtNodeDataProcArr1[01]);
      LowLrObjCntCalc1;
      EventGroupsCalc(calc_arr,[10,18,30,31,32,41,52,53,55]);
      TV_Scene_Tree.Invalidate;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Object_Properties_ScalableChange            (sender:TObject);                                                                          {$region -fold}
begin
  with TV_Scene_Tree,srf_var,sln_var,sel_var,obj_var do
    begin
      SpatialStateChange;
      if (SelectionCount=0) or (is_mouse_in_scene_tree) then
        Exit;
      bit_mask:=%00100000;
      WrtNodeData(      global_prop.obj_show,
                  PByte(@obj_arr[0].obj_show)-
                  PByte(@obj_arr[0]),
                  WrtNodeDataProcArr0[01],
                  WrtNodeDataProcArr1[01]);
      LowLrObjCntCalc1;
      EventGroupsCalc(calc_arr,[10,18,30,31,32,41,52,53,55]);
      TV_Scene_Tree.Invalidate;
    end;
end; {$endregion}
procedure TF_MainForm.CB_Object_Properties_RotatableChange           (sender:TObject);                                                                          {$region -fold}
begin
  with TV_Scene_Tree,srf_var,sln_var,sel_var,obj_var do
    begin
      SpatialStateChange;
      if (SelectionCount=0) or (is_mouse_in_scene_tree) then
        Exit;
      bit_mask:=%01000000;
      WrtNodeData(      global_prop.obj_show,
                  PByte(@obj_arr[0].obj_show)-
                  PByte(@obj_arr[0]),
                  WrtNodeDataProcArr0[01],
                  WrtNodeDataProcArr1[01]);
      LowLrObjCntCalc1;
      EventGroupsCalc(calc_arr,[10,18,30,31,32,41,52,53,55]);
      TV_Scene_Tree.Invalidate;
    end;
end; {$endregion}
// (Tag    Properties) Свойства тега:
procedure TF_MainForm.SB_Tag_PropertiesMouseEnter                    (sender:TObject);                                                                          {$region -fold}
begin
  SB_Tag_Properties.Color:=HighLightLimit(SB_Tag_Properties.Color,16);
  P_Tag_Properties .Color:=HighLightLimit(P_Tag_Properties .Color,16);
end; {$endregion}
procedure TF_MainForm.SB_Tag_PropertiesMouseLeave                    (sender:TObject);                                                                          {$region -fold}
begin
  SB_Tag_Properties.Color:=Darken2(SB_Tag_Properties.Color,16);
  P_Tag_Properties .Color:=Darken2(P_Tag_Properties .Color,16);
end; {$endregion}
// (Clear Scene) Очистить сцену:
procedure TF_MainForm.SB_Clear_SceneClick                            (sender:TObject);                                                                          {$region -fold}
begin
  P_Selective_Deletion.Visible:=SB_Clear_Scene.Down;
  P_Load_Save_Clear.Repaint;
end; {$endregion}
procedure TF_MainForm.BB_Delete_SelectedClick                        (sender:TObject);                                                                          {$region -fold}
begin
end; {$endregion}
procedure TF_MainForm.BB_Delete_AllClick                             (sender:TObject);                                                                          {$region -fold}
var
  i: integer;
begin
  {with srf_var,tex_var,sln_var,sel_var do
    begin

      {Clear Layer Canvas}
      srf_bmp.Canvas.Clear;
      low_bmp.Canvas.Clear;

      {Clear Texture List}
      for i:=FP_Image_List.ControlCount-1 downto 0 do
        FP_Image_List.Controls[i].Destroy;

      {Clear Scene Tree Nodes}
      with TV_Scene_Tree do
        begin
          Items[0].DeleteChildren;
          if Items.Count>1 then
            for i:=1 to Items.Count-1 do
              ClrNodeData(Items[i]);
        end;

      {Reset Layer Bounding Rectangles}
      srf_bmp_rct:=Default(TPtRect);

      {Reset Texture}
      is_tex_enabled :=False;
      loaded_picture.Clear;
      loaded_picture :=Graphics.TPicture.Create;
      tex_bmp_rct_pts:=tex_bmp_rct_origin_pts;

      {Reset Miscellaneous Parameters}
      L_Object_Info.Caption             :='';
      FP_Image_List.Caption             :='Texture List is Empty';
      L_Object_Info.Visible             :=False;
    //MI_Antialiasing.Checked           :=False;
    //srf_bmp.Canvas.Antialiasingmode   :=amOff;
      EventGroupsCalc(calc_arr,[0,1,2]);

    end;}
end; {$endregion}
{$endregion}

procedure WaterWave4Test(const pts:TPtPosFArr;                           const dt:double; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; constref color_info:TColorInfo); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  pt   : TPtPosF;
  v0   : double=100;
  m    : double=100;
  sig  : double=1;
  ro   : double=1000;
  g    : double=GRAVITY;
  r    : double;
  c    : double;
  A    : double;
  d0,d1: double;
  i    : integer;
  k    : integer=0;                                         //exp(d0) <=A/2
begin
  r:=pts[0].y;                                                 //d0<=0
  k:=Length(pts)>>1;
  c:=sqrt(g*r);
  A:=(m*v0)/(ro*sig);                                      //d0<=ln(A/2);   Abs(pts[i].x-pts[k].x-c*dt)/sig<=sqrt(ln(A/2))

  F_MainForm.M_Test_Log.Lines.Text:=IntToStr(Trunc(c*dt{A/2}));

  for i:=0 to Length(pts)-1 do
    begin
      d0  :=sqr((pts[i].x-pts[k].x-c*dt)/sig);
      d1  :=sqr((pts[i].x-pts[k].x+c*dt)/sig);
      {if Trunc(exp(d0))=0 then
        Halt;}
      pt.y:=r+((1/exp(d0))+(1/exp(d1)))*(A/2);
      Point(Trunc(pts[i].x),
            Trunc(pt.y),
            bmp_dst_ptr,
            bmp_dst_width,
            rct_clp,
            color_info);
    end;
end; {$endregion}
procedure WaterWave5Test(var   pts:TPtPosFArr; const sln_pts:TPtPosFArr; const dt:double; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; constref color_info:TColorInfo); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_clp_2: TPtRect;
  pt       : TPtPosF;
  pt_start : TPtPosF;
  v0       : double=100;
  m        : double=100;
  sig      : double=1;
  ro       : double=1000;
  g        : double=GRAVITY;
  r        : double;
  c        : double;
  A        : double;
  d0,d1    : double;
  dy       : double;
  i        : integer;
  k        : integer=0;
begin
  rct_clp_2:=PtRct(rct_clp.left  +1,
                   rct_clp.top   +1,
                   rct_clp.right -1,
                   rct_clp.bottom-1);
  dy:=dy0;
  //pts[0].y:=sln_pts[0].y;
  pts[0].y+=dy;
  pt_start.x:=0;//cur_pos.x-pts[Length(pts)-1].x;
  pt_start.y:=0;//cur_pos.y-pts[Length(pts)-1].y;
  for i:=0 to Length(pts)-1 do
    if (i<>0) then
      begin
        dy      :=dy/(i+1);
        //pts[i].y:=sln_pts[i].y;
        pts[i].y+=dy;
      end;
  for i:=0 to Length(pts)-2 do
    LineAC(Trunc(pts[i+0].x+pt_start.x),
           Trunc(pts[i+0].y+pt_start.y),
           Trunc(pts[i+1].x+pt_start.x),
           Trunc(pts[i+1].y+pt_start.y),
           bmp_dst_ptr,
           bmp_dst_width,
           rct_clp_2,
           color_info);
  for i:=0 to Length(pts)-1 do
    Point(Trunc(pts[i].x+pt_start.x),
          Trunc(pts[i].y+pt_start.y),
          bmp_dst_ptr,
          bmp_dst_width,
          rct_clp,
          color_info);
end; {$endregion}
procedure WaterWave6Test(var   pts:TPtPosFArr; const sln_pts:TPtPosFArr; const dt:double; constref bmp_dst_ptr:PInteger; constref bmp_dst_width:TColor; constref rct_clp:TPtRect; constref color_info:TColorInfo); {$ifdef Linux}[local];{$endif} {$region -fold}
var
  rct_clp_2: TPtRect;
  pt       : TPtPosF;
  pt_start : TPtPosF;
  v0       : double=100;
  m        : double=100;
  sig      : double=1;
  ro       : double=1000;
  g        : double=GRAVITY;
  r        : double;
  c        : double;
  A        : double;
  d0,d1    : double;
  dy       : double;
  i        : integer;
  k        : integer=0;
begin
  rct_clp_2:=PtRct(rct_clp.left  +1,
                   rct_clp.top   +1,
                   rct_clp.right -1,
                   rct_clp.bottom-1);
  dy:=dy0;
  //pts[0].y:=sln_pts[0].y;
  pts[0].y+=dy;
  pt_start.x:=0;//cur_pos.x-pts[Length(pts)-1].x;
  pt_start.y:=0;//cur_pos.y-pts[Length(pts)-1].y;
  for i:=0 to Length(pts)-1 do
    if (i<>0) then
      begin
        dy      :=dy/(i+1);
        //pts[i].y:=sln_pts[i].y;
        pts[i].y+=dy;
      end;
  for i:=0 to Length(pts)-1 do
    Point(Trunc(pts[i].x+pt_start.x),
          Trunc(pts[i].y+pt_start.y),
          bmp_dst_ptr,
          bmp_dst_width,
          rct_clp,
          color_info);
end; {$endregion}

// (Game Loop) Игровой цикл:
{LI} {$region -fold}
{$endregion}
{UI} {$region -fold}
procedure TF_MainForm.T_Editor_TimeTimer(sender:TObject);                   {$region -fold}
var
  t1,t2: TDateTime;
  i,j,k: integer;
begin
  {M_Test_Log.Lines.Text:='';
  with sln_var do
    if (sln_obj_cnt<>0) then
      for i:=0 to sln_obj_cnt-1 do
        M_Test_Log.Lines.Add(IntToStr(has_sel_pts[i])+';'+IntToStr(has_mod_pts0[i])+';'+IntToStr(has_mod_pts1[i])+';'+#13);}

  {F_MainForm.M_Test_Log.Lines.Text:='';
  F_MainForm.M_Test_Log.Lines.Text:=IntToStr(Byte(srf_var.form_resized));}
  //M_Test_Log.Lines.Text:=IntToStr(obj_var.sel_cnt);

  Inc(obj_tags_repaint_counter);
  ObjectTagsListRepaint;
  if (obj_tags_repaint_counter>=100) then
    begin
      obj_tags_repaint_counter:=0;
      T_Editor_Time.Enabled   :=False;
      Exit;
    end;

{
  t1:=Now;
  with srf_var do
    PPAlphaBlendMT0(srf_bmp_ptr,   //test_arr_ptr,
                    srf_bmp.width, //test_arr_width,
                    srf_bmp.height,//test_arr_height,
                    TPtRect_(srf_var.inn_wnd_rct),
                    SetColorInv(clGreen),
                    040);

  {with srf_var do
    begin
      //srf_bmp.BeginUpdate(True);
      TThread.Synchronize(TThread.CurrentThread,@Update);
      for k:=0 to usable_threads_cnt-1 do
        begin
          StartIdx:=k*ChunkSize;
          if (k=usable_threads_cnt-1) then
            EndIdx:={srf_bmp.width*srf_bmp.height}Length(test_arr)-1
          else
            EndIdx:=(k+1)*ChunkSize-1;
          thread_obj_arr[k]:=TArrThread.Create(StartIdx,
                                               EndIdx,
                                               {srf_bmp_}test_arr_ptr,
                                               {srf_bmp.}test_arr_width,
                                               {srf_bmp.}test_arr_height,
                                               TPtRect_(inn_wnd_rct),
                                               clGreen,//SetColorInv(clGreen),
                                               040);
        end;
      TThread.Synchronize(TThread.CurrentThread,@Update);
      // Ждём завершения всех потоков
      for k:=0 to usable_threads_cnt-1 do
        begin
          thread_obj_arr[k].WaitFor;
          thread_obj_arr[k].Free;
        end;
      TThread.Synchronize(TThread.CurrentThread,@Update);
      //
      //srf_bmp.EndUpdate(True);
    end;}


  t2:=Now;
  F_MainForm.M_Test_Log.Lines.Text:='';
  F_MainForm.M_Test_Log.Lines.Text:=FloatToStrF(100000000*(t2-t1),ffFixed,10,10);
}

end; {$endregion}
procedure TF_MainForm.T_Game_LoopTimer  (sender:TObject);                   {$region -fold}
var
  sln_pts_ptr          : PPtPosF;
  obj_arr_ptr          : PObjProp;
  w1,w2                : integer;
  i,j                  : integer;
  color_info           : TColorInfo;
  cur_pt               : TPtPosF;
  w_a_s_x,w_a_s_y      : integer;
  x0,y0,x1,y1          : integer;

  tlmap_ind            : TColor;

  tmp_pt               : TPtPos;

  x0_proj,y0_proj,x1_proj,y1_proj: integer;
  pt_in_rct0,pt_in_rct1: boolean;

  pixels_per_block_y0__: integer;
  pixels_per_block_y1__: integer;
  index__              : PtrInt;
  block_count__        : integer;
  color__              : TColor;

  ccc                  : TColor=0;
  frame_shift          : integer;
  anim_err             : integer;
  anim_err0            : integer=0;
  anim_err1            : integer=0;
  dir_angle            : double;
 {t                    : integer;
  vec_x_dist_sht       : integer;
  velocity             : integer=4;
  distance             : integer=4;
  sprite_rect_arr_ptr  : PPtPos;
  useless_arr_ptr      : PByte;
  m                    : byte;
  f                    : TPtPos;
  n                    : integer;
  x0,y0,x1,y1,v1,w1,k,b: double;
  str                  : string;
  projectile_arr_ptr   : PProjectile;}

  inn_wnd_rct_2        : TPtRect;
  inn_wnd_rct_3        : TPtRect;

  __i__ ,__j__ ,__x__ ,__y__: integer;
  __u__0,__v__0,__u__1,__v__1,__u__2,__v__2,__u__3,__v__3,__I2__,__J2__,__D1__,__D2__: integer;
  __A1__,__A2__,__C1__,__C2__,__B1__,__B2__: double;

label
  l1,l2,l3,l4,l5,l6;
begin

  if (WindowState=wsMinimized) then
    Exit;

  LockCursorToWindow;

  {Inc(session_time);
  if (session_time=MAXDWORD) then
      session_time:=0;

  if (session_time=300) then
    begin
      LCLVLCPlayer_Intro.Stop;
      Panel1.Enabled:=False;
      Panel1.Visible:=False;
    end;}

  //M_Test_Log.Lines.Text:=IntToStr(session_time);

  with obj_var,cmr_var,srf_var,sln_var,fast_physics_var,fast_fluid_var do
    begin

      {Update Animation-----------------------------} {$region -fold}
      // TODO
      // Example:
      {FXAnimPingPong(fx_inc_check,5,5,fx,0.0,255.0);
      for i:=0 to Length(sprite_sheet_arr)-1 do
        with sprite_sheet_arr[i],fast_image_data,fast_image_proc_var do
          begin
            fast_image_data_ptr0:=@fast_image_data;
            for j:=0 to 10 do
              col_trans_arr[j]:=Trunc(fx);
          end;}
      {$endregion}

      {Resize Scene---------------------------------} {$region -fold}
      if scene_resize_calc then
        begin
          {scene_resize_calc:=False;
          if scale_scene_calc or repaint_spline_calc then
            SetRctDstPtr(@inn_wnd_rct,0,low_lr_obj_cnt-1);
          SetObjBkgnd
          (
            srf_bmp_ptr,
            srf_bmp.width,
            srf_bmp.height,
            @inn_wnd_rct,
            0,
            low_lr_obj_cnt-1
          );
          scale_scene_calc :=True;
          spline_scale_calc:=True;
          rectangles_calc  :=True;}
          if (scl_dir=sdDown) then
            Dec(scl_dif)
          else
          if (scl_dir=sdUp  ) then
            Inc(scl_dif);
          SetRctDstPtr(@inn_wnd_rct,0,obj_cnt-1);
          EventGroupsCalc(calc_arr,[18,19,29,{30,}32,41,52,55]);
          scene_resize_calc:=False;
          {SceneSclPowCalc;
          SclSplineCalc;
          RepSplineDraw0;
          scale_scene_calc :=False;
          spline_scale_calc:=False;
          rectangles_calc  :=False;
          FilScene(0,low_lr_obj_cnt-1);
          SetObjBkgnd
          (
            low_bmp_ptr,
            low_bmp.width,
            low_bmp.height,
            @inn_wnd_rct,
            0,
            low_lr_obj_cnt-1
          );}
          goto l1;
        end;
      {$endregion}

      {Draw Objects of Lower Layer------------------} {$region -fold}
      exec_time0:=0;
      exec_timer.Start;

      {Refresh Lower Layer} {$region -fold}
      {if (refresh_lower_layer and is_camera_moving) then
        RefreshLowerLayer;}
      {$endregion}

      {Move    Lower Layer} {$region -fold}
      if dir_a then
        begin
          MovLeft;
          if (low_bmp_draw and (spd_mul.x*obj_arr[0].parallax_shift.x<>0)) then
            begin
              FilLeft;
              MovScene(0,low_lr_obj_cnt-1);
            end;
        end;
      if dir_d then
        begin
          MovRight;
          if (low_bmp_draw and (spd_mul.x*obj_arr[0].parallax_shift.x<>0)) then
            begin
              FilRight;
              MovScene(0,low_lr_obj_cnt-1);
            end;
        end;
      if dir_w then
        begin
          MovUp;
          if (low_bmp_draw and (spd_mul.y*obj_arr[0].parallax_shift.y<>0)) then
            begin
              FilUp;
              MovScene(0,low_lr_obj_cnt-1);
            end;
        end;
      if dir_s then
        begin
          MovDown;
          if (low_bmp_draw and (spd_mul.y*obj_arr[0].parallax_shift.y<>0)) then
            begin
              FilDown;
              MovScene(0,low_lr_obj_cnt-1);
            end;
        end;
      exec_timer.Stop;
      exec_time0:=Trunc(exec_timer.Delay*1000);
      l1:
      exec_timer.Start;
      if low_bmp_draw then
        LowerBmpToMainBmp
      else
        PPFloodFill(srf_bmp_ptr,srf_bmp.width,inn_wnd_rct,bg_col,flood_fill_inc);
      flood_fill_inc:=not flood_fill_inc;
      {$endregion}

      exec_timer.Stop;
      exec_time0+=Trunc(exec_timer.Delay*1000);
      {$endregion}

      {Draw Objects of Upper Layer------------------} {$region -fold}
      exec_time1:=0;
      exec_timer.Start;

      if (upp_lr_obj_cnt>0) then
        begin
          if dir_a then
            CameraMove(dir_w,dir_s,mdLeftUp  ,mdLeftDown ,mdLeft );
          if dir_d then
            CameraMove(dir_w,dir_s,mdRightUp ,mdRightDown,mdRight);
          if dir_w then
            CameraMove(dir_a,dir_d,mdLeftUp  ,mdRightUp  ,mdUp   );
          if dir_s then
            CameraMove(dir_a,dir_d,mdLeftDown,mdRightDown,mdDown );

          {Splines Sprites Streaming} {$region -fold}
          RctSplineAll2(0,obj_cnt-1);
          RepSplineDraw1; {$endregion}

          SetRctDstPtr(@inn_wnd_rct,low_lr_obj_cnt,obj_cnt-1);
          MovScene    (             low_lr_obj_cnt,obj_cnt-1);
          // Multi-Threading Test:
          // MovSceneMT  ( inn_wnd_rct,low_lr_obj_cnt,obj_cnt-1,4);

        end;

      exec_timer.Stop;
      exec_time1+=Trunc(exec_timer.Delay*1000);
      {$endregion}

      {World Axis-----------------------------------} {$region -fold}
      if show_world_axis then
        WorldAxisDraw;
      {$endregion}

      {Tests----------------------------------------} {$region -fold}

      {Test: Bullets--------------------------------} {$region -fold}
      {begin
        SetColorInfo2(clBlue,color_info);
        for i:=0 to 10 do
          begin
            if PointCollDraw(vec_x,
                             vec_y,
                             width,
                             coll_box_arr,
                             inn_wnd_rct,
                             0) then
              begin
                vec_x         -=0{velocity}{d.x-t+Random(t<<1)};
                vec_x_dist_sht:=vec_x-i*distance;
              end
            else
              begin
                vec_x         +=velocity{d.x-t+Random(t<<1)};
                vec_x_dist_sht:=vec_x+i*distance;
              end;
            Point(vec_x_dist_sht,
                  vec_y,
                  srf_bmp_ptr,
                  srf_bmp.width,
                  color_info,
                  inn_wnd_rct);
          end;
        ArrClear(coll_box_arr,inn_wnd_rct,width);
      end;}
      {$endregion}

      {Test: Fluid Simul. 1-------------------------} {$region -fold}
      {if (sln_pts_cnt>0) then
        begin
          dir_angle:=000;
          if dir_a then
            dir_angle:=090;
          if dir_d then
            dir_angle:=270;
          if dir_s then
            dir_angle:=180;
          if dir_w then
            dir_angle:=000;

          SetColorInfo2({clDkGray}clRed{clGray},color_info);
          for i:=0 to sln_obj_cnt-1 do
            for j:=partial_pts_sum[i] to partial_pts_sum[i]+sln_obj_pts_cnt[i]-1 do
              begin
                WaterWaveInit3(PtPosF(sln_pts[j].x,
                                      sln_pts[j].y));
                WaterWave3(PtPosF(sln_pts[j].x,
                                  sln_pts[j].y),
                           PtPosF(obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].world_axis_shift.x,
                                  obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].world_axis_shift.y),
                           3,
                           90+dir_angle,
                           8,
                           srf_bmp_ptr,
                           srf_bmp.width,
                           color_info,
                           inn_wnd_rct);
              end;

          //WaterWaveParamChg(a0,001,00,00);
          //WaterWaveParamChg(a3,0.5,00,80);

          SetColorInfo2({clBlack}{clAqua}clYellow{clBlack},color_info);
          for i:=0 to sln_obj_cnt-1 do
            for j:=partial_pts_sum[i] to partial_pts_sum[i]+sln_obj_pts_cnt[i]-1 do
              begin
                WaterWaveInit3(PtPosF(sln_pts[j].x,
                                      sln_pts[j].y));
                WaterWave3(PtPosF(sln_pts[j].x,
                                  sln_pts[j].y),
                           PtPosF(obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].world_axis_shift.x,
                                  obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]].world_axis_shift.y),
                           3,
                           90+dir_angle,
                           8,
                           srf_bmp_ptr,
                           srf_bmp.width,
                           color_info,
                           inn_wnd_rct);
              end;

        //WaterWaveParamChg(a0,001,00,00);
          WaterWaveParamChg(a3,0.5,00,80);

        end;}

      {WaterWave2(PtPosF(world_axis.x,
                         world_axis.y),
                  PtPosF(world_axis_shift.x,
                         world_axis_shift.y),
                  4,
                  -90,
                  64,
                  srf_bmp_ptr,
                  srf_bmp.width,
                  color_info,
                  inn_wnd_rct);}
      {if (sln_pts_cnt>0) then
        begin
          WaterWaveArea(sln_pts,
                        sln_pts_cnt-sln_obj_pts_cnt[sln_obj_cnt-1],
                        sln_pts_cnt);
          SetColorInfo(clRed{clRed},color_info);
          for i:=sln_pts_cnt-sln_obj_pts_cnt[sln_obj_cnt-1] to sln_pts_cnt-2 do
            Line(Trunc(sln_pts[i+0].x),
                 Trunc(sln_pts[i+0].y),
                 Trunc(sln_pts[i+1].x),
                 Trunc(sln_pts[i+1].y),
                 srf_bmp_ptr,
                 srf_bmp.width,
                 color_info,
                 inn_wnd_rct);
          SetColorInfo2(clRed{clWhite},color_info);
          for i:=sln_pts_cnt-sln_obj_pts_cnt[sln_obj_cnt-1] to sln_pts_cnt-1 do
            Point(Trunc(sln_pts[i].x),
                  Trunc(sln_pts[i].y),
                  srf_bmp_ptr,
                  srf_bmp.width,
                  color_info,
                  inn_wnd_rct);
        end;}
      {$endregion}

      {Test: Fluid Simul. 2-------------------------} {$region -fold}
      {SetColorInfo(clAqua,color_info);
      for i:=0 to Trunc(srf_bmp.width/5)-4 do
        for j:=0 to Trunc(srf_bmp.height/5)-4 do
          begin
            CircleC
            (
              10+i*5,
              10+j*5,
              2,
              srf_bmp_ptr,
              inn_wnd_rct,
              srf_bmp.width,
              color_info.pix_col
            );
            {CircleFloodFill2
            (
              10+i*5,
              10+j*5,
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              color_info,
              7,
              32
            );}
            {CircleHighlight011
            (
              10+i*4,
              10+j*4,
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              color_info,
              9,
              255
            );}
          end;}
      {
      inn_wnd_rct_2:=PtRct
      (
        inn_wnd_rct.left  +10,
        inn_wnd_rct.top   +10,
        inn_wnd_rct.right -10,
        inn_wnd_rct.bottom-10
      );
      inn_wnd_rct_3:=PtRct
      (
        inn_wnd_rct.left  +10,
        inn_wnd_rct.top   +300,
        inn_wnd_rct.right -10,
        inn_wnd_rct.bottom-300
      );
      PPDarken
      (
        srf_bmp_ptr,
        inn_wnd_rct_3,
        srf_bmp.width
      );
      for j:=0 to 400-1 do
        for i:=0 to 400-1 do
          with br_vec_projectile_arr[i+400*j] do
            with projectile_mov_vec do
              begin

                {x0_proj:=Trunc(world_axis_shift.x+x0);
                y0_proj:=Trunc(world_axis_shift.y+y0);
                x1_proj:=Trunc(world_axis_shift.x+projectile_curr_pos.x);
                y1_proj:=Trunc(world_axis_shift.y+projectile_curr_pos.y);
                LineC(x0_proj,y0_proj,x1_proj,y1_proj,inn_wnd_rct_3);
                  begin
                    SetColorInfo2(clBlack,color_info);
                    Point(x0_proj,
                          y0_proj,
                          srf_bmp_ptr,
                          srf_bmp.width,
                          color_info,
                          inn_wnd_rct);
                    SetColorInfo2(clWhite,color_info);
                    Point(x1_proj,
                          y1_proj,
                          srf_bmp_ptr,
                          srf_bmp.width,
                          color_info,
                          inn_wnd_rct);
                  end;} //

                if (x0=x1) and (y0=y1) then
                  goto l3;

                if (projectile_dir_tick_counter0>=projectile_dir_tick_c_lim) then
                  begin
                    projectile_rnd              :=1-2*Random(2);//2*(1-Random(2))-1;
                    x0                          :=projectile_curr_pos.x;
                    y0                          :=projectile_curr_pos.y;
                    x1                          :=x0+projectile_rnd*(Random(100)+1);
                    y1                          :=y0+projectile_rnd*(Random(100)+1);
                    projectile_dir_tick_counter0:=0;
                    projectile_dir_tick_counter1:=0;
                  end;
                if (projectile_mov_vec.x0<=projectile_mov_vec.x1) then
                  projectile_dir:=+1
                else
                  projectile_dir:=-1;

                projectile_curr_pos:=LineS(x0,y0,x1,y1,projectile_dir*projectile_dir_tick_counter1);

                pt_in_rct0:=IsPtInRct
                (
                  x0+world_axis_shift.x,
                  y0+world_axis_shift.y,
                  inn_wnd_rct_3
                );
                pt_in_rct1:=IsPtInRct
                (
                  projectile_curr_pos.x+world_axis_shift.x,
                  projectile_curr_pos.y+world_axis_shift.y,
                  inn_wnd_rct_3
                );
                if (pt_in_rct0<>pt_in_rct1) then
                  begin
                    x1:=projectile_curr_pos.x;
                    y1:=projectile_curr_pos.y;
                    x0:=x1;
                    y0:=y1;
                  end;

                l3:
                {SetColorInfo(clPurple,color_info);
                LineAC(Round(world_axis_shift.x+x0),
                       Round(world_axis_shift.y+y0),
                       Round(world_axis_shift.x+projectile_curr_pos.x),
                       Round(world_axis_shift.y+projectile_curr_pos.y),
                       srf_bmp_ptr,
                       srf_bmp.width,
                       color_info,
                       inn_wnd_rct);}
                SetColorInfo2(clAqua,color_info);
                {Point(Round(x0+world_axis_shift.x),
                      Round(y0+world_axis_shift.y),
                      srf_bmp_ptr,
                      srf_bmp.width,
                      color_info,
                      inn_wnd_rct);}

                Point ////
                (
                  Round(projectile_curr_pos.x+world_axis_shift.x),
                  Round(projectile_curr_pos.y+world_axis_shift.y),
                  srf_bmp_ptr,
                  srf_bmp.width,
                  color_info,
                  inn_wnd_rct
                );
                {CircleHighlight001
                (
                  Round(projectile_curr_pos.x+world_axis_shift.x),
                  Round(projectile_curr_pos.y+world_axis_shift.y),
                  srf_bmp_ptr,
                  inn_wnd_rct_2,
                  srf_bmp.width,
                  color_info,
                  5,
                  255
                );}
                {CircleHighlight011
                (
                  Round(projectile_curr_pos.x+world_axis_shift.x),
                  Round(projectile_curr_pos.y+world_axis_shift.y),
                  srf_bmp_ptr,
                  inn_wnd_rct_2,
                  srf_bmp.width,
                  color_info,
                  11,
                  255
                );}
                {CircleC
                (
                  Round(projectile_curr_pos.x+world_axis_shift.x),
                  Round(projectile_curr_pos.y+world_axis_shift.y),
                  17,
                  srf_bmp_ptr,
                  inn_wnd_rct,
                  srf_bmp.width,
                  color_info.pix_col
                );}

                {pvt_var.SelectionToolsMarkerDraw
                (
                  Round(projectile_curr_pos.x+world_axis_shift.x),
                  Round(projectile_curr_pos.y+world_axis_shift.y)
                );}

                {x0_proj:=Trunc(world_axis_shift.x+x0);
                y0_proj:=Trunc(world_axis_shift.y+y0);
                x1_proj:=Trunc(world_axis_shift.x+projectile_curr_pos.x);
                y1_proj:=Trunc(world_axis_shift.y+projectile_curr_pos.y);
                LineC(x0_proj,y0_proj,x1_proj,y1_proj,inn_wnd_rct_3);
                  begin
                    SetColorInfo2(clBlack,color_info);
                    Point(x0_proj,
                          y0_proj,
                          srf_bmp_ptr,
                          srf_bmp.width,
                          color_info,
                          inn_wnd_rct);
                    SetColorInfo2(clWhite,color_info);
                    Point(x1_proj,
                          y1_proj,
                          srf_bmp_ptr,
                          srf_bmp.width,
                          color_info,
                          inn_wnd_rct);
                    {if (x1_proj<>Trunc(world_axis_shift.x+projectile_curr_pos.x)) or
                       (y1_proj<>Trunc(world_axis_shift.y+projectile_curr_pos.y)) then
                      projectile_dir:=-1;}
                  end;}

                Inc(projectile_dir_tick_counter0,projectile_dir_tick_inc0);
                Inc(projectile_dir_tick_counter1,projectile_dir_tick_inc1);
              end;
      PPBDec(srf_bmp_ptr,
             inn_wnd_rct_3,
             srf_bmp.width,
             0,
             @BlurRGGDec);}
      {$endregion}

      {Test: Fluid Simul. 3-------------------------} {$region -fold}
      {frame_counter+=1;
      {FXAnimPingPong(fx_inc_check,0.01,0.01,dy0,00,100,dir_);
      if not (dir_=mdDown) then
        dy0*=-1;}
      dy0:=1/sqrt(frame_counter);
      //F_MainForm.M_Test_Log.Lines.Text:=FloatToStrF(dy0,ffFixed,1,3);

      SetColorInfo2(clYellow,color_info);
      if (sln_pts_cnt<>0) then
        WaterWave5Test(sln_pts_res,
                       sln_pts,
                       frame_counter,
                       srf_bmp_ptr,
                       srf_bmp.width,
                       inn_wnd_rct,
                       color_info);}
      {$endregion}

      {Test: Equidistant Curves---------------------} {$region -fold}
      {with inn_wnd_rct do
        begin
          //ArrClear(coll_arr,PtRct(left,top,right-1,bottom-1),srf_bmp.width);
          LineBCE3
          (
            sln_pts,
            0,
            sln_pts_cnt-1,
            @coll_arr[0],
            srf_bmp.width,
            PtRct(left,top,right-1,bottom-1),
            PtPos(0,0){world_axis_shift},
            projectile_arr[0].c_rad,
            {True}False
          );
          {ArrFill(coll_arr,
                  srf_bmp_ptr,
                  srf_bmp.width,
                  srf_bmp.height,
                  PtRct(left,top,right-1,bottom-1),
                  clGreen);}
          LineBCE{LineABCE}
          (
            sln_pts,
            0,
            sln_pts_cnt-1,
            srf_bmp_ptr,
            srf_bmp.width,
            color_info,
            PtRct(left,top,right-1,bottom-1),
            world_axis_shift,
            projectile_arr[0].c_rad,
            {True}False
          ); //
        end;}
      {$endregion}

      {Test: Projectile-----------------------------} {$region -fold}
      {projectile_arr_ptr:=Unaligned(@projectile_arr[0]);
      for i:=0 to 0{9999} do
        with projectile_arr_ptr^ do
          begin

            {Proj. Collision Calc.} {$region -fold}
            Projectile(projectile_arr_ptr^,@coll_arr[0],srf_bmp.width,inn_wnd_rct,sln_pts); {$endregion}

            {Proj. Shape Drawing--} {$region -fold}
            CircleHighlight(Trunc(pt_n.x)+world_axis_shift.x,
                            Trunc(pt_n.y)+world_axis_shift.y,
                            low_bmp_ptr,
                            inn_wnd_rct,
                            srf_bmp.width,
                            Default(TColorInfo),
                            c_rad,
                            255);
            CircleC(Trunc(pt_n.x)+world_axis_shift.x,
                    Trunc(pt_n.y)+world_axis_shift.y,
                    c_rad,
                    srf_bmp_ptr,
                    inn_wnd_rct,
                    srf_bmp.width,
                    clBlue);
            {x0:=pt_p.x;
            y0:=pt_p.y;
            x1:=pt_n.x;
            y1:=pt_n.y;
            if LineC(Trunc(x0),
                     Trunc(y0),
                     Trunc(x1),
                     Trunc(y1),
                     inn_wnd_rct) then
              begin

                {n :=8;
                v1:=x1+n*(x1-x0);
                k :=(y1-y0)/(x1-x0);
                b :=(x1*y0-x0*y1)/(x1-x0);
                w1:=k*v1+b;
                SetColorInfo(clPurple,color_info);
                LineAC(Trunc(x0)+world_axis_shift.x,
                       Trunc(y0)+world_axis_shift.y,
                       Trunc(v1)+world_axis_shift.x,
                       Trunc(w1)+world_axis_shift.y,
                       srf_bmp_ptr,
                       srf_bmp.width,
                       color_info,
                       inn_wnd_rct);}
                {SetColorInfo2(clBlue,color_info);
                Point(Trunc(pt_p.x)+world_axis_shift.x,
                      Trunc(pt_p.y)+world_axis_shift.y,
                      srf_bmp_ptr,
                      srf_bmp.width,
                      color_info);
                SetColorInfo2(clGreen,color_info);
                Point(Trunc(pt_n.x)+world_axis_shift.x,
                      Trunc(pt_n.y)+world_axis_shift.y,
                      srf_bmp_ptr,
                      srf_bmp.width,
                      color_info);
                SetColorInfo2(clYellow,color_info);
                Point(Trunc(pt_c.x)+world_axis_shift.x,
                      Trunc(pt_c.y)+world_axis_shift.y,
                      srf_bmp_ptr,
                      srf_bmp.width,
                      color_info);}
              end;} {$endregion}

            Inc(projectile_arr_ptr);
          end;
      with inn_wnd_rct do
        ArrClear(coll_arr,PtRct(left,top,right-1,bottom-1),srf_bmp.width);}
      {$endregion}

      {Test: Points Cloud 1-------------------------} {$region -fold}
      {SetColorInfo2(clRed,color_info);
      w1:=Trunc(world_axis.x+world_axis_shift.x);
      w2:=Trunc(world_axis.y+world_axis_shift.y);
      exec_timer.Start;
      for i:=0 to 500000 do
        Point(w1-test_pos_arr[i].x,//Trunc(tex_bmp_rct_pts[0].x)+Random(Trunc(tex_bmp_rct_pts[1].x-tex_bmp_rct_pts[0].x)-1)+1,
              w2-test_pos_arr[i].y,//Trunc(tex_bmp_rct_pts[0].y)+Random(Trunc(tex_bmp_rct_pts[1].y-tex_bmp_rct_pts[0].y)-1)+1,
              srf_bmp_ptr,
              srf_bmp.width,
              color_info,
              inn_wnd_rct);
      exec_timer.Stop;
      exec_time1:=Trunc(exec_timer.Delay*1000);}
      {$endregion}

      {Test: Points Cloud 2-------------------------} {$region -fold}
      {exec_timer.Start;
      SetColorInfo2(clRed,color_info);
      if (sln_obj_cnt<>0) then
        begin
          sln_pts_ptr:=Unaligned(@sln_pts[partial_pts_sum[0]]);
          obj_arr_ptr:=@obj_arr[curve_inds_obj_arr[0]];
          w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
          w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
          for i:=0 to sln_obj_pts_cnt[0]-1 do
            begin
              Point(Trunc(sln_pts_ptr^.x)+w_a_s_x,
                    Trunc(sln_pts_ptr^.y)+w_a_s_y,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    color_info,
                    inn_wnd_rct);
              Inc(sln_pts_ptr);
            end;
        end;
      exec_timer.Stop;
      exec_time1:=Trunc(exec_timer.Delay*1000);}
      {$endregion}

      {Test: Point in Polygon-----------------------} {$region -fold}
      {if (sln_pts_cnt>2) then
        begin
          w_a_s_x   :=Trunc(obj_arr[curve_inds_obj_arr[0]].world_axis_shift.x);
          w_a_s_y   :=Trunc(obj_arr[curve_inds_obj_arr[0]].world_axis_shift.y);
          cur_pt    :=PtPosF(cur_pos.x-w_a_s_x,cur_pos.y-w_a_s_y);
          exec_time1:=Trunc(GaussSumTrisArea(sln_obj_pts_cnt[0],@sln_pts[0],@cur_pt)-GaussPolygonArea(sln_obj_pts_cnt[0],@sln_pts[0]));
        end;}
      {$endregion}

      {Test: Projectile Movement 1------------------} {$region -fold}
      {with srf_var,obj_var,projectile_mov_vec do
        if (tlmap_cnt<>0) then
          begin
            tlmap_ind:=obj_arr[obj_inds_arr[Length(tlm_var.tilemap_inds_arr)-1]].k_ind;
            with sprite_sheet_arr[tlm_var.tilemap_inds_arr[tlmap_ind]],fast_image_data,fast_image_proc_var do
              begin
                fast_image_data_ptr0:=@fast_image_data;
                obj_arr_ptr         :=@obj_arr[tlmap_inds_obj_arr[tlmap_ind]];

                //if (not collision_detect.coll_det) then
                  begin
                    if (projectile_dir_tick_counter0>=projectile_dir_tick_c_lim)      or collision_detect.coll_det      then
                      begin
                        projectile_rnd0             :=1-2*Random(2);
                        projectile_rnd1             :=1-2*Random(2);
                        x0                          :=projectile_curr_pos.x;
                        y0                          :=projectile_curr_pos.y;
                        x1                          :=x0+projectile_rnd0*(Random(100)+1);
                        y1                          :=y0+projectile_rnd1*(Random(100)+1);
                        projectile_dir_tick_counter0:=0;
                        projectile_dir_tick_counter1:=0;
                      end;
                    if (projectile_mov_vec.x0<=projectile_mov_vec.x1) then
                      projectile_dir:=+1
                    else
                      projectile_dir:=-1;
                    projectile_curr_pos:=LineS(x0,y0,x1,y1,projectile_dir*projectile_dir_tick_counter1);

                    collision_detect:=CollisionTest2(Trunc(obj_arr_ptr^.world_axis_shift.x+x0),
                                                     Trunc(obj_arr_ptr^.world_axis_shift.y+y0),
                                                     Trunc(obj_arr_ptr^.world_axis_shift.x+projectile_curr_pos.x),
                                                     Trunc(obj_arr_ptr^.world_axis_shift.y+projectile_curr_pos.y));
                    if collision_detect.coll_det then
                      begin
                        projectile_curr_pos.x:=collision_detect.pt_c.x-obj_arr_ptr^.world_axis_shift.x;
                        projectile_curr_pos.y:=collision_detect.pt_c.y-obj_arr_ptr^.world_axis_shift.y;
                      end;
                  end;

                projectile_mov_vec2.x0:=Trunc(obj_arr_ptr^.world_axis_shift.x+x0);
                projectile_mov_vec2.y0:=Trunc(obj_arr_ptr^.world_axis_shift.y+y0);
                projectile_mov_vec2.x1:=Trunc(obj_arr_ptr^.world_axis_shift.x+projectile_curr_pos.x);
                projectile_mov_vec2.y1:=Trunc(obj_arr_ptr^.world_axis_shift.y+projectile_curr_pos.y);

                {draw projectile} {$region -fold}
                SetColorInfo(clPurple,color_info);
                LineAC(projectile_mov_vec2.x0,
                       projectile_mov_vec2.y0,
                       projectile_mov_vec2.x1,
                       projectile_mov_vec2.y1,
                       srf_bmp_ptr,
                       srf_bmp.width,
                       inn_wnd_rct,
                       color_info);
                SetColorInfo2(clRed,color_info);
                Point(projectile_mov_vec2.x0,
                      projectile_mov_vec2.y0,
                      srf_bmp_ptr,
                      srf_bmp.width,
                      inn_wnd_rct,
                      color_info);
                CircleC
                (
                  projectile_mov_vec2.x1,
                  projectile_mov_vec2.y1,
                  16,
                  srf_bmp_ptr,
                  srf_bmp.width,
                  inn_wnd_rct,
                  color_info.pix_col
                ); {$endregion}

                //if (not collision_detect.coll_det) then
                  begin
                    Inc(projectile_dir_tick_counter0,projectile_dir_tick_inc0);
                    Inc(projectile_dir_tick_counter1,projectile_dir_tick_inc1);
                  end;

              end;

          end;
      {Grid Calc.} {$region -fold}
      {if (sln_pts_cnt<>0) then
        begin

          w_a_s_x:=Trunc(obj_arr[curve_inds_obj_arr[0]].world_axis_shift.x);
          w_a_s_y:=Trunc(obj_arr[curve_inds_obj_arr[0]].world_axis_shift.y);

          FillDWord(pt_ind_arr[0],Length(pt_ind_arr),0);
          //ccc:=PtsSimplify1(@sln_pts[0],@pt_ind_arr[0],sln_pts_cnt,28);
          ccc:=PtsSimplify0(@sln_pts[0],@pt_ind_arr[0],sln_pts_cnt,10);
          SetColorInfo(clBlue,color_info);
          for i:=0 to ccc-1 do
            LineAC
            (
              Trunc(sln_pts[pt_ind_arr[i+0]].x)+w_a_s_x,
              Trunc(sln_pts[pt_ind_arr[i+0]].y)+w_a_s_y,
              Trunc(sln_pts[pt_ind_arr[i+1]].x)+w_a_s_x,
              Trunc(sln_pts[pt_ind_arr[i+1]].y)+w_a_s_y,
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              color_info
            );
          SetColorInfo2(clRed,color_info);
          for i:=0 to ccc do
            Point
            (
              Trunc(sln_pts[pt_ind_arr[i+0]].x)+w_a_s_x,
              Trunc(sln_pts[pt_ind_arr[i+0]].y)+w_a_s_y,
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              color_info,
              32
            );

          {with eds_img_arr[0],rct_ent_2 do
            begin
              left     :=Trunc(rct_ent.left  )+w_a_s_x;
              top      :=Trunc(rct_ent.top   )+w_a_s_y;
              right    :=Trunc(rct_ent.right )+w_a_s_x;
              bottom   :=Trunc(rct_ent.bottom)+w_a_s_y;
              width    :=right-left;
              height   :=bottom-top;
              rct_ent_2:=inn_wnd_rct;
            end;
          FillDWord  (grid_ln_arr[0],Length(grid_ln_arr),0);
          SetGridProp0( grid_ln_prop,
                       PtRctF(eds_img_arr[0].rct_ent_2),
                       obj_arr[curve_inds_obj_arr[0]].world_axis_shift,
                       PtPos(collision_grid_density.x,collision_grid_density.y),
                       1);
          FillLnOnGrid( grid_ln_prop,
                       @grid_ln_arr[0],
                       @sln_pts    [0],
                        sln_pts_cnt);
          SetTextInfo (srf_var.srf_bmp.Canvas,22,clBlack);}
          {ArrNzItCnt  ( grid_ln_prop,
                       @grid_ln_arr[0],
                       @sln_pts    [0],
                       srf_var.srf_bmp.Canvas);}
          {with pts_img_arr[0],rct_ent_2 do
            begin
              left     :=Trunc(rct_ent.left  )+w_a_s_x;
              top      :=Trunc(rct_ent.top   )+w_a_s_y;
              right    :=Trunc(rct_ent.right )+w_a_s_x;
              bottom   :=Trunc(rct_ent.bottom)+w_a_s_y;
              width    :=right-left;
              height   :=bottom-top;
              rct_ent_2:=inn_wnd_rct;
            end;
          FillDWord  (grid_pt_arr[0],Length(grid_pt_arr),0);
          SetGridProp0( grid_pt_prop,
                       PtRctF(pts_img_arr[0].rct_ent_2),
                       obj_arr[curve_inds_obj_arr[0]].world_axis_shift,
                       PtPos(collision_grid_density.x,collision_grid_density.y),
                       1);
          FillPtOnGrid( grid_pt_prop,
                       @grid_pt_arr[0],
                       @sln_pts    [0],
                        sln_pts_cnt);
          SetTextInfo (srf_var.srf_bmp.Canvas,22,clWhite);}
         {ArrNzItCnt  ( grid_pt_prop,
                       @grid_pt_arr[0],
                       @sln_pts    [0],
                       srf_var.srf_bmp.Canvas);}
        end;}
      {with eds_img_arr[0] do
        begin

          x0:=rct_ent_2.left;
          x1:=rct_ent_2.right-1;
          for i:=0 to collision_grid_density.y-1 do
            begin
              y0:=Trunc(rct_ent_2.top+i*(rct_ent_2.height/collision_grid_density.y));
              if LineHC(x0,y0,x1,inn_wnd_rct) then
                 LineH (x0,y0,x1,srf_bmp_ptr,srf_bmp.width,clBlue);
            end;
          y0:=rct_ent_2.bottom-1;
          if LineHC(x0,y0,x1,inn_wnd_rct) then
             LineH (x0,y0,x1,srf_bmp_ptr,srf_bmp.width,clBlue);

          y0:=rct_ent_2.top;
          y1:=rct_ent_2.bottom-1;
          for i:=0 to collision_grid_density.x-1 do
            begin
              x0:=Trunc(rct_ent_2.left+i*(rct_ent_2.width/collision_grid_density.x));
              if LineVC(x0,y0,y1,inn_wnd_rct) then
                 LineV (x0,y0,y1,srf_bmp_ptr,srf_bmp.width,clBlue);
            end;
          x0:=rct_ent_2.right-1;
          if LineVC(x0,y0,y1,inn_wnd_rct) then
             LineV (x0,y0,y1,srf_bmp_ptr,srf_bmp.width,clBlue);

        end;}
      {with pts_img_arr[0] do
        begin

          x0:=rct_ent_2.left;
          x1:=rct_ent_2.right-1;
          for i:=0 to collision_grid_density.y-1 do
            begin
              y0:=Trunc(rct_ent_2.top+i*(rct_ent_2.height/collision_grid_density.y));
              if LineHC(x0,y0,x1,inn_wnd_rct) then
                 LineH (x0,y0,x1,srf_bmp_ptr,srf_bmp.width,clRed);
            end;
          y0:=rct_ent_2.bottom-1;
          if LineHC(x0,y0,x1,inn_wnd_rct) then
             LineH (x0,y0,x1,srf_bmp_ptr,srf_bmp.width,clRed);

          y0:=rct_ent_2.top;
          y1:=rct_ent_2.bottom-1;
          for i:=0 to collision_grid_density.x-1 do
            begin
              x0:=Trunc(rct_ent_2.left+i*(rct_ent_2.width/collision_grid_density.x));
              if LineVC(x0,y0,y1,inn_wnd_rct) then
                 LineV (x0,y0,y1,srf_bmp_ptr,srf_bmp.width,clRed);
            end;
          x0:=rct_ent_2.right-1;
          if LineVC(x0,y0,y1,inn_wnd_rct) then
             LineV (x0,y0,y1,srf_bmp_ptr,srf_bmp.width,clRed);

        end;}  {$endregion}}
      {$endregion}

      {Test: Projectile Movement 2------------------} {$region -fold}
      {exec_timer.Start;

      inn_wnd_rct_2:=PtRct
      (
        inn_wnd_rct.left  +1,
        inn_wnd_rct.top   +1,
        inn_wnd_rct.right -1,
        inn_wnd_rct.bottom-1
      );
      if (tlmap_cnt<>0) then
        begin
          tlmap_ind:=obj_arr[obj_inds_arr[Length(tlm_var.tilemap_inds_arr)-1]].k_ind;
          with sprite_sheet_arr[tlm_var.tilemap_inds_arr[tlmap_ind]],fast_image_data,fast_image_proc_var do
            begin

              SetColorInfo(clPurple,color_info);
              Grid(rct_ent.left,
                   rct_ent.top,
                   srf_bmp_ptr,
                   srf_bmp.width,
                   inn_wnd_rct_2,
                   color_info,
                   tilemap_sprite_w_h.x,
                   tilemap_sprite_w_h.y,
                   bmp_ftimg_width_origin,
                   bmp_ftimg_height_origin);

              {Debug} {$region -fold}
             {SetTextInfo(srf_var.srf_bmp.Canvas,12,clBlue);
              TextGrid(rct_ent.left,
                       rct_ent.top,
                       srf_bmp.Canvas,
                       tilemap_sprite_w_h.x,
                       tilemap_sprite_w_h.y,
                       bmp_ftimg_width_origin,
                       bmp_ftimg_height_origin);}
              {$endregion}

              for i:=0 to Length(br_vec_projectile_arr)-1 do
                with br_vec_projectile_arr[i] do
                  with projectile_mov_vec do
                    begin
                      fast_image_data_ptr0:=@fast_image_data;
                      obj_arr_ptr         :=@obj_arr[tlmap_inds_obj_arr[tlmap_ind]];

                      {if (projectile_dir_tick_inc0<=0) then
                        goto l4;}

                      {Set Reflection Ray---} {$region -fold}
                      if collision_detect.coll_det then
                        begin
                          projectile_dir_tick_counter0:=projectile_dir_tick_inc0;
                          case collision_detect.coll_ed_type of
                            0,2:
                              begin
                                x1:=                        x0;
                                y1:=2*projectile_curr_pos.y-y0;
                                x0:=  projectile_curr_pos.x;
                                y0:=  projectile_curr_pos.y;
                               {projectile_dir:=Sign(Abs(x1-LineS(x0,y0,x1,y1,projectile_dir_tick_counter0,-1).x)-
                                                     Abs(x1-LineS(x0,y0,x1,y1,projectile_dir_tick_counter0,+1).x));
                                d:=Abs(x1-x0);
                                dir:=+1; x1-(x0+dir*d)=x1-x0-Abs(x1-x0)=(x1-x0)*(1-Sign(x1-x0));
                                dir:=-1; x1-(x0+dir*d)=x1-x0+Abs(x1-x0)=(x1-x0)*(1+Sign(x1-x0));}
                                projectile_dir:=Sign(x1-x0);
                                // buoyant vector calc. :
                                (PPtPosF(@projectile_mov_vec)^):=LineS(x0,y0,x1,y1,{projectile_dir_tick_counter0}2,projectile_dir);
                                {
                                x0                              :=LineS(x0,y0,x1,y1,{projectile_dir_tick_counter0}2,projectile_dir).x;
                                y0                              :=LineS(x0,y0,x1,y1,{projectile_dir_tick_counter0}2,projectile_dir).y;
                                projectile_curr_pos.x           :=x0;
                                projectile_curr_pos.y           :=y0;
                                }
                                tmp_pt:=GetArrCellInd(obj_arr_ptr^.world_axis_shift.x+x0,
                                                      obj_arr_ptr^.world_axis_shift.y+y0);

                                {Debug} {$region -fold}
                                {SetColorInfo(clRed,color_info);
                                PPAdditiveDec(srf_bmp_ptr,
                                              srf_bmp.width,
                                              ClippedRct(inn_wnd_rct,
                                                         PtRct(rct_ent.left+tilemap_sprite_w_h.x*(tmp_pt.x+0),
                                                               rct_ent.top +tilemap_sprite_w_h.y*(tmp_pt.y+0),
                                                               rct_ent.left+tilemap_sprite_w_h.x*(tmp_pt.x+1),
                                                               rct_ent.top +tilemap_sprite_w_h.y*(tmp_pt.y+1))),
                                              color_info.pix_col,
                                              000);
                                M_Test_Log.Lines.Text:=IntToStr(tmp_pt.x)+'; '+IntToStr(tmp_pt.y)+#13+
                                                       IntToStr(Trunc(x0))+'; '+IntToStr(Trunc(y0))+#13+
                                                       IntToStr(Trunc(obj_arr_ptr^.world_axis_shift.x))+'; '+IntToStr(Trunc(obj_arr_ptr^.world_axis_shift.y))+#13+
                                                       IntToStr(rct_ent.left)+'; '+IntToStr(rct_ent.top)+#13+
                                                       IntToStr(Trunc(obj_arr_ptr^.world_axis_shift_centrify.x))+'; '+IntToStr(Trunc(obj_arr_ptr^.world_axis_shift_centrify.y));}
                                {$endregion}

                                if (tilemap_coll_grid0[(tmp_pt.x)+(tmp_pt.y)*bmp_ftimg_width_origin]=1) then
                                  begin
                                    y0:=2*projectile_curr_pos.y-y0;
                                    y1:=2*projectile_curr_pos.y-y1;
                                  end;
                              end;
                            1,3:
                              begin
                                x1:=2*projectile_curr_pos.x-x0;
                                y1:=                        y0;
                                x0:=  projectile_curr_pos.x;
                                y0:=  projectile_curr_pos.y;
                               {projectile_dir:=Sign(Abs(y1-LineS(x0,y0,x1,y1,projectile_dir_tick_counter0,-1).y)-
                                                     Abs(y1-LineS(x0,y0,x1,y1,projectile_dir_tick_counter0,+1).y));
                                d:=Abs(x1-x0); k:=(y1-y0)/(x1-x0); d*k=(y1-y0)*Sign(x1-x0);
                                dir:=+1; y1-(y0+dir*d*k)=y1-y0-(y1-y0)*Sign(x1-x0)=(y1-y0)*(1-Sign(x1-x0));
                                dir:=-1; y1-(y0+dir*d*k)=y1-y0+(y1-y0)*Sign(x1-x0)=(y1-y0)*(1+Sign(x1-x0));}
                                projectile_dir:=Sign(x1-x0);
                                // buoyant vector calc. :
                                (PPtPosF(@projectile_mov_vec)^):=LineS(x0,y0,x1,y1,{projectile_dir_tick_counter0}2,projectile_dir);
                                {
                                x0                              :=LineS(x0,y0,x1,y1,{projectile_dir_tick_counter0}2,projectile_dir).x;
                                y0                              :=LineS(x0,y0,x1,y1,{projectile_dir_tick_counter0}2,projectile_dir).y;
                                projectile_curr_pos.x           :=x0;
                                projectile_curr_pos.y           :=y0;
                                }
                                tmp_pt:=GetArrCellInd(obj_arr_ptr^.world_axis_shift.x+x0,
                                                      obj_arr_ptr^.world_axis_shift.y+y0);

                                {Debug} {$region -fold}
                                {SetColorInfo(clRed,color_info);
                                PPAdditiveDec(srf_bmp_ptr,
                                              srf_bmp.width,
                                              ClippedRct(inn_wnd_rct,
                                                         PtRct(rct_ent.left+tilemap_sprite_w_h.x*(tmp_pt.x+0),
                                                               rct_ent.top +tilemap_sprite_w_h.y*(tmp_pt.y+0),
                                                               rct_ent.left+tilemap_sprite_w_h.x*(tmp_pt.x+1),
                                                               rct_ent.top +tilemap_sprite_w_h.y*(tmp_pt.y+1))),
                                              color_info.pix_col,
                                              000);
                                M_Test_Log.Lines.Text:=IntToStr(tmp_pt.x)+'; '+IntToStr(tmp_pt.y)+#13+
                                                       IntToStr(Trunc(x0))+'; '+IntToStr(Trunc(y0))+#13+
                                                       IntToStr(Trunc(obj_arr_ptr^.world_axis_shift.x))+'; '+IntToStr(Trunc(obj_arr_ptr^.world_axis_shift.y))+#13+
                                                       IntToStr(rct_ent.left)+'; '+IntToStr(rct_ent.top)+#13+
                                                       IntToStr(Trunc(obj_arr_ptr^.world_axis_shift_centrify.x))+'; '+IntToStr(Trunc(obj_arr_ptr^.world_axis_shift_centrify.y));}
                                {$endregion}

                                if (tilemap_coll_grid0[(tmp_pt.x)+(tmp_pt.y)*bmp_ftimg_width_origin]=1) then
                                  begin
                                    x0:=2*projectile_curr_pos.x-x0;
                                    x1:=2*projectile_curr_pos.x-x1;
                                  end;
                              end;
                          end;
                        end;
                      {$endregion}

                      {Projectile Pos. Calc.} {$region -fold}
                      projectile_curr_pos:=LineS(x0,y0,x1,y1,projectile_dir_tick_counter0,projectile_dir);
                      {$endregion}

                      {Collision Calc.------} {$region -fold}
                      collision_detect.coll_ed_type:=4;
                      if (projectile_dir_tick_counter0<>projectile_dir_tick_inc0) then //if collision_detect.coll_det then
                        begin
                          collision_detect:=CollisionTest1(Trunc(obj_arr_ptr^.world_axis_shift.x+x0),
                                                           Trunc(obj_arr_ptr^.world_axis_shift.y+y0),
                                                           Trunc(obj_arr_ptr^.world_axis_shift.x+projectile_curr_pos.x),
                                                           Trunc(obj_arr_ptr^.world_axis_shift.y+projectile_curr_pos.y));
                          if collision_detect.coll_det then
                            begin
                              projectile_curr_pos.x:=collision_detect.pt_c.x-obj_arr_ptr^.world_axis_shift.x;
                              projectile_curr_pos.y:=collision_detect.pt_c.y-obj_arr_ptr^.world_axis_shift.y;
                            end;
                        end;
                      {$endregion}

                      //l4:

                      {Projectile Drawing---} {$region -fold}
                      projectile_mov_vec2.x0:=Trunc(obj_arr_ptr^.world_axis_shift.x+x0);
                      projectile_mov_vec2.y0:=Trunc(obj_arr_ptr^.world_axis_shift.y+y0);
                      projectile_mov_vec2.x1:=Trunc(obj_arr_ptr^.world_axis_shift.x+projectile_curr_pos.x);
                      projectile_mov_vec2.y1:=Trunc(obj_arr_ptr^.world_axis_shift.y+projectile_curr_pos.y);
                      if Length(library_images_inds_arr)<>0 then
                        with sprite_sheet_arr[library_images_inds_arr[0]],fast_image_data,fast_image_proc_var do
                          SdrProc[sdr_proc_ind]SetRctPos(projectile_mov_vec2.x1-bmp_ftimg_width_origin >>1,
                                                         projectile_mov_vec2.y1-bmp_ftimg_height_origin>>1,
                                                         @fast_image_data)
                      else
                        begin

                         {SetColorInfo(clPurple,color_info);
                          LineAC(projectile_mov_vec2.x0,
                                 projectile_mov_vec2.y0,
                                 projectile_mov_vec2.x1,
                                 projectile_mov_vec2.y1,
                                 srf_bmp_ptr,
                                 srf_bmp.width,
                                 inn_wnd_rct_2,
                                 color_info);
                          SetColorInfo2(clRed,color_info);
                          Point(projectile_mov_vec2.x0,
                                projectile_mov_vec2.y0,
                                srf_bmp_ptr,
                                srf_bmp.width,
                                inn_wnd_rct,
                                color_info);
                          CircleC(projectile_mov_vec2.x1,
                                  projectile_mov_vec2.y1,
                                  16,
                                  srf_bmp_ptr,
                                  srf_bmp.width,
                                  inn_wnd_rct,
                                  color_info.pix_col);}

                          CircleHighlight003(projectile_mov_vec2.x1,
                                             projectile_mov_vec2.y1,
                                             srf_bmp_ptr,
                                             srf_bmp.width,
                                             inn_wnd_rct,
                                             color_info,
                                             07,
                                             32);
                          SetColorInfo2(clRed,color_info);
                          Point(projectile_mov_vec2.x1,
                                projectile_mov_vec2.y1,
                                srf_bmp_ptr,
                                srf_bmp.width,
                                inn_wnd_rct,
                                color_info);

                         {CircleHighlight011(projectile_mov_vec2.x1,
                                             projectile_mov_vec2.y1,
                                             srf_bmp_ptr,
                                             srf_bmp.width,
                                             inn_wnd_rct_2,
                                             color_info,
                                             9,
                                             255);}

                        end;
                      {$endregion}

                      {if (projectile_dir_tick_inc0<=0) then
                        Continue;}

                      {Increase Distance----} {$region -fold}
                      //if (not collision_detect.coll_det) then
                          projectile_dir_tick_counter0+=  projectile_dir_tick_inc0;
                      if (projectile_dir_tick_counter0 =2*projectile_dir_tick_inc0) then
                        collision_detect.coll_det:=False;
                      {$endregion}

                      //projectile_dir_tick_inc0-=0.007;

                    end;
            end;
        end;

      exec_timer.Stop;
      exec_time1+=Trunc(exec_timer.Delay*1000);}
      {$endregion}

      {Test: Projectile Movement 3------------------} {$region -fold}
      {if (tlmap_cnt<>0) then
        begin

          exec_timer.Start;

          Inc(frame_skip_counter);

          inn_wnd_rct_2:=PtRct(inn_wnd_rct.left  +1,
                               inn_wnd_rct.top   +1,
                               inn_wnd_rct.right -1,
                               inn_wnd_rct.bottom-1);

          tlmap_ind:=obj_arr[obj_inds_arr[Length(tlm_var.tilemap_inds_arr)-1]].k_ind;
          with sprite_sheet_arr[tlm_var.tilemap_inds_arr[tlmap_ind]],fast_image_data,fast_image_proc_var do
            begin
              fast_image_data_ptr0:=@fast_image_data;
              obj_arr_ptr         :=@obj_arr[tlmap_inds_obj_arr[tlmap_ind]];
              SetRctPos (Trunc(world_axis.x)+Trunc(obj_arr_ptr^.world_axis_shift.x)-(bmp_ftimg_width_origin *tilemap_sprite_w_h.x)>>1,
                         Trunc(world_axis.y)+Trunc(obj_arr_ptr^.world_axis_shift.y)-(bmp_ftimg_height_origin*tilemap_sprite_w_h.y)>>1);
              SetRctPosF(      world_axis.x +      obj_arr_ptr^.world_axis_shift.x -(bmp_ftimg_width_origin *tilemap_sprite_w_h.x)>>1,
                               world_axis.y +      obj_arr_ptr^.world_axis_shift.y -(bmp_ftimg_height_origin*tilemap_sprite_w_h.y)>>1);

              {Debug} {$region -fold}
              {
              SetTextInfo(srf_var.srf_bmp.Canvas,12,clBlue);
              TextGrid(rct_ent.left,
                       rct_ent.top ,
                       srf_bmp.Canvas,
                       tilemap_sprite_w_h.x,
                       tilemap_sprite_w_h.y,
                       bmp_ftimg_width_origin,
                       bmp_ftimg_height_origin);
              }
              {$endregion}

              for i:=0 to Length(br_vec_projectile_arr)-1 do
                with br_vec_projectile_arr[i] do
                  with projectile_mov_vec do
                    begin
                      fast_image_data_ptr0:=@fast_image_data;
                      obj_arr_ptr         :=@obj_arr[tlmap_inds_obj_arr[tlmap_ind]];

                      if (frame_skip_counter=frame_skip_val) then
                        begin

                          {if (projectile_dir_tick_inc0<=0) then
                            goto l4;}

                          {Set Reflection Ray---} {$region -fold}
                          if collision_detect.coll_det then
                            begin
                              projectile_dir_tick_counter0:=projectile_dir_tick_inc0;
                              case collision_detect.coll_ed_type of
                                0,2:
                                  begin
                                    x1:=                        x0;
                                    y1:=2*projectile_curr_pos.y-y0;
                                    x0:=  projectile_curr_pos.x;
                                    y0:=  projectile_curr_pos.y;
                                   {projectile_dir:=Sign(Abs(x1-LineS(x0,y0,x1,y1,projectile_dir_tick_counter0,-1).x)-
                                                         Abs(x1-LineS(x0,y0,x1,y1,projectile_dir_tick_counter0,+1).x));
                                    d:=Abs(x1-x0);
                                    dir:=+1; x1-(x0+dir*d)=x1-x0-Abs(x1-x0)=(x1-x0)*(1-Sign(x1-x0));
                                    dir:=-1; x1-(x0+dir*d)=x1-x0+Abs(x1-x0)=(x1-x0)*(1+Sign(x1-x0));}
                                    projectile_dir:=Sign(x1-x0);
                                    // buoyant vector calc. :
                                    (PPtPosF(@projectile_mov_vec)^):=LineS(x0,y0,x1,y1,0.000001,projectile_dir);
                                    tmp_pt:=GetArrCellInd(obj_arr_ptr^.world_axis_shift.x+x0,
                                                          obj_arr_ptr^.world_axis_shift.y+y0);

                                    {Debug} {$region -fold}
                                    {
                                    SetColorInfo(clRed,color_info);
                                    PPAdditiveDec(srf_bmp_ptr,
                                                  srf_bmp.width,
                                                  ClippedRct(inn_wnd_rct,
                                                             PtRct(rct_ent.left+tilemap_sprite_w_h.x*(tmp_pt.x+0),
                                                                   rct_ent.top +tilemap_sprite_w_h.y*(tmp_pt.y+0),
                                                                   rct_ent.left+tilemap_sprite_w_h.x*(tmp_pt.x+1),
                                                                   rct_ent.top +tilemap_sprite_w_h.y*(tmp_pt.y+1))),
                                                  color_info.pix_col,
                                                  000);
                                    M_Test_Log.Lines.Text:=IntToStr(tmp_pt.x)+'; '+IntToStr(tmp_pt.y)+#13+
                                                           IntToStr(Trunc(x0))+'; '+IntToStr(Trunc(y0))+#13+
                                                           IntToStr(Trunc(obj_arr_ptr^.world_axis_shift.x))+'; '+IntToStr(Trunc(obj_arr_ptr^.world_axis_shift.y))+#13+
                                                           IntToStr(rct_ent.left)+'; '+IntToStr(rct_ent.top)+#13+
                                                           IntToStr(Trunc(obj_arr_ptr^.world_axis_shift_centrify.x))+'; '+IntToStr(Trunc(obj_arr_ptr^.world_axis_shift_centrify.y));
                                    }
                                    {$endregion}

                                    if (tilemap_coll_grid0[(tmp_pt.x)+(tmp_pt.y)*bmp_ftimg_width_origin]=1) then
                                      begin
                                        y0            :=2*projectile_curr_pos.y-y0;
                                        y1            :=2*projectile_curr_pos.y-y1;
                                        projectile_dir:=Sign(x1-x0);
                                      end;
                                    goto l6;
                                  end;
                                1,3:
                                  begin
                                    x1:=2*projectile_curr_pos.x-x0;
                                    y1:=                        y0;
                                    x0:=  projectile_curr_pos.x;
                                    y0:=  projectile_curr_pos.y;
                                   {projectile_dir:=Sign(Abs(y1-LineS(x0,y0,x1,y1,projectile_dir_tick_counter0,-1).y)-
                                                         Abs(y1-LineS(x0,y0,x1,y1,projectile_dir_tick_counter0,+1).y));
                                    d:=Abs(x1-x0); k:=(y1-y0)/(x1-x0); d*k=(y1-y0)*Sign(x1-x0);
                                    dir:=+1; y1-(y0+dir*d*k)=y1-y0-(y1-y0)*Sign(x1-x0)=(y1-y0)*(1-Sign(x1-x0));
                                    dir:=-1; y1-(y0+dir*d*k)=y1-y0+(y1-y0)*Sign(x1-x0)=(y1-y0)*(1+Sign(x1-x0));}
                                    projectile_dir:=Sign(x1-x0);
                                    // buoyant vector calc. :
                                    (PPtPosF(@projectile_mov_vec)^):=LineS(x0,y0,x1,y1,0.000001,projectile_dir);
                                    tmp_pt:=GetArrCellInd(obj_arr_ptr^.world_axis_shift.x+x0,
                                                          obj_arr_ptr^.world_axis_shift.y+y0);

                                    {Debug} {$region -fold}
                                    {
                                    SetColorInfo(clRed,color_info);
                                    PPAdditiveDec(srf_bmp_ptr,
                                                  srf_bmp.width,
                                                  ClippedRct(inn_wnd_rct,
                                                             PtRct(rct_ent.left+tilemap_sprite_w_h.x*(tmp_pt.x+0),
                                                                   rct_ent.top +tilemap_sprite_w_h.y*(tmp_pt.y+0),
                                                                   rct_ent.left+tilemap_sprite_w_h.x*(tmp_pt.x+1),
                                                                   rct_ent.top +tilemap_sprite_w_h.y*(tmp_pt.y+1))),
                                                  color_info.pix_col,
                                                  000);
                                    M_Test_Log.Lines.Text:=IntToStr(tmp_pt.x)+'; '+IntToStr(tmp_pt.y)+#13+
                                                           IntToStr(Trunc(x0))+'; '+IntToStr(Trunc(y0))+#13+
                                                           IntToStr(Trunc(obj_arr_ptr^.world_axis_shift.x))+'; '+IntToStr(Trunc(obj_arr_ptr^.world_axis_shift.y))+#13+
                                                           IntToStr(rct_ent.left)+'; '+IntToStr(rct_ent.top)+#13+
                                                           IntToStr(Trunc(obj_arr_ptr^.world_axis_shift_centrify.x))+'; '+IntToStr(Trunc(obj_arr_ptr^.world_axis_shift_centrify.y));
                                    }
                                    {$endregion}

                                    if (tilemap_coll_grid0[(tmp_pt.x)+(tmp_pt.y)*bmp_ftimg_width_origin]=1) then
                                      begin
                                        x0            :=2*projectile_curr_pos.x-x0;
                                        x1            :=2*projectile_curr_pos.x-x1;
                                        projectile_dir:=Sign(x1-x0);
                                      end;
                                    goto l6;
                                  end;
                              end;
                            end;
                          {$endregion}

                          {Projectile Pos. Calc.} {$region -fold}
                          projectile_curr_pos:=LineS(x0,y0,x1,y1,projectile_dir_tick_counter0,projectile_dir);
                          {$endregion}

                          l6:

                          {Collision Calc.------} {$region -fold}
                          //collision_detect.coll_ed_type:=4;
                          if (projectile_dir_tick_counter0<>projectile_dir_tick_inc0) then //if collision_detect.coll_det then
                            begin
                              collision_detect:=CollisionTest2(obj_arr_ptr^.world_axis_shift.x+x0,
                                                               obj_arr_ptr^.world_axis_shift.y+y0,
                                                               obj_arr_ptr^.world_axis_shift.x+projectile_curr_pos.x,
                                                               obj_arr_ptr^.world_axis_shift.y+projectile_curr_pos.y);
                              if collision_detect.coll_det then
                                begin
                                  projectile_curr_pos.x:=collision_detect.pt_c.x-obj_arr_ptr^.world_axis_shift.x;
                                  projectile_curr_pos.y:=collision_detect.pt_c.y-obj_arr_ptr^.world_axis_shift.y;
                                end;
                            end;
                          {$endregion}

                        //l4:

                        end;

                      {Projectile Drawing---} {$region -fold}
                      projectile_mov_vec2.x0:=Trunc(obj_arr_ptr^.world_axis_shift.x+x0);
                      projectile_mov_vec2.y0:=Trunc(obj_arr_ptr^.world_axis_shift.y+y0);
                      projectile_mov_vec2.x1:=Trunc(obj_arr_ptr^.world_axis_shift.x+projectile_curr_pos.x);
                      projectile_mov_vec2.y1:=Trunc(obj_arr_ptr^.world_axis_shift.y+projectile_curr_pos.y);
                      if Length(library_images_inds_arr)<>0 then
                        with sprite_sheet_arr[library_images_inds_arr[0]],fast_image_data,fast_image_proc_var do
                          SdrProc[sdr_proc_ind](Trunc(projectile_mov_vec2.x1-bmp_ftimg_width_origin >>1),
                                                Trunc(projectile_mov_vec2.y1-bmp_ftimg_height_origin>>1),
                                                @fast_image_data)
                      else
                        begin

                          SetColorInfo      (clPurple,color_info);
                          LineAC            (Trunc(projectile_mov_vec2.x0),
                                             Trunc(projectile_mov_vec2.y0),
                                             Trunc(projectile_mov_vec2.x1),
                                             Trunc(projectile_mov_vec2.y1),
                                             srf_bmp_ptr,
                                             srf_bmp.width,
                                             inn_wnd_rct_2,
                                             color_info);
                          SetColorInfo2     (clYellow,color_info);
                          Point             (Trunc(projectile_mov_vec2.x0),
                                             Trunc(projectile_mov_vec2.y0),
                                             srf_bmp_ptr,
                                             srf_bmp.width,
                                             inn_wnd_rct,
                                             color_info);
                          CircleC           (Trunc(projectile_mov_vec2.x1),
                                             Trunc(projectile_mov_vec2.y1),
                                             4{16},
                                             srf_bmp_ptr,
                                             srf_bmp.width,
                                             inn_wnd_rct,
                                             color_info.pix_col);

                         {CircleHighlight003(Trunc(projectile_mov_vec2.x1),
                                             Trunc(projectile_mov_vec2.y1),
                                             srf_bmp_ptr,
                                             srf_bmp.width,
                                             inn_wnd_rct,
                                             color_info,
                                             07,
                                             32);
                          SetColorInfo2     (clRed,color_info);
                          Point             (Trunc(projectile_mov_vec2.x1),
                                             Trunc(projectile_mov_vec2.y1),
                                             srf_bmp_ptr,
                                             srf_bmp.width,
                                             inn_wnd_rct,
                                             color_info);}

                         {CircleHighlight011(Trunc(projectile_mov_vec2.x1),
                                             Trunc(projectile_mov_vec2.y1),
                                             srf_bmp_ptr,
                                             srf_bmp.width,
                                             inn_wnd_rct_2,
                                             color_info,
                                             9,
                                             255);}

                        end;
                      {$endregion}

                      {if (projectile_dir_tick_inc0<=0) then
                        Continue;}

                      if (frame_skip_counter=frame_skip_val) then
                        begin

                          {Increase Distance----} {$region -fold}
                          //if (not collision_detect.coll_det) then
                              projectile_dir_tick_counter0+=  projectile_dir_tick_inc0;
                          if (projectile_dir_tick_counter0 =2*projectile_dir_tick_inc0) then
                            collision_detect.coll_det:=False;
                          {$endregion}

                          //projectile_dir_tick_inc0-=0.007;

                        end;

                    end;
            end;

          if (frame_skip_counter =frame_skip_val) then
              frame_skip_counter:=0;

          exec_timer.Stop;
          exec_time1+=Trunc(exec_timer.Delay*1000);

        end;}

      {$endregion}

      {Test: Circle-Circle Intersection-------------} {$region -fold}
      {
      vec2:=CrcCrcInt(vec0,vec1,FSE_Rad0.Value,FSE_Rad1.Value,SE_K.Value,SE_T.Value,crc_crc_int);

      case crc_crc_int of
        0,2:SetColorInfo(clWhite ,color_info);
        1  :SetColorInfo(clRed   ,color_info);
        3  :SetColorInfo(clYellow,color_info);
      end;
      CircleC(Trunc(vec2.x0),
              Trunc(vec2.y0),
              Trunc(FSE_Rad0.Value),
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              color_info.pix_col);
      CircleC(Trunc(vec2.x1),
              Trunc(vec2.y1),
              Trunc(FSE_Rad1.Value),
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              color_info.pix_col);

      SetColorInfo(clBlue,color_info);
      LineAC(Trunc(vec0.x0),
             Trunc(vec0.y0),
             Trunc(vec0.x1),
             Trunc(vec0.y1),
             srf_bmp_ptr,
             srf_bmp.width,
             inn_wnd_rct_2,
             color_info);
      SetColorInfo2(clYellow,color_info);
      Point(Trunc(vec0.x0),
            Trunc(vec0.y0),
            srf_bmp_ptr,
            srf_bmp.width,
            inn_wnd_rct,
            color_info);

      SetColorInfo(clGreen,color_info);
      LineAC(Trunc(vec1.x0),
             Trunc(vec1.y0),
             Trunc(vec1.x1),
             Trunc(vec1.y1),
             srf_bmp_ptr,
             srf_bmp.width,
             inn_wnd_rct_2,
             color_info);
      SetColorInfo2(clYellow,color_info);
      Point(Trunc(vec1.x0),
            Trunc(vec1.y0),
            srf_bmp_ptr,
            srf_bmp.width,
            inn_wnd_rct,
            color_info);
      }
      {$endregion}

      {Test: Image Scaling 1------------------------} {$region -fold}
      {with sprite_sheet_arr[{tlm_var.tilemap_sprite_inds_arr[Length(tlm_var.tilemap_sprite_inds_arr)-1]}pvt_var.local_axis_bmp_ind],fast_image_data,fast_image_proc_var do
        begin
          exec_timer.Start;
          fast_image_data_ptr0:=@fast_image_data;
          w1                  :=Trunc(world_axis.x)+Trunc(world_axis_shift.x)-bmp_ftimg_width_origin >>1;
          w2                  :=Trunc(world_axis.y)+Trunc(world_axis_shift.y)-bmp_ftimg_height_origin>>1;
          scl_mul             :=PtPosF({cmr_var.scl_mul_pow}TB_Test0.Position/TB_Test0.Max{0.6}{0.95},{cmr_var.scl_mul_pow}TB_Test0.Position/TB_Test0.Max{0.6}{0.95});
          {pvt0.x              :=w1+bmp_ftimg_width_origin >>1;
          pvt0.y              :=w2+bmp_ftimg_height_origin>>1;}
          for i:=0 to 1{000}{0}{0}-1 do
            begin
              SetRctPosF(w1,
                         w2);
              pvt0.x:=rct_ent_f.left+bmp_ftimg_width_origin >>1;
              pvt0.y:=rct_ent_f.top +bmp_ftimg_height_origin>>1;
              SetRctPos(w1{-test_pos_arr[i].x},
                        w2{-test_pos_arr[i].y});
              if not ((scl_mul.x=1.0) and (scl_mul.y=1.0)) then
                begin

                  SetRctDst2;
                  if pix_clp_type=3 then
                    goto l2;
                  SetRctSrc;

                  {SetColorInfo(clBlue,color_info);

                  LineAC
                  (
                    rct_dst.left    ,
                    rct_dst.top     ,
                    rct_dst.right -1,
                    rct_dst.top     ,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    color_info,
                    inn_wnd_rct
                  );
                  LineAC
                  (
                    rct_dst.left    ,
                    rct_dst.bottom-1,
                    rct_dst.right -1,
                    rct_dst.bottom-1,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    color_info,
                    inn_wnd_rct
                  );
                  LineAC
                  (
                    rct_dst.left    ,
                    rct_dst.top     ,
                    rct_dst.left    ,
                    rct_dst.bottom-1,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    color_info,
                    inn_wnd_rct
                  );
                  LineAC
                  (
                    rct_dst.right -1,
                    rct_dst.top     ,
                    rct_dst.right -1,
                    rct_dst.bottom-1,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    color_info,
                    inn_wnd_rct
                  );

                  SetColorInfo(clWhite,color_info);

                  LineAC
                  (
                    rct_src.left    ,
                    rct_src.top     ,
                    rct_src.right -1,
                    rct_src.top     ,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    color_info,
                    inn_wnd_rct
                  );
                  LineAC
                  (
                    rct_src.left    ,
                    rct_src.bottom-1,
                    rct_src.right -1,
                    rct_src.bottom-1,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    color_info,
                    inn_wnd_rct
                  );
                  LineAC
                  (
                    rct_src.left    ,
                    rct_src.top     ,
                    rct_src.left    ,
                    rct_src.bottom-1,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    color_info,
                    inn_wnd_rct
                  );
                  LineAC
                  (
                    rct_src.right -1,
                    rct_src.top     ,
                    rct_src.right -1,
                    rct_src.bottom-1,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    color_info,
                    inn_wnd_rct
                  );}

                  SetSdrType;
                     SdrType    [0000+sdr_type_ind];
                  GenPTBeginProc[fx_arr[0].pt_fx_prop.begin_proc_ind.main_part+fx_arr[0].pt_fx_prop.begin_proc_ind.clip_part];
                  GenNTBeginProc[fx_arr[0].nt_fx_prop.begin_proc_ind.main_part+fx_arr[0].nt_fx_prop.begin_proc_ind.clip_part];

                  FilPTValueArrK;{FilPTValueArrE;}{FilPTValueArrC;}{FilPTValueArrG;}
                  RSDNTColorA10; {RSDNTColorA01; }{RSDNTColorA00; }{RSDNTColorA02; } ///
                  if ((scl_mul.x>=0.1) and (scl_mul.y>=0.1)) then
                    begin
                      RSDPTColorA10; {RSDPTColorA01; }{RSDPTColorA00; }{RSDPTColorA02; }
                      FilPTValueArrL;{FilPTValueArrF;}{FilPTValueArrD;}{FilPTValueArrH;}
                    end;
                  l2:

                end
              else
                SdrProc[sdr_proc_ind];
            end;
          exec_timer.Stop;
        //exec_time0:=TB_Test0.Position;
          exec_time1:=Trunc(exec_timer.Delay*1000);
        end;}
      {$endregion}

      {Test: Image Scaling 2------------------------} {$region -fold}
      {if Length(library_images_inds_arr)<>0 then
        with sprite_sheet_arr[library_images_inds_arr[0]],fast_image_data,fast_image_proc_var do
          begin
            exec_timer.Start;
            fast_image_data_ptr0:=@fast_image_data;

            {rct_clp_test        :=PtRct(inn_wnd_rct.left  +200,
                                       {inn_wnd_rct.top   +200}inn_wnd_rct.top+1*Round(inn_wnd_rct.height/4),
                                        inn_wnd_rct.right -200,
                                       {inn_wnd_rct.bottom-200}inn_wnd_rct.top+2*Round(inn_wnd_rct.height/4));
            rct_clp_ptr         :=@rct_clp_test;
            PPAlphaBlend(srf_bmp_ptr,
                         srf_bmp.width,
                         rct_clp_test,
                         clGreen,
                         100);}

            scl_mul             :=PtPosF(TB_Test0.Position/TB_Test0.Max,TB_Test0.Position/TB_Test0.Max);

            GetFrameHeight(26);

            M_Test_Log.Lines.Text:=IntToStr(Byte(True){rct_src_mrg_inc});


            {img_inv_type:=0;
            if (rct_src_mrg_inc >=frame_cnt_v) then
                rct_src_mrg_inc :=00;
            w1                  :=Trunc(world_axis.x)+Trunc(world_axis_shift.x)-bmp_ftimg_width_origin>>1;
            w2                  :=Trunc(world_axis.y)+Trunc(world_axis_shift.y)-(frame_height_int>>1+frame_height_int*rct_src_mrg_inc);
            rct_src_mrg.top     :=frame_height_int*rct_src_mrg_inc;
            rct_src_mrg.bottom  :=frame_height_int*(frame_cnt_v-rct_src_mrg_inc-1);
            if (img_inv_type in [2,3]) and (not ((scl_mul.x=1.0) and (scl_mul.y=1.0))) then
              Swap1(rct_src_mrg.top,rct_src_mrg.bottom);
            SetRctPos(w1,w2);
            //rct_ent_f           :=PtRctF(rct_ent);
            pvt0.x              :=rct_ent{_f}.left+bmp_ftimg_width_origin>>1;
            pvt0.y              :=rct_ent{_f}.top +(frame_height_int>>1+frame_height_int*rct_src_mrg_inc);}


            w1                  :=Trunc(world_axis.x)+Trunc(world_axis_shift.x)-bmp_ftimg_width_origin >>1;
            w2                  :=Trunc(world_axis.y)+Trunc(world_axis_shift.y)-bmp_ftimg_height_origin>>1;

            rct_src_mrg.top     :=0;
            rct_src_mrg.bottom  :=0;

            SetRctPos(w1,w2);
            //rct_ent_f           :=PtRctF(rct_ent);
            pvt0.x              :=rct_ent.left+bmp_ftimg_width_origin >>1;
            pvt0.y              :=rct_ent.top +bmp_ftimg_height_origin>>1;

            {fast_image_data_arr[0].scl_mul:=PtPosF(TB_Test0.Position/TB_Test0.Max,TB_Test0.Position/TB_Test0.Max);
            for i:=0 to 1{000}{0}{0}-1 do
              begin
                img_inv_type:=0;
                SdrProc[sdr_proc_ind](w1,w2,fast_image_data_ptr0);
              end;}

            if (not (scl_mul.x*scl_mul.y=0.0)) then
              for index__:=0 to usable_threads_cnt{1}{000}{0}{0}-1 do
                begin

                  block_count__          :=usable_threads_cnt;
                    pixels_per_block_y0__:=Round(inn_wnd_rct.height/block_count__);
                  if (index__<block_count__-1) then
                    pixels_per_block_y1__:=pixels_per_block_y0__
                  else
                    pixels_per_block_y1__:=      inn_wnd_rct.height     -pixels_per_block_y0__*(block_count__-1);
                  rct_clp_test           :=PtRct(inn_wnd_rct.left,
                                                 inn_wnd_rct.top+index__*pixels_per_block_y0__,
                                                 inn_wnd_rct.right{-inn_wnd_rct.width>>1},
                                                 inn_wnd_rct.top+index__*pixels_per_block_y0__+
                                                                         pixels_per_block_y1__-10);
                  rct_clp_ptr         :=@rct_clp_test;
                  case index__ of
                    0: color__:=$FFFFFFF0;
                    1: color__:=$FFFFFF0F;
                    2: color__:=$FFFFF0FF;
                    3: color__:=$FFFF0FFF;
                  end;
                  PPAlphaBlend(srf_bmp_ptr,
                               srf_bmp.width,
                               rct_clp_test,
                               color__,
                               100);

                  //SetRctPos(w1,w2);
                  if not ((scl_mul.x=1.0) and (scl_mul.y=1.0)) then // if not (((scl_mul.x=1.0) and (scl_mul.y=1.0)) or (scl_mul.x*scl_mul.y=0.0)) then
                    begin

                      img_inv_type:=2; //

                      //SetRctPosF(w1,w2);

                      //SetRctDst2;
                      //SetRctDst3;

                      {with fast_image_data_ptr0^ do
                        begin
                          {
                          M_Test_Log.Lines.Text:=IntToStr(vat_test_g1-vat_test_g0)+#13+   //4591870180066957722
                                                 IntToStr(vat_test_g2-vat_test_g1)+#13+   //4503599627370496
                                                 IntToStr(vat_test_g3-vat_test_g2)+#13+   //2702159776422297
                                                 IntToStr(vat_test_g4-vat_test_g3)+#13+   //1801439850948199
                                                 IntToStr(vat_test_g5-vat_test_g4)+#13+   //1801439850948198
                                                 IntToStr(vat_test_g6-vat_test_g5)+#13+   //900719925474099
                                                 IntToStr(vat_test_g7-vat_test_g6);       //0
                          }
                          {M_Test_Log.Lines.Text:='rct_ent_f.left  :='+IntToStr(Trunc(rct_ent_f.left  ))+';'+#13+
                                                 'rct_ent_f.top   :='+IntToStr(Trunc(rct_ent_f.top   ))+';'+#13+
                                                 'rct_ent_f.right :='+IntToStr(Trunc(rct_ent_f.right ))+';'+#13+
                                                 'rct_ent_f.bottom:='+IntToStr(Trunc(rct_ent_f.bottom))+';';}
                          Rectangle(Trunc(rct_dst_f.left  ),
                                    Trunc(rct_dst_f.top   ),
                                    Trunc(rct_dst_f.right ),
                                    Trunc(rct_dst_f.bottom),
                                    srf_bmp_ptr,
                                    srf_bmp.width,
                                    inn_wnd_rct,
                                    SetcolorInv(clBlue));
                          Rectangle(Trunc(rct_scl.left  ),
                                    Trunc(rct_scl.top   ),
                                    Trunc(rct_scl.right ),
                                    Trunc(rct_scl.bottom),
                                    srf_bmp_ptr,
                                    srf_bmp.width,
                                    inn_wnd_rct,
                                    SetcolorInv(clRed));
                        end;}

                      //if (pix_clp_type=3) then
                      //  goto l2;

                      //SetRctSrc;
                      //SetRctSrcF;

                      GenNTBeginProc[1](fast_image_data_ptr0,
                                        fast_image_data_ptr0^);
                      GenPTBeginProc[1](fast_image_data_ptr0,
                                        fast_image_data_ptr0^);

                      // 275 ms.
                      //RSDNTColorA10(fast_image_data_ptr0,
                      //              fast_image_data_ptr0^);
                      //RSDPTColorA10(fast_image_data_ptr0,
                      //              fast_image_data_ptr0^);

                      // 307 ms.
                      //RSDNTColorA12(fast_image_data_ptr0,
                      //              fast_image_data_ptr0^);
                      //RSDPTColorA12(fast_image_data_ptr0,
                      //              fast_image_data_ptr0^);

                      // 263 ms.
                      //RSDNTColor000(fast_image_data_ptr0,
                      //              fast_image_data_ptr0^);
                      //RSDPTColor000(fast_image_data_ptr0,
                      //              fast_image_data_ptr0^);

                      // 296 ms.
                      RSDNTColor002(fast_image_data_ptr0,
                                    fast_image_data_ptr0^);
                      {RSDPTColor002(fast_image_data_ptr0,
                                    fast_image_data_ptr0^);}

                      // 305 ms.
                      //RSDNTColor004(fast_image_data_ptr0,
                      //              fast_image_data_ptr0^);
                      //RSDPTColor004(fast_image_data_ptr0,
                      //              fast_image_data_ptr0^);

                      // ... ms.
                      //RSDNTColor006(fast_image_data_ptr0,
                      //              fast_image_data_ptr0^);
                      //RSDPTColor006(fast_image_data_ptr0,
                      //              fast_image_data_ptr0^);

                      l2:

                    end
                  else
                    SdrProc[sdr_proc_ind](w1,w2,fast_image_data_ptr0);
                end;

            fast_image_data_arr[0].scl_mul:=PtPosF(1.0,1.0);

            Inc(rct_src_mrg_inc);

            exec_timer.Stop;
            exec_time0:=TB_Test0.Position;
            exec_time1:=Trunc(exec_timer.Delay*1000);

            {
            __u__0:=400;     //200;
            __v__0:=200;     //200;
            __u__1:=655-05;  //455;
            __v__1:=200-55;  //200;
            __u__2:=655+55;  //455;
            __v__2:=455-55;  //455;
            __u__3:=400+55;  //200;
            __v__3:=455-05;  //455;

            __I2__:=400;
            __J2__:=400;
            __D1__:= __u__0;
            __D2__:= __v__0;
            __A1__:=(__u__1-__u__0)/__I2__;
            __A2__:=(__v__1-__v__0)/__I2__;
            __C1__:=(__u__3-__u__0)/__J2__;
            __C2__:=(__v__3-__v__0)/__J2__;
            __B1__:=(__u__2-__u__3-__u__1+__u__0)/__I2__/__J2__;
            __B2__:=(__v__2-__v__3-__v__1+__v__0)/__I2__/__J2__;
            for __x__:=0 to __I2__-1 do
              for __y__:=0 to __J2__-1 do
                begin
                  __i__:=Trunc{Round}(__A1__*__x__+__B1__*__x__*__y__+__C1__*__y__+__D1__);
                  __j__:=Trunc{Round}(__A2__*__x__+__B2__*__x__*__y__+__C2__*__y__+__D2__);
                  (srf_bmp_ptr+__i__+__j__*srf_bmp.width)^:=BlurRGB9(srf_bmp_ptr+__x__+__y__*srf_bmp.width,srf_bmp.width);//(srf_bmp_ptr+__x__+__y__*srf_bmp.width)^;
                end;
            }

          end;}
      {$endregion}

      {Test: Sprites Animation 1--------------------} {$region -fold}
      {with sprite_sheet_arr[{tlm_var.tilemap_sprite_inds_arr[Length(tlm_var.tilemap_sprite_inds_arr)-1]}pvt_var.local_axis_bmp_ind],fast_image_data,fast_image_proc_var do
        begin
          fast_image_data_ptr0     :=@fast_image_data;
          fx_arr[1].cfx_pow0       :=SE_Test_FX_Value      .Value;
          fx_arr[1].nt_pix_cfx_type:=SE_Test_FX_Type       .Value;
          fx_arr[1].pt_pix_cfx_type:=SE_Test_FX_Type       .Value;
          fx_arr[1].nt_pix_cng_type:=SE_Test_FX_Fading_Type.Value;
          fx_arr[1].pt_pix_cng_type:=SE_Test_FX_Fading_Type.Value;
          fx_arr[1].pt_as_nt       :=CB_Test               .Checked;
        end;}
      {$endregion}

      {Test: Sprites Animation 2--------------------} {$region -fold}
      {with sprite_sheet_arr[pvt_var.local_axis_bmp_ind],fast_image_data,fast_image_proc_var do
        begin
          exec_timer.Start;
          fast_image_data_ptr0:=@fast_image_data;
          w1:=Trunc(world_axis.x+world_axis_shift.x)-bmp_ftimg_width_origin >>1;
          w2:=Trunc(world_axis.y+world_axis_shift.y){-bmp_ftimg_height_origin>>1};
          if (rct_src_mrg_inc=26) then
              rct_src_mrg_inc:=0;
          for i:=0 to Length(test_pos_arr)-1 do
            begin
              rct_src_mrg.top   :=rct_src_mrg_inc*60{240};
              rct_src_mrg.bottom:=60{240}*26{6240}-(rct_src_mrg_inc+1)*60{240};
              SdrProc[sdr_proc_ind](w1-test_pos_arr[i].x,
                                    w2-test_pos_arr[i].y-(60{240}>>1+60{240}*rct_src_mrg_inc),
                                    fast_image_data_ptr0);
            end;
          Inc(anim_inc);
          if (anim_inc mod 2=0) then
          Inc(rct_src_mrg_inc);
          exec_timer.Stop;
          exec_time1:=Trunc(exec_timer.Delay*1000);
        end;}
      {$endregion}

      {Test: Sprites Animation 3--------------------} {$region -fold}
      {with sprite_sheet_arr[pvt_var.local_axis_bmp_ind],fast_image_data,fast_image_proc_var do
        begin
          exec_timer.Start;
          fast_image_data_ptr0:=@fast_image_data;
          if (rct_src_mrg_inc =00) then
              rct_src_mrg_inc:=01;
          if (rct_src_mrg_inc =26) then
              rct_src_mrg_inc:=00;
          c1_+=1;
          c2_+=1;
          set_grad_to_vis_area:=True;
          SetGradCol($00000000+{$000000FF}{c1_}clWhite{Random($FFFFFF)},{$FF000000}$AA000000+{$0000FF00}{c2_}clBlack{Random($FFFFFF)});
          GetFrameHeight(26);
         {rct_src_mrg.left  :=39;
          rct_src_mrg.right :=39;}
          rct_src_mrg.top   :=frame_height*             rct_src_mrg_inc;
          rct_src_mrg.bottom:=frame_height*(frame_cnt_v-rct_src_mrg_inc-1);
          SetGradVec(rct_src_mrg.top,rct_src_mrg.top+frame_height);
          if (sln_pts_cnt<>0) then
            for i:=0 to sln_obj_cnt-1 do
              begin
                obj_arr_ptr:=@obj_var.obj_arr[obj_var.curve_inds_obj_arr[i]];
                w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
                w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
                for j:=partial_pts_sum[i] to partial_pts_sum[i]+sln_obj_pts_cnt[i]-1 do
                  SdrProc[sdr_proc_ind](Trunc(sln_pts[j].x)+w_a_s_x-bmp_ftimg_width_origin>>1,
                                        Trunc(sln_pts[j].y)+w_a_s_y-(frame_height>>1+frame_height*rct_src_mrg_inc),
                                        @fast_image_data);
              end;
          Inc(anim_inc);
          if (anim_inc mod 2=0) then
            Inc(rct_src_mrg_inc);
          exec_timer.Stop;
          exec_time1:=Trunc(exec_timer.Delay*1000);
        end;}
      {$endregion}

      {Test: Sprites Animation 4--------------------} {$region -fold}
      {with sprite_sheet_arr[pvt_var.local_axis_bmp_ind],fast_image_data,fast_image_proc_var do
        begin
          exec_timer.Start;
          fast_image_data_ptr0:=@fast_image_data;
          if (rct_src_mrg_inc =00) then
              rct_src_mrg_inc:=01;
          if (rct_src_mrg_inc =26) then
              rct_src_mrg_inc:=00;
          obj_arr_ptr:=@obj_var.obj_arr[0];
          w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
          w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
          Inc(tf1);
          if (tf1>=255) then
              tf1:=0;
          fx_arr[1].nt_fx_prop.cfx_pow0:=tf1;
          fx_arr[1].pt_fx_prop.cfx_pow0:=tf1;
          c1_+=1;
          c2_+=1;
          set_grad_to_vis_area:=False;
          SetGradVec(0,rct_ent.height{tf1});
          SetGradCol($00000000+{$000000FF}c1_{clWhite}{Random($FFFFFF)},$FF000000+{$0000FF00}c2_{clBlack}{Random($FFFFFF)});
          for i:=0 to 100{Length(test_pos_arr)}-1 do
            begin
              rct_src_mrg.top   :=rct_src_mrg_inc*60{240};
              rct_src_mrg.bottom:=60{240}*(26-rct_src_mrg_inc-1);
              SdrProc[sdr_proc_ind](Trunc(test_pos_arr[i].x)+w_a_s_x-bmp_ftimg_width_origin>>1,
                                    Trunc(test_pos_arr[i].y)+w_a_s_y-(60{240}>>1+60{240}*rct_src_mrg_inc),
                                    @fast_image_data);
            end;
          Inc(anim_inc);
          if (anim_inc mod 2=0) then
            Inc(rct_src_mrg_inc);
          exec_timer.Stop;
          exec_time1:=Trunc(exec_timer.Delay*1000);
        end;}
      {$endregion}

      {Test: Sprites Animation 5--------------------} {$region -fold}
      {exec_timer.Start;
      if (sln_obj_cnt<>0) and (Length(library_images_inds_arr)<>0) then
        begin

          obj_arr_ptr:=@obj_arr[curve_inds_obj_arr[0]];
          with sprite_sheet_arr[library_images_inds_arr[0]],fast_image_data,fast_image_proc_var do
            begin

              fast_image_data_ptr0:=@fast_image_data;

              with fast_image_data_ptr0^ do
                begin
                  GetFrameHeight(26);
                  if (rct_src_mrg_inc =frame_cnt_v) then
                      rct_src_mrg_inc:=00;
                  w_a_s_x            :=Trunc(obj_arr_ptr^.world_axis_shift.x)-bmp_ftimg_width_origin>>1;
                  w_a_s_y            :=Trunc(obj_arr_ptr^.world_axis_shift.y)-(frame_height_int>>1+frame_height_int*rct_src_mrg_inc);
                  GetFrameHeight(26) ;
                  rct_src_mrg.top    :=frame_height_int*rct_src_mrg_inc;
                  rct_src_mrg.bottom :=frame_height_int*(frame_cnt_v-rct_src_mrg_inc-1);
                end;

              for i:=0 to usable_threads_cnt-1 do
                with fast_image_data_arr[i] do
                  begin
                    set_grad_to_vis_area:={True}{False}fast_image_data_ptr0^.set_grad_to_vis_area;
                    SetPPInfo            (clRed,
                                          fast_image_data_arr[i]);
                    SetGradVec           (fast_image_data_ptr0^.frame_height_int*(rct_src_mrg_inc+0),//0{fast_image_data_ptr0^.rct_ent.height>>1},
                                          fast_image_data_ptr0^.frame_height_int*(rct_src_mrg_inc+1),//fast_image_data_ptr0^.rct_ent.height,
                                          fast_image_data_ptr0,
                                          fast_image_data_arr[i]);
                    SetGradCol           ($00000000+$000000FF,
                                          $50000000+$00FF0000,
                                          fast_image_data_arr[i]);
                  end;

              UberShader8{9}(@sln_pts[0],sln_pts_cnt{sln_obj_pts_cnt[0]},w_a_s_x,w_a_s_y,usable_threads_cnt);

            end;

          Inc(rct_src_mrg_inc);

        end;
      exec_timer.Stop;
      exec_time1+=Trunc(exec_timer.Delay*1000);}
      {$endregion}

      {Test: Sprites Static 1: Value----------------} {$region -fold}
      {with sprite_sheet_arr[pvt_var.local_axis_bmp_ind],fast_image_data,fast_image_proc_var do
        begin
          exec_timer.Start;
          fast_image_data_ptr0:=@fast_image_data;
          obj_arr_ptr         :=@obj_var.obj_arr[0];
          w1                  :=Trunc(world_axis.x+world_axis_shift.x)-bmp_ftimg_width_origin >>1{-200};
          w2                  :=Trunc(world_axis.y+world_axis_shift.y)-bmp_ftimg_height_origin>>1{-100};
          {Inc(tf1);
          if (tf1>=255) then
              tf1:=0;
          fx_arr[1].nt_fx_prop.cfx_pow0:=tf1;
          fx_arr[1].pt_fx_prop.cfx_pow0:=tf1;}
          for i:=0 to 1{0000}{Length(test_pos_arr)}-1 do
            SdrProc[sdr_proc_ind]({Trunc(test_pos_arr[i].x)+}w1,
                                  {Trunc(test_pos_arr[i].y)+}w2,
                                  @fast_image_data);
          exec_timer.Stop;
          exec_time1:={img_kind}{fast_image_data.pt_pix_cnt}{+fast_image_data.nt_pix_cnt-rct_ent.width*rct_ent.height}{fx_arr[1].pt_fx_prop.value_proc_ind.main_part+fx_arr[1].pt_fx_prop.value_proc_ind.clip_part}{sdr_type_ind}{nt_pix_cnt+pt_pix_cnt}{rct_ent.left}{rct_ent.top}{rct_src.left}{rct_src.top}{rct_dst.left}{rct_dst.top}Trunc(exec_timer.Delay*1000);
        end;}
      {$endregion}

      {Test: Sprites Static 2: Value----------------} {$region -fold}
      {exec_timer.Start;
      if (sln_obj_cnt<>0) and (Length(library_images_inds_arr)<>0) then
        begin
          sln_pts_ptr:=Unaligned(@sln_pts[partial_pts_sum[0]]);
          obj_arr_ptr:=@obj_arr[curve_inds_obj_arr[0]];
          w_a_s_x    :=Trunc(obj_arr_ptr^.world_axis_shift.x);
          w_a_s_y    :=Trunc(obj_arr_ptr^.world_axis_shift.y);
          with sprite_sheet_arr[library_images_inds_arr[0]],fast_image_data,fast_image_proc_var do
            begin
              fast_image_data_ptr0:=@fast_image_data;
              {UberShader4(@sln_pts[0],sln_obj_pts_cnt[0],w_a_s_x,w_a_s_y,4);} // cpu 28%: 67 ms.
              for i:=0 to sln_obj_pts_cnt[0]-1 do
                SdrProc[sdr_proc_ind](Trunc((sln_pts_ptr+i)^.x)+w_a_s_x-bmp_ftimg_width_origin >>1,
                                      Trunc((sln_pts_ptr+i)^.y)+w_a_s_y-bmp_ftimg_height_origin>>1,
                                      @fast_image_data); // cpu 24: 220 ms.
            end;
        end;
      exec_timer.Stop;
      exec_time1+=Trunc(exec_timer.Delay*1000);}
      {$endregion}

      {Test: Sprites Static 3: Value(Multithreading)} {$region -fold}
      exec_timer.Start;
      if (sln_obj_cnt<>0) and (Length(library_images_inds_arr)<>0) then
        begin

          {Debug} {$region -fold}
          {block_count__          :=usable_threads_cnt;
              index__            :=0;
            pixels_per_block_y0__:=Round(inn_wnd_rct.height/block_count__);
          if (index__<block_count__-1) then
            pixels_per_block_y1__:=pixels_per_block_y0__
          else
            pixels_per_block_y1__:=      inn_wnd_rct.height     -pixels_per_block_y0__*(block_count__-1);
          rct_clp_test           :=PtRct(inn_wnd_rct.left,
                                         inn_wnd_rct.top+index__*pixels_per_block_y0__,
                                         inn_wnd_rct.right-inn_wnd_rct.width>>1,
                                         inn_wnd_rct.top+index__*pixels_per_block_y0__+
                                                                 pixels_per_block_y1__);
          PPAlphaBlend(srf_bmp_ptr,
                       srf_bmp.width,
                       rct_clp_test,
                       clGreen,
                       100);} {$endregion}

          obj_arr_ptr:=@obj_arr[curve_inds_obj_arr[0]];
          with sprite_sheet_arr[library_images_inds_arr[0]],fast_image_data,fast_image_proc_var do
            begin

              fast_image_data_ptr0:=@fast_image_data;

              w_a_s_x:=Trunc(obj_arr_ptr^.world_axis_shift.x)-fast_image_data_ptr0^.bmp_ftimg_width_origin >>1;
              w_a_s_y:=Trunc(obj_arr_ptr^.world_axis_shift.y)-fast_image_data_ptr0^.bmp_ftimg_height_origin>>1;
              //M_Test_Log.Lines.Text:=IntToStr(nt_pix_cnt+pt_pix_cnt);

              {with fast_image_data_ptr0^ do
                begin
                  fx_arr[0].nt_fx_prop.is_fx_animate:=True;
                  fx_arr[0].pt_fx_prop.is_fx_animate:=True;
                  fx_arr[0].nt_fx_prop.pix_cfx_type :=2;
                  fx_arr[0].pt_fx_prop.pix_cfx_type :=2;
                  fx_arr[0].nt_fx_prop.pix_cng_type :=1;
                  fx_arr[0].pt_fx_prop.pix_cng_type :=1;
                  fx_arr[1].nt_fx_prop.is_fx_animate:=True;
                  fx_arr[1].pt_fx_prop.is_fx_animate:=True;
                  fx_arr[1].nt_fx_prop.pix_cfx_type :=2;
                  fx_arr[1].pt_fx_prop.pix_cfx_type :=2;
                  fx_arr[1].nt_fx_prop.pix_cng_type :=1;
                  fx_arr[1].pt_fx_prop.pix_cng_type :=1;
                end;

              Inc(test_nt_fx_prop_cfx_pow0);
              Inc(test_pt_fx_prop_cfx_pow0);
              for i:=0 to usable_threads_cnt-1 do
                with fast_image_data_arr[i] do
                  begin
                    with fx_arr[0] do
                      begin
                        nt_fx_prop.is_fx_animate:=True;
                        pt_fx_prop.is_fx_animate:=True;
                        nt_fx_prop.pix_cfx_type :=2;
                        pt_fx_prop.pix_cfx_type :=2;
                        nt_fx_prop.pix_cng_type :=1;
                        pt_fx_prop.pix_cng_type :=1;
                        nt_fx_prop.cfx_pow0     :=test_nt_fx_prop_cfx_pow0;
                        pt_fx_prop.cfx_pow0     :=test_pt_fx_prop_cfx_pow0;
                        //Inc(nt_fx_prop.cfx_pow0);
                        //Inc(pt_fx_prop.cfx_pow0);
                      end;
                    with fx_arr[1] do
                      begin
                        nt_fx_prop.is_fx_animate:=True;
                        pt_fx_prop.is_fx_animate:=True;
                        nt_fx_prop.pix_cfx_type :=2;
                        pt_fx_prop.pix_cfx_type :=2;
                        nt_fx_prop.pix_cng_type :=1;
                        pt_fx_prop.pix_cng_type :=1;
                        nt_fx_prop.cfx_pow0     :=test_nt_fx_prop_cfx_pow0;
                        pt_fx_prop.cfx_pow0     :=test_pt_fx_prop_cfx_pow0;
                        //Inc(nt_fx_prop.cfx_pow0);
                        //Inc(pt_fx_prop.cfx_pow0);
                      end;
                  end;}

              with fast_image_data_ptr0^ do
                begin
                  img_inv_type:=0;
                  //...
                end;

              for i:=0 to usable_threads_cnt-1 do
                with fast_image_data_arr[i] do
                  begin
                    scl_mul             :=PtPosF(TB_Test0.Position/TB_Test0.Max,TB_Test0.Position/TB_Test0.Max);
                    rct_src_mrg.top     :=0;
                    rct_src_mrg.bottom  :=0;

                    set_grad_to_vis_area:={True}{False}fast_image_data_ptr0^.set_grad_to_vis_area;
                    SetPPInfo            (clRed,
                                          fast_image_data_arr[i]);
                    SetGradVec           (0{fast_image_data_ptr0^.rct_ent.height>>1},
                                          fast_image_data_ptr0^.rct_ent.height,
                                          fast_image_data_ptr0,
                                          fast_image_data_arr[i]);
                    SetGradCol           ($00000000+$000000FF,
                                          $FF000000+$00FF0000,
                                          fast_image_data_arr[i]);
                  end;

              UberShader8{9}(@sln_pts[0],sln_pts_cnt{sln_obj_pts_cnt[0]},w_a_s_x,w_a_s_y,usable_threads_cnt);

              fast_image_data_arr[0].scl_mul:=PtPosF(1.0,1.0);

            end;
        end;

      exec_timer.Stop;
      exec_time1+=Trunc(exec_timer.Delay*1000);
      {$endregion}

      {Test: Sprites Static 4: Gradient-------------} {$region -fold}
      {with sprite_sheet_arr[pvt_var.local_axis_bmp_ind],fast_image_data,fast_image_proc_var do
        begin
          exec_timer.Start;
          fast_image_data_ptr0:=@fast_image_data;
          obj_arr_ptr         :=@obj_var.obj_arr[0];
          w_a_s_x             :=Trunc(obj_arr_ptr^.world_axis_shift.x-bmp_ftimg_width_origin >>1+512);
          w_a_s_y             :=Trunc(obj_arr_ptr^.world_axis_shift.y-bmp_ftimg_height_origin>>1+200);
          Inc(tf1);
          if (tf1>=rct_ent.height-1) then
              tf1:=0;
          c1_+=1;
          c2_+=1;
          set_grad_to_vis_area:=False;
          SetGradVec(0,rct_ent.height{tf1});
          SetGradCol($00000000+{$000000FF}c1_{clWhite}{Random($FFFFFF)},$FF000000+{$0000FF00}c2_{clBlack}{Random($FFFFFF)});
          for i:=0 to 1{000}{Length(test_pos_arr)}-1 do
            SdrProc[sdr_proc_ind]({Trunc(test_pos_arr[i].x)+}w_a_s_x,
                                  {Trunc(test_pos_arr[i].y)+}w_a_s_y,
                                  @fast_image_data);
          exec_timer.Stop;
          exec_time1:=Trunc(exec_timer.Delay*1000);
        end;}
      {$endregion}

      {Test: x-axis inverted sprites----------------} {$region -fold}
      {if (Length(library_images_inds_arr)<>0) and (tlmap_cnt=0) then
        begin

          rct_clp_test :=PtRct(inn_wnd_rct.left  +200,
                               inn_wnd_rct.top   +200,
                               inn_wnd_rct.right -200,
                               inn_wnd_rct.bottom-200);
          rct_src_test0:=PtRct(Trunc(world_axis.x+world_axis_shift.x),
                               Trunc(world_axis.y+world_axis_shift.y)-199,
                               Trunc(world_axis.x+world_axis_shift.x)+199,
                               Trunc(world_axis.y+world_axis_shift.y));
          rct_dst_test1:=PtRct(Trunc(world_axis.x+world_axis_shift.x)-200,
                               Trunc(world_axis.y+world_axis_shift.y)-200,
                               Trunc(world_axis.x+world_axis_shift.x),
                               Trunc(world_axis.y+world_axis_shift.y));
          rct_dst_test2:=PtRct(Trunc(world_axis.x+world_axis_shift.x),
                               Trunc(world_axis.y+world_axis_shift.y),
                               Trunc(world_axis.x+world_axis_shift.x)+200,
                               Trunc(world_axis.y+world_axis_shift.y)+200);
          rct_dst_test3:=PtRct(Trunc(world_axis.x+world_axis_shift.x)-200,
                               Trunc(world_axis.y+world_axis_shift.y),
                               Trunc(world_axis.x+world_axis_shift.x),
                               Trunc(world_axis.y+world_axis_shift.y)+200);

          PPAlphaBlend(srf_bmp_ptr,
                       srf_bmp.width,
                       rct_clp_test,
                       clGreen,
                       100);

         {BitBlt1  (srf_bmp_ptr,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    srf_bmp.width,
                    Trunc(world_axis.x+world_axis_shift.x),
                    Trunc(world_axis.y+world_axis_shift.y)-199,
                    rct_src_test0);
          BitBlt1X (srf_bmp_ptr,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    srf_bmp.width,
                    Trunc(world_axis.x+world_axis_shift.x)-198,
                    Trunc(world_axis.y+world_axis_shift.y)-199,
                    rct_src_test0);
          BitBlt1Y (srf_bmp_ptr,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    srf_bmp.width,
                    Trunc(world_axis.x+world_axis_shift.x),
                    Trunc(world_axis.y+world_axis_shift.y)+1,
                    rct_src_test0);
          BitBlt1XY(srf_bmp_ptr,
                    srf_bmp_ptr,
                    srf_bmp.width,
                    srf_bmp.width,
                    Trunc(world_axis.x+world_axis_shift.x)-198,
                    Trunc(world_axis.y+world_axis_shift.y)+1,
                    rct_src_test0);}

          with sprite_sheet_arr[library_images_inds_arr[0]],fast_image_data,fast_image_proc_var do
            begin
              fast_image_data_ptr0:=@fast_image_data;
             {img_inv_type:=0;
              SdrProc[sdr_proc_ind](Trunc(world_axis.x+world_axis_shift.x-bmp_ftimg_width_origin>>1),
                                    Trunc(world_axis.y+world_axis_shift.y),
                                    @fast_image_data);
              img_inv_type:=1;
              SdrProc[sdr_proc_ind](Trunc(world_axis.x+world_axis_shift.x+bmp_ftimg_width_origin>>1),
                                    Trunc(world_axis.y+world_axis_shift.y),
                                    @fast_image_data);}
              rct_clp_ptr :=@rct_clp_test;
              img_inv_type:=0;
              with fast_image_data_arr[0] do
                begin
                  img_inv_type:=0;
                  set_grad_to_vis_area:=True{False}{fast_image_data_ptr0^.set_grad_to_vis_area};
                  SetPPInfo            (clRed,
                                        fast_image_data_arr[0]);
                  SetGradVec           (0{fast_image_data_ptr0^.rct_ent.height>>1},
                                        fast_image_data_ptr0^.rct_ent.height,
                                        fast_image_data_ptr0,
                                        fast_image_data_arr[0]);
                  SetGradCol           ($00000000+$000000FF,
                                        $FF000000+$000000FF,
                                        fast_image_data_arr[0]);
                end;
              SdrProc[sdr_proc_ind](Trunc(world_axis.x)+Trunc(world_axis_shift.x),
                                    Trunc(world_axis.y)+Trunc(world_axis_shift.y),
                                    @fast_image_data);
              //
              {Debug} {$region -fold}
              //{
              {M_Test_Log.Lines.Text:=IntToStr(nt_pix_cnt+pt_pix_cnt)+';'+#13+
                                     IntToStr(rct_src.top)+';'+#13+
                                     IntToStr(pt_pix_arr_row_mrg_top)+';'+#13+
                                     IntToStr(pt_pix_arr_row_mrg_btm)+';'
                                     //IntToStr(sdr_proc_ind  )+';'+#13+
                                     //IntToStr(sdr_type_ind  )+';'+#13+
                                     //IntToStr(pix_clp_type  )+';'+#13+
                                     //IntToStr(rct_ent.left  )+';'+#13+
                                     //IntToStr(rct_ent.top   )+';'+#13+
                                     //IntToStr(rct_ent.width )+';'+#13+
                                     //IntToStr(rct_ent.height)+';'+#13+
                                     {IntToStr(rct_src.width )+';'+#13+
                                     IntToStr(rct_src.height)+';'+#13+
                                     IntToStr(rct_src.left  )+';'+#13+
                                     IntToStr(rct_src.right )+';'+#13+
                                     IntToStr(rct_src.top   )+';'+#13+
                                     IntToStr(rct_src.bottom)+';'};}
              //}
              // w*h*4 R (h*2+h*2+nt_pix_cnt*2+pt_pix_cnt*2+h*2+h*2+nt_pix_cnt*4+pt_pix_cnt*4)=(8*h+6*(nt_pix_cnt+pt_pix_cnt)) =>
              // w*h*2 R 4*h+3*(nt_pix_cnt+pt_pix_cnt) =>
              // 2*h*(w-2)/3 R (nt_pix_cnt+pt_pix_cnt)
              // 11666       R 6233
              // 71000       R 38534
              {$endregion}

            end;

        end;}
      {$endregion}

      {Test: Minimap--------------------------------} {$region -fold}
      {exec_timer.Start;}
      //for i:=0 to 10-1 do
        //ImgSclDown0(srf_bmp_ptr,srf_bmp_ptr,srf_bmp.width,srf_bmp.height,2,2);
      {exec_timer.Stop;
      exec_time1:=Trunc(exec_timer.Delay*1000);}
      {$endregion}

      {Test: TimeLine Buttons-----------------------} {$region -fold}
      {TimeLineButtonsDraw(F_MainForm.S_Splitter2.Top-40,F_MainForm.S_Splitter2.Width>>1-16+4);}
      {$endregion}

      {Test: Post-processing 1----------------------} {$region -fold}
      {PPGamma(srf_bmp_ptr,srf_bmp.Width,inn_wnd_rct,GAMMA_MAX*TB_Test0.Position/TB_Test0.Max);
      exec_time0:=TB_Test0.Position;}
      {$endregion}

      {Test: Post-processing 2----------------------} {$region -fold}
      {case TB_Camera_Speed.Position of
        0:PPRandNoise0Dec(srf_bmp_ptr,srf_bmp.Width,inn_wnd_rct,TB_Test1.Position,TB_Test2.Position);
        1:PPRandNoise1Dec(srf_bmp_ptr,srf_bmp.Width,inn_wnd_rct,TB_Test1.Position,TB_Test2.Position);
        2:PPRandNoise2Dec(srf_bmp_ptr,srf_bmp.Width,inn_wnd_rct,TB_Test1.Position,TB_Test2.Position);
        3:PPRandNoise3Dec(srf_bmp_ptr,srf_bmp.Width,inn_wnd_rct,TB_Test1.Position,TB_Test2.Position);
        4:PPRandNoise4Dec(srf_bmp_ptr,srf_bmp.Width,inn_wnd_rct,TB_Test1.Position,TB_Test2.Position);
      end;
      exec_time0:=TB_Test0.Position;}
      {$endregion}

      {Test: Post-processing 3----------------------} {$region -fold}
      {exec_timer.Start;
      for i:=0 to 10 do
        PPAlphaBlend(srf_bmp_ptr,
                     srf_bmp.width,
                     inn_wnd_rct,
                     SetColorInv(clGreen),
                     040);
        {PPAlphaBlendMTTest(srf_bmp_ptr,
                           srf_bmp.width,
                           srf_bmp.height,
                           inn_wnd_rct,
                           SetColorInv(clGreen),
                           040);}
      exec_timer.Stop;
      exec_time1+=Trunc(exec_timer.Delay*1000);}
      {SetColorInfo(clRed,color_info);
      CircleHighlight101(Trunc(world_axis.x+world_axis_shift.x),
                         Trunc(world_axis.y+world_axis_shift.y),
                         srf_bmp_ptr,
                         srf_bmp.width,
                         inn_wnd_rct,
                         color_info,
                         201,8,
                         255,255);}
      {CircleHighlight001(Trunc(world_axis.x+world_axis_shift.x),
                         Trunc(world_axis.y+world_axis_shift.y),
                         srf_bmp_ptr,
                         srf_bmp.width,
                         inn_wnd_rct,
                         color_info,
                         201,
                         255);}
     {CircleC(Trunc(world_axis.x+world_axis_shift.x),
              Trunc(world_axis.y+world_axis_shift.y),
              100,
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              SetColorInv(clRed));}
     {CircleC(Trunc(world_axis.x+world_axis_shift.x),
              Trunc(world_axis.y+world_axis_shift.y),
              099,
              srf_bmp_ptr,
              srf_bmp.width,
              inn_wnd_rct,
              SetColorInv(clGreen));}
      {$endregion}

      {Test: Camera Movement------------------------} {$region -fold}
      {if (sln_pts_cnt<>0) then
        begin
          Inc(sln_pt_ind);
          if (sln_pt_ind=Length(sln_pts)-1) then
            sln_pt_ind:=0;
          GLCameraSetPos(-(sln_pts[sln_pt_ind].x-world_axis.x){Random(40)},
                         +(sln_pts[sln_pt_ind].y-world_axis.y){Random(40)},
                           srf_bmp.width,
                           srf_bmp.height);
        end
      else}
        GLCameraSetPos(0,0,srf_bmp.width,srf_bmp.height);
      //shake_mrg:=PtPosF(40,40);//
      {$endregion}

      {$endregion}

      {Cursor---------------------------------------} {$region -fold}
      CursorDraw;
      {$endregion}

      {Inner Window Rectangle-----------------------} {$region -fold}
      {if (inn_wnd_mrg>0) then
        InnerWindowDraw($00FF9F66);}
      {$endregion}

      {Game Loop: Check Exit------------------------} {$region -fold}
      {if (not down_play_anim_ptr^) then
        begin
          MainBmpToLowerBmp;
          Exit;
        end;}
      {$endregion}

      {Scene Statistics-----------------------------} {$region -fold}
      SetTextInfo(srf_bmp.Canvas,22,$006ABE58);
      srf_bmp.Canvas.TextOut(20,
                             srf_bmp.height-40,
                             'Execution time: refresh lower layer - '+IntToStr(exec_time0        )+' ms.; '+
                                             'refresh upper layer - '+IntToStr(exec_time1        )+' ms.; '+
                             'sprites: '                             +IntToStr(sln_pts_cnt       )+'; '    +
                             'threads: '                             +IntToStr(usable_threads_cnt));
      {$endregion}

      {Full Scene Drawing---------------------------} {$region -fold}
      if (not shader_var.use_shaders) then
        begin

         {CnvToCnv(srf_bmp_rct,Canvas,srf_bmp.Canvas,SRCCOPY);}
          CnvDraw0(0-shake_mrg.x,srf_bmp.Height+shake_mrg.y,srf_bmp.Width+shake_mrg.x,0-shake_mrg.y,srf_bmp_ptr{buffer.bmBits},srf_bmp.Width,srf_bmp.Height);

         {Test0: GL fading Effect} {$region -fold}
         {FXAnimPingPong(fx_inc_check,0.015,0.022,fx,{0.0}0.1,0.8);
         if (fx<>0.0) then
           if (texture_test_ptr<>Nil) and (texture_test_ptr2<>Nil) then
             CnvDraw2(texture_test_ptr,texture_test_width,texture_test_height,fx{0.8}{,GL_ALPHA});} ///TFastImageItem///
         {$endregion}

        end
      else
        begin

         {Test1: Using GL Shaders} {$region -fold}
         shader_var.DrawShaders;
         {$endregion}

        end;

      {gl_canvas}OGLC_GPU_Canvas.SwapBuffers; //gl_canvas.Invalidate; //OGLC_GPU_Canvas.SwapBuffers; //OGLC_GPU_Canvas.Invalidate;
      {$endregion}

      {Drawing of Inner Window Buttons--------------} {$region -fold}
      {if P_Inner_Window_Buttons.Visible then
         P_Inner_Window_Buttons.Invalidate;}
      {$endregion}

    end;

end; {$endregion}
{$endregion}

// (Test) Тест:
{UI} {$region -fold}
procedure TF_MainForm.B_TestClick(sender:TObject); {$region -fold}
var
  args_            : TFunc0Args;

  sqrt_x0,sqrt_x1  : double;

  c,s,v,w          : double;
  execution_time   : double;
  i,j,k            : integer;
  color_info       : TColorInfo;
  b                : boolean;
  rot_img          : TFastImageItem;
  tex_img          : TFastImageItem;
  bmp_ptr0,bmp_ptr1: PInteger;
  n                : integer=256;
  grid_arr         : array of TColor;
  r                : TPtPosF;
  rct_inn,rct_out  : TPtRectF;
  grid_density     : TPtPos;


  aa_nz_arr_it_cnt : TColor;
  arr_brdr_blur_tst: T1Byte1Arr;


  img_rct          : TPtRect;
  x0               : integer;
  y0               : integer;
  x1               : integer;
  y1               : integer;
  crc              : TCrPosF;
  lnint            : boolean;
  col_info         : TColorInfo;
  c1,c2            : TColor;

  len              : pointer;

  txt0,txt1,txt2   : integer;

  v0,v1,v2,v3      : integer;

  // Line with conversion "float to integer" in the main loop:
  procedure LineTest0(x0_,y0_,x1_,y1_:double;  bmp_dst_ptr:PInteger; const bmp_dst_width,col:TColor); inline; {$region -fold}
  var
    k_,b_,dx_,dy_: double;
    i_,t0,t1     : integer;
  begin
    dx_:=x1_-x0_;
    dy_:=y1_-y0_;
    k_ :=dy_/dx_;
    b_ :=y0_-k_*x0_;
    if (Abs(dx_)>=Abs(dy_)) then
      begin
        if (dx_<0) then
          begin
            //Swap3(y0_,y1_);
            Swap3(x0_,x1_);
          end;
        t0:=Trunc(x0_);
        t1:=Trunc(x1_);
        if (t0=t1) then
          Exit;
        for i_:=t0 to t1 do
          (bmp_dst_ptr+i_+bmp_dst_width*Trunc(k_*i_+b_))^:=col;
      end
    else
      begin
        if (dy_<0) then
          begin
            Swap3(y0_,y1_);
            //Swap3(x0_,x1_);
          end;
        t0:=Trunc(y0_);
        t1:=Trunc(y1_);
        if (t0=t1) then
          Exit;
        for i_:=t0 to t1 do
          (bmp_dst_ptr+Trunc((i_-b_)/k_)+bmp_dst_width*i_)^:=col;
      end;
  end; {$endregion}
  // Line based only on integer calculatons  in the main loop(standart quality):
  procedure LineTest1(x0_,y0_,x1_,y1_:integer; bmp_dst_ptr:PInteger; const bmp_dst_width,col:TColor); inline; {$region -fold}
  var
    bmp_dst_ptr2                 : PInteger;
    i_,short_len,long_len,dec_inc: integer;
    x,ym,r0,p0,r1,p1             : integer;
    yLonger                      : boolean=False;
  begin

    short_len:=y1_-y0_;
    long_len :=x1_-x0_;
    if (Abs(short_len)>Abs(long_len)) then
      begin
        Swap1(short_len,long_len);
        yLonger:=True;
      end;

    if (long_len=0) then
      dec_inc:=0
    else
      dec_inc:=Trunc((short_len<<16)/long_len);

    if (yLonger) then
      begin

        //Exit;

        {almost vertical   line} {$region -fold}
        if (long_len>0) then
          begin
  	    long_len+=y0_;
            i_:=$8000+(x0_<<16);
            bmp_dst_ptr2:=bmp_dst_ptr+y0_*bmp_dst_width;
            while (y0_<=long_len) do
              begin
                ((i_>>16)+bmp_dst_ptr2)^:=col;
  	        i_+=dec_inc;
                Inc(y0_);
                Inc(bmp_dst_ptr2,bmp_dst_width);
                {srf_var.LowerBmpToMainBmp;
                CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
                Sleep(4);}
              end;
          end {$endregion}
        {almost vertical   line} {$region -fold}
        else
          begin
            long_len+=y0_;
            i_:=$8000+(x0_<<16);
            bmp_dst_ptr2:=bmp_dst_ptr+y0_*bmp_dst_width;
            while (y0_>=long_len) do
              begin
                ((i_>>16)+bmp_dst_ptr2)^:=col;
                i_-=dec_inc;
                Dec(y0_);
                Dec(bmp_dst_ptr2,bmp_dst_width);
                {srf_var.LowerBmpToMainBmp;
                CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
                Sleep(4);}
              end;
          end; {$endregion}
      end
    else
      begin

        //Exit;

        {almost horizontal line} {$region -fold}
        if (long_len>0) then
          begin

            {srf_var.LowerBmpToMainBmp;

            {x:=x0_+Random(Abs(long_len));
            y:=($8000+y0_<<16+(x-x0_)*dec_inc)>>16;}
            y:=y0_+Random(Abs(short_len));
            x:=((y<<16-y0_<<16-$8000) div dec_inc)+x0_+1;

            (bmp_dst_ptr+x+y*bmp_dst_width)^:=clYellow;
            CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
            Sleep(16);}

            long_len+=x0_;
            i_:=$8000+(y0_<<16);
            while (x0_<=long_len) do
              begin
                (bmp_dst_ptr+x0_+(i_>>16)*bmp_dst_width)^:=col;
                i_+=dec_inc;
                Inc(x0_);
                {srf_var.LowerBmpToMainBmp;
                CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
                Sleep(4);}
              end;
          end {$endregion}
        {almost horizontal line} {$region -fold}
        else
          begin
            long_len+=x0_;
            i_:=$8000+(y0_<<16);
            while (x0_>=long_len) do
              begin
                (bmp_dst_ptr+x0_+(i_>>16)*bmp_dst_width)^:=col;
                i_-=dec_inc;
                Dec(x0_);
                {srf_var.LowerBmpToMainBmp;
                CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
                Sleep(4);}
              end;
          end; {$endregion}
      end;

  end; {$endregion}
  // Line based only on integer calculatons  in the main loop(best clipping quality):
  {procedure LineTest2(x0_,y0_,x1_,y1_:double;  bmp_dst_ptr:PInteger; bmp_dst_width,col,time_wait:TColor); inline;
  var
    m,p,s,u,dx,dy: double;
    h1           : integer=1;
    i,j1,j2      : integer;
    d,e,o        : integer;
    tst0         : integer;
    tst1         : integer;
    tst2         : integer;
    tst3         : integer;
  const
    c_int=$10000;

    function GetShift1(q:integer): TPtPos; inline;
    var
      k_   : double;
      r1,r2: integer;
    begin
      k_      :=dy/dx;
      r1      :={Abs}(Trunc(k_*s*q+y0_))<<16;
      r2      :=tst2*q+tst3;
      Result.x:=r1;
      Result.y:=c_int+r1-r2-1;
    end;

    function GetShift2(q:integer): TPtPos; inline;
    var
      k_inv: double;
      r1,r2: integer;
    begin
      k_inv   :=dx/dy;
      r1      :={Abs}Trunc(k_inv*s*q+x0_ )<<16;
      r2      :=tst2*q+tst3;
      Result.x:=r1;
      Result.y:=c_int+r1-r2-1;
    end;

  begin
    // Case 1(almost horizontal line):
    if (Abs(x1_-x0_)>=Abs(y1_-y0_)) then
      begin
        if (x1_<x0_) then
          begin
            Swap3(y0_,y1_);
            Swap3(x0_,x1_);
          end;
        dx  :=x1_-x0_;
        dy  :=y1_-y0_;
        m   :=dy *x0_;
        p   :=x1_*y0_-x0_*y1_;
        d  :=Trunc   (x0_);
        e  :=Trunc   (x1_);
        o  :=e-d;
        u   :=c_int/o;
        s   :=dx   /o;
        tst0:=Trunc(u    *      dx );
        tst1:=Trunc(c_int*      x0_);
        tst2:=Trunc(u    *      dy );
        tst3:=Trunc(c_int*(m+p)/dx );
        tst3+=Min2(GetShift1(0).y,GetShift1(o).y);

        srf_var.LowerBmpToMainBmp;
        (bmp_dst_ptr+d+bmp_dst_width*Trunc(y0_))^:=clBlack;
        (bmp_dst_ptr+e+bmp_dst_width*Trunc(y1_))^:=clWhite;
        CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
        srf_var.LowerBmpToMainBmp;
        (bmp_dst_ptr+d+bmp_dst_width*Trunc(y0_))^:=clBlack;
        (bmp_dst_ptr+e+bmp_dst_width*Trunc(y1_))^:=clWhite;
        CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
        Sleep(time_wait+100);

        j1:=tst1;
        j2:=tst3;
        for i:=0 to o do
          begin
            srf_var.LowerBmpToMainBmp;
            (bmp_dst_ptr+(j1>>16)      +bmp_dst_width*(j2>>16)                  )^:=col;
          //(bmp_dst_ptr+Trunc(i*s+x0_)+bmp_dst_width*Trunc((dy*(i*s+x0_)+p)/dx))^:=col;
            Inc(j1,tst0);
            Inc(j2,tst2);
            CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
            Sleep(time_wait);
          end;
      end
    // Case 2(almost vertical   line):
    else
      begin
        if (x1_<x0_) then
          begin
            Swap3(y0_,y1_);
            Swap3(x0_,x1_);
          end;
        if (y1_<y0_) then
          h1:=-1;
        dx  :=x1_-x0_;
        dy  :=y1_-y0_;
        m   :=dx *y0_;
        p   :=x1_*y0_-x0_*y1_;
        d   :=Trunc  (y0_);
        e   :=Trunc  (y1_);
        o   :=Abs  (e-d);
        u   :=h1*c_int  /o;
        s   :=h1*Abs(dy)/o;
        tst0:=Trunc(u    *Abs  (dy));
        tst1:=Trunc(c_int*      y0_);
        tst2:=Trunc(u    *h1   *dx );
        tst3:=Trunc(c_int*(m-p)/dy );
        tst3+=Min2(GetShift(True,0,x0_).y,GetShift(True,o,x0_).y);

        {d:=Trunc(x0_);
        e:=Trunc(x1_);
        srf_var.LowerBmpToMainBmp;
        (bmp_dst_ptr+d+bmp_dst_width*Trunc(y0_))^:=clBlack;
        (bmp_dst_ptr+e+bmp_dst_width*Trunc(y1_))^:=clWhite;
        CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
        srf_var.LowerBmpToMainBmp;
        (bmp_dst_ptr+d+bmp_dst_width*Trunc(y0_))^:=clBlack;
        (bmp_dst_ptr+e+bmp_dst_width*Trunc(y1_))^:=clWhite;
        CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
        Sleep(time_wait+100);}

        for i:=0 to o do
          begin
            srf_var.LowerBmpToMainBmp;
            (bmp_dst_ptr+(i_*tst2+tst3)>>16        +bmp_dst_width*((i*tst0+tst1)>>16))^:=col;
          //(bmp_dst_ptr+Trunc((dx*(i*s+y0_)-p)/dy)+bmp_dst_width*Trunc(i*s+y0_)     )^:=col;
            CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
            Sleep(time_wait);
          end;
      end;
  end;}
  procedure LineTest2(x0_,y0_,x1_,y1_:double;  bmp_dst_ptr:PInteger; const bmp_dst_width,col:TColor); inline; {$region -fold}
  var
    bmp_dst_ptr2                  : PInteger;
    k_,b_,dx_,dy_                 : double;
    i_,t_k_,t_b_,j0,j1,r0,p0,r1,p1: integer;
  begin

    dx_:=x1_-x0_;
    dy_:=y1_-y0_;
    k_ :=dy_/dx_;
    b_ :=y0_-k_*x0_;

    {Nearly Horizontal Line} {$region -fold}
    if (Abs(dx_)>=Abs(dy_)) then
      begin
        r0:=Trunc(x0_);
        p0:=Trunc(y0_);
        r1:=Trunc(x1_);
        p1:=Trunc(y1_);
        if (p0=p1) then
          Exit;
        if (dx_<0) then
          //begin
            Swap2(r0,r1);
            {if (y1_<y0_) then
              Exit;
          end
        else
          begin
            if (y1_>y0_) then
              Exit;
          end;}
        t_k_        :=Trunc($10000*k_);
        t_b_        :=Trunc($10000*b_)+$111;
        j0          :=t_k_*r0+t_b_;
        bmp_dst_ptr2:=bmp_dst_ptr+r0;
        i_          :=r0;
        while (i_<=r1) do
          begin
            (bmp_dst_ptr2+bmp_dst_width*(j0>>16))^:=col;
            j0+=t_k_;
            Inc(i_);
            Inc(bmp_dst_ptr2);
          end;
      end {$endregion}

    {Nearly Vertical   Line} {$region -fold}
    else
      begin
        r0:=Trunc(x0_);
        p0:=Trunc(y0_);
        r1:=Trunc(x1_);
        p1:=Trunc(y1_);
        if (r0=r1) then
          Exit;
        if (dy_<0) then
          //begin
            Swap2(p0,p1);
            {if (x1_<x0_) then
              Exit;
          end
        else
          begin
            if (x1_>x0_) then
              Exit;
          end;}
        t_k_        :=Trunc($10000   /k_);
        t_b_        :=Trunc($10000*b_/k_)-$111;
        j0          :=t_k_*p0-t_b_;
        bmp_dst_ptr2:=bmp_dst_ptr+bmp_dst_width*p0;
        i_          :=p0;
        while (i_<=p1) do
          begin
            (bmp_dst_ptr2+(j0>>16))^:=col;
            j0+=t_k_;
            Inc(i_);
            Inc(bmp_dst_ptr2,bmp_dst_width);
          end;
      end; {$endregion}

  end; {$endregion}

  procedure LineTest3(x0_,y0_,x1_,y1_:double;  bmp_dst_ptr:PInteger; const bmp_dst_width,col:TColor; const rct_clp:TPtRect); inline; {$ifdef Linux}[local];{$endif} {$region -fold}
  var
    bmp_dst_ptr2                       : PInteger;
    x,y                                : array[0..1] of double;
    k_,b_,dx_,dy_                      : double;
    ff0,ff1,r0,p0,r1,p1,t_k_,t_b_,j0,i_: integer;
    chk_bnds                           : boolean=False;

    function CheckBounds: boolean; inline; {$ifdef Linux}[local];{$endif} {$region -fold}
    begin
      Result:=((not ((x[0]<rct_clp.left) and (x[1]<rct_clp.left))) and (not ((x[0]>=rct_clp.right ) and (x[1]>=rct_clp.right )))) and
              ((not ((y[0]<rct_clp.top ) and (y[1]<rct_clp.top ))) and (not ((y[0]>=rct_clp.bottom) and (y[1]>=rct_clp.bottom))))
    end; {$endregion}

  begin

    r0 :=Trunc(x0_);
    p0 :=Trunc(y0_);
    r1 :=Trunc(x1_);
    p1 :=Trunc(y1_);
    ff0:=r0;
    ff1:=p0;

    {horizontal line} {$region -fold}
    if (p0=p1) then
      Exit; {$endregion}

    {vertical   line} {$region -fold}
    if (r0=r1) then
      Exit; {$endregion}

    {regular    line} {$region -fold}
    begin
      x[0]:=x0_;
      y[0]:=y0_;
      x[1]:=x1_;
      y[1]:=y1_;
      if CheckBounds then
        begin
          dx_:=x1_-x0_;
          dy_:=y1_-y0_;
          k_ :=dy_/dx_;
          b_ :=y0_-x0_*k_;
          if (Abs(dx_)>=Abs(dy_)) then
            begin
              if (x1_<x0_) then
                begin
                  ff0:=     r1  ;
                  Swap2(r0 ,r1 );
                  Swap3(x0_,x1_);
                  Swap3(y0_,y1_);
                  x[0]:=x0_;
                  y[0]:=y0_;
                  x[1]:=x1_;
                  y[1]:=y1_;
                end;
              t_k_:=Trunc($10000*k_);
              t_b_:=Trunc($10000*b_)+$111;
              j0  :=t_k_*r0+t_b_;
              if (y1_>y0_) then
                begin
                  if (x[0]<         rct_clp.left     ) then
                    begin
                      y[0]:=       (rct_clp.left-x0_ )*k_+y0_;
                       r0 :=        rct_clp.left;
                    end;
                  if (y[0]<         rct_clp.top      ) then
                       r0 :=Trunc(((rct_clp.top-1    )<<16-j0+ONE_SHL_16_SUB_1)/t_k_)+ff0+1;
                  if (x[1]>=        rct_clp.right    ) then
                    begin
                      y[1]:=       (rct_clp.right-x0_)*k_+y0_;
                       r1 :=        rct_clp.right-1;
                    end;
                  if (y[1]>=        rct_clp.bottom   ) then
                       r1 :=Trunc(((rct_clp.bottom-1 )<<16-j0+ONE_SHL_16_SUB_1)/t_k_)+ff0;
                  if CheckBounds then
                    begin
                      chk_bnds:=True;
                      j0:=t_k_*r0+t_b_;
                      if ((j0>>16)=rct_clp.top-1) then
                        begin
                          r0+=1;
                          j0+=t_k_;
                        end;
                    end;
                end
              else
                begin
                  if (x[0]<         rct_clp.left     ) then
                    begin
                      y[0]:=       (rct_clp.left-x0_ )*k_+y0_;
                       r0 :=        rct_clp.left;
                    end;
                  if (y[0]>=        rct_clp.bottom   ) then
                       r0 :=Trunc(((rct_clp.bottom-1 )<<16-j0+ONE_SHL_16_SUB_1)/t_k_)+ff0+1;
                  if (x[1]>=        rct_clp.right    ) then
                    begin
                      y[1]:=       (rct_clp.right-x0_)*k_+y0_;
                       r1 :=        rct_clp.right-1;
                    end;
                  if (y[1]<         rct_clp.top      ) then
                       r1 :=Trunc(((rct_clp.top-1    )<<16-j0+ONE_SHL_16_SUB_1)/t_k_)+ff0;
                  if CheckBounds then
                    begin
                      chk_bnds:=True;
                      j0  :=t_k_*r0+t_b_;
                      if (((t_k_*r1+t_b_)>>16)=rct_clp.top-1) then
                        r1:=Trunc((rct_clp.top<<16-j0+ONE_SHL_16_SUB_1)/t_k_)+ff0;
                      if ((j0>>16)=rct_clp.bottom) then
                        begin
                          r0+=1;
                          j0+=t_k_;
                        end;
                    end;
                end;
              if chk_bnds then
                begin
                  if (r1=rct_clp.right) then
                    r1-=1;
                  bmp_dst_ptr2:=bmp_dst_ptr+r0;
                  i_          :=r0;
                  while (i_<=r1) do
                    begin
                      (bmp_dst_ptr2+bmp_dst_width*(j0>>16))^:=col;
                      j0+=t_k_;
                      Inc(i_);
                      Inc(bmp_dst_ptr2);
                    end;
                end;
            end
          else
            begin
              if (y1_<y0_) then
                begin
                  ff1:=     p1  ;
                  Swap2(p0 ,p1 );
                  Swap3(x0_,x1_);
                  Swap3(y0_,y1_);
                  x[0]:=x0_;
                  y[0]:=y0_;
                  x[1]:=x1_;
                  y[1]:=y1_;
                end;
              t_k_:=Trunc($10000   /k_);
              t_b_:=Trunc($10000*b_/k_)-$111;
              j0  :=t_k_*p0-t_b_;
              if (x1_>x0_) then
                begin
                  if (x[0]<         rct_clp.left     ) then
                    begin
                      y[0]:=       (rct_clp.left-x0_ )*k_+y0_;
                       p0 :=Trunc(((rct_clp.left-1   )<<16-j0+ONE_SHL_16_SUB_1)/t_k_)+ff1+1;
                    end;
                  if (y[0]<         rct_clp.top      ) then
                       p0 :=        rct_clp.top;
                  if (x[1]>=        rct_clp.right    ) then
                    begin
                      y[1]:=       (rct_clp.right-x0_)*k_+y0_;
                       p1 :=Trunc(((rct_clp.right-1  )<<16-j0+ONE_SHL_16_SUB_1)/t_k_)+ff1;
                    end;
                  if (y[1]>=        rct_clp.bottom   ) then
                       p1 :=        rct_clp.bottom-1;
                  if CheckBounds then
                    begin
                      chk_bnds:=True;
                      j0:=t_k_*p0-t_b_;
                      if ((j0>>16)=rct_clp.left-1) then
                        begin
                          p0+=1;
                          j0+=t_k_;
                        end;
                    end;
                end
              else
                begin
                  if (x[0]>=        rct_clp.right    ) then
                    begin
                      y[0]:=       (rct_clp.right-x0_)*k_+y0_;
                       p0 :=Trunc(((rct_clp.right-1  )<<16-j0+ONE_SHL_16_SUB_1)/t_k_)+ff1+1;
                    end;
                  if (y[0]<         rct_clp.top      ) then
                       p0 :=        rct_clp.top;
                  if (x[1]<         rct_clp.left     ) then
                    begin
                      y[1]:=       (rct_clp.left-x0_ )*k_+y0_;
                       p1 :=Trunc(((rct_clp.left-1   )<<16-j0+ONE_SHL_16_SUB_1)/t_k_)+ff1;
                    end;
                  if (y[1]>=        rct_clp.bottom   ) then
                       p1 :=        rct_clp.bottom-1;
                  if CheckBounds then
                    begin
                      chk_bnds:=True;
                      j0  :=t_k_*p0-t_b_;
                      if (((t_k_*p1-t_b_)>>16)=rct_clp.left-1) then
                        p1:=Trunc((rct_clp.left<<16-j0+ONE_SHL_16_SUB_1)/t_k_)+ff1;
                      if ((j0>>16)=rct_clp.right) then
                        begin
                          p0+=1;
                          j0+=t_k_;
                        end;
                    end;
                end;
              if chk_bnds then
                begin
                  if (p1=rct_clp.bottom) then
                    p1-=1;
                  bmp_dst_ptr2:=bmp_dst_ptr+bmp_dst_width*p0;
                  i_          :=p0;
                  while (i_<=p1) do
                    begin
                      (bmp_dst_ptr2+(j0>>16))^:=col;
                      j0+=t_k_;
                      Inc(i_);
                      Inc(bmp_dst_ptr2,bmp_dst_width);
                    end;
                end;
            end;
        end;
    end; {$endregion}

end; {$endregion}

label
  l1;

begin
  {
  {angle    :=0{45};
  angle_cnt:=361{0};
  loop_cnt :=1{000}{00000};
  SetLength(rot_img_arr,angle_cnt);

  with srf_var do
    if show_tex then
      begin
        tex_bmp_ptr:=GetBmpHandle(tex_bmp );
        tex_bmp.Canvas.Draw(0,0,loaded_picture.Bitmap);
      end;

  PPFloodFill(srf_var.srf_bmp_ptr,srf_var.srf_bmp.width,bounding_rct,srf_var.bg_col);
  exec_timer:=TPerformanceTime.Create;
  exec_timer.Start;

  with srf_var do
    tex_img:=TFastImage.Create
    (
      rot_arr_ptr,
      srf_bmp.width,
      srf_bmp.height,
      inn_wnd_rct,
      bounding_rct,
      0
    );

  with srf_var,tex_img do
    begin
      SetValInfo (tex_bmp_ptr,Nil,Nil,tex_bmp.width,tex_bmp.height);
      //CrtTBmpInst(loaded_picture.Bitmap,bmp_color_ptr);
      bmp_src_rct_clp:=PtRct(0,0,tex_bmp.width,tex_bmp.height);
      ImgToCImg;
    end;

  for i:=0 to angle_cnt-1 do
    BakeRot(rot_img_arr[i],angle+i);

  exec_timer.Stop;
  execution_time:=Trunc(exec_timer.Delay*1000);

  Sleep(1000);}
  //for i:=0 to (angle_cnt-1)*2{-1} do
    begin
      {Sleep(10);
      PPFloodFill(srf_var.srf_bmp_ptr,srf_var.srf_bmp.width,srf_var.inn_wnd_rct{bounding_rct},srf_var.bg_col);
      with tex_img do
        begin
          SetBckgd
          (
            srf_var.srf_bmp_ptr,
            srf_var.srf_bmp.width,
            srf_var.srf_bmp.height
          );
          SdrProc[sdr_proc_ind](100,100,@fast_image_data);
        end;
      i_:=i mod 360;
      DrawRot(rot_img_arr[i_],angle+i_);}

      EdgeAATest(srf_var.srf_bmp_ptr,srf_var.inn_wnd_rct,srf_var.srf_bmp.width,100,10{StrToInt(M_Description.Lines.Text)});

      CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
      InvalidateInnerWindow;
      Application.ProcessMessages;
    end;

  {with srf_var do
    begin
      //Sleep(10);
      EdgeAATest(srf_bmp_ptr,inn_wnd_rct,srf_bmp.width,StrToInt(M_Description.Lines.Text));
      CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
      InvalidateInnerWindow;
    end;}
  }

  with srf_var do
    begin

      {exec_timer.Start;
      for i:=0 to 100 do
        LocalAxisDraw(world_axis.x+world_axis_shift.x,world_axis.y+world_axis_shift.y);
      exec_timer.Stop;
      execution_time:=Trunc(exec_timer.Delay*1000);
      SetTextInfo(srf_var.srf_bmp.Canvas,22);
      srf_var.srf_bmp.Canvas.TextOut(L_Exec_Time_Info.left,
                                     L_Exec_Time_Info.top,
                                     'Execution time: '+FloatToStr(execution_time)+' ms.');}

      {LowerBmpToMainBmp;
      scl_mul:=PtPosF(0.0+25/32,0.0+25/32);
      SetRctPos(Trunc(world_axis.x+world_axis_shift.x)-bmp_ftimg_width_origin >>1,
                Trunc(world_axis.y+world_axis_shift.y)-bmp_ftimg_height_origin>>1);
      {Sprite Bounding Rectangles}
      SetRctDst0;
      SetRctSrc;
      {Sprite Shader Type}
      SetSdrType;
         SdrType [0000+sdr_type_ind];
      {Sprite Drawing}
      GenNTBeginProc[nt_begin_proc_ind];
      FilNTColorScaleDown;
      //BlrNTColorScaleDown;
      GenPTBeginProc[pt_begin_proc_ind];
      FilPTColorScaleDown;
      //BlrPTColorScaleDown;
      CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);}

      {scale image test} {$region -fold}
      {//for j:=0 to 4-1 do
        begin
          for i:=0 to 128 do
            begin
              LowerBmpToMainBmp;
              scl_mul:=PtPosF({0.3}1.0-i/128,{0.3}1.0-i/128);
              for k:=0 to 1{6}{1}{40}{000}-1 do
                begin
                  SetRctPos(Trunc(world_axis.x+world_axis_shift.x)-bmp_ftimg_width_origin >>1+1{0}*k,
                            Trunc(world_axis.y+world_axis_shift.y)-bmp_ftimg_height_origin>>1);
                  if (scl_mul=PtPosF(1.0,1.0)) then
                    SdrProc[sdr_proc_ind]
                  else
                    begin
                      {Sprite Bounding Rectangles}
                      SetRctDst0;
                      SetRctSrc;
                      {Sprite Shader Type}
                      SetSdrType;
                         SdrType    [sdr_type_ind];
                      {Sprite Drawing}
                      GenPTBeginProc[fx_arr[0].pt_begin_proc_ind.main_part+fx_arr[0].pt_begin_proc_ind.clip_part];
                      FilPTColorScaleDownMAll;
                      GenNTBeginProc[fx_arr[0].nt_begin_proc_ind.main_part+fx_arr[0].nt_begin_proc_ind.clip_part];
                      FilNTColorScaleDownMAll;
                    end;
                end;
              Sleep(16);
              ArrClr(srf_var.srf_bmp_ptr,srf_var.srf_bmp_rct,srf_var.srf_bmp.width,0,false);
              SetTextInfo(srf_var.srf_bmp.Canvas,22,clBlue);
              with obj_var,sln_var do
                srf_var.srf_bmp.Canvas.TextOut(Trunc(world_axis.x+world_axis_shift.x)-bmp_ftimg_width_origin >>1{L_Exec_Time_Info.left+300},
                                               Trunc(world_axis.y+world_axis_shift.y)-bmp_ftimg_height_origin>>1{L_Exec_Time_Info.top     },
                                               FloatToStr(scl_mul.x));
              CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
              //InvalidateInnerWindow;
            end;
          for i:=0 to 128 do
            begin
              LowerBmpToMainBmp;
              scl_mul:=PtPosF({0.3}0.0+i/128,{0.3}0.0+i/128);
              for k:=0 to 1{6}{1}{40}{000}-1 do
                begin
                  SetRctPos(Trunc(world_axis.x+world_axis_shift.x)-bmp_ftimg_width_origin >>1+1{0}*k,
                            Trunc(world_axis.y+world_axis_shift.y)-bmp_ftimg_height_origin>>1);
                  if (scl_mul=PtPosF(1.0,1.0)) then
                    SdrProc[sdr_proc_ind]
                  else
                    begin
                      {Sprite Bounding Rectangles}
                      SetRctDst0;
                      SetRctSrc;
                      {Sprite Shader Type}
                      SetSdrType;
                         SdrType    [sdr_type_ind];
                      {Sprite Drawing}
                      GenPTBeginProc[fx_arr[0].pt_begin_proc_ind.main_part+fx_arr[0].pt_begin_proc_ind.clip_part];
                      FilPTColorScaleDownMAll;
                      GenNTBeginProc[fx_arr[0].nt_begin_proc_ind.main_part+fx_arr[0].nt_begin_proc_ind.clip_part];
                      FilNTColorScaleDownMAll;
                    end;
                end;
              Sleep(16);
              ArrClr(srf_var.srf_bmp_ptr,srf_var.srf_bmp_rct,srf_var.srf_bmp.width,0,false);
              SetTextInfo(srf_var.srf_bmp.Canvas,22,clBlue);
              with obj_var,sln_var do
                srf_var.srf_bmp.Canvas.TextOut(Trunc(world_axis.x+world_axis_shift.x)-bmp_ftimg_width_origin >>1{L_Exec_Time_Info.left+300},
                                               Trunc(world_axis.y+world_axis_shift.y)-bmp_ftimg_height_origin>>1{L_Exec_Time_Info.top     },
                                               FloatToStr(scl_mul.x));
              CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
              //InvalidateInnerWindow;
            end;
        end;} {$endregion}

      exec_timer.Start;

      {gradient test} {$region -fold}
      {
      c1:=$00000000+$000000FF{clWhite}{Random($FFFFFF)};
      c2:=$FF000000+$0000FF00{clBlack}{Random($FFFFFF)};

      SetRctPos(Trunc(world_axis.x+world_axis_shift.x)-bmp_ftimg_width_origin >>1-200,
                Trunc(world_axis.y+world_axis_shift.y)-bmp_ftimg_height_origin>>1);
      SetRctDst0;
      SetRctSrc;
      set_grad_to_vis_area:=True;
      SetGradVec(0,rct_ent.height+2000);
      SetGradCol(c1,c2);
      for i:=0 to 1{2000}-1 do
        begin
          {RegNTValue002;
          RegPTValue002;}
          GrVNTValue024;
          GrVPTValue024;
        end;

      SetRctPos(Trunc(world_axis.x+world_axis_shift.x)-bmp_ftimg_width_origin >>1,
                Trunc(world_axis.y+world_axis_shift.y)-bmp_ftimg_height_origin>>1);
      SetRctDst0;
      SetRctSrc;
      set_grad_to_vis_area:=False;
      SetGradVec(-10000,rct_ent.height-200);
      SetGradCol(c1,c2);
      for i:=0 to 1{2000}-1 do
        begin
          {RegNTValue002;
          RegPTValue002;}
          GrVNTValue024;
          GrVPTValue024;
        end;

      SetRctPos(Trunc(world_axis.x+world_axis_shift.x)-bmp_ftimg_width_origin >>1+200,
                Trunc(world_axis.y+world_axis_shift.y)-bmp_ftimg_height_origin>>1);
      SetRctDst0;
      SetRctSrc;
      set_grad_to_vis_area:=False;
      SetGradVec(-10000,rct_ent.height);
      SetGradCol(c1,c2);
      for i:=0 to 1{2000}-1 do
        begin
          {RegNTValue002;
          RegPTValue002;}
          GrVNTValue024;
          GrVPTValue024;
        end;
      } {$endregion}

      {grid_density:=PtPos(32,32);
      SetLength(grid_arr,grid_density.x*grid_density.y);
      FillDWord(grid_arr[0],Length(grid_arr),0);
      with obj_var,sln_var do
        for i:=0 to sln_obj_pts_cnt[0]-1 do
          begin
            rct_inn.left  :=Trunc(sln_pts[i].x)+Trunc(obj_arr[curve_inds_obj_arr[0]].world_axis_shift.x)-2;
            rct_inn.top   :=Trunc(sln_pts[i].y)+Trunc(obj_arr[curve_inds_obj_arr[0]].world_axis_shift.y)-2;
            rct_inn.right :=Trunc(sln_pts[i].x)+Trunc(obj_arr[curve_inds_obj_arr[0]].world_axis_shift.x)+3;
            rct_inn.bottom:=Trunc(sln_pts[i].y)+Trunc(obj_arr[curve_inds_obj_arr[0]].world_axis_shift.y)+3;
            rct_inn.width :=5;
            rct_inn.height:=5;
            rct_out       :=pts_img_arr[0].rct_ent;
            FillRectangleOnArray1(@grid_arr[0],rct_inn,rct_out,grid_density,1);
          end;}

      {line test} {$region -fold}
    {//LineTest2(35,35,100,60,low_bmp_ptr,low_bmp.width,SetColorInv(clGreen ));
    //LineTest2(35.2,35.9,100.99,60.01,low_bmp_ptr,low_bmp.width,SetColorInv(clGreen));

     Rectangle(200,200,400,400,low_bmp_ptr,low_bmp.width,inn_wnd_rct,clGreen);
     for i:=0 to 800{0}{000}-1 do
       begin
         v0:=100+Random(400);
         v1:=100+Random(400);
         v2:=100+Random(400);
         v3:=100+Random(400);
         //if (abs(v0-v2)>abs(v1-v3)) {and (v0>v2)} then
           begin
             LineTest0(v0,v1,v2,v3,low_bmp_ptr,low_bmp.width,clBlack);
             {srf_var.LowerBmpToMainBmp;
             CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
             Sleep(1);}
             //LineTest1(v0,v1,v2,v3,low_bmp_ptr,low_bmp.width,clBlue );
             {srf_var.LowerBmpToMainBmp;
             CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
             Sleep(1);}
             LineTest2(v0,v1,v2,v3,low_bmp_ptr,low_bmp.width,clWhite);
             {srf_var.LowerBmpToMainBmp;
             CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);}
             //Sleep(1);
             LineTest3(v0,v1,v2,v3,low_bmp_ptr,low_bmp.width,clBlue,PtRct(200,200,400,400));
             {srf_var.LowerBmpToMainBmp;
             CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);}
             //Sleep(1);
           end;
       end;
     srf_var.LowerBmpToMainBmp;
     CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
     {srf_var.LowerBmpToMainBmp;
     CnvToCnv(srf_var.srf_bmp_rct,Canvas,srf_var.srf_bmp.Canvas,SRCCOPY);
     Sleep(1);}

     {
      for i:=0 to 1000000 do
        LineTest0(35,35,400,360,low_bmp_ptr,low_bmp.width,clWhite);

      exec_timer.Stop;
      txt0:=Trunc(exec_timer.Delay*1000);

      exec_timer.Start;

      for i:=0 to 1000000 do
        LineTest1(35,35,400,360,low_bmp_ptr,low_bmp.width,clWhite);

      exec_timer.Stop;
      txt1:=Trunc(exec_timer.Delay*1000);

      exec_timer.Start;

      for i:=0 to 1000000 do
        LineTest2(35,35,400,360,low_bmp_ptr,low_bmp.width,clWhite);
      }

      {LineTest0(035,035,100,100,low_bmp_ptr,low_bmp.width,clBlack);
      LineTest0(035,100,100,035,low_bmp_ptr,low_bmp.width,clBlack);
      LineTest0(100,035,035,100,low_bmp_ptr,low_bmp.width,clBlack);
      LineTest0(100,100,035,035,low_bmp_ptr,low_bmp.width,clBlack);}

      //LineTest0(035,035,100,140,low_bmp_ptr,low_bmp.width,clBlack);
      //LineTest0(035,140,100,035,low_bmp_ptr,low_bmp.width,clBlack);

      {LineTest2(035,035,100,100,low_bmp_ptr,low_bmp.width,clWhite);
      LineTest2(035,100,100,035,low_bmp_ptr,low_bmp.width,clWhite);
      LineTest2(100,035,035,100,low_bmp_ptr,low_bmp.width,clWhite);
      LineTest2(100,100,035,035,low_bmp_ptr,low_bmp.width,clWhite);}

      //LineTest2(035,035,100,140,low_bmp_ptr,low_bmp.width,clWhite);
      //LineTest2(035,140,100,035,low_bmp_ptr,low_bmp.width,clWhite);

     {LineTest2(035,035,100,100,low_bmp_ptr,low_bmp.width,SetColorInv(clRed   ));
      LineTest2(035,100,100,035,low_bmp_ptr,low_bmp.width,SetColorInv(clGreen ));
      LineTest2(100,035,035,100,low_bmp_ptr,low_bmp.width,SetColorInv(clBlue  ));
      LineTest2(100,100,035,035,low_bmp_ptr,low_bmp.width,SetColorInv(clYellow));

      LineTest2(035,035,100,140,low_bmp_ptr,low_bmp.width,SetColorInv(clRed   ));
      LineTest2(035,140,100,035,low_bmp_ptr,low_bmp.width,SetColorInv(clGreen ));
      LineTest2(100,035,035,140,low_bmp_ptr,low_bmp.width,SetColorInv(clBlue  ));
      LineTest2(100,140,035,035,low_bmp_ptr,low_bmp.width,SetColorInv(clYellow));}

    //LineTest1(35,35,100,60,low_bmp_ptr,low_bmp.width,clWhite,64);
    //LineTest2(35,35,100,60,low_bmp_ptr,low_bmp.width,clWhite,64);

      //LowerBmpToMainBmp;}
      {$endregion}

      if Length(library_images_inds_arr)<>0 then
        with sprite_sheet_arr[library_images_inds_arr[0]],fast_image_data,fast_image_proc_var do
          begin
            fast_image_data_ptr0:=@fast_image_data;
            x0                  :=Trunc(world_axis.x)-bmp_ftimg_width_origin >>1;
            y0                  :=Trunc(world_axis.y)-bmp_ftimg_height_origin>>1;
            img_rct             :=ClippedRct(
              inn_wnd_rct,
              PtRct(
                x0-1,
                y0-1,
                x0+bmp_ftimg_width_origin +1,
                y0+bmp_ftimg_height_origin+1));
            {{PPAdditiveDec}{PPInverseDec}PPFloodFill(
               srf_bmp_ptr,
               srf_bmp.width,
               img_rct,
               //SetColorInv(pix_col),
               0);}
            PPWriteAlpha(srf_bmp_ptr,srf_bmp.width,img_rct,0);
            SdrProc[sdr_proc_ind](x0,y0,@fast_image_data);
            SetLength(arr_brdr_blur_tst,srf_bmp.width*srf_bmp.height);

            for i:=0 to 100 do
              begin
                BorderCalc0( srf_bmp_ptr,arr_brdr_blur_tst,srf_bmp.width,srf_bmp.width,img_rct,aa_nz_arr_it_cnt,0);
                BorderBlur (@arr_brdr_blur_tst[0],srf_bmp_ptr,srf_bmp.width,img_rct,0,NT_BIT_MASK_ALPHA);
                ArrClr     ( arr_brdr_blur_tst,img_rct,srf_bmp.width,0);
              end;
            Rectangle(img_rct.left,img_rct.top,img_rct.right,img_rct.bottom,srf_bmp_ptr,srf_bmp.width,inn_wnd_rct,clGreen);

          end;

      exec_timer.Stop;
      txt2:=Trunc(exec_timer.Delay*1000);
      execution_time:=Trunc(exec_timer.Delay*1000);
      SetTextInfo(srf_var.srf_bmp.Canvas,22,clBlue);
      with obj_var,sln_var do
        srf_var.srf_bmp.Canvas.TextOut(L_Exec_Time_Info.left,
                                       L_Exec_Time_Info.top,
                                       'Execution time: '{+IntToStr(txt0)+'; '+IntToStr(txt1)+'; '}+IntToStr(txt2)+{FloatToStr(execution_time)+}' ms.');
      ResInnWndToBmp;

    end;

end; {$endregion}
{$endregion}

end.

initialization

end.
